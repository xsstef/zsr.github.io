<!doctype html><html class="theme-next pisces use-motion"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css"><link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css"><meta name="keywords" content="Java,"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1"><meta name="description" content="ThreadPoolExecutor线程池 实现原理
类结构首先要先了解一下类结构，如下图：


Executor

123public interface Executor &amp;#123;    void execute(Runnable command);&amp;#125;
只有一个接口，传入一个Runnable对象，线程池就会帮你执行这个指令。

ExecutorService

123456789"><meta property="og:type" content="article"><meta property="og:title" content="ThreadPoolExecutor"><meta property="og:url" content="http://zsr.github.io/2017/05/03/ThreadPoolExecutor/index.html"><meta property="og:site_name" content="Hello Coder"><meta property="og:description" content="ThreadPoolExecutor线程池 实现原理
类结构首先要先了解一下类结构，如下图：


Executor

123public interface Executor &amp;#123;    void execute(Runnable command);&amp;#125;
只有一个接口，传入一个Runnable对象，线程池就会帮你执行这个指令。

ExecutorService

123456789"><meta property="og:image" content="http://kael-aiur.com/static/img/blog/java-thread-pool/images/class_struts.png"><meta property="og:updated_time" content="2017-05-03T13:42:45.000Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="ThreadPoolExecutor"><meta name="twitter:description" content="ThreadPoolExecutor线程池 实现原理
类结构首先要先了解一下类结构，如下图：


Executor

123public interface Executor &amp;#123;    void execute(Runnable command);&amp;#125;
只有一个接口，传入一个Runnable对象，线程池就会帮你执行这个指令。

ExecutorService

123456789"><meta name="twitter:image" content="http://kael-aiur.com/static/img/blog/java-thread-pool/images/class_struts.png"><script type="text/javascript" id="hexo.configuration">var NexT=window.NexT||{},CONFIG={scheme:"Pisces",sidebar:{position:"left",display:"post"},fancybox:!0,motion:!0,duoshuo:{userId:0,author:"博主"}}</script><link rel="canonical" href="http://zsr.github.io/2017/05/03/ThreadPoolExecutor/"><title> ThreadPoolExecutor | Hello Coder</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><script>!function(e,a,t,n,c,o,s){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,o=a.createElement(t),s=a.getElementsByTagName(t)[0],o.async=1,o.src=n,s.parentNode.insertBefore(o,s)}(window,document,"script","//www.google-analytics.com/analytics.js","ga"),ga("create","UA-81477846-1","auto"),ga("send","pageview")</script><div class="container one-collumn sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Hello Coder</span><span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle"></p></div><div class="site-nav-toggle"> <button><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br> 首页</a></li><li class="menu-item menu-item-archives"><a href="/archives" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br> 归档</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br> 标签</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br> 搜索</a></li></ul><div class="site-search"><div class="popup"><span class="search-icon fa fa-search"></span> <input type="text" id="local-search-input"><div id="local-search-result"></div> <span class="popup-btn-close">close</span></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><header class="post-header"><h1 class="post-title" itemprop="name headline"> ThreadPoolExecutor</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time itemprop="dateCreated" datetime="2017-05-03T19:29:16+08:00" content="2017-05-03">2017-05-03</time></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="ThreadPoolExecutor线程池-实现原理"><a href="#ThreadPoolExecutor线程池-实现原理" class="headerlink" title="ThreadPoolExecutor线程池 实现原理"></a>ThreadPoolExecutor线程池 实现原理</h1><hr><h3 id="类结构"><a href="#类结构" class="headerlink" title="类结构"></a>类结构</h3><p>首先要先了解一下类结构，如下图：</p><p><img src="http://kael-aiur.com/static/img/blog/java-thread-pool/images/class_struts.png" alt="enter description here"></p><ul><li><code>Executor</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>只有一个接口，传入一个<code>Runnable</code>对象，线程池就会帮你执行这个指令。</p><ul><li><code>ExecutorService</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</div><div class="line">    <span class="function">List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</div><div class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</div><div class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</div><div class="line"> </div><div class="line">    .......省略........</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这个接口是执行器服务接口，声明了关于执行器的许多管理方法。</p><ul><li><code>AbstractExecutorService</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractExecutorService</span> <span class="keyword">implements</span> <span class="title">ExecutorService</span> </span>&#123;</div><div class="line">  </div><div class="line">  .......省略........</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</div><div class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">        RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</div><div class="line">        execute(ftask);</div><div class="line">        <span class="keyword">return</span> ftask;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">        RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);</div><div class="line">        execute(ftask);</div><div class="line">        <span class="keyword">return</span> ftask;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">        RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</div><div class="line">        execute(ftask);</div><div class="line">        <span class="keyword">return</span> ftask;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line"> .......省略........</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这个抽象类实现了<code>ExecutorService</code>接口中的大部分方法，不过大部分的实现都依赖于<code>Executor</code>接口声明的<code>execute</code>方法，而这里并没有实现这个关键的方法，而是把这个方法的实现交给了子类，也就是<code>java.util.concurrent.ThreadPoolExecutor</code>来实现了。</p><a id="more"></a><ul><li><code>Worker</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ThreadPoolExecutor内部类</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></div><div class="line">&#123;</div><div class="line">   Worker(Runnable firstTask) &#123;</div><div class="line">            setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></div><div class="line">            <span class="keyword">this</span>.firstTask = firstTask;</div><div class="line">            <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">  <span class="comment">/** Delegates main run loop to outer runWorker  */</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            runWorker(<span class="keyword">this</span>);</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>Worker</code>，每一个<code>Worker</code>对象代表了一个线程，同时也是真正负责执行任务的对象。</p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></div><div class="line">                              <span class="keyword">int</span> maximumPoolSize,</div><div class="line">                              <span class="keyword">long</span> keepAliveTime,</div><div class="line">                              TimeUnit unit,</div><div class="line">                              BlockingQueue&lt;Runnable&gt; workQueue) &#123;</div><div class="line">        <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</div><div class="line">             Executors.defaultThreadFactory(), defaultHandler);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">.......省略........</div><div class="line">   </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></div><div class="line">                              <span class="keyword">int</span> maximumPoolSize,</div><div class="line">                              <span class="keyword">long</span> keepAliveTime,</div><div class="line">                              TimeUnit unit,</div><div class="line">                              BlockingQueue&lt;Runnable&gt; workQueue,</div><div class="line">                              ThreadFactory threadFactory,</div><div class="line">                              RejectedExecutionHandler handler) &#123;</div><div class="line">        <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</div><div class="line">            maximumPoolSize &lt;= <span class="number">0</span> ||</div><div class="line">            maximumPoolSize &lt; corePoolSize ||</div><div class="line">            keepAliveTime &lt; <span class="number">0</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</div><div class="line">        <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">        <span class="keyword">this</span>.corePoolSize = corePoolSize;</div><div class="line">        <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</div><div class="line">        <span class="keyword">this</span>.workQueue = workQueue;</div><div class="line">        <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</div><div class="line">        <span class="keyword">this</span>.threadFactory = threadFactory;</div><div class="line">        <span class="keyword">this</span>.handler = handler;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><ul><li><code>corePoolSize</code>：核心池的大小，在创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，当线程池中的线程数目达到<code>corePoolSize</code>后，就会把到达的任务放到缓存队列当中。只有当工作队列满了的情况下才会创建超出这个数量的线程。如果某个线程的空闲时间超过了活动时间，那么将标记为可回收，并且只有当线程池的当前大小超过<code>corePoolSize</code>时该线程才会被终止。用户可调用<code>prestartAllCoreThreads()</code>或者<code>prestartCoreThread()</code>方法预先创建线程，即在没有任务到来之前就创建<code>corePoolSize</code>个线程或者一个线程。</li><li><code>maximumPoolSize</code>：线程池最大线程数，这个参数也是一个非常重要的参数，它表示在线程池中最多能创建多少个线程；当大于了这个值就会将<code>Thread</code>由一个丢弃处理机制来处理。</li><li><code>keepAliveTime</code>：表示线程没有任务执行时最多保持多久时间会终止。默认情况下，只有当线程池中的线程数大于<code>corePoolSize</code>时，<code>keepAliveTime</code>才会起作用，直到线程池中的线程数不大于<code>corePoolSize</code>，即当线程池中的线程数大于<code>corePoolSize</code>时，如果一个线程空闲的时间达到<code>keepAliveTime</code>，则会终止，直到线程池中的线程数不超过<code>corePoolSize</code>。但是如果调用了<code>allowCoreThreadTimeOut(boolean)</code>方法，在线程池中的线程数不大于<code>corePoolSize</code>时，<code>keepAliveTime</code>参数也会起作用，直到线程池中的线程数为0；</li><li><code>Unit</code>：参数<code>keepAliveTime</code>的时间单位，有7种取值，在<code>TimeUnit</code>类中有7种静态属性。</li><li><code>workQueue</code>：一个阻塞队列，用来存储等待执行的任务，当线程池中的线程数目达到<code>corePoolSize</code>后，就会把到达的任务放到缓存队列当中。</li><li><code>threadFactory</code>：线程工厂，主要用来创建线程；</li><li><code>handler</code>：表示当拒绝处理任务时的策略，也就是参数<code>maximumPoolSize</code>达到后丢弃处理的方法。有以下四种取值：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。 </div><div class="line">ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 </div><div class="line">ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</div><div class="line">ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务</div></pre></td></tr></table></figure><p>用户也可以实现接口<code>RejectedExecutionHandler</code>定制自己的策略。</p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>按照下面的几个方面来阅读jdk的源码：</p><ol><li>线程池的状态</li><li>线程任务执行</li><li>线程池关闭</li><li>线程容量动态调整</li></ol><h4 id="线程池的状态"><a href="#线程池的状态" class="headerlink" title="线程池的状态"></a>线程池的状态</h4><p>跟线程池状态有关的几个属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">AtomicInteger ctl; <span class="comment">// 状态计数器</span></div><div class="line"><span class="keyword">int</span> RUNNING; <span class="comment">// 运行状态</span></div><div class="line"><span class="keyword">int</span> SHUTDOWN ;<span class="comment">// 关闭状态</span></div><div class="line"><span class="keyword">int</span> STOP; <span class="comment">// 停止状态</span></div><div class="line"><span class="keyword">int</span> TIDYING; <span class="comment">// 整理状态</span></div><div class="line"><span class="keyword">int</span> TERMINATED; <span class="comment">//结束状态</span></div></pre></td></tr></table></figure><ul><li><code>ctl</code>：标识线程池当前状态和线程数的，这里要特别注意，这个属性把两个变量打包成一个变量了，通过这个属性可以计算得出目前的线程数和线程池当前的状态。</li><li><p><code>RUNNING</code>：正在处理任务和接受队列中的任务。</p></li><li><p><code>SHUTDOWN</code>：不再接受新的任务，但是会继续处理完队列中的任务。</p></li></ul><ul><li><code>STOP</code>：不再接受新任务，也不继续处理队列中的任务，并且会中止正在处理的任务。</li></ul><ul><li><code>TIDYING</code>：所有任务都已经处理结束，目前<code>worker</code>数为0，当线程池进入这个状态的时候，会调用<code>terminated()</code>方法。</li></ul><ul><li><code>TERMINATED</code>：线程池已经全部结束，并且<code>terminated()</code>方法执行完成。</li></ul><h4 id="线程任务执行"><a href="#线程任务执行" class="headerlink" title="线程任务执行"></a>线程任务执行</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (command == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">        <span class="comment">/*</span></div><div class="line">         * Proceed in 3 steps:</div><div class="line">         *</div><div class="line">         * 1. If fewer than corePoolSize threads are running, try to</div><div class="line">         * start a new thread with the given command as its first</div><div class="line">         * task.  The call to addWorker atomically checks runState and</div><div class="line">         * workerCount, and so prevents false alarms that would add</div><div class="line">         * threads when it shouldn't, by returning false.</div><div class="line">         *</div><div class="line">         * 2. If a task can be successfully queued, then we still need</div><div class="line">         * to double-check whether we should have added a thread</div><div class="line">         * (because existing ones died since last checking) or that</div><div class="line">         * the pool shut down since entry into this method. So we</div><div class="line">         * recheck state and if necessary roll back the enqueuing if</div><div class="line">         * stopped, or start a new thread if there are none.</div><div class="line">         *</div><div class="line">         * 3. If we cannot queue task, then we try to add a new</div><div class="line">         * thread.  If it fails, we know we are shut down or saturated</div><div class="line">         * and so reject the task.</div><div class="line">         */</div><div class="line">        <span class="keyword">int</span> c = ctl.get();</div><div class="line">        <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</div><div class="line">            <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            c = ctl.get();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</div><div class="line">            <span class="keyword">int</span> recheck = ctl.get();</div><div class="line">            <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</div><div class="line">                reject(command);</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</div><div class="line">                addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</div><div class="line">            reject(command);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>首先判断了传入的指令对象是否为空，为空就不用执行了，直接抛出异常。如果指令对象不为空，那么就真正进入线程任务的逻辑，一共分为3步来处理：</p><ul><li>检查当前线程总数，如果低于核心线程数，则创建新的线程来执行这个任务</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> c = ctl.get();</div><div class="line"><span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</div><div class="line">    <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</div><div class="line">    	<span class="keyword">return</span>;</div><div class="line">    c = ctl.get();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里<code>workerCountOf(c)</code>可以从计数器(clt)的结果中计算出当前线程数。</p><p><code>addWorker(command, true)</code>会检查线程池状态和总线程数，并确定是否创建新线程，如果创建了新线程执行这个任务，则返回true，如果没有创建新线程，则返回false。</p><ul><li>尝试把任务放入任务队列，并且重新检查线程池状态，如果线程池已经不接收新的任务，则移除这个任务，并转入拒绝策略。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</div><div class="line">	<span class="keyword">int</span> recheck = ctl.get();</div><div class="line">	<span class="keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command))</div><div class="line">		reject(command);</div><div class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</div><div class="line">	addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>第二步先检查了线程池当前是否运行状态，如果是运行状态的话，则执行<code>workQueue.offer(command)</code>把任务放入任务队列。</p><p>任务放入队列之后，会复查线程池状态是否RUNNING，这里需要做复查的主要原因是在前面的检查中没有加锁，因此可能在添加任务队列的过程，其他线程修改了线程池的状态。</p><p>如果这个时候线程池状态被修改了，那么就会把这次添加的任务移除<code>remove(command)</code>，同时启动拒绝策略<code>reject(command)</code>。</p><p>如果线程池状态没有被改变，则重新检查当前核心线程数，如果为0则调用<code>addWorker(null, false)</code>去队列中取任务并执行，如果不为0，则不做任何操作，等待线程执行完当前任务后自动去任务队列中获取新的任务并执行。</p><ul><li>如果任务队列已满，则尝试添加临时线程，并把当然任务交给临时线程处理，如果临时线程也满了，则启动拒绝策略</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</div><div class="line">            reject(command);</div></pre></td></tr></table></figure><p>这里先通过<code>addWorker(command, false)</code>尝试添加临时线程，如果临时线程创建成功则由临时线程执行这个任务，如果临时线程创建失败，则会返回false，并转入拒绝策略<code>reject(command)</code>。</p><h5 id="addWorker"><a href="#addWorker" class="headerlink" title="addWorker"></a><code>addWorker</code></h5><p>这里有一个重要的方法<code>addWorker(Runnable firstTask, boolean core)</code>，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</div><div class="line">        retry:</div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="keyword">int</span> c = ctl.get();</div><div class="line">            <span class="keyword">int</span> rs = runStateOf(c);</div><div class="line"></div><div class="line">            <span class="comment">/** 这里返回false有以下可能：</span></div><div class="line">              * 1 线程池状态大于SHUTDOWN</div><div class="line">              * 2 线程池状态为SHUTDOWN，但firstTask不为空，也就是说线程池已经SHUTDOWN，拒绝添加新任务</div><div class="line">              * 3 线程池状态为SHUTDOWN且firstTask为空，但workQueue为空，即无任务需要执行</div><div class="line">              */</div><div class="line">            <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</div><div class="line">                ! (rs == SHUTDOWN &amp;&amp;</div><div class="line">                   firstTask == <span class="keyword">null</span> &amp;&amp;</div><div class="line">                   ! workQueue.isEmpty()))</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">            <span class="keyword">for</span> (;;) &#123;</div><div class="line">                <span class="keyword">int</span> wc = workerCountOf(c);</div><div class="line">                <span class="comment">/** 返回false有以下可能：</span></div><div class="line">                  * 1 工作线程数量超过最大容量</div><div class="line">                  * 2 core为true，工作线程数量超过边界corePoolSize</div><div class="line">                  * 3 core为false,工作线程数量超过边界maximumPoolSize</div><div class="line">                  */</div><div class="line">                <span class="keyword">if</span> (wc &gt;= CAPACITY ||</div><div class="line">                    wc &gt;= (core ? corePoolSize : maximumPoolSize))</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</div><div class="line">                    <span class="keyword">break</span> retry;<span class="comment">//直接跳出最外层循环</span></div><div class="line">                c = ctl.get();  <span class="comment">// Re-read ctl</span></div><div class="line">                <span class="keyword">if</span> (runStateOf(c) != rs)<span class="comment">//线程池状态发生改变则从最外层循环重新开始</span></div><div class="line">                    <span class="keyword">continue</span> retry;</div><div class="line">                <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Worker w = <span class="keyword">new</span> Worker(firstTask);</div><div class="line">        Thread t = w.thread;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</div><div class="line">        mainLock.lock();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// 持有锁之后需要重新检查线程池状态，防止ThreadFactory返回失败或线程池在加锁之前被关闭</span></div><div class="line">            <span class="keyword">int</span> c = ctl.get();</div><div class="line">            <span class="keyword">int</span> rs = runStateOf(c);</div><div class="line">             <span class="comment">/** 返回false有以下可能：</span></div><div class="line">               * 1 t为null,说明ThreadFactory创建线程失败，可能发生OutOfMemoryError</div><div class="line">               * 2 线程池状态大于SHUTDOWN</div><div class="line">               * 3 线程池状态为SHUTDOWN，但firstTask不为空</div><div class="line">               */</div><div class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span> ||</div><div class="line">                (rs &gt;= SHUTDOWN &amp;&amp;</div><div class="line">                 ! (rs == SHUTDOWN &amp;&amp;</div><div class="line">                    firstTask == <span class="keyword">null</span>))) &#123;</div><div class="line">                decrementWorkerCount();</div><div class="line">                tryTerminate();</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            workers.add(w);</div><div class="line"></div><div class="line">            <span class="keyword">int</span> s = workers.size();</div><div class="line">            <span class="keyword">if</span> (s &gt; largestPoolSize)</div><div class="line">                largestPoolSize = s;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            mainLock.unlock();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        t.start();</div><div class="line">        <span class="comment">// 在线程池变为stop期间，线程可能已经被添加到workers，但还未被启动（该现象不太可能发生，这可能</span></div><div class="line">        <span class="comment">// 导致罕见的丢失中断，因为Thread.interrupt不能保证对非启动状态的线程有效</span></div><div class="line">        <span class="keyword">if</span> (runStateOf(ctl.get()) == STOP &amp;&amp; ! t.isInterrupted())</div><div class="line">            t.interrupt();</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>addWorker首先会检查当前线程池的状态和给定的边界是否可以创建一个新的worker，在此期间会对workers的数量进行适当调整；如果满足条件，将创建一个新的worker并启动，以参数中的firstTask作为worker的第一个任务。</p><ul><li><code>addWorker</code>方法参数：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Runnable firstTask; // 表示新建的线程的第一个任务</div><div class="line">boolean core; // 是否以核心线程数为边界，如果传入true，表示以核心线程数为边界，当前线程超过核心线程数则不创建新线程，如果不使用核心线程数为边界，则会以最大线程数为边界</div></pre></td></tr></table></figure><ul><li>第一步就是检查线程池当前的状态:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> c = ctl.get();</div><div class="line"><span class="keyword">int</span> rs = runStateOf(c);</div><div class="line"></div><div class="line"><span class="comment">// Check if queue empty only if necessary.</span></div><div class="line"><span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</div><div class="line">	! (rs == SHUTDOWN &amp;&amp;</div><div class="line">		firstTask == <span class="keyword">null</span> &amp;&amp;</div><div class="line">		! workQueue.isEmpty()))</div><div class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</div></pre></td></tr></table></figure><p>如果已经不允许接受新任务了，这里就直接返回了，如果允许接受新任务的话，会继续执行</p><ul><li>检查是否要求使用核心线程数为边界，如果不满足条件，则直接返回false</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (;;) &#123;</div><div class="line">	<span class="keyword">int</span> wc = workerCountOf(c);</div><div class="line">	<span class="keyword">if</span> (wc &gt;= CAPACITY ||</div><div class="line">		wc &gt;= (core ? corePoolSize : maximumPoolSize))</div><div class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">	<span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</div><div class="line">		<span class="keyword">break</span> retry;</div><div class="line">	c = ctl.get();  <span class="comment">// Re-read ctl</span></div><div class="line">	<span class="keyword">if</span> (runStateOf(c) != rs)</div><div class="line">		<span class="keyword">continue</span> retry;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果满足条件，则会执行<code>compareAndIncrementWorkerCount(c)</code>给计数器加1，同时跳出循环，执行下一步，如果计数器添加失败，会再次计算线程池当前状态是否RUNNING，如果线程池还在RUNNING状态，则继续重试。</p><ul><li>前面已经添加了线程数了，那么下一步就开始创建新线程了：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">w = <span class="keyword">new</span> Worker(firstTask);</div><div class="line"><span class="keyword">final</span> Thread t = w.thread;</div></pre></td></tr></table></figure><p>一个<code>Worker</code>对象表示的是一个线程，每创建一个<code>Worker</code>对象，就会创建一个新的线程，并以自己作为线程的运行对象(<code>Worker</code>自己也是<code>Runnable</code>的实现类)。</p><ul><li>创建了<code>Worker</code>对象之后，需要对线程池做一系列的检查，并将这个对象加入到线程池中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</div><div class="line">mainLock.lock();</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">	<span class="keyword">int</span> rs = runStateOf(ctl.get());</div><div class="line">	<span class="keyword">if</span> (rs &lt; SHUTDOWN ||</div><div class="line">	(rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</div><div class="line">		<span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</div><div class="line">		workers.add(w);</div><div class="line">		<span class="keyword">int</span> s = workers.size();</div><div class="line">		<span class="keyword">if</span> (s &gt; largestPoolSize)</div><div class="line">			largestPoolSize = s;</div><div class="line">		workerAdded = <span class="keyword">true</span>;</div><div class="line">	&#125;</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">	mainLock.unlock();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里首先获取线程池的主锁，保证在添加线程的过程不受其他线程干扰。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mainLock.lock();</div></pre></td></tr></table></figure><p>然后检查线程池状态和线程状态，如果线程池各个状态都是正常的，可以把线程加入到线程池中，则会把线程池加入线程池，并将线程添加状态设置为true:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">workers.add(w);</div><div class="line"><span class="comment">// ... 省略若干代码</span></div><div class="line">workerAdded = <span class="keyword">true</span>;</div></pre></td></tr></table></figure><p>最后释放锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">finally</span> &#123;</div><div class="line">	mainLock.unlock();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里要特别注意，锁一定要在<code>finally</code>代码块中释放，不然很容易造成死锁。</p><ul><li>最后，判断线程是否已经加入线程池中，如果已经加入线程池中，则启动线程：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (workerAdded) &#123;</div><div class="line">	t.start();</div><div class="line">	workerStarted = <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>在最后判断线程是否启动，如果线程没有启动，则会做回滚：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">finally</span> &#123;</div><div class="line">	<span class="keyword">if</span> (!workerStarted)</div><div class="line">		addWorkerFailed(w);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h5 id="reject"><a href="#reject" class="headerlink" title="reject"></a><code>reject</code></h5><p>这个方法是调用线程池的拒绝处理策略：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">final void reject(Runnable command) &#123;</div><div class="line">        handler.rejectedExecution(command, this);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>当然这个策略可以通过我们自己传入的对象来处理，默认使用<code>AbortPolicy</code>处理，抛出异常。</p><h5 id="worker线程运行"><a href="#worker线程运行" class="headerlink" title="worker线程运行"></a><code>worker</code>线程运行</h5><p>这里就涉及到<code>Worker</code>的<code>run</code>方法实现了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">	runWorker(<span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里实际上是调用了<code>java.util.concurrent.ThreadPoolExecutor</code>的<code>runWorker(Worker w)</code>方法，我们来看下这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</div><div class="line">        Thread wt = Thread.currentThread();</div><div class="line">        Runnable task = w.firstTask;</div><div class="line">        w.firstTask = <span class="keyword">null</span>;</div><div class="line">        w.unlock(); <span class="comment">// allow interrupts</span></div><div class="line">        <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</div><div class="line">                w.lock();</div><div class="line">                <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</div><div class="line">                     (Thread.interrupted() &amp;&amp;</div><div class="line">                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</div><div class="line">                    !wt.isInterrupted())</div><div class="line">                    wt.interrupt();</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    beforeExecute(wt, task);</div><div class="line">                    Throwable thrown = <span class="keyword">null</span>;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        task.run();</div><div class="line">                    &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</div><div class="line">                        thrown = x; <span class="keyword">throw</span> x;</div><div class="line">                    &#125; <span class="keyword">catch</span> (Error x) &#123;</div><div class="line">                        thrown = x; <span class="keyword">throw</span> x;</div><div class="line">                    &#125; <span class="keyword">catch</span> (Throwable x) &#123;</div><div class="line">                        thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</div><div class="line">                    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                        afterExecute(task, thrown);</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                    task = <span class="keyword">null</span>;</div><div class="line">                    w.completedTasks++;</div><div class="line">                    w.unlock();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            completedAbruptly = <span class="keyword">false</span>;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            processWorkerExit(w, completedAbruptly);</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里首先调用Worker的unlock()方法，允许这个线程被中断，然后进入一个循环，这个循环内部做了几件事情：</p><ul><li>获取要执行的任务</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>)</div></pre></td></tr></table></figure><p>这里判断是否有第一个任务，如果有第一个任务则使用第一个任务，如果没有第一个任务，则使用<code>getTask()</code>获得新任务，<strong><code>getTask()</code>是一个重要的方法，如果获取不到任务的话，这个方法会阻塞并等待任务</strong>，后边详细看这个方法。</p><ul><li>获取当前线程的锁，检查当前线程是否允许运行</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">w.lock();</div><div class="line"><span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</div><div class="line">                     (Thread.interrupted() &amp;&amp;</div><div class="line">                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</div><div class="line">                    !wt.isInterrupted())</div><div class="line">                    wt.interrupt();</div></pre></td></tr></table></figure><ul><li>所有检查通过之后，确认当前任务可以执行了，就开始执行任务</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">	beforeExecute(wt, task);</div><div class="line">	Throwable thrown = <span class="keyword">null</span>;</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">		task.run();</div><div class="line">	&#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</div><div class="line">		thrown = x; <span class="keyword">throw</span> x;</div><div class="line">	&#125; <span class="keyword">catch</span> (Error x) &#123;</div><div class="line">		thrown = x; <span class="keyword">throw</span> x;</div><div class="line">	&#125; <span class="keyword">catch</span> (Throwable x) &#123;</div><div class="line">		thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</div><div class="line">	&#125; <span class="keyword">finally</span> &#123;</div><div class="line">		afterExecute(task, thrown);</div><div class="line">	&#125;</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">	task = <span class="keyword">null</span>;	</div><div class="line">	w.completedTasks++;</div><div class="line">	w.unlock();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>执行任务的过程，先调用了<code>beforeExecute(wt, task)</code>做执行前处理，任务执行完成后，调用<code>afterExecute(task, thrown)</code>做执行完成后处理，这里主要是留给开发者扩展用的，默认不做任何处理，如果我们需要做一些处理，比如计算任务执行时间一类的，可以通过继承<code>java.util.concurrent.ThreadPoolExecutor</code>并重写这两个方法来实现。</p><p>任务执行完成后，在finally中释放了锁并给完成任务计数器加1。</p><h6 id="getTask"><a href="#getTask" class="headerlink" title="getTask()"></a>getTask()</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></div><div class="line"></div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="keyword">int</span> c = ctl.get();</div><div class="line">            <span class="keyword">int</span> rs = runStateOf(c);</div><div class="line"></div><div class="line">            <span class="comment">// Check if queue empty only if necessary.</span></div><div class="line">            <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</div><div class="line">                decrementWorkerCount();</div><div class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</div><div class="line"></div><div class="line">            <span class="comment">// Are workers subject to culling?</span></div><div class="line">            <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</div><div class="line">                &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</div><div class="line">                <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                Runnable r = timed ?</div><div class="line">                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</div><div class="line">                    workQueue.take();</div><div class="line">                <span class="keyword">if</span> (r != <span class="keyword">null</span>)</div><div class="line">                    <span class="keyword">return</span> r;</div><div class="line">                timedOut = <span class="keyword">true</span>;</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</div><div class="line">                timedOut = <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>简单而言就是检查线程池状态，只要线程池还没有终止，这里就就会无限循环知道抛出异常或者线程池终止，线程的阻塞是用<code>workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS)</code>或<code>workQueue.take()</code>实现的。</p><h4 id="线程池关闭"><a href="#线程池关闭" class="headerlink" title="线程池关闭"></a>线程池关闭</h4><p>在<code>java.util.concurrent.ExecutorService</code>接口中提供了如下两个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>; <span class="comment">// 不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务</span></div><div class="line"><span class="function">List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span></span>; <span class="comment">// 立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务</span></div></pre></td></tr></table></figure><h4 id="线程池容量的动态调整"><a href="#线程池容量的动态调整" class="headerlink" title="线程池容量的动态调整"></a>线程池容量的动态调整</h4><p>动态调整线程池容量，在执行过程我们已经知道了，只要改变核心线程数和最大线程数即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setCorePoolSize</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span></span>;<span class="comment">// 调整核心线程数</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setMaximumPoolSize</span><span class="params">(<span class="keyword">int</span> maximumPoolSize)</span> </span>; <span class="comment">// 调整动态线程数</span></div></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://kael-aiur.com/java/jdk%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0-ThreadPoolExecutor.html" target="_blank" rel="external">jdk的线程池实现-ThreadPoolExecutor</a></p><p><a href="https://my.oschina.net/7001/blog/889931" target="_blank" rel="external">Java线程池核心实现原理和源码解析</a></p></div><div></div><div></div><footer class="post-footer"><div class="post-tags"> <a href="/tags/Java/" rel="tag">#Java</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2017/04/27/LinkedHashMap/" rel="next" title="LinkedHashMap"><i class="fa fa-chevron-left"></i> LinkedHashMap</a></div><div class="post-nav-prev post-nav-item"> <a href="/2017/05/05/Spring-Bean-生命周期/" rel="prev" title="Spring Bean 生命周期">Spring Bean 生命周期<i class="fa fa-chevron-right"></i></a></div></div></footer></article><div class="post-spread"><div class="jiathis_style"><a class="jiathis_button_tsina"></a><a class="jiathis_button_tqq"></a><a class="jiathis_button_weixin"></a><a class="jiathis_button_cqq"></a><a class="jiathis_button_douban"></a><a class="jiathis_button_renren"></a><a class="jiathis_button_qzone"></a><a class="jiathis_button_kaixin001"></a><a class="jiathis_button_copy"></a><a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank"></a><a class="jiathis_counter_style"></a></div><script type="text/javascript">var jiathis_config={hideMore:!1}</script><script type="text/javascript" src="http://v3.jiathis.com/code/jia.js" charset="utf-8"></script></div></div></div><p>热评文章</p><div class="ds-top-threads" data-range="weekly" data-num-items="4"></div><div class="comments" id="comments"></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap"> 文章目录</li><li class="sidebar-nav-overview" data-target="site-overview"> 站点概览</li></ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="David"><p class="site-author-name" itemprop="name">David</p><p class="site-description motion-element" itemprop="description">Develop Notes</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"> <a href="/archives"><span class="site-state-item-count">150</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags"><span class="site-state-item-count">37</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/zsr" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i> GitHub</a></span><span class="links-of-author-item"><a href="http://weibo.com/u/2214956781" target="_blank" title="Weibo"><i class="fa fa-fw fa-weibo"></i> Weibo</a></span></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#ThreadPoolExecutor线程池-实现原理"><span class="nav-number">1.</span> <span class="nav-text">ThreadPoolExecutor线程池 实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#类结构"><span class="nav-number">1.0.1.</span> <span class="nav-text">类结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构造方法"><span class="nav-number">1.0.2.</span> <span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现原理"><span class="nav-number">1.0.3.</span> <span class="nav-text">实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#线程池的状态"><span class="nav-number">1.0.3.1.</span> <span class="nav-text">线程池的状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程任务执行"><span class="nav-number">1.0.3.2.</span> <span class="nav-text">线程任务执行</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#addWorker"><span class="nav-number">1.0.3.2.1.</span> <span class="nav-text">addWorker</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#reject"><span class="nav-number">1.0.3.2.2.</span> <span class="nav-text">reject</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#worker线程运行"><span class="nav-number">1.0.3.2.3.</span> <span class="nav-text">worker线程运行</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#getTask"><span class="nav-number">1.0.3.2.3.1.</span> <span class="nav-text">getTask()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程池关闭"><span class="nav-number">1.0.3.3.</span> <span class="nav-text">线程池关闭</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程池容量的动态调整"><span class="nav-number">1.0.3.4.</span> <span class="nav-text">线程池容量的动态调整</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参考"><span class="nav-number">1.0.4.</span> <span class="nav-text">参考</span></a></li></ol></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright"> &copy; 2016 - <span itemprop="copyrightYear">2018</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">David</span></div><div class="powered-by"> 由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div><div class="theme-info"> 主题 - <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script><script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script><script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script><script type="text/javascript">function proceedsearch(){$("body").append('<div class="popoverlay">').css("overflow","hidden"),$(".popup").toggle()}var isfetched=!1,search_path="search.xml";0==search_path.length&&(search_path="search.xml");var path="/"+search_path,searchFunc=function(e,t,a){"use strict";$.ajax({url:e,dataType:"xml",async:!0,success:function(e){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var r=$("entry",e).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get(),c=document.getElementById(t),s=document.getElementById(a);c.addEventListener("input",function(){var e=0,t='<ul class="search-result-list">',a=this.value.trim().toLowerCase().split(/[\s\-]+/);s.innerHTML="",this.value.trim().length>1&&r.forEach(function(r){var c=!0,s=r.title.trim().toLowerCase(),n=r.content.trim().replace(/<[^>]+>/g,"").toLowerCase(),i=r.url,o=-1,l=-1,p=-1;if(""!=s&&""!=n&&a.forEach(function(e,t){o=s.indexOf(e),l=n.indexOf(e),o<0&&l<0?c=!1:(l<0&&(l=0),0==t&&(p=l))}),c){e+=1,t+="<li><a href='"+i+"' class='search-result-title'>"+s+"</a>";var h=r.content.trim().replace(/<[^>]+>/g,"");if(p>=0){var u=p-20,d=p+80;u<0&&(u=0),0==u&&(d=50),d>h.length&&(d=h.length);var f=h.substring(u,d);a.forEach(function(e){var t=new RegExp(e,"gi");f=f.replace(t,'<b class="search-keyword">'+e+"</b>")}),t+='<p class="search-result">'+f+"...</p>"}t+="</li>"}}),t+="</ul>",0==e&&(t='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'),""==a&&(t='<div id="no-result"><i class="fa fa-search fa-5x" /></div>'),s.innerHTML=t}),proceedsearch()}})};$(".popup-trigger").click(function(e){e.stopPropagation(),0==isfetched?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(function(e){$(".popup").hide(),$(".popoverlay").remove(),$("body").css("overflow","")}),$(".popup").click(function(e){e.stopPropagation()})</script></body></html>