<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Netty 核心组件]]></title>
      <url>http://zsr.github.io/2018/12/15/Netty-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/</url>
      <content type="html"><![CDATA[<h3 id="Netty工作架构图"><a href="#Netty工作架构图" class="headerlink" title="Netty工作架构图"></a><code>Netty</code>工作架构图</h3><p><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fy8w6dygu9j30fa0cs0t5.jpg" alt=""></p>
<h3 id="模块组件"><a href="#模块组件" class="headerlink" title="模块组件"></a>模块组件</h3><h4 id="Bootstrap"><a href="#Bootstrap" class="headerlink" title="Bootstrap"></a><code>Bootstrap</code></h4><p><code>Bootstrap</code>是启动引导类，一个 <code>Netty</code> 应用通常由一个 <code>Bootstrap</code> 开始，主要作用是配置整个 <code>Netty</code> 程序，串联各个组件</p>
<ul>
<li><code>Bootstrap</code> 类是客户端程序的启动引导类</li>
<li><code>ServerBootstrap</code> 类是服务端启动引导类</li>
</ul>
<h4 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a><code>Channel</code></h4><p><code>Channel</code>的本质是对操作系统产生的FD（文件描述符）的映射，并且提供绑定到<code>Selector</code>多路选择器上的能力</p>
<h4 id="ChannelFuture"><a href="#ChannelFuture" class="headerlink" title="ChannelFuture"></a><code>ChannelFuture</code></h4><p>在 <code>Netty</code> 中所有的IO操作都是异步的，不能立刻得知消息是否被正确处理。 <code>Future</code> 对象可以看作是一个异步操作结果的占位符；它将在未来的某个时刻完成，并提供对其结果的访问。</p>
<p><code>Netty</code> 提供了<code>ChannelFuture</code>，用于在执行异步操作的时候使用。每个<code>Netty</code>的出站IO操作都会返回一个<code>ChannelFuture</code>。<code>ChannelFuture</code>可以注册<code>ChannelFutureListener</code> 实例，其中的回调方法<code>operationComplete()</code>,将会在对应的操作完成时被调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">ChannelFuture <span class="title">write</span><span class="params">(Object msg, ChannelPromise promise)</span></span>;</div></pre></td></tr></table></figure>
<h4 id="ChannelHandler"><a href="#ChannelHandler" class="headerlink" title="ChannelHandler"></a><code>ChannelHandler</code></h4><p><code>ChannelHandler</code> 是一个接口，它充当了所有处理入站和出站数据的应用程序逻辑的容器，并将其转发到其 <code>ChannelPipeline</code>中的下一个<code>ChannelHandler</code>；该类是基于事件驱动的，它会响应相关的事件然后去调用其关联的回调函数，例如：当一个新的连接被建立时，<code>ChannelHandler</code>的<code>channelActive()</code>方法将会被调用</p>
<p><code>ChannelHandler</code>子类，例如：</p>
<ul>
<li><code>ChannelInboundHandler</code>：用于处理入站IO事件。</li>
<li><code>ChannelOutboundHandler</code>：用于处理出站IO操作。</li>
</ul>
<h4 id="ChannelPipline"><a href="#ChannelPipline" class="headerlink" title="ChannelPipline"></a><code>ChannelPipline</code></h4><p><code>ChannelPipeline</code> 是聚合了 <code>ChannelHandler</code> 的管道，本质上是一个职责链路（用于处理<code>Channel</code>的入站事件和出站操作），在<code>Worker</code>线程中会对每一个<code>Channel</code>执行其所对应的<code>pipeline</code>链，完成整个生命周期。</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fy8rq2caj7j30uw08k76d.jpg" alt=""></p>
<p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fy8tkgaop2j31jo0mcac9.jpg" alt=""></p>
<p>蓝色表示 <code>ChannelInboundHandler</code> ，绿色表示 <code>ChannelOutboundHandler</code>，黄色则承担两个角色，而每个<code>Handler</code>又会使用 <code>ChannelHandlerContext</code> 封装起来，在 <code>ChannelPipeline</code> 中组装成双向链表。</p>
<p><strong>ChannelPipeline handler 执行顺序</strong>：</p>
<ul>
<li><strong>入站事件流从头到尾执行所有的<code>handler</code>(入站的时候也会经过<code>OutboundChannelHandler</code>，只不过略过了这个<code>ChannelHandler</code>)</strong></li>
<li><strong>出站事件流从尾到头执行所有的<code>handler</code>(出站的时候也会经过<code>InboundChannelHandler</code>，只不过略过了这个<code>ChannelHandler</code>)</strong></li>
</ul>
<p><strong>注意： 在具体业务处理类<code>ProcessingHandler</code>中将响应数据发出有2种方式</strong>：</p>
<ol>
<li><code>ChannelHandlerContext.writeAndFlush(msg)</code>：不用经过<code>TailConext</code>, 从该<code>handler</code>开始往前执行<code>OutboundChannelHandler</code>，性能更好一些</li>
<li><code>ChannelHandlerContext.pipeline().writeAndFlush(msg)</code>：从<code>TailConext</code>开始执行， 往前执行<code>OutboundChannelHandler</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> AbstractChannelHandlerContext <span class="title">findContextOutbound</span><span class="params">()</span> </span>&#123;</div><div class="line">        AbstractChannelHandlerContext ctx = <span class="keyword">this</span>;</div><div class="line">        do &#123;</div><div class="line">            <span class="comment">// 注意，这里是往前找</span></div><div class="line">            ctx = ctx.prev;</div><div class="line">        &#125; <span class="keyword">while</span> (!ctx.outbound);</div><div class="line">        <span class="keyword">return</span> ctx;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h4 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a><code>EventLoop</code></h4><p><code>EventLoop</code> 是事件循环，对应<code>Reactor</code>线程，以 <code>NioEventLoop</code> 为例，实现原理是：维护了一个线程和任务队列，支持异步提交任务，线程启动时会调用<code>NioEventLoop</code> 的 <code>run</code> 方法，执行IO任务和非IO任务，由于 <code>EventLoop</code> 是单线程，因此在使用时要注意耗时操作，阻塞操作都不要放到 <code>EventLoop</code> 中，其适合处理耗时短并且简单的任务</p>
<ul>
<li><strong>IO任务</strong>：即 <code>selectionKey</code> 中事件，如 <code>accept</code>、<code>connect</code>、<code>read</code>、<code>write</code>等，由<code>processSelectedKeys</code>方法触发。</li>
<li><strong>非IO任务</strong>：添加到 <code>taskQueue</code> 中的任务，如延迟任务，由 <code>runAllTasks</code> 方法触发。</li>
</ul>
<p>两种任务的执行时间比由变量 <code>ioRatio</code> 控制，默认为50%，则表示允许<strong>非IO任务执行的时间与IO任务的执行时间相等</strong></p>
<h4 id="EventLoopGroup"><a href="#EventLoopGroup" class="headerlink" title="EventLoopGroup"></a><code>EventLoopGroup</code></h4><p><code>EventLoopGroup</code>包含一个或者多个<code>EventLoop</code>，主要管理<code>EventLoop</code>的生命周期，可以理解为一个线程池，内部维护了一组线程，<strong>每个线程(<code>EventLoop</code>)可以负责处理多个<code>Channel</code>上的事件，而一个<code>Channel</code>只能注册于一个<code>EventLoop</code>(防止线程并发问题)</strong></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.lmlphp.com/user/95/article/item/12624/" target="_blank" rel="external">最透彻的Netty原理架构解析</a></p>
<p><a href="http://www.liuhaihua.cn/archives/530938.html" target="_blank" rel="external">Netty–Reactor模型的应用</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Netty fix epoll bug]]></title>
      <url>http://zsr.github.io/2018/12/15/Netty-fix-epoll-bug/</url>
      <content type="html"><![CDATA[<p><code>JDK NIO</code>的<code>epoll bug</code>，会导致<code>Selector</code>空轮询，最终导致CPU 100%</p>
<h3 id="Bug出现的原因"><a href="#Bug出现的原因" class="headerlink" title="Bug出现的原因"></a><strong><code>Bug</code>出现的原因</strong></h3><p>若<code>Selector</code>的轮询结果一直为空，没有新消息处理，则发生空轮询，CPU使用率100%（在<code>selector</code>中，即使是<code>select</code>轮询事件为0的话，照样不断的从<code>select</code>本应该阻塞状态下<code>wake up</code>出来）</p>
<h3 id="Netty的解决方案"><a href="#Netty的解决方案" class="headerlink" title="Netty的解决方案"></a><strong><code>Netty</code>的解决方案</strong></h3><ul>
<li>对<code>Selector</code>的<code>select</code>操作周期进行统计，每完成一次空的<code>select</code>操作进行一次计数</li>
<li>若在某个周期内连续发生N次空轮询，则触发了<code>epoll</code>死循环bug。</li>
<li>重建<code>Selector</code>，将出现bug的<code>Selector</code>上的<code>channel</code>重新注册到新的<code>Selector</code>上，并将原来的<code>Selector</code>关闭，使用新的<code>Selector</code>进行替换。</li>
</ul>
<h3 id="JDK源码分析："><a href="#JDK源码分析：" class="headerlink" title="JDK源码分析："></a><code>JDK</code>源码分析：</h3><p><code>JDK NIO</code>执行代码如下：</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fy7ija4ukgj311e0j2q7v.jpg" alt=""></p>
<p>执行<code>selector.select()</code>方法返回keys是0，所以本应该对key值进行遍历的事件处理根本没有执行，又回到最上面的<code>while(true)</code>循环，循环往复，不断的轮询，直到系统出现100%的CPU情况，最终导致程序崩溃。</p>
<h3 id="Netty源码分析"><a href="#Netty源码分析" class="headerlink" title="Netty源码分析"></a><code>Netty</code>源码分析</h3><p>具体位置在实现类<code>NioEventLoop</code>中：</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fy7jey5qmkj315c0nigso.jpg" alt=""></p>
<p><code>netty</code>会在每次进行 <code>selector.select(timeoutMillis)</code> 之前记录一下开始时间<code>currentTimeNanos</code>，在<code>select</code>之后记录一下结束时间，判断<code>select</code>操作是否至少持续了<code>timeoutMillis</code>时间；<code>selectCnt</code>记录空轮询次数</p>
<h4 id="重建selector"><a href="#重建selector" class="headerlink" title="重建selector"></a>重建<code>selector</code></h4><p>当发生<code>epoll bug</code>，则创建一个新的<code>Selector</code>，将出现bug的<code>Selector</code>上的<code>channel</code>重新注册到新的<code>Selector</code>上，关闭bug的<code>Selector</code>，使用新的<code>Selector</code>进行替换 :</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fy7k5ilf63j31h40u0ahl.jpg" alt=""></p>
<p><code>Netty</code>的解决策略：</p>
<ul>
<li>根据该<code>bug</code>的特征，首先侦测该<code>bug</code>是否发生</li>
<li>将问题<code>Selector</code>上注册的<code>Channel</code>转移到新建的<code>Selector</code>上</li>
<li>老的问题<code>Selector</code>关闭，使用新建的<code>Selector</code>替换</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/JAYIT/p/8241634.html" target="_blank" rel="external">NIO的epoll空轮询bug</a></p>
<p><a href="http://blogxin.cn/2017/03/20/Netty-epollbug/" target="_blank" rel="external">Netty源码分析 解决NIO的epoll死循环bug</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[java 和netty epoll实现]]></title>
      <url>http://zsr.github.io/2018/12/14/java-%E5%92%8Cnetty-epoll%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<p><code>Java NIO</code>根据操作系统不同， 针对<code>Selector</code>有不同的默认实现：</p>
<ul>
<li><strong>macosx</strong>：KQueueSelectorProvider</li>
<li><strong>solaris</strong>：DevPollSelectorProvider</li>
<li><strong>Linux</strong>：EPollSelectorProvider (Linux kernels &gt;= 2.6)或 PollSelectorProvider</li>
<li><strong>windows</strong>： WindowsSelectorProvider</li>
</ul>
<h3 id="为什么netty还要提供一个基于epoll的实现"><a href="#为什么netty还要提供一个基于epoll的实现" class="headerlink" title="为什么netty还要提供一个基于epoll的实现"></a>为什么<code>netty</code>还要提供一个基于<code>epoll</code>的实现</h3><p>自4.0.16起, <code>Netty</code>为<code>Linux</code>通过<code>JNI</code>的方式提供了<code>native socket transport</code>.</p>
<ul>
<li><code>NioEventLoopGroup</code> → <code>EpollEventLoopGroup</code></li>
<li><code>NioEventLoop</code> → <code>EpollEventLoop</code></li>
<li><code>NioServerSocketChannel</code> → <code>EpollServerSocketChannel</code></li>
<li><code>NioSocketChannel</code> → <code>EpollSocketChannel</code></li>
</ul>
<p><strong>原因：</strong></p>
<ol>
<li><code>Netty</code>的 <code>epoll transport</code>使用 <code>epoll</code>边缘触发 而 <code>java nio</code> 使用 <code>epoll</code>水平触发（在这个模式下，io来了数据，就只通知这些io设备对应的fd，上次通知过的fd不再通知，内核不用扫描一大堆fd）</li>
<li><code>netty epoll transport</code> 暴露了更多的<code>java nio</code>没有的配置参数， 如 <code>TCP_CORK</code>, <code>SO_REUSEADDR</code>等</li>
</ol>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://netty.io/wiki/native-transports.html" target="_blank" rel="external">Netty native transports</a></p>
<p><a href="https://stackoverflow.com/questions/23465401/why-native-epoll-support-is-introduced-in-netty" target="_blank" rel="external">Why native epoll support is introduced in Netty?</a></p>
<p><a href="https://www.cnblogs.com/tianhangzhang/p/5374034.html" target="_blank" rel="external">高性能网络服务器编程：为什么linux下epoll是最好，Netty要比NIO好？</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Netty Server Demo]]></title>
      <url>http://zsr.github.io/2018/12/14/Netty-Server-Demo/</url>
      <content type="html"><![CDATA[<h3 id="Maven添加依赖"><a href="#Maven添加依赖" class="headerlink" title="Maven添加依赖"></a><code>Maven</code>添加依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.29.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="Server-Demo"><a href="#Server-Demo" class="headerlink" title="Server Demo"></a><code>Server Demo</code></h3><h4 id="模拟请求-响应model"><a href="#模拟请求-响应model" class="headerlink" title="模拟请求/响应model"></a>模拟请求/响应<code>model</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.zsr.test.netty;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestData</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">int</span> intValue;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIntValue</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> intValue;</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIntValue</span><span class="params">(<span class="keyword">int</span> intValue)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.intValue = intValue;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// return RequestData inValue * 2</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponseData</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">int</span> intValue;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIntValue</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> intValue;</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIntValue</span><span class="params">(<span class="keyword">int</span> intValue)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.intValue = intValue;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="服务端对请求解码"><a href="#服务端对请求解码" class="headerlink" title="服务端对请求解码"></a>服务端对请求解码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerRequestDecoder</span> <span class="keyword">extends</span> <span class="title">ReplayingDecoder</span>&lt;<span class="title">RequestData</span>&gt; </span>&#123;</div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    RequestData data = <span class="keyword">new</span> RequestData();</div><div class="line">    data.setIntValue(in.readInt());</div><div class="line">    out.add(data);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="服务端对响应编码"><a href="#服务端对响应编码" class="headerlink" title="服务端对响应编码"></a>服务端对响应编码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerResponseEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span>&lt;<span class="title">ResponseData</span>&gt; </span>&#123;</div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, ResponseData msg, ByteBuf out)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    out.writeInt(msg.getIntValue());</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="服务端具体业务处理"><a href="#服务端具体业务处理" class="headerlink" title="服务端具体业务处理"></a>服务端具体业务处理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerProcessingHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    RequestData requestData = (RequestData) msg;</div><div class="line">    ResponseData responseData = <span class="keyword">new</span> ResponseData();</div><div class="line">    responseData.setIntValue(requestData.getIntValue() * <span class="number">2</span>);</div><div class="line">    ctx.writeAndFlush(responseData);</div><div class="line">    System.out.println(<span class="string">"server receive request: "</span> + requestData.getIntValue());</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyTestServer</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="keyword">new</span> NettyTestServer(<span class="number">8080</span>).start();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</div><div class="line">    EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</div><div class="line">      bootstrap.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class)</div><div class="line">          .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">              ch.pipeline().addLast(<span class="keyword">new</span> ServerRequestDecoder(), <span class="keyword">new</span> ServerResponseEncoder(),</div><div class="line">                  <span class="keyword">new</span> ServerProcessingHandler());</div><div class="line">            &#125;</div><div class="line">          &#125;).option(ChannelOption.SO_BACKLOG, <span class="number">128</span>).childOption(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>);</div><div class="line"></div><div class="line">      ChannelFuture channelFuture = bootstrap.bind(<span class="keyword">new</span> InetSocketAddress(port)).sync();</div><div class="line">      System.out.println(</div><div class="line">          NettyTestServer.class.getName() + <span class="string">" started and listen on "</span> + channelFuture.channel().localAddress());</div><div class="line"></div><div class="line">      channelFuture.channel().closeFuture().sync();</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">      workerGroup.shutdownGracefully();</div><div class="line">      bossGroup.shutdownGracefully();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.baeldung.com/netty" target="_blank" rel="external">Introduction to Netty</a></p>
<p><a href="https://sylvanassun.github.io/2017/11/30/2017-11-30-netty_introduction/" target="_blank" rel="external">Netty的那点事儿</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Netty初探]]></title>
      <url>http://zsr.github.io/2018/12/12/Netty%E5%88%9D%E6%8E%A2/</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Netty is an asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp; clients.</div><div class="line"></div><div class="line">Netty is a NIO client server framework which enables quick and easy development of network applications such as protocol servers and clients. It greatly simplifies and streamlines network programming such as TCP and UDP socket server.</div></pre></td></tr></table></figure>
<h3 id="为什么不选择JAVA原生NIO"><a href="#为什么不选择JAVA原生NIO" class="headerlink" title="为什么不选择JAVA原生NIO"></a>为什么不选择<code>JAVA</code>原生<code>NIO</code></h3><ul>
<li><code>NIO</code> 的类库和 <code>API</code> 繁杂，使用麻烦：需要熟练掌握 <code>Selector</code>、<code>ServerSocketChannel</code>、<code>SocketChannel</code>、<code>ByteBuffer</code>等。</li>
<li>编写出高质量的 <code>NIO</code> 程序需要具备其他的额外技能做铺垫：例如熟悉 <code>Java</code> 多线程编程，因为 <code>NIO</code> 编程涉及到 <code>Reactor</code> 模式，必须对多线程和网路编程非常熟悉。</li>
<li><code>NIO</code> 编程的特点是功能开发相对容易，但是可靠性能力补齐工作量和难度都非常大：例如客户端面临断连重连、网络闪断、半包读写、失败缓存、网络拥塞和异常码流的处理等等。</li>
<li><a href="http://www.10tiao.com/html/308/201602/401718035/1.html" target="_blank" rel="external"><code>JDK NIO</code>的 <code>Epoll Bug</code>，它会导致<code>Selector</code>空轮询，最终导致<code>CPU 100%</code></a></li>
</ul>
<h3 id="为什么选择Netty"><a href="#为什么选择Netty" class="headerlink" title="为什么选择Netty"></a>为什么选择<code>Netty</code></h3><ul>
<li><code>API</code>使用简单，开发门槛低；</li>
<li>功能强大，预置了多种编解码功能，支持多种主流协议；</li>
<li><strong>定制能力强，可以通过ChannelHandler对通信框架进行灵活地扩展；</strong></li>
<li>性能高，通过与其他业界主流的<code>NIO</code>框架对比，Netty的综合性能最优；</li>
<li>成熟、稳定，<code>Netty</code>修复了已经发现的所有<code>JDK NIO BUG</code>；</li>
</ul>
<h3 id="Netty架构设计"><a href="#Netty架构设计" class="headerlink" title="Netty架构设计"></a><code>Netty</code>架构设计</h3><p><code>Netty</code>采用了比较典型的三层网络架构进行设计，逻辑架构图如下所示：</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fy53lm41bjj30ts0fytgt.jpg" alt=""></p>
<ul>
<li>传输服务：支持 <code>BIO</code> 和 <code>NIO</code></li>
<li>容器集成：支持 <code>OSGI</code>、<code>JBossMC</code>、<code>Spring</code>、<code>Guice</code>容器</li>
<li>协议支持：<code>HTTP</code>、<code>Protobuf</code>、二进制、<code>WebSocket</code>等一系列常见协议都支持。还支持通过实行编码解码逻辑来实现自定义协议</li>
<li><code>Core</code> 核心：可扩展事件模型、通用通信 <code>API</code>、支持零拷贝的 <code>ByteBuf</code> 缓冲对象</li>
</ul>
<h3 id="高性能的三大要素"><a href="#高性能的三大要素" class="headerlink" title="高性能的三大要素"></a><strong>高性能的三大要素</strong></h3><ol>
<li><strong>传输</strong>：用什么样的通道将数据发送给对方，BIO、NIO 或者 AIO，<strong>IO 模型在很大程度上决定了框架的性能</strong>。</li>
<li><strong>协议</strong>：采用什么样的通信协议，<code>HTTP</code> 或者内部私有协议。协议的选择不同，性能模型也不同。相比于公有协议，内部私有协议的性能通常可以被设计的更优。</li>
<li><strong>线程模型</strong>：数据报如何读取？读取之后的编解码在哪个线程进行，编解码后的消息如何派发，<code>Reactor</code> 线程模型的不同，对性能的影响也非常大。</li>
</ol>
<p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fy53swbgjzj30rc0nwdk8.jpg" alt=""></p>
<h3 id="Netty高性能原因"><a href="#Netty高性能原因" class="headerlink" title="Netty高性能原因"></a><code>Netty</code>高性能原因</h3><h4 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a><strong>IO模型</strong></h4><p><code>Netty</code>的IO线程<code>NioEventLoop</code>由于聚合了多路复用器<code>Selector</code>，可以同时并发处理成百上千个客户端<code>Channel</code>，由于读写操作都是非阻塞的，这就可以充分提升IO线程的运行效率，避免由于频繁IO阻塞导致的线程挂起</p>
<h4 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h4><p><strong>在后面的文章专门详解</strong></p>
<h4 id="内存池"><a href="#内存池" class="headerlink" title="内存池"></a>内存池</h4><p><strong>在后面的文章专门详解</strong></p>
<h4 id="Netty-线程模型"><a href="#Netty-线程模型" class="headerlink" title="Netty 线程模型"></a><strong>Netty 线程模型</strong></h4><p><code>Netty</code> 主要基于主从 <code>Reactor</code> 多线程模型（如下图）做了一定的修改，其中主从 <code>Reactor</code> 多线程模型有多个 <code>Reactor</code>：</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fy548sanm2j30rk0iwh0n.jpg" alt=""></p>
<ul>
<li><code>MainReactor</code>负责客户端的连接请求，并将请求转交给 <code>SubReactor</code></li>
<li><code>SubReactor</code>负责相应通道的IO读写请求</li>
<li>非IO请求（具体逻辑处理）等待 <code>worker threads</code> 进行处理</li>
</ul>
<p><strong>注意：<code>Netty</code> 的线程模型基于主从 <code>Reactor</code>多线程，借用了 <code>MainReactor</code> 和 <code>SubReactor</code> 的结构。但是<code>Netty</code>实际实现上 <code>SubReactor</code> 和 <code>Worker</code> 线程在同一个线程池中</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(); </div><div class="line">EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup(); </div><div class="line">ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap(); </div><div class="line">bootstrap.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class)</div></pre></td></tr></table></figure>
<p><code>Netty</code>里对应<code>mainReactor</code>的角色叫做<code>Boss</code>，而对应<code>subReactor</code>的角色叫做<code>Worker</code></p>
<p><code>bossGroup</code> 和 <code>workerGroup</code> 这两个 <code>group</code> 均是线程池：</p>
<ul>
<li><code>bossGroup</code> 线程池则只是在 <code>Bind</code> 某个端口后，获得其中一个线程作为 <code>MainReactor</code>，专门处理端口的 <code>Accept</code> 事件</li>
<li><code>workerGroup</code> 线程池会被各个<code>SubReactor</code> 和 <code>Worker</code> 线程充分利用</li>
</ul>
<h3 id="Netty线程模型"><a href="#Netty线程模型" class="headerlink" title="Netty线程模型"></a>Netty线程模型</h3><p>下图来自组内大牛分享，盗来使用～～：</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fy6dbsx3k1j31d60sok1f.jpg" alt=""></p>
<p><strong>注意：服务器端的 <code>ServerSocketChannel</code> 只绑定到了 <code>bossGroup</code> 中的一个线程, 因此在调用<code>Selector.select</code> 处理客户端的连接请求时, 实际上是在一个线程中的, 所以对只有一个服务(监听一个端口)的应用来说, <code>bossGroup</code> 设置多个线程是没有什么作用的, 反而还会造成资源浪费。</strong></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.baeldung.com/netty" target="_blank" rel="external">Introduction to Netty</a></p>
<p><a href="https://sylvanassun.github.io/2017/11/30/2017-11-30-netty_introduction/" target="_blank" rel="external">Netty的那点事儿</a></p>
<p><a href="https://xiaozhuanlan.com/topic/2153098467" target="_blank" rel="external">NIO Reactor 模型 &amp; Netty 线程模型</a></p>
<p><a href="https://stackoverflow.com/questions/22280916/do-we-need-more-than-a-single-thread-for-boss-group" target="_blank" rel="external">do we need more than a single thread for boss group?</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Reactor 模型]]></title>
      <url>http://zsr.github.io/2018/12/07/Reactor-%E6%A8%A1%E5%9E%8B/</url>
      <content type="html"><![CDATA[<p>服务端如何处理请求：后端接收到一个请求，简化下会做以下四个操作：</p>
<ol>
<li><strong>建立连接</strong></li>
<li><strong>读取数据</strong></li>
<li><strong>业务操作</strong></li>
<li><strong>写回数据</strong></li>
</ol>
<p><strong>Reactor的核心思想</strong>：<code>Reactor</code> 模式也叫 <code>Dispatcher</code> 模式，将关注的IO事件注册到多路复用器上，一旦有IO事件触发，将事件分发到事件处理器中，执行就绪IO事件对应的处理函数中。模型中有三个重要的组件：</p>
<ul>
<li><code>Reactor</code>：在一个单独的线程中运行，负责监听和分发事件，分发给适当的处理程序来对 IO 事件做出反应。</li>
<li><code>Handlers</code>：处理程序执行IO事件要完成的实际事件，<code>Reactor</code>通过调度处理程序来响应IO事件，处理程序执行非阻塞操作。</li>
</ul>
<h3 id="Reactor模式演进"><a href="#Reactor模式演进" class="headerlink" title="Reactor模式演进"></a><a href="http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf" target="_blank" rel="external">Reactor模式演进</a></h3><p><code>Reactor</code> 模型取决于 <code>Reactor</code> 的数量和 <code>Hanndler</code> 线程数量的不同，<code>Reactor</code> 模型有 3 个变种：</p>
<ul>
<li>单线程<code>Reactor</code>模式：单<code>Reactor</code>单线程<code>Hanndler</code></li>
<li>多线程<code>Reactor</code>模式：单<code>Reactor</code>多线程<code>Hanndler</code></li>
<li>主从<code>Reactor</code>模式：主从<code>Reactor</code>多线程<code>Hanndler</code></li>
</ul>
<p><code>Reactor</code> 就是一个执行 <code>while (true) { selector.select(); …}</code> 循环的线程，会源源不断的产生新的事件，称作反应堆很贴切。</p>
<h4 id="单线程Reactor模式"><a href="#单线程Reactor模式" class="headerlink" title="单线程Reactor模式"></a>单线程<code>Reactor</code>模式</h4><p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fy1i62jskoj31la0muk05.jpg" alt=""></p>
<p>单线程<code>Reactor</code>模式 : 建立连接，读取/写回数据和业务操作都在同一个<code>Reactor</code>线程中执行，虽然<code>Reactor</code>的读取写回不会造成阻塞，但是业务操作就很可能造成阻塞；并且单线程不能充分利用<code>CPU</code>多核优势，因此处理能力是有限的，对于小量连接情况下问题不大，对于大量链接情况下，单个<code>NIO</code>线程因处理能力有限会导致连接大量超时。</p>
<h4 id="多线程Reactor模式"><a href="#多线程Reactor模式" class="headerlink" title="多线程Reactor模式"></a>多线程<code>Reactor</code>模式</h4><p>将非IO的业务逻辑操作从<code>Reactor</code>线程上卸载，以此来加速<code>Reactor</code>线程对IO请求的响应。</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fy2txzpfcwj30rs0jjqdo.jpg" alt=""></p>
<p>多线程<code>Reactor</code>模式：多线程模式下把业务操作（<code>decode</code>，<code>compute</code>，<code>encode</code>）等放到线程池中处理，保证<code>Reactor</code>线程不会阻塞，而<code>Reactor</code>仍为单个线程仍然要处理连接和读取/写回操作，其承担连接负载量上来时仍然承受很大压力（例如并发百万客户端连接，或者服务端需要对客户端握手进行安全认证，但是认证本身非常损耗性能）</p>
<h3 id="主从Reactor模式"><a href="#主从Reactor模式" class="headerlink" title="主从Reactor模式"></a>主从<code>Reactor</code>模式</h3><p><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fy3sy13x4cj312u0r847b.jpg" alt=""></p>
<p>主从<code>Reactor</code>模式：相比多线程<code>Reactor</code>模式，主从<code>Reactor</code>模式下把IO读取/写回两个操作放在 <strong>从Reactor线程池</strong> 中执行， <strong>主Reactor线程</strong>也就是<code>Acceptor</code>只负责建立连接，建立之后将其注册到 <strong>从Reactor线程</strong> 中，因此大大提高了负载能力。同时为了避免并发问题还要保证一个连接只能注册一个<code>Reactor</code>线程上</p>
<ul>
<li><code>MainReactor</code>负责客户端的连接请求，并将请求转交给 <code>SubReactor</code></li>
<li><code>SubReactor</code>负责相应通道的IO读写操作</li>
<li>非IO请求（具体逻辑处理）的任务则会交由工作线程池处理</li>
</ul>
<p><strong>好处：因为subReactor也会执行一些比较耗时的IO操作，例如消息的读写，使用多个线程去执行，则更加有利于发挥CPU的运算能力，减少IO等待时间。</strong></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf" target="_blank" rel="external">Scalable IO in Java</a></p>
<p><a href="http://www.liuhaihua.cn/archives/530938.html" target="_blank" rel="external">Netty–Reactor模型的应用</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java NIO:Selector详解]]></title>
      <url>http://zsr.github.io/2018/12/04/Java-NIO-Selector%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p><code>Selector</code>事件分发器(单线程选择就绪的事件)作为Java NIO的核心组件，这里详细了解内部实现</p>
<h3 id="服务端代码"><a href="#服务端代码" class="headerlink" title="服务端代码"></a>服务端代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">ServerSocketChannel serverChannel = ServerSocketChannel.open();</div><div class="line">serverChannel.configureBlocking(<span class="keyword">false</span>);</div><div class="line">serverChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(port));</div><div class="line">Selector selector = Selector.open();</div><div class="line">serverChannel.register(selector, SelectionKey.OP_ACCEPT);</div><div class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">    selector.select();</div><div class="line">    Iterator iter = <span class="keyword">this</span>.selector.selectedKeys().iterator();</div><div class="line">    <span class="keyword">while</span>(iter.hasNext())&#123;</div><div class="line">        SelectionKey key = (SelectionKey)iter.next();</div><div class="line">        <span class="keyword">if</span> (key.isAcceptable())&#123;</div><div class="line">            SocketChannel clientChannel = ((ServerSocketChannel) key.channel()).accept();</div><div class="line">            clientChannel.configureBlocking(<span class="keyword">false</span>);</div><div class="line">            <span class="comment">// 监听客户端socket可读就绪事件</span></div><div class="line">            client.register(selector, SelectionKey.OP_READ);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (key.isReadable())&#123;</div><div class="line">            handleRead(key);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (key.isWritable() &amp;&amp; key.isValid())&#123;</div><div class="line">            handleWrite(key);</div><div class="line">        &#125;</div><div class="line">      iter.remove();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>如果有客户端A连接服务，执行<code>select</code>方法时，可以通过<code>serverSocketChannel</code>获取客户端A的<code>socketChannel</code>，并在<code>selector</code>上注册<code>socketChannel</code>的<code>OP_READ</code>事件。</li>
<li>如果客户端A发送数据，会触发<code>OP_READ</code>事件，这样下次轮询调用<code>select</code>方法时，就能通过<code>socketChannel</code>读取数据，同时在<code>selector</code>上注册该<code>socketChannel</code>的<code>OP_WRITE</code>事件，实现服务器往客户端写数据。</li>
</ol>
<h3 id="Selector-open-实现原理"><a href="#Selector-open-实现原理" class="headerlink" title="Selector.open()实现原理"></a><code>Selector.open()</code>实现原理</h3><p><strong>注意：以下源代码皆来源于<code>openjdk8</code></strong></p>
<ul>
<li><code>Selector.open()</code>可以得到一个<code>Selector</code>实例</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Selector <span class="title">open</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="comment">// 首先找到provider,然后再打开Selector</span></div><div class="line">    <span class="keyword">return</span> SelectorProvider.provider().openSelector();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// java.nio.channels.spi.SelectorProvider</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SelectorProvider <span class="title">provider</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">synchronized</span> (lock) &#123;</div><div class="line">        <span class="keyword">if</span> (provider != <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span> provider;</div><div class="line">        <span class="keyword">return</span> AccessController.doPrivileged(</div><div class="line">            <span class="keyword">new</span> PrivilegedAction&lt;SelectorProvider&gt;() &#123;</div><div class="line">                <span class="function"><span class="keyword">public</span> SelectorProvider <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                        <span class="keyword">if</span> (loadProviderFromProperty())</div><div class="line">                            <span class="keyword">return</span> provider;</div><div class="line">                        <span class="keyword">if</span> (loadProviderAsService())</div><div class="line">                            <span class="keyword">return</span> provider;</div><div class="line">                            <span class="comment">// 实际创建SelectorProvider的方法</span></div><div class="line">                        provider = sun.nio.ch.DefaultSelectorProvider.create();</div><div class="line">                        <span class="keyword">return</span> provider;</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>sun.nio.ch.DefaultSelectorProvider</code></li>
</ul>
<p>不同系统对应着不同的<code>sun.nio.ch.DefaultSelectorProvider</code>，以<code>Linux</code>为例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Returns the default SelectorProvider.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SelectorProvider <span class="title">create</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 获取OS名称</span></div><div class="line">    String osname = AccessController</div><div class="line">        .doPrivileged(<span class="keyword">new</span> GetPropertyAction(<span class="string">"os.name"</span>));</div><div class="line">    <span class="comment">// 根据名称来创建不同的Selctor</span></div><div class="line">    <span class="keyword">if</span> (osname.equals(<span class="string">"SunOS"</span>))</div><div class="line">        <span class="keyword">return</span> createProvider(<span class="string">"sun.nio.ch.DevPollSelectorProvider"</span>);</div><div class="line">    <span class="keyword">if</span> (osname.equals(<span class="string">"Linux"</span>))</div><div class="line">        <span class="keyword">return</span> createProvider(<span class="string">"sun.nio.ch.EPollSelectorProvider"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> sun.nio.ch.PollSelectorProvider();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果系统名称是<code>Linux</code>的话，真正创建的是<code>sun.nio.ch.EPollSelectorProvider</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// EPollSelectorProvider.openSelector()</span></div><div class="line"><span class="function"><span class="keyword">public</span> AbstractSelector <span class="title">openSelector</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> EPollSelectorImpl(<span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Linux</code>最终的<code>Selector</code>实现:<code>sun.nio.ch.EPollSelectorImpl</code></p>
<h3 id="EPollSelectorImpl-select-实现原理"><a href="#EPollSelectorImpl-select-实现原理" class="headerlink" title="EPollSelectorImpl.select()实现原理"></a><code>EPollSelectorImpl.select()</code>实现原理</h3><p><code>epoll</code>系统调用主要分为3个函数: <code>epoll_create</code>, <code>epoll_ctl</code>, <code>epoll_wait</code></p>
<h4 id="epoll-create：创建一个epoll-fd"><a href="#epoll-create：创建一个epoll-fd" class="headerlink" title="epoll_create：创建一个epoll fd"></a><code>epoll_create</code>：创建一个<code>epoll fd</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// class EPollSelectorImpl extends SelectorImpl</span></div><div class="line">EPollSelectorImpl(SelectorProvider sp) <span class="keyword">throws</span> IOException &#123;</div><div class="line">        <span class="keyword">super</span>(sp);</div><div class="line">        <span class="comment">// makePipe返回管道的2个文件描述符，编码在一个long类型的变量中</span></div><div class="line">        <span class="comment">// 高32位代表读 低32位代表写</span></div><div class="line">        <span class="comment">// 使用pipe为了实现Selector的wakeup逻辑</span></div><div class="line">        <span class="keyword">long</span> pipeFds = IOUtil.makePipe(<span class="keyword">false</span>);</div><div class="line">        fd0 = (<span class="keyword">int</span>) (pipeFds &gt;&gt;&gt; <span class="number">32</span>);</div><div class="line">        fd1 = (<span class="keyword">int</span>) pipeFds;</div><div class="line">        <span class="comment">// 创建一个EPollArrayWrapper</span></div><div class="line">        pollWrapper = <span class="keyword">new</span> EPollArrayWrapper();</div><div class="line">        pollWrapper.initInterrupt(fd0, fd1);</div><div class="line">        fdToKey = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p> 创建一个<code>EPollArrayWrapper</code> 初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">EPollArrayWrapper() <span class="keyword">throws</span> IOException &#123;</div><div class="line">    <span class="comment">// 创建epoll fd</span></div><div class="line">    epfd = epollCreate();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">epollCreate</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure>
<p>在初始化过程中调用了<code>native epollCreate</code>方法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Java_sun_nio_ch_EPollArrayWrapper_epollCreate(JNIEnv *env, jobject <span class="keyword">this</span>)</div><div class="line">&#123;</div><div class="line">     <span class="comment">//从Linux2.6.8之后，改用了红黑树结构，指定了大小也没用</span></div><div class="line">    <span class="keyword">int</span> epfd = epoll_create(<span class="number">256</span>);</div><div class="line">    <span class="keyword">if</span> (epfd &lt; <span class="number">0</span>) &#123;</div><div class="line">       JNU_ThrowIOExceptionWithLastError(env, <span class="string">"epoll_create failed"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> epfd;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><code>epoll_create</code>: 内核系统调用，创建一个<code>epoll fd</code>, 并且开辟epoll自己的内核高速cache区，建立红黑树分配初始size的内存对象，同时建立一个list链表，用于存储准备就绪的事件</strong></p>
<h4 id="Epoll-wait-等待内核IO事件"><a href="#Epoll-wait-等待内核IO事件" class="headerlink" title="Epoll wait:等待内核IO事件"></a><code>Epoll wait</code>:等待内核IO事件</h4><p>调用<code>Selector.select()</code>,最后会委托给<code>EPollSelectorImpl</code>的<code>doSelect()</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doSelect</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="keyword">if</span> (closed)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClosedSelectorException();</div><div class="line">    processDeregisterQueue();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        begin();</div><div class="line">        <span class="comment">// 等待事件到来，收集事件到来的fd并用来处理</span></div><div class="line">        pollWrapper.poll(timeout);</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        end();</div><div class="line">    &#125;</div><div class="line">    processDeregisterQueue();</div><div class="line">    <span class="keyword">int</span> numKeysUpdated = updateSelectedKeys();</div><div class="line">  </div><div class="line">    <span class="keyword">if</span> (pollWrapper.interrupted()) &#123;</div><div class="line">        <span class="comment">// Clear the wakeup pipe</span></div><div class="line">        pollWrapper.putEventOps(pollWrapper.interruptedIndex(), <span class="number">0</span>);</div><div class="line">        <span class="keyword">synchronized</span> (interruptLock) &#123;</div><div class="line">            pollWrapper.clearInterrupted();</div><div class="line">            IOUtil.drain(fd0);</div><div class="line">            interruptTriggered = <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> numKeysUpdated;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实际执行<code>EPollArrayWrapper.poll(timeout);</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="comment">// 看下文</span></div><div class="line">    updateRegistrations();</div><div class="line">    <span class="comment">// 调用native方法，发起系统内核调用</span></div><div class="line">    updated = epollWait(pollArrayAddress, NUM_EPOLLEVENTS, timeout, epfd);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;updated; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (getDescriptor(i) == incomingInterruptFD) &#123;</div><div class="line">            interruptedIndex = i;</div><div class="line">            interrupted = <span class="keyword">true</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> updated;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">epollWait</span><span class="params">(<span class="keyword">long</span> pollAddress, <span class="keyword">int</span> numfds, <span class="keyword">long</span> timeout,</span></span></div><div class="line">                             <span class="keyword">int</span> epfd) <span class="keyword">throws</span> IOException;</div></pre></td></tr></table></figure>
<p><code>epollWait</code>也是个<code>native</code>方法:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">Java_sun_nio_ch_EPollArrayWrapper_epollWait(JNIEnv *env, jobject <span class="keyword">this</span>,</div><div class="line">                                            jlong address, jint numfds,</div><div class="line">                                            jlong timeout, jint epfd)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">struct</span> epoll_event *events = jlong_to_ptr(address);</div><div class="line">    <span class="keyword">int</span> res;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (timeout &lt;= <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// 发起epoll_wait系统调用等待内核事件</span></div><div class="line">        RESTARTABLE(epoll_wait(epfd, events, numfds, timeout), res);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        res = iepoll(epfd, events, numfds, timeout);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</div><div class="line">        JNU_ThrowIOExceptionWithLastError(env, <span class="string">"epoll_wait failed"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><code>epoll_wait</code>: 内核系统调用, 等待内核返回IO事件</strong></p>
<h4 id="epoll-ctl-IO事件管理"><a href="#epoll-ctl-IO事件管理" class="headerlink" title="epoll_ctl: IO事件管理"></a><code>epoll_ctl</code>: IO事件管理</h4><p>注册到<code>Selector</code>上的IO事件是使用<code>SelectionKey</code>来表示，代表了<code>Channel</code>感兴趣的事件，如<code>Read</code>,<code>Write</code>,<code>Connect</code>,<code>Accept</code>.</p>
<p>调用<code>Selector.register()</code>完成IO事件注册，实际执行<code>EPollSelectorImpl.implRegister()</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">implRegister</span><span class="params">(SelectionKeyImpl ski)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (closed)</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> ClosedSelectorException();</div><div class="line">       SelChImpl ch = ski.channel;</div><div class="line">       <span class="keyword">int</span> fd = Integer.valueOf(ch.getFDVal());</div><div class="line">       fdToKey.put(fd, ski);</div><div class="line">       pollWrapper.add(fd);</div><div class="line">       keys.add(ski);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>调用<code>Selector.register()</code>时均会将事件存储到<code>EpollArrayWrapper</code>的成员变量<code>eventsLow</code>和<code>eventsHigh</code>中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 使用数组保存事件变更, 数组的最大长度是MAX_UPDATE_ARRAY_SIZE, 最大64*1024</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] eventsLow = <span class="keyword">new</span> <span class="keyword">byte</span>[MAX_UPDATE_ARRAY_SIZE];</div><div class="line"><span class="comment">// 超过数组长度的事件会缓存到这个map中，等待下次处理</span></div><div class="line"><span class="keyword">private</span> Map&lt;Integer,Byte&gt; eventsHigh;</div><div class="line"></div><div class="line"><span class="comment">// 添加文件描述符fd</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</div><div class="line">        <span class="comment">// force the initial update events to 0 as it may be KILLED by a</span></div><div class="line">        <span class="comment">// previous registration.</span></div><div class="line">        <span class="keyword">synchronized</span> (updateLock) &#123;</div><div class="line">            <span class="keyword">assert</span> !registered.get(fd);</div><div class="line">            setUpdateEvents(fd, (<span class="keyword">byte</span>)<span class="number">0</span>, <span class="keyword">true</span>);</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setUpdateEvents</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">byte</span> events, <span class="keyword">boolean</span> force)</span> </span>&#123;</div><div class="line">    <span class="comment">// 判断fd和数组长度</span></div><div class="line">    <span class="keyword">if</span> (fd &lt; MAX_UPDATE_ARRAY_SIZE) &#123;</div><div class="line">        <span class="keyword">if</span> ((eventsLow[fd] != KILLED) || force) &#123;</div><div class="line">            eventsLow[fd] = events;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        Integer key = Integer.valueOf(fd);</div><div class="line">        <span class="keyword">if</span> (!isEventsHighKilled(key) || force) &#123;</div><div class="line">            eventsHigh.put(key, Byte.valueOf(events));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行<code>EpollArrayWrapper.poll()</code>的时候, 首先会调用<code>updateRegistrations()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Returns the pending update events for the given file descriptor.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">byte</span> <span class="title">getUpdateEvents</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (fd &lt; MAX_UPDATE_ARRAY_SIZE) &#123;</div><div class="line">        <span class="keyword">return</span> eventsLow[fd];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        Byte result = eventsHigh.get(Integer.valueOf(fd));</div><div class="line">        <span class="comment">// result should never be null</span></div><div class="line">        <span class="keyword">return</span> result.byteValue();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateRegistrations</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">synchronized</span> (updateLock) &#123;</div><div class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (j &lt; updateCount) &#123;</div><div class="line">            <span class="keyword">int</span> fd = updateDescriptors[j];</div><div class="line">            <span class="comment">// 从保存的eventsLow和eventsHigh里取出事件</span></div><div class="line">            <span class="keyword">short</span> events = getUpdateEvents(fd);</div><div class="line">            <span class="keyword">boolean</span> isRegistered = registered.get(fd);</div><div class="line">            <span class="keyword">int</span> opcode = <span class="number">0</span>;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (events != KILLED) &#123;</div><div class="line">                <span class="comment">// 判断操作类型以传给epoll_ctl</span></div><div class="line">                <span class="comment">// 没有指定EPOLLET事件类型</span></div><div class="line">                <span class="keyword">if</span> (isRegistered) &#123;</div><div class="line">                    <span class="comment">// 如果已经注册过，不需要调用epollCtl去内核红黑树新增节点</span></div><div class="line">                    opcode = (events != <span class="number">0</span>) ? EPOLL_CTL_MOD : EPOLL_CTL_DEL;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    opcode = (events != <span class="number">0</span>) ? EPOLL_CTL_ADD : <span class="number">0</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (opcode != <span class="number">0</span>) &#123;</div><div class="line">                    <span class="comment">// 熟悉的epoll_ctl</span></div><div class="line">                    epollCtl(epfd, opcode, fd, events);</div><div class="line">                    <span class="keyword">if</span> (opcode == EPOLL_CTL_ADD) &#123;</div><div class="line">                        registered.set(fd);</div><div class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (opcode == EPOLL_CTL_DEL) &#123;</div><div class="line">                        registered.clear(fd);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            j++;</div><div class="line">        &#125;</div><div class="line">        updateCount = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">epollCtl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> opcode, <span class="keyword">int</span> fd, <span class="keyword">int</span> events)</span></span>;</div></pre></td></tr></table></figure>
<p>在获取到事件之后将操作委托给了<code>epollCtl</code>,这又是个native方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Java_sun_nio_ch_EPollArrayWrapper_epollCtl(JNIEnv *env, jobject <span class="keyword">this</span>, jint epfd,</div><div class="line">                                           jint opcode, jint fd, jint events)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">struct</span> epoll_event event;</div><div class="line">    <span class="keyword">int</span> res;</div><div class="line"></div><div class="line">    event.events = events;</div><div class="line">    event.data.fd = fd;</div><div class="line"></div><div class="line">    <span class="comment">// 发起epoll_ctl调用来进行IO事件的管理</span></div><div class="line">    RESTARTABLE(epoll_ctl(epfd, (<span class="keyword">int</span>)opcode, (<span class="keyword">int</span>)fd, &amp;event), res);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (res &lt; <span class="number">0</span> &amp;&amp; errno != EBADF &amp;&amp; errno != ENOENT &amp;&amp; errno != EPERM) &#123;</div><div class="line">        JNU_ThrowIOExceptionWithLastError(env, <span class="string">"epoll_ctl failed"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>注意：jdk nio没有指定<code>ET(边缘触发)</code>还是<code>LT(水平触发)</code>, 所以默认会用<code>LT</code>, 而<code>Netty epoll transport</code>使用<code>ET</code>触发</strong></p>
<p><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fxv38f07maj310g0jmdm2.jpg" alt=""></p>
<p>通过<code>channel</code>就能不断的获取客户端<code>socket</code>数据，实现后端业务处理</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://juejin.im/entry/5b51546df265da0f70070b93" target="_blank" rel="external">Java NIO分析(8): 高并发核心Selector详解</a></p>
<p><a href="https://www.jianshu.com/p/7b507069debb" target="_blank" rel="external">java NIO 运行原理介绍</a></p>
<p><a href="https://www.baeldung.com/java-nio-selector" target="_blank" rel="external">Introduction to the Java NIO Selector</a></p>
<p><a href="https://www.jianshu.com/p/0d497fe5484a" target="_blank" rel="external">深入浅出NIO之Selector实现原理</a></p>
<p><a href="http://matt33.com/2017/08/12/java-nio/" target="_blank" rel="external">谈一谈 Java IO 模型</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[IO多路复用机制]]></title>
      <url>http://zsr.github.io/2018/11/29/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">One basic concept of Linux (actually Unix) is the rule that everything in Unix/Linux is a file. Each process has a table of file descriptors that point to files, sockets, devices and other operating system objects</div></pre></td></tr></table></figure>
<h3 id="用户空间与内核空间"><a href="#用户空间与内核空间" class="headerlink" title="用户空间与内核空间"></a>用户空间与内核空间</h3><p>对于一次IO访问（以<code>read</code>举例），数据会先被拷贝到操作系统内核的缓冲区中(通过DMA，不需要CPU)，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间(需要CPU)。所以说，当一个read操作发生时，它会经历两个阶段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1. 等待数据准备 (Waiting for the data to be ready)；对于一个socket接口上的操作，这一步骤关系到数据从网络到达，并将其复制到内核的缓冲区</div><div class="line">2. 将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)</div></pre></td></tr></table></figure>
<h3 id="Blocking-IO"><a href="#Blocking-IO" class="headerlink" title="Blocking IO"></a>Blocking IO</h3><p>传统的阻塞 I/O 模型工作方式：当线程使用 <code>read</code> 或者 <code>write</code> 对某一个<strong>文件描述符（File Descriptor 以下简称 FD)</strong>进行读写时，如果当前 FD 不可读或不可写，当前线程会被CPU挂起阻塞，一直等待数据准备完毕。</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fxp3a06e2jj30rs0ku0wq.jpg" alt=""></p>
<p>例如：tomcat服务器BIO模式，利用多线程 + 线程池 处理；即每一个socket连接创建一个独立的线程处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line"> ExecutorService executor = Excutors.newFixedThreadPollExecutor(<span class="number">100</span>);<span class="comment">//线程池</span></div><div class="line"> ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket();</div><div class="line"> serverSocket.bind(<span class="number">8080</span>);</div><div class="line"> <span class="keyword">while</span>(<span class="keyword">true</span>)&#123; <span class="comment">//死循环等待新连接到来</span></div><div class="line"> 	Socket socket = serverSocket.accept();</div><div class="line"> 	executor.submit(<span class="keyword">new</span> ConnectIOHandler(socket));<span class="comment">//为新的连接创建新的线程</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConnectIOHandler</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> Socket socket;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConnectIOnHandler</span><span class="params">(Socket socket)</span></span>&#123;</div><div class="line">       <span class="keyword">this</span>.socket = socket;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">      <span class="keyword">while</span>(!socket.isClosed())&#123; <span class="comment">// 死循环处理读写事件</span></div><div class="line">          String someThing = socket.read()....<span class="comment">//读取数据</span></div><div class="line">          <span class="keyword">if</span>(someThing!=<span class="keyword">null</span>)&#123;</div><div class="line">             ......<span class="comment">//处理数据</span></div><div class="line">             socket.write()....<span class="comment">//写数据</span></div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>线程本身占用较大内存，像Java的线程栈，一般至少分配512K～1M的空间，如果系统中的线程数过千，恐怕整个JVM的内存都会被吃掉一半</li>
<li>线程的切换成本是很高的。操作系统发生线程切换的时候，需要保留线程的上下文，然后执行系统调用。如果线程数过高，可能执行线程切换的时间甚至会大于线程执行的时间</li>
</ul>
<h3 id="IO多路复用-IO-mutiplexing"><a href="#IO多路复用-IO-mutiplexing" class="headerlink" title="IO多路复用(IO mutiplexing)"></a>IO多路复用(IO mutiplexing)</h3><p>IO多路复用就通过一种机制，单个线程通过监视多个I/O流的状态来同时管理多个I/O流，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fxpxgg7qbfj30rs0kun32.jpg" alt=""></p>
<p>当应用进程通过<code>select</code>读取文件(<code>socket</code>)，应用进程会被<code>block</code>，于此同时内核会“监视”所有通过<code>select</code>请求的文件读取(<code>socket</code>)，任何一个文件(<code>socket</code>)的数据被准备好，<code>select</code>就会返回，应用进程再调用<code>read</code>操作，把数据从内核中拷贝到应用进程。</p>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><ul>
<li>IO复用技术的优势在于，只需要使用一个线程就可以管理多个socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，很大程度上减少了资源占用；适合于连接数多的场景(nginx，rpc，redis等)。</li>
<li>如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于<strong>能处理更多的连接</strong></li>
</ul>
<h3 id="select，poll，epoll"><a href="#select，poll，epoll" class="headerlink" title="select，poll，epoll"></a><code>select</code>，<code>poll</code>，<code>epoll</code></h3><p><code>select</code>，<code>poll</code>，<code>epoll</code>都是IO多路复用的实现机制。<code>select</code>，<code>poll</code>，<code>epoll</code>本质上都是同步I/O，因为它们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的</p>
<p><strong>注意: IO多路复用经常被称为异步非阻塞，这里的异步只是相对于以前同步阻塞而起的名称，并非实际情况下的unix异步模型，如果从Unix IO模型角度只能将IO多路复用称为非阻塞IO</strong></p>
<p>对于IO多路复用，有两件事是必须要做的(对于监控可读事件而言)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1. 准备好需要监控的fds集合</div><div class="line">2. 探测并返回fds集合中哪些fd可读</div></pre></td></tr></table></figure>
<h4 id="select"><a href="#select" class="headerlink" title="select"></a><code>select</code></h4><h5 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">单个进程就可以同时处理多个网络连接的IO请求（同时阻塞多个IO操作）。基本原理就是程序调用select()，然后整个程序就阻塞了，这时候，select会将需要监控的readfds集合拷贝到内核空间（假设监控的仅仅是socket可读），kernel就会轮询检查所有select负责的fd，当找到一个client中的数据准备就绪了，select就会返回，这个时候程序就会系统调用，将数据从kernel复制到进程缓冲区。</div></pre></td></tr></table></figure>
<h5 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h5><ul>
<li><code>select</code>目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点</li>
<li>每次调用<code>select</code>，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大</li>
<li>同时每次调用<code>select</code>都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大</li>
<li><code>select</code>支持的文件描述符数量太小了，默认是1024</li>
</ul>
<h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a><code>poll</code></h4><h5 id="基本原理-1"><a href="#基本原理-1" class="headerlink" title="基本原理"></a>基本原理</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">poll的原理与select非常相似，差别如下：</div><div class="line">	1) 描述fd集合的方式不同，poll使用 pollfd 结构而不是select结构fd_set结构，所以poll是链式的，没有最大连接数的限制</div><div class="line">	2) poll有一个特点是水平触发，也就是通知程序fd就绪后，这次没有被处理，那么下次poll的时候会再次通知该fd已经就绪。</div></pre></td></tr></table></figure>
<h5 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h5><p><code>poll</code>机制虽然改进了<code>select</code>的监控大小1024的限制，但以下两个性能问题还没有解决 :</p>
<ul>
<li>fds集合整体仍然需要从用户空间拷贝到内核空间的问题，而不管这样的复制是不是有意义</li>
<li>当被监控的fds中某些有数据可读的时候，我们希望通知更加精细一点，就是我们希望能够从通知中得到有可读事件的fds列表，而不是需要遍历整个fds来收集。</li>
</ul>
<h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a><code>epoll</code></h4><p>它是由<code>Linux</code>内核2.6推出的可伸缩的IO多路复用实现，目的是为了替代<code>select()</code>与<code>poll()</code></p>
<p>事实上，同时连接的大量客户端在一时刻可能只有很少的处于就绪状态，因此随着监视的描述符数量的增长，<code>select()</code>与<code>poll()</code>的效率也会线性下降。</p>
<h5 id="基本原理-2"><a href="#基本原理-2" class="headerlink" title="基本原理"></a>基本原理</h5><p><code>select</code>和<code>poll</code>都只提供了一个函数－<code>select</code>或者<code>poll</code>函数。而<code>epoll</code>提供了三个函数，分别如下：</p>
<ul>
<li><strong>int epoll_create(int size)</strong>：// 创建一个<code>epoll</code>的句柄，size用来告诉内核这个监听的数目一共有多大</li>
<li><strong>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)</strong>：// 注册描述符fd要监听的事件类型；<code>epfd</code>:是<code>epoll_create()</code>的返回值; fd:需要监听的文件描述符; <code>epoll_event</code>:告诉内核需要监听什么事</li>
<li><strong>int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout)</strong>： // 等待<code>epfd</code>上的io事件，返回在<code>events</code>中发生的事件, 最多返回<code>maxevents</code>个事件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">epoll执行过程:</div><div class="line">	1) 首先执行epoll_create创建一个epoll句柄；并开辟epoll自己的内核高速cache区，在该缓冲区建立红黑树和就绪链表</div><div class="line">	2) epoll_ctl执行add动作时除了将要监听的文件句柄放到红黑树上之外，还向内核注册了该文件句柄的回调函数(内核中断处理程序注册一个回调函数)，内核在检测到某句柄可读可写时（内核针对读缓冲区和写缓冲区来判断是否可读可写）则调用该回调函数，回调函数将文件句柄放到就绪链表(当一个socket上有数据到了，内核在把网卡上的数据copy到内核中后就来把socket插入到准备就绪链表里了)。</div><div class="line">	3) epoll_wait只监控就绪链表就可以(利用schedule_timeout()实现睡一会，判断一会的效果)，如果就绪链表有文件句柄不为空，则表示该文件句柄可读可写，并返回到用户态（少量的拷贝）</div><div class="line">	4) 由于内核不修改文件句柄的位置，因此只需要在第一次传入就可以重复监控，直到使用epoll_ctl删除，否则不需要重新传入，因此无多次拷贝</div></pre></td></tr></table></figure>
<p><code>epoll_ctl</code>通过(<code>EPOLL_CTL_ADD</code>、<code>EPOLL_CTL_MOD</code>、<code>EPOLL_CTL_DEL</code>)三个操作来分散对需要监控的fds集合的修改，做到了有变化才变更，将<code>select/poll</code>高频、大块内存拷贝(集中处理)变成<code>epoll_ctl</code>的低频、小块内存的拷贝(分散处理)，避免了大量的内存拷贝</p>
<h5 id="优缺点-3"><a href="#优缺点-3" class="headerlink" title="优缺点"></a>优缺点</h5><p>相比<code>select/poll</code>，epoll的优点如下：</p>
<ul>
<li>没有最大并发连接的限制，能打开的FD的上限远大于1024 (在1GB内存的机器上大约是10万左右)</li>
<li>效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用<code>callback</code>函数；即<code>epoll</code>最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，<code>epoll</code>的效率就会远远高于<code>select</code>和<code>poll</code>。</li>
<li><code>epoll</code>内部使用了<code>mmap</code>共享了用户和内核的部分空间，避免了数据的来回拷贝</li>
<li><code>epoll</code> 有个致命的缺点，只有<code>linux</code>支持</li>
</ul>
<h5 id="epoll的两种工作模式"><a href="#epoll的两种工作模式" class="headerlink" title="epoll的两种工作模式"></a><code>epoll</code>的两种工作模式</h5><p>支持边缘触发<strong>ET（edge trigger）</strong>与水平触发<strong>LT（level trigger）</strong>两种模式（<code>poll()</code>只支持水平触发）</p>
<ul>
<li><strong>LT模式</strong>：缺省的工作方式，并且同时支持<code>block</code>和<code>no-block socket</code>；当<code>epoll_wait</code>检测到描述符事件发生并将此事件通知应用程序，<code>应用程序可以不立即处理该事件</code>。下次调用<code>epoll_wait</code>时，会再次响应应用程序并通知此事件(<strong>清理就绪列表后，重新把句柄放回刚刚清空的就绪列表</strong>)</li>
<li><p><strong>ET模式</strong>：高速工作方式，只支持<code>no-block socket</code>；当<code>epoll_wait</code>检测到描述符事件发生并将此事件通知应用程序，<code>应用程序必须立即处理该事件</code>。如果不处理，下次调用<code>epoll_wait</code>时，不会再次响应应用程序并通知此事件(<strong>only once</strong>)。所以在<strong>ET模式</strong>下，一般是通过while循环，一次性读完全部数据．<code>epoll</code>默认使用的是LT．</p>
<p><strong>ET模式</strong>在很大程度上减少了<code>epoll</code>事件被重复触发的次数，因此效率要比<strong>LT模式</strong>高。<code>epoll</code>工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p>
</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://devarea.com/linux-io-multiplexing-select-vs-poll-vs-epoll/" target="_blank" rel="external">LINUX – IO MULTIPLEXING – SELECT VS POLL VS EPOLL</a></p>
<p><a href="https://github.com/jasonGeng88/blog/blob/master/201708/java-socket.md" target="_blank" rel="external">JAVA 中原生的 socket 通信机制</a></p>
<p><a href="https://www.zybuluo.com/phper/note/595507" target="_blank" rel="external">通俗讲解 异步，非阻塞和 IO 复用</a></p>
<p><a href="https://draveness.me/redis-io-multiplexing" target="_blank" rel="external">Redis 和 I/O 多路复用</a></p>
<p><a href="https://www.cnblogs.com/Anker/p/3265058.html" target="_blank" rel="external">select、poll、epoll之间的区别总结</a></p>
<p><a href="https://segmentfault.com/a/1190000003063859" target="_blank" rel="external">Linux IO模式及 select、poll、epoll详解</a></p>
<p><a href="https://cs.xieyonghui.com/java/33.html" target="_blank" rel="external">Java NIO和多路复用(I/O multiplexing)</a></p>
<p><a href="https://tech.meituan.com/nio.html" target="_blank" rel="external">Java NIO浅析</a></p>
<p><a href="http://ifeve.com/netty-2-5/" target="_blank" rel="external">《Netty 权威指南》—4种IO的对比</a></p>
<p><a href="https://www.zhihu.com/question/20122137" target="_blank" rel="external">epoll 或者 kqueue 的原理是什么？</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[innoDb快照读]]></title>
      <url>http://zsr.github.io/2018/10/22/innoDb%E5%BF%AB%E7%85%A7%E8%AF%BB/</url>
      <content type="html"><![CDATA[<h3 id="快照读-Snapshot-Read"><a href="#快照读-Snapshot-Read" class="headerlink" title="快照读(Snapshot Read)"></a>快照读(Snapshot Read)</h3><p>MySQL数据库，InnoDB存储引擎，为了提高并发，使用MVCC(<strong>多版本并发控制</strong>)机制，在并发事务时，通过读取数据行的历史数据版本，不加锁，来提高并发的一种不加锁一致性读(Consistent Nonlocking Read)。一致性读，又称为快照读</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">A consistent read means that InnoDB uses multi-versioning to present to a query a snapshot of the database at a point in time. The query sees the changes made by transactions that committed before that point of time, and no changes made by later or uncommitted transactions. The exception to this rule is that the query sees the changes made by earlier statements within the same transaction.</div></pre></td></tr></table></figure>
<p><strong>注意：本事务中修改的数据，即使未提交的数据也可以被本事务的后面部分读取到</strong></p>
<h3 id="快照实现"><a href="#快照实现" class="headerlink" title="快照实现"></a>快照实现</h3><ul>
<li><strong>undo log</strong> ：记录事务变更前的状态。操作数据之前，先将数据备份到undo log，然后进行数据修改(COW:写时备份)，如果出现错误或用户执行了rollback语句，则系统就可以利用undo log中的备份数据恢复到事务开始之前的状态。</li>
<li><strong>redo log：</strong> 记录事务变更后的状态。在事务提交前，只要将redo log持久化即可，数据在内存中变更。当系统崩溃时，虽然数据没有落盘，但是redo log已持久化，系统可以根据redo Log的内容，将所有数据恢复到最新的状态。</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://dev.mysql.com/doc/refman/5.6/en/innodb-consistent-read.html" target="_blank" rel="external">一致性读</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[nginx负载均衡策略]]></title>
      <url>http://zsr.github.io/2018/09/17/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5/</url>
      <content type="html"><![CDATA[<p>负载均衡可以将前端的请求分担到后端多个节点上，提升系统的响应和处理能力。</p>
<h3 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h3><p>负载均衡的策略可以分为两大类：<code>内置策略</code> 和<code>扩展策略</code></p>
<ul>
<li>内置策略：一般会直接编译进Nginx内核，常用的有<code>轮询</code>、<code>ip hash</code></li>
<li>扩展策略：<code>fair</code>、<code>url hash</code>等</li>
</ul>
<h4 id="普通轮询方式"><a href="#普通轮询方式" class="headerlink" title="普通轮询方式"></a>普通轮询方式</h4><p>默认选项，当<code>weight</code>不指定时，各服务器权重相同， 每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">upstream</span> bakend &#123;</div><div class="line">  <span class="attribute">server</span> <span class="number">10.11.0.1</span>;</div><div class="line">  <span class="attribute">server</span> <span class="number">10.11.0.2</span>;</div><div class="line">  <span class="attribute">server</span> <span class="number">10.11.0.3</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="加权轮询方式"><a href="#加权轮询方式" class="headerlink" title="加权轮询方式"></a>加权轮询方式</h4><p>指定轮询几率，<code>weight</code>和访问比率成正比，用于后端服务器性能不均的情况。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">upstream</span> backend &#123;</div><div class="line">  <span class="attribute">server</span> <span class="number">10.11.0.1</span> weight=<span class="number">3</span>;</div><div class="line">  <span class="attribute">server</span> <span class="number">10.11.0.2</span> weight=<span class="number">7</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>权重越高，在被访问的概率越大，如上例，分别是30%，70%。</p>
<h5 id="轮询流程图"><a href="#轮询流程图" class="headerlink" title="轮询流程图"></a>轮询流程图</h5><p><img src="http://www.rowkey.me/images/blog_images/nginx/ngx_wr.png" alt=""></p>
<p>首先将请求都分给高权重的机器，直到该机器的权值降到了比其他机器低，才开始将请求分给下一个高权重的机器；当所有后端机器都down掉时，<code>nginx</code>会立即将所有机器的标志位清成初始状态，以避免造成所有的机器都处在<code>timeout</code>的状态</p>
<h4 id="ip-hash方式"><a href="#ip-hash方式" class="headerlink" title="ip hash方式"></a>ip hash方式</h4><p><strong>默认情况下，Nginx 会为你提供轮询作为负载均衡策略</strong>。</p>
<p>采用<code>ip_hash</code>策略解决登录信息丢失，如果客户已经访问了某个服务器，当用户再次访问时，会将该请求通过<strong>哈希算法，自动定位到同一个服务器</strong>，当然，如果所 <code>hash</code> 到的 <code>server</code> 当前不可用，则请求会被转移到其他<code>server</code>。<br>每个请求按访问<code>ip</code>的<code>hash</code>结果分配，这样每个访客固定访问一个后端服务器，可以解决<strong>session的问题</strong>。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">upstream backend &#123;</div><div class="line">    ip_hash;</div><div class="line">    server 10.11.0.1;</div><div class="line">    server 10.11.0.2;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="fair"><a href="#fair" class="headerlink" title="fair"></a>fair</h4><p>根据后端服务器的响应时间判断负载情况，从中选出负载最轻的机器进行优先分配。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">upstream backend &#123;</div><div class="line">    server 10.11.0.1;</div><div class="line">    server 10.11.0.2;</div><div class="line">    fair;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>缺点：需要「负载均衡器」不停的去统计每一台后端服务器对请求的处理速度，比如一分钟统计一次，生成一个后端服务器处理速度的排行榜，然后「负载均衡器」根据这个排行榜去转发服务。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[jvm内存参数]]></title>
      <url>http://zsr.github.io/2018/05/10/jvm%E5%86%85%E5%AD%98%E5%8F%82%E6%95%B0/</url>
      <content type="html"><![CDATA[<h3 id="线上jvm参数"><a href="#线上jvm参数" class="headerlink" title="线上jvm参数"></a>线上jvm参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">-Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager,</div><div class="line">-XX:MetaspaceSize=256M, // 分配给类元数据空间的初始大小</div><div class="line">-XX:MaxMetaspaceSize=256M, // 分配给类元数据空间的最大值</div><div class="line">-Xms4g, // 初始堆大小</div><div class="line">-Xmx4g, // 最大堆大小</div><div class="line">-Xmn1g, // 年轻代大小</div><div class="line">-Xss256k, // 每个线程的堆栈大小</div><div class="line">-XX:SurvivorRatio=8, // Eden区与Survivor区的大小比值</div><div class="line">-XX:MaxTenuringThreshold=8, // 垃圾最大年龄, 该参数只有在串行GC时才有效.</div><div class="line">-XX:ParallelGCThreads=8, // 并行收集器的线程数</div><div class="line">-XX:+UseConcMarkSweepGC, // 使用CMS内存收集</div><div class="line">-XX:+UseParNewGC, // 设置年轻代为并行收集</div><div class="line">-XX:+DisableExplicitGC, // 关闭System.gc()</div><div class="line">-XX:+CMSParallelRemarkEnabled, // 降低标记停顿</div><div class="line">-XX:+CMSClassUnloadingEnabled, // 在CMS中清理过期的Class而不等到Full GC</div><div class="line">-XX:CMSInitiatingOccupancyFraction=70, // 使用cms作为垃圾回收，使用70％后开始CMS收集</div><div class="line">-XX:CMSFullGCsBeforeCompaction=5, // 多少次GC后进行内存压缩</div><div class="line">-XX:+UseCMSCompactAtFullCollection, // 在FULLGC的时候，对年老代的压缩</div><div class="line">-XX:+CMSScavengeBeforeRemark, // 在CMS remark前，先执行一次minor GC将新生代清掉</div><div class="line">-XX:+HeapDumpOnOutOfMemoryError, // 当OutOfMemoryError发生时，将heap内存dump到文件</div><div class="line">......</div></pre></td></tr></table></figure>
<h4 id="XX-MetaspaceSize"><a href="#XX-MetaspaceSize" class="headerlink" title="-XX:MetaspaceSize"></a>-XX:MetaspaceSize</h4><p><code>Java 8</code>彻底将永久代 (<code>PermGen</code>) 移除出了 <code>HotSpot JVM</code>，将其原有的数据迁移至 <code>Java Heap</code> 或 <code>Metaspace</code></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Spring事务源码分析]]></title>
      <url>http://zsr.github.io/2018/05/08/Spring%E4%BA%8B%E5%8A%A1%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>关于事务的具体概念和使用方式，<strong>Spring事务管理</strong>有详细介绍</p>
<h3 id="基于注解的事务管理"><a href="#基于注解的事务管理" class="headerlink" title="基于注解的事务管理"></a>基于注解的事务管理</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">&lt;!-- 数据源配置 --&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span> <span class="attr">value</span>=<span class="string">"#&#123;jdbc['jdbc.driverClassName']&#125;"</span>/&gt;</span></div><div class="line"> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"> <span class="comment">&lt;!-- 配置事务管理器 --&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span> /&gt;</span></div><div class="line"> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 开启注解方式配置事物 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>/&gt;</span></div></pre></td></tr></table></figure>
<h3 id="Spring事务调用过程"><a href="#Spring事务调用过程" class="headerlink" title="Spring事务调用过程"></a>Spring事务调用过程</h3><p><code>Spring</code>事务使用AOP代理后的方法调用执行流程，如图所示：</p>
<p><a href="http://tech.lede.com/2017/02/06/rd/server/SpringTransactional/2.png" target="_blank" rel="external"><img src="http://tech.lede.com/2017/02/06/rd/server/SpringTransactional/2.png" alt="2"></a></p>
<p>从图中可以看出，调用事务时首先调用的是AOP代理对象而不是目标对象，首先执行事务切面，事务切面内部通过<code>TransactionInterceptor</code>环绕增强进行事务的增强。即进入目标方法之前开启事务，退出目标方法时提交/回滚事务。</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>假设配置两个以上的<code>&lt;tx:annotation-driven/&gt;</code>标签：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager1"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager1"</span> </span></div><div class="line">        <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource1"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager2"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager2"</span> </span></div><div class="line">        <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource2"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<p>结果只有第一个<code>&lt;tx:annotation-driven/&gt;</code>会生效，也就是使用<code>@Transactional</code>注解时不指定事务管理器，默认使用的事务管理器是<code>transactionManager1</code>。如果要使用多个事务管理器，需要在使用<code>@Transactional</code>时指定具体的<code>TransactionManager</code></p>
<h4 id="lt-tx-annotation-driven-gt-分析"><a href="#lt-tx-annotation-driven-gt-分析" class="headerlink" title="&lt;tx:annotation-driven/&gt;分析"></a><code>&lt;tx:annotation-driven/&gt;</code>分析</h4><p>这个标签是由<code>TxNamespaceHandler</code>解析的，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TxNamespaceHandler</span> <span class="keyword">extends</span> <span class="title">NamespaceHandlerSupport</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">static</span> <span class="keyword">final</span> String TRANSACTION_MANAGER_ATTRIBUTE = <span class="string">"transaction-manager"</span>;</div><div class="line"></div><div class="line">	<span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_TRANSACTION_MANAGER_BEAN_NAME = <span class="string">"transactionManager"</span>;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// advice标签解析</span></div><div class="line">		registerBeanDefinitionParser(<span class="string">"advice"</span>, <span class="keyword">new</span> TxAdviceBeanDefinitionParser());</div><div class="line">        <span class="comment">// annotation-driven标签解析</span></div><div class="line">		registerBeanDefinitionParser(<span class="string">"annotation-driven"</span>, <span class="keyword">new</span> AnnotationDrivenBeanDefinitionParser());</div><div class="line">        <span class="comment">// jta-transaction-manager分布式事务标签解析</span></div><div class="line">		registerBeanDefinitionParser(<span class="string">"jta-transaction-manager"</span>, <span class="keyword">new</span> JtaTransactionManagerBeanDefinitionParser());</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里关注<code>AnnotationDrivenBeanDefinitionParser</code>解析器，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnnotationDrivenBeanDefinitionParser</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionParser</span> </span>&#123;</div><div class="line">   </div><div class="line">  	<span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</div><div class="line">		String mode = element.getAttribute(<span class="string">"mode"</span>);</div><div class="line">		<span class="keyword">if</span> (<span class="string">"aspectj"</span>.equals(mode)) &#123;</div><div class="line">			<span class="comment">// mode="aspectj"</span></div><div class="line">            <span class="comment">// 提供对aspectj方式进行事务切入的支持</span></div><div class="line">			registerTransactionAspect(element, parserContext);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> &#123;</div><div class="line">			<span class="comment">// mode="proxy"</span></div><div class="line">            <span class="comment">// 默认采用aop代理方式</span></div><div class="line">			AopAutoProxyConfigurer.configureAutoProxyCreator(element, parserContext);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>AopAutoProxyConfigurer</code>作为<code>AnnotationDrivenBeanDefinitionParser</code>静态内部类，关键代码如下：</p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fr3sdys27fj317u0xiwsb.jpg" alt=""></p>
<p>重点代码被红框标记，<strong>最外层的if判断保证<code>&lt;tx:annotation-driven/&gt;</code>标签只能被解析一次</strong>，所以只有第一次被解析的标签会生效。分别注册了三个<code>BeanDefinition</code>，分别为<code>AnnotationTransactionAttributeSource</code>、<code>TransactionInterceptor</code>和<code>BeanFactoryTransactionAttributeSourceAdvisor</code>，并将前两个<code>BeanDefinition</code>添加到第三个<code>BeanDefinition</code>的属性当中，这三个bean支撑了整个事务功能</p>
<p>下面关注事务管理怎么注册的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">registerTransactionManager(element, interceptorDef);</div><div class="line"></div><div class="line"><span class="comment">// AnnotationDrivenBeanDefinitionParser.class</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerTransactionManager</span><span class="params">(Element element, BeanDefinition def)</span> </span>&#123;</div><div class="line">		def.getPropertyValues().add(<span class="string">"transactionManagerBeanName"</span>,</div><div class="line">				TxNamespaceHandler.getTransactionManagerName(element));</div><div class="line">	&#125;</div><div class="line"></div><div class="line"><span class="comment">// TxNamespaceHandler.class</span></div><div class="line"><span class="function"><span class="keyword">static</span> String <span class="title">getTransactionManagerName</span><span class="params">(Element element)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> (element.hasAttribute(TRANSACTION_MANAGER_ATTRIBUTE) ?</div><div class="line">				element.getAttribute(TRANSACTION_MANAGER_ATTRIBUTE) : DEFAULT_TRANSACTION_MANAGER_BEAN_NAME);</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>如果<code>tx:annotation-driven</code>没有指定<code>transaction-manager</code>，系统会默认注册<code>transactionManager</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">AopNamespaceUtils.registerAutoProxyCreatorIfNecessary(parserContext, element);</div><div class="line"></div><div class="line"><span class="comment">// AopNamespaceUtils.class</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerAutoProxyCreatorIfNecessary</span><span class="params">(</span></span></div><div class="line">			ParserContext parserContext, Element sourceElement) &#123;</div><div class="line">        <span class="comment">// 注册AutoProxyCreator，这里是InfrastructureAdvisorAutoProxyCreator</span></div><div class="line">		BeanDefinition beanDefinition = AopConfigUtils.registerAutoProxyCreatorIfNecessary(</div><div class="line">				parserContext.getRegistry(), parserContext.extractSource(sourceElement));</div><div class="line">	&#125;</div><div class="line"></div><div class="line"><span class="comment">// AopConfigUtils.class</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BeanDefinition <span class="title">registerAutoProxyCreatorIfNecessary</span><span class="params">(BeanDefinitionRegistry registry, Object source)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> registerOrEscalateApcAsRequired(InfrastructureAdvisorAutoProxyCreator.class, registry, source);</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>实际注册的是<code>InfrastructureAdvisorAutoProxyCreator</code>动态代理生成器</p>
<p><img src="https://img-blog.csdn.net/20161126120230590?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p>前面文章介绍使用<code>Spring Aop</code>做切面增强，使用的是<code>AspectJAwareAdvisorAutoProxyCreator</code>，可见普通aop代理生成器和<code>InfrastructureAdvisorAutoProxyCreator</code>都是继承于<code>AbstractAdvisorAutoProxyCreator</code>,具体的代理生成过程参考“<a href="https://zsr.github.io/2017/11/30/Spring-AOP%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Spring AOP源码分析</a>”</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://www.linkedkeeper.com/detail/blog.action?bid=1045" target="_blank" rel="external">Spring源码解析之事务篇</a></p>
<p><a href="http://tech.lede.com/2017/02/06/rd/server/SpringTransactional/" target="_blank" rel="external">Spring @Transactional原理及使用</a></p>
<p><a href="http://cxis.me/2017/04/10/Spring%E4%B8%ADAOP%E7%9A%84%E9%85%8D%E7%BD%AE%E4%BB%8E1.0%E5%88%B05.0%E7%9A%84%E6%BC%94%E8%BF%9B/" target="_blank" rel="external">Spring中AOP的配置从1.0到5.0的演进</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java中检查的异常与未检查的异常]]></title>
      <url>http://zsr.github.io/2018/05/07/Java%E4%B8%AD%E6%A3%80%E6%9F%A5%E7%9A%84%E5%BC%82%E5%B8%B8%E4%B8%8E%E6%9C%AA%E6%A3%80%E6%9F%A5%E7%9A%84%E5%BC%82%E5%B8%B8/</url>
      <content type="html"><![CDATA[<h3 id="java异常"><a href="#java异常" class="headerlink" title="java异常"></a>java异常</h3><p> <img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fr6dtnesi2j30ow0dgabd.jpg" alt=""></p>
<p>通常我们说的异常是包括<code>exception</code>和<code>error</code>：</p>
<ul>
<li><code>Error</code>（错误）：是程序无法处理的错误，表示运行应用程序中较严重问题。大多数的错误与代码编写者执行的操作无关，而是表示代码运行时 JVM（Java 虚拟机）出现的问题。例如，当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。</li>
<li><code>Exception</code>（异常）:是程序本身可以处理的异常。</li>
</ul>
<p>除了<code>RuntimeException</code>与其子类，以及错误（<code>Error</code>），其他的都是检查异常</p>
<ul>
<li><code>checked exception</code>(检查异常) ：编译器要求你必须处置的异常</li>
<li><code>unchecked exception</code>(未检查异常)：编译器不要求强制处置的异常</li>
</ul>
<p>对于未检查异常也叫<code>RuntimeException</code>(运行时异常)，对于运行时异常，java编译器不要求你一定要把它捕获或者一定要继续抛出，但是对<code>checked exception</code>(检查异常)要求你必须要在方法里面或者捕获或者继续抛出.</p>
<h3 id="异常处理方法"><a href="#异常处理方法" class="headerlink" title="异常处理方法"></a>异常处理方法</h3><ul>
<li>对未检查的异常(<code>unchecked exception</code>)的几种处理方式： </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1、捕获 </div><div class="line">2、继续抛出 </div><div class="line">3、不处理</div></pre></td></tr></table></figure>
<ul>
<li>对检查的异常(<code>checked exception</code>，除了<code>RuntimeException</code>，其他的异常都是<code>checked exception</code>)的几种处理方式： </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1、继续抛出，消极的方法，一直可以抛到java虚拟机来处理 </div><div class="line">2、用try...catch捕获</div></pre></td></tr></table></figure>
<p><strong>注意：对于检查的异常必须处理，或者必须捕获或者必须抛出</strong></p>
<p>​     </p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[mysql慢查询分析]]></title>
      <url>http://zsr.github.io/2018/05/02/mysql%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%88%86%E6%9E%90/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[java字节码增强技术]]></title>
      <url>http://zsr.github.io/2018/04/24/java%E5%AD%97%E8%8A%82%E7%A0%81%E5%A2%9E%E5%BC%BA%E6%8A%80%E6%9C%AF/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[事务特性]]></title>
      <url>http://zsr.github.io/2018/04/18/%E4%BA%8B%E5%8A%A1%E7%89%B9%E6%80%A7/</url>
      <content type="html"><![CDATA[<h3 id="事务特性"><a href="#事务特性" class="headerlink" title="事务特性"></a>事务特性</h3><ul>
<li><strong>原子性：</strong>事务中的所有操作要么全部执行，要么都不执行；</li>
<li><strong>一致性：</strong>一个事务执行之前和执行之后都必须处于一致性状态；假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性</li>
<li><strong>隔离性：</strong>多个事务并发（同时）执行，每个事务都感觉不到系统中有其他的事务在执行；</li>
<li><strong>持久性：</strong>一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作；</li>
</ul>
<h3 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h3><p>如果没有事务的隔离性，会发生的几种问题：</p>
<h4 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h4><p><strong>脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。</strong></p>
<p>　　当一个事务正在多次修改某个数据，而在这个事务中这多次的修改都还未提交，这时一个并发的事务来访问该数据，就会造成两个事务得到的数据不一致。例如：用户A向用户B转账100元，对应SQL命令如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">update account set money=money+100 where name=’B’; </div><div class="line">update account set money=money - 100 where name=’A’;</div></pre></td></tr></table></figure>
<p>　　当只执行第一条SQL时，A通知B查看账户，B发现确实钱已到账（此时即发生了脏读），而之后无论第二条SQL是否执行，只要该事务不提交，则所有操作都将回滚，那么当B以后再次查看账户时就会发现钱其实并没有转。</p>
<h4 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h4><p><strong>不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询之间，被另一个事务修改并提交了。</strong></p>
<p>　　例如事务T1在读取某一数据，而事务T2立马修改了这个数据并且提交事务给数据库，事务T1再次读取该数据就得到了不同的结果，发送了不可重复读。</p>
<p>　　不可重复读和脏读的区别是：<strong>脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务已提交的数据。</strong></p>
<h4 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h4><p><strong>幻读是指事务T1读取了满足某条件的一个数据集，事务T2插入了一行或者多行数据满足了T1的选择条件，导致事务T1再次使用同样的选择条件读取的时候，得到了比第一次读取更多的数据集</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1、T1：select * from users where name = &quot;A&quot;;</div><div class="line">2、T2：insert into `users`(`id`, `name`) values (1, &apos;A&apos;);</div><div class="line">3、T1：select * from users where name = &quot;A&quot;;</div></pre></td></tr></table></figure>
<p>　　幻读和不可重复读都是读取了另一条已经提交的事务，所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体。</p>
<h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><p><code>MySQL</code>数据库提供了四种隔离级别：</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td>未提交读(<code>Read uncommitted</code>)</td>
<td>可能</td>
<td>可能</td>
<td>可能</td>
</tr>
<tr>
<td>已提交读(<code>Read committed</code>)</td>
<td>不可能</td>
<td>可能</td>
<td>可能</td>
</tr>
<tr>
<td>可重复读(<code>Repeatable read</code>)</td>
<td>不可能</td>
<td>不可能</td>
<td>可能</td>
</tr>
<tr>
<td>可串行化(<code>Serializable</code>)</td>
<td>不可能</td>
<td>不可能</td>
<td>不可能</td>
</tr>
</tbody>
</table>
<p><strong><code>InnoDB</code>默认级别：可重复读(<code>Repeatable read</code>)，为什么能避免幻读，另一篇<code>mysql锁</code>有说明(间隙锁)</strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Spring事务管理]]></title>
      <url>http://zsr.github.io/2018/04/17/Spring%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/</url>
      <content type="html"><![CDATA[<h3 id="Spring事务管理概述"><a href="#Spring事务管理概述" class="headerlink" title="Spring事务管理概述"></a>Spring事务管理概述</h3><h4 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h4><p>隔离级别是指若干个并发的事务之间的隔离程度。<code>TransactionDefinition</code> 接口中定义了五个表示隔离级别的常量：</p>
<ul>
<li><code>TransactionDefinition.ISOLATION_DEFAULT</code>：这是默认值，表示使用底层数据库的默认隔离级别。对大部分数据库而言，通常这值就是<code>TransactionDefinition.ISOLATION_READ_COMMITTED</code>，<code>MySQL InnoDB</code> 存储引擎隔离级别为 <code>Repeatable Read</code>。</li>
<li><code>TransactionDefinition.ISOLATION_READ_UNCOMMITTED</code>：该隔离级别表示一个事务可以读取另一个事务修改但还没有提交的数据。该级别不能防止脏读和不可重复读，因此很少使用该隔离级别。</li>
<li><code>TransactionDefinition.ISOLATION_READ_COMMITTED</code>：该隔离级别表示一个事务只能读取另一个事务已经提交的数据。该级别可以防止脏读，这也是大多数情况下的推荐值。</li>
<li><code>TransactionDefinition.ISOLATION_REPEATABLE_READ</code>：该隔离级别表示一个事务在整个过程中可以多次重复执行某个查询，并且每次返回的记录都相同。即使在多次查询之间有新增的数据满足该查询，这些新增的记录也会被忽略。该级别可以防止脏读和不可重复读。</li>
<li><code>TransactionDefinition.ISOLATION_SERIALIZABLE</code>：所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li>
</ul>
<h4 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a>事务传播行为</h4><p>事务的传播行为是指，如果在开始当前事务之前，一个事务上下文已经存在，此时有若干选项可以指定一个事务性方法的执行行为。在<code>TransactionDefinition</code>定义中包括了如下几个表示传播行为的常量</p>
<ul>
<li><code>TransactionDefinition.PROPAGATION_REQUIRED</code>：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</li>
</ul>
<p><img src="https://img-blog.csdn.net/20140420132157531?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaXRfd2FuZ3hpYW5ncGFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<ul>
<li><code>TransactionDefinition.PROPAGATION_REQUIRES_NEW</code>：创建一个新的事务，如果当前存在事务，则把当前事务挂起。</li>
<li><code>TransactionDefinition.PROPAGATION_SUPPORTS</code>：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li>
<li><code>TransactionDefinition.PROPAGATION_NOT_SUPPORTED</code>：以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li>
<li><code>TransactionDefinition.PROPAGATION_NEVER</code>：以非事务方式运行，如果当前存在事务，则抛出异常。</li>
<li><code>TransactionDefinition.PROPAGATION_MANDATORY</code>：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。</li>
<li><code>TransactionDefinition.PROPAGATION_NESTED</code>：如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于<code>TransactionDefinition.PROPAGATION_REQUIRED</code>。</li>
</ul>
<h3 id="Spring事务使用方式"><a href="#Spring事务使用方式" class="headerlink" title="Spring事务使用方式"></a>Spring事务使用方式</h3><p><code>Spring</code>提供了对<code>编码式</code>和<code>声明式</code>事务管理的支持，<code>Spring</code>对事务管理是通过事务管理器来实现的</p>
<ul>
<li><strong>编程式事务：</strong>指的是通过编码方式实现事务，即类似于<code>JDBC</code>编程实现事务管理。使用<code>TransactionTemplate</code>或者直接使用底层的<code>PlatformTransactionManager</code>做事务管理。</li>
<li><strong>声明式事务：</strong>其本质是对方法前后进行拦截(<code>AOP</code>)，然后在目标方法开始之前创建或者加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。</li>
</ul>
<p><strong>声明式事务优点：不需要通过编程的方式管理事务，这样就不需要在业务逻辑代码中掺杂事务管理的代码，</strong>只需在配置文件中做相关的事务规则声明(或通过基于<code>@Transactional</code>注解的方式)，便可以将事务规则应用到业务逻辑中;</p>
<p><strong>声明式事务缺点：声明式的最细粒度只能作用到方法级别，无法做到像编程式事务那样可以作用到代码块级别</strong></p>
<table>
<thead>
<tr>
<th>事务管理器(<code>org.springframework.*</code>)</th>
<th>使用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>DataSourceTransactionManager</code></td>
<td>提供对单个<code>javax.sql.DataSource</code>事务管理，用于Spring JDBC抽象框架、iBATIS或MyBatis框架的事务管理；</td>
</tr>
<tr>
<td><code>JpaTransactionManager</code></td>
<td>提供对单个<code>javax.persistence.EntityManagerFactory</code>事务支持，用于集成JPA实现框架时的事务管理；</td>
</tr>
<tr>
<td><code>JtaTransactionManager</code></td>
<td>提供对分布式事务管理的支持，并将事务管理委托给Java EE应用服务器事务管理器；</td>
</tr>
</tbody>
</table>
<h4 id="编程式事务"><a href="#编程式事务" class="headerlink" title="编程式事务"></a>编程式事务</h4><p><code>Spring</code>提供了线程安全的<code>TransactionTemplate</code>模板类来处理不变的事务管理逻辑，将变化的部分抽象为回调接口<code>TransactionCallback</code>供用户自定义数据访问逻辑</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 数据源配置 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span> <span class="attr">value</span>=<span class="string">"#&#123;jdbc['jdbc.driverClassName']&#125;"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 配置事务管理器 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!--事务模板 --&gt;</span>  </div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.transaction.support.TransactionTemplate"</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"transactionManager"</span> <span class="attr">ref</span>=<span class="string">"transactionManager"</span>/&gt;</span>  </div><div class="line">    <span class="comment">&lt;!--ISOLATION_DEFAULT 表示由使用的数据库决定  --&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"isolationLevelName"</span> <span class="attr">value</span>=<span class="string">"ISOLATION_DEFAULT"</span>/&gt;</span>  </div><div class="line">    <span class="comment">&lt;!-- 事务传播方式 --&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"propagationBehaviorName"</span> <span class="attr">value</span>=<span class="string">"PROPAGATION_REQUIRED"</span> /&gt;</span>  </div><div class="line">    <span class="comment">&lt;!-- &lt;property name="timeout" value="30"/&gt; --&gt;</span>  </div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceImpl</span> </span>&#123;</div><div class="line">  </div><div class="line">	<span class="meta">@autowried</span></div><div class="line">	<span class="keyword">private</span> TransactionTemplate template;</div><div class="line">  </div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addElement</span><span class="params">(<span class="keyword">final</span> Element ele)</span> </span>&#123;</div><div class="line">		template.execute(<span class="keyword">new</span> TransactionCallbackWithoutResult() &#123;</div><div class="line">			<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doInTransactionWithoutResult</span><span class="params">(TransactionStatus status)</span></span>&#123;</div><div class="line">                    <span class="comment">// 数据库操作1</span></div><div class="line">                    <span class="comment">// 数据库操作2</span></div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>根据默认规则，如果在执行回调方法的过程中抛出了未检查异常(继承自<code>RuntimeException</code>的异常)，或者显式调用了<code>TransacationStatus.setRollbackOnly()</code> 方法，则回滚事务；如果事务执行完成或者抛出了 checked 类型的异常，则提交事务。</p>
<p>不管是使用哪种方式，<strong>数据源</strong>、<strong>事务管理器</strong>都是必须的，一般通过XML的Bean配置</p>
<h4 id="声明式事务-常用"><a href="#声明式事务-常用" class="headerlink" title="声明式事务(常用)"></a>声明式事务(常用)</h4><p>声明式事务可以分为2种：<strong>基于XML配置的事务管理</strong>或<strong>基于注解的事务管理</strong>，都是基于AOP实现</p>
<h5 id="基于XML配置的事务管理"><a href="#基于XML配置的事务管理" class="headerlink" title="基于XML配置的事务管理"></a>基于XML配置的事务管理</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">   <span class="comment">&lt;!-- 数据源配置 --&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span> <span class="attr">value</span>=<span class="string">"#&#123;jdbc['jdbc.driverClassName']&#125;"</span>/&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line">   <span class="comment">&lt;!-- 配置事务管理器 --&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span> /&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line">   <span class="comment">&lt;!-- 配置事务属性：传播行为、隔离级别、只读、超时时间回滚--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"txAdvice"</span> <span class="attr">transaction-manager</span>=<span class="string">"txManager"</span>&gt;</span></div><div class="line">   	<span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></div><div class="line">   		<span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"create*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span> <span class="attr">timeout</span>=<span class="string">"300"</span> <span class="attr">rollback-</span>	<span class="attr">for</span>=<span class="string">"java.lang.Exception"</span> /&gt;</span></div><div class="line"> 		<span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></div><div class="line"></div><div class="line">   <span class="comment">&lt;!-- 配置事务切入点。并把事务切入点与事务属性关联起来 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></div><div class="line"> 		<span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"txPointcut"</span> <span class="attr">expression</span>=<span class="string">"execution(* com.zsr.test.transaction.service.*ServiceImpl.*(..))"</span> /&gt;</span></div><div class="line"> 		<span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">pointcut-ref</span>=<span class="string">"txPointcut"</span> <span class="attr">advice-ref</span>=<span class="string">"txAdvice"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></div></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Service</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceImpl</span> <span class="keyword">implements</span> <span class="title">IService</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">createTicket</span><span class="params">(String isbn)</span> </span>&#123;</div><div class="line">		<span class="comment">// do something</span></div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h5 id="基于注解的事务管理"><a href="#基于注解的事务管理" class="headerlink" title="基于注解的事务管理"></a>基于注解的事务管理</h5><p>通过<code>@Transactional</code>对需要事务增强的Bean接口、实现类或方法进行标注，在容器中配置以启用基于注解的声明式事务。。注解所提供的事务属性信息与XML配置中的事务信息基本一致，只不过是另一种形式的元数据而已</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 数据源配置 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span> <span class="attr">value</span>=<span class="string">"#&#123;jdbc['jdbc.driverClassName']&#125;"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- 配置事务管理器 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line">   <span class="comment">&lt;!-- 开启注解方式配置事物 --&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>/&gt;</span></div></pre></td></tr></table></figure>
<p><strong>注意：当<code>&lt;tx:annotation-driven/&gt;</code>标签在不指定<code>transaction-manager</code>属性的时候，会默认寻找id固定名为<code>transactionManager</code>的bean作为事务管理器，如果没有id为<code>transactionManager</code>的bean并且在使用<code>@Transactional</code>注解时也没有指定value（事务管理器），程序就会报错</strong></p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Transactional</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceImpl</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> DaoA daoA;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addElement</span><span class="params">(<span class="keyword">final</span> Element ele)</span> </span>&#123;</div><div class="line">		...</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>@Transactional</code>可以作用于接口、接口方法、类以及类方法上。当作用于类上时，该类的所有 <code>public</code> 方法将都具有该类型的事务属性，同时，也可以在方法级别使用该标注来覆盖类级别的定义</p>
<h4 id="Spring-Transactional的注意事项"><a href="#Spring-Transactional的注意事项" class="headerlink" title="Spring @Transactional的注意事项"></a><code>Spring @Transactional</code>的注意事项</h4><ul>
<li><code>@Transactional</code> 注解只被应用到 <code>public</code> 可见度的方法上。 如果你在 <code>protected</code>、<code>private</code> 或者 <code>package-visible</code> 的方法上使用 <code>@Transactional</code> 注解，它也不会报错，但是这个被注解的方法将不会展示已配置的事务设置。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">（1）对于基于接口动态代理的AOP事务增强来说，由于接口的方法是public的，这就要求实现类的实现方法必须是public的（不能是protected，private等），同时不能使用static的修饰符。所以，可以实施接口动态代理的方法只能是使用“public”或“public final”修饰符的方法，其它方法不可能被动态代理，相应的也就不能实施AOP增强，也即不能进行Spring事务增强。</div><div class="line"></div><div class="line">（2）基于CGLib字节码动态代理的方案是通过扩展被增强类，动态创建子类的方式进行AOP增强植入的。由于使用final,static,private修饰符的方法都不能被子类覆盖，相应的，这些方法将不能被实施的AOP增强。</div></pre></td></tr></table></figure>
<ul>
<li>Spring团队的建议在具体的类（或类的方法）上使用 <code>@Transactional</code> 注解，而不要使用在类所要实现的任何接口上。当然也可以在接口上使用 <code>@Transactional</code> 注解，但是这将只能当你设置了基于接口的代理时它才生效。因为注解是不能继承的，这就意味着如果你正在使用基于类的代理时(cglib)，那么事务的设置将不能被基于类的代理所识别，而且对象也将不会被事务代理所包装。因此，建议并且在具体的类火方法上使用 <code>@Transactional</code> 注解。</li>
<li><code>@Transactional</code> 的事务开启，在同一个类中一个方法调用另一个有事务的方法，事务是不会起作用的。</li>
<li><code>@Transactional</code> 注解标注的方法中不要出现网络调用、比较耗时的处理程序，因为，事务中数据库连接是不会释放的，如果每个事务的处理时间都非常长，那么宝贵的数据库连接资源将很快被耗尽。</li>
<li><code>Spring</code>使用声明式事务处理，默认情况下，如果操作方法中发生了<code>unchecked</code>异常，所有的操作将<code>rollback</code>；如果发生的异常是<code>checked</code>异常，默认情况下数据库操作还是会提交的。</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.ibm.com/developerworks/cn/education/opensource/os-cn-spring-trans/index.html" target="_blank" rel="external">全面分析 Spring 的编程式事务管理及声明式事务管理</a></p>
<p><a href="https://blog.csdn.net/lovesomnus/article/details/52619702" target="_blank" rel="external">Spring的声明式事务和编程式事务详解</a></p>
<p><a href="http://www.yangbing.club/2017/03/22/spring-transaction-management/" target="_blank" rel="external">spring事务管理</a></p>
<p><a href="http://tech.lede.com/2017/02/06/rd/server/SpringTransactional/" target="_blank" rel="external">Spring @Transactional原理及使用</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[jdk动态代理分析]]></title>
      <url>http://zsr.github.io/2018/04/08/jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">疑问：JDK的动态代理为什么不支持对类的代理，只支持接口的代理？</div></pre></td></tr></table></figure>
<h3 id="jdk动态代理实例"><a href="#jdk动态代理实例" class="headerlink" title="jdk动态代理实例"></a><code>jdk</code>动态代理实例</h3><ul>
<li>服务接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.zsr.test.proxy;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Hello</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(String someThing)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>接口实现类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.zsr.test.proxy;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloImpl</span> <span class="keyword">implements</span> <span class="title">Hello</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(String someThing)</span> </span>&#123;</div><div class="line">    System.out.println(<span class="string">"Hello: "</span> + someThing);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>调用处理类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.zsr.test.proxy;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.Method;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloInvocationHandle</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> Object target;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HelloInvocationHandle</span><span class="params">(Object target)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.target = target;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">    System.out.println(<span class="string">"Before invocation"</span>);</div><div class="line">    Object ret = method.invoke(target, args);</div><div class="line">    System.out.println(<span class="string">"after invocation"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>运行测试</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.zsr.test.proxy;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloProxyTest</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">    Hello hello = <span class="keyword">new</span> HelloImpl();</div><div class="line">    HelloInvocationHandle helloInvocationHandler = <span class="keyword">new</span> HelloInvocationHandle(hello);</div><div class="line"></div><div class="line">    <span class="comment">// 通过Proxy.newProxyInstance生成代理对象</span></div><div class="line">    Hello helloProxy = (Hello) Proxy.newProxyInstance(Hello.class.getClassLoader(), hello.getClass().getInterfaces(),</div><div class="line">            helloInvocationHandler);</div><div class="line"></div><div class="line">    <span class="comment">// 调用say方法</span></div><div class="line">    helloProxy.say(<span class="string">"test"</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Before invocation</div><div class="line">Hello: test</div><div class="line">after invocation</div></pre></td></tr></table></figure>
<h3 id="Proxy-newProxyInstance分析"><a href="#Proxy-newProxyInstance分析" class="headerlink" title="Proxy.newProxyInstance分析"></a><code>Proxy.newProxyInstance</code>分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></div><div class="line">                                          Class&lt;?&gt;[] interfaces,</div><div class="line">                                          InvocationHandler h)</div><div class="line">        <span class="keyword">throws</span> IllegalArgumentException</div><div class="line">    &#123;</div><div class="line">        Objects.requireNonNull(h);</div><div class="line"></div><div class="line">        <span class="keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();</div><div class="line">        <span class="keyword">final</span> SecurityManager sm = System.getSecurityManager();</div><div class="line">        <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</div><div class="line">            checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/*</span></div><div class="line">         * 动态生成Class的地方，重点是看这里面的方法</div><div class="line">         */</div><div class="line">        Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</div><div class="line"></div><div class="line">        <span class="comment">/*</span></div><div class="line">         * 获取代理类的实例  </div><div class="line">         */</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</div><div class="line">                checkNewProxyPermission(Reflection.getCallerClass(), cl);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</div><div class="line">            <span class="keyword">final</span> InvocationHandler ih = h;</div><div class="line">            <span class="keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;</div><div class="line">                AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</div><div class="line">                    <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                        cons.setAccessible(<span class="keyword">true</span>);</div><div class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> Object[]&#123;h&#125;);</div><div class="line">        &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>生成代理类<code>Class</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt; getProxyClass0(ClassLoader loader,</div><div class="line">                                           Class&lt;?&gt;... interfaces) &#123;</div><div class="line">        <span class="keyword">if</span> (interfaces.length &gt; <span class="number">65535</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"interface limit exceeded"</span>);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// JDK对代理进行了缓存，如果已经存在相应的代理类，则直接返回，</span></div><div class="line">        <span class="comment">// 否则才会通过ProxyClassFactory来创建代理  </span></div><div class="line">        <span class="keyword">return</span> proxyClassCache.get(loader, interfaces);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;</div><div class="line">        proxyClassCache = <span class="keyword">new</span> WeakCache&lt;&gt;(<span class="keyword">new</span> KeyFactory(), <span class="keyword">new</span> ProxyClassFactory());</div></pre></td></tr></table></figure>
<ul>
<li>代理类<code>Class</code>工厂</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">private static final class ProxyClassFactory</div><div class="line">        implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;</div><div class="line">    &#123;</div><div class="line">        // 所有代理类名字的前缀</div><div class="line">        private static final String proxyClassNamePrefix = "$Proxy";</div><div class="line"></div><div class="line">        // next number to use for generation of unique proxy class names</div><div class="line">        private static final AtomicLong nextUniqueNumber = new AtomicLong();</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;</div><div class="line">            ......</div><div class="line"></div><div class="line">            /*</div><div class="line">             * Choose a name for the proxy class to generate.</div><div class="line">             */</div><div class="line">            long num = nextUniqueNumber.getAndIncrement();</div><div class="line">            // 默认情况下，代理类的完全限定名为：</div><div class="line">            // com.sun.proxy.$Proxy0，com.sun.proxy.$Proxy1依次递增</div><div class="line">            String proxyName = proxyPkg + proxyClassNamePrefix + num;</div><div class="line"></div><div class="line">            // ** 生成代理类字节码的地方 ** //</div><div class="line">            byte[] proxyClassFile = ProxyGenerator.generateProxyClass(</div><div class="line">                proxyName, interfaces);</div><div class="line">            try &#123;</div><div class="line">               // 根据二进制字节码返回相应的Class实例  </div><div class="line">                return defineClass0(loader, proxyName,</div><div class="line">                                    proxyClassFile, 0, proxyClassFile.length);</div><div class="line">            &#125; catch (ClassFormatError e) &#123;</div><div class="line">                throw new IllegalArgumentException(e.toString());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="反编译代理类"><a href="#反编译代理类" class="headerlink" title="反编译代理类"></a>反编译代理类</h3><ul>
<li>修改测试<code>HelloProxyTest</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloProxyTest</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    </div><div class="line">  <span class="comment">//设置为true,会在工程根目录生成$Proxy0.class代理类（com.sun.proxy.$Proxy0.class）</span></div><div class="line">    System.getProperties().put(</div><div class="line">        <span class="string">"sun.misc.ProxyGenerator.saveGeneratedFiles"</span>, <span class="string">"true"</span>);</div><div class="line"></div><div class="line">    Hello hello = <span class="keyword">new</span> HelloImpl();</div><div class="line">    HelloInvocationHandle helloInvocationHandler = <span class="keyword">new</span> HelloInvocationHandle(hello);</div><div class="line"></div><div class="line">    <span class="comment">// 通过Proxy.newProxyInstance生成代理对象</span></div><div class="line">    Hello helloProxy = (Hello) Proxy.newProxyInstance(Hello.class.getClassLoader(), hello.getClass().getInterfaces(),</div><div class="line">            helloInvocationHandler);</div><div class="line"></div><div class="line">    <span class="comment">// 调用say方法</span></div><div class="line">    helloProxy.say(<span class="string">"test"</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>注意，当把<code>saveGeneratedFiles</code>属性设置为true时，生成的class文件及其所在的路径都需要提前创建，否则会抛出FileNotFoundException异常；即要在运行当前main方法的路径下创建com/sun/proxy目录，并创建一个$Proxy0.class文件</strong></p>
<ul>
<li>反编译文件<code>$Proxy0.class</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.sun.proxy;</div><div class="line"></div><div class="line"><span class="keyword">import</span> com.zsr.test.proxy.Hello;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.Method;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</div><div class="line"></div><div class="line"><span class="comment">// ** 注意这里代理类实现了接口 ** //</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span></span></div><div class="line">  <span class="keyword">implements</span> <span class="title">Hello</span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</div><div class="line"></div><div class="line">  <span class="keyword">public</span> $Proxy0(InvocationHandler paramInvocationHandler)</div><div class="line">    <span class="keyword">throws</span> </div><div class="line">  &#123;</div><div class="line">    <span class="keyword">super</span>(paramInvocationHandler);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object paramObject)</span></span></div><div class="line">    <span class="keyword">throws</span> </div><div class="line">  &#123;</div><div class="line">    <span class="keyword">try</span></div><div class="line">    &#123;</div><div class="line">      <span class="keyword">return</span> ((Boolean)<span class="keyword">this</span>.h.invoke(<span class="keyword">this</span>, m1, <span class="keyword">new</span> Object[] &#123; paramObject &#125;)).booleanValue();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (RuntimeException localRuntimeException)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">throw</span> localRuntimeException;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (Throwable localThrowable)</div><div class="line">    &#123;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(localThrowable);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span></div><div class="line">    <span class="keyword">throws</span> </div><div class="line">  &#123;</div><div class="line">    <span class="keyword">try</span></div><div class="line">    &#123;</div><div class="line">      <span class="keyword">return</span> ((Integer)<span class="keyword">this</span>.h.invoke(<span class="keyword">this</span>, m0, <span class="keyword">null</span>)).intValue();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (RuntimeException localRuntimeException)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">throw</span> localRuntimeException;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (Throwable localThrowable)</div><div class="line">    &#123;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(localThrowable);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(String paramString)</span></span></div><div class="line">    <span class="keyword">throws</span> </div><div class="line">  &#123;</div><div class="line">    <span class="keyword">try</span></div><div class="line">    &#123;</div><div class="line">      <span class="keyword">this</span>.h.invoke(<span class="keyword">this</span>, m3, <span class="keyword">new</span> Object[] &#123; paramString &#125;);</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (RuntimeException localRuntimeException)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">throw</span> localRuntimeException;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (Throwable localThrowable)</div><div class="line">    &#123;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(localThrowable);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span></span></div><div class="line">    <span class="keyword">throws</span> </div><div class="line">  &#123;</div><div class="line">    <span class="keyword">try</span></div><div class="line">    &#123;</div><div class="line">      <span class="keyword">return</span> (String)<span class="keyword">this</span>.h.invoke(<span class="keyword">this</span>, m2, <span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (RuntimeException localRuntimeException)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">throw</span> localRuntimeException;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (Throwable localThrowable)</div><div class="line">    &#123;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(localThrowable);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">static</span></div><div class="line">  &#123;</div><div class="line">    <span class="keyword">try</span></div><div class="line">    &#123;</div><div class="line">      m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, <span class="keyword">new</span> Class[] &#123; Class.forName(<span class="string">"java.lang.Object"</span>) &#125;);</div><div class="line">      m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</div><div class="line">      m3 = Class.forName(<span class="string">"com.zsr.test.proxy.Hello"</span>).getMethod(<span class="string">"say"</span>, <span class="keyword">new</span> Class[] &#123; Class.forName(<span class="string">"java.lang.String"</span>) &#125;);</div><div class="line">      m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (NoSuchMethodException localNoSuchMethodException)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(localNoSuchMethodException.getMessage());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (ClassNotFoundException localClassNotFoundException)</div><div class="line">    &#123;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(localClassNotFoundException.getMessage());</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>显而易见，动态生成的代理类有如下特性：</p>
<ol>
<li><strong>继承了Proxy类，实现了代理的接口，由于java不能多继承，这里已经继承了Proxy类了，不能再继承其他的类，所以JDK的动态代理不支持对实现类的代理，只支持接口的代理。</strong></li>
<li>代理类实现代理接口的<code>say</code>方法中，只是简单的调用了<code>InvocationHandler</code>的<code>invoke</code>方法，我们可以在<code>invoke</code>方法中进行一些特殊操作，甚至不调用实现的方法，直接返回。</li>
</ol>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://zhuanlan.zhihu.com/p/29188162" target="_blank" rel="external">JDK动态代理源码分析</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[消息feed系统研究]]></title>
      <url>http://zsr.github.io/2018/03/27/%E6%B6%88%E6%81%AFfeed%E7%B3%BB%E7%BB%9F%E7%A0%94%E7%A9%B6/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[LRUMap]]></title>
      <url>http://zsr.github.io/2018/03/21/LRUMap/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[无锁hashMap]]></title>
      <url>http://zsr.github.io/2018/03/14/%E6%97%A0%E9%94%81hashMap/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[TreeMap]]></title>
      <url>http://zsr.github.io/2018/03/13/TreeMap/</url>
      <content type="html"><![CDATA[<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><ul>
<li>类继承关系</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NavigableMap&lt;K,V&gt;</div><div class="line">    java.util.AbstractMap&lt;K,V&gt;</div><div class="line">        java.util.TreeMap&lt;K,V&gt;</div></pre></td></tr></table></figure>
<ul>
<li>定义 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public class TreeMap&lt;K,V&gt;</div><div class="line">    extends AbstractMap&lt;K,V&gt;</div><div class="line">    implements NavigableMap&lt;K,V&gt;, Cloneable, java.io.Serializable</div></pre></td></tr></table></figure>
<p><code>TreeMap</code>实现<code>NavigableMap</code>接口，说明支持一系列的导航方法</p>
<ul>
<li>核心成员变量</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>
<ul>
<li>内部节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>
<ul>
<li>要点</li>
</ul>
<p>]</p>
<a id="more"></a>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[rabbitmq消息防丢失]]></title>
      <url>http://zsr.github.io/2018/02/22/rabbitmq%E6%B6%88%E6%81%AF%E9%98%B2%E4%B8%A2%E5%A4%B1/</url>
      <content type="html"><![CDATA[<h3 id="如何解决消息丢失"><a href="#如何解决消息丢失" class="headerlink" title="如何解决消息丢失"></a>如何解决消息丢失</h3><p><strong>生产者与消费者相互解耦，怎么保证生产者已将消息投递到 <code>RabbitMQ</code> 服务端，又如何确认消费者已经消费了该消息？</strong></p>
<h4 id="消息生产可靠性"><a href="#消息生产可靠性" class="headerlink" title="消息生产可靠性"></a>消息生产可靠性</h4><p><code>RabbitMQ</code>为我们提供了两种方式：</p>
<ol>
<li>通过<code>AMQP</code>事务机制实现，这也是<code>AMQP</code>协议层面提供的解决方案；</li>
<li>通过将<code>channel</code>设置成<code>confirm</code>模式来实现；</li>
</ol>
<h5 id="RabbitMQ事务机制"><a href="#RabbitMQ事务机制" class="headerlink" title="RabbitMQ事务机制"></a><code>RabbitMQ</code>事务机制</h5><p><strong>注意：使用事务模式会导致服务端吞吐量急剧下降，实际使用场景很少，这里简单介绍一下</strong></p>
<p><code>RabbitMQ</code>中与事务机制有关的方法有三个：<code>txSelect()</code>, <code>txCommit()</code>以及<code>txRollback()</code>, <code>txSelect</code>用于将当前<code>channel</code>设置成<code>transaction</code>模式(通道事务)，<code>txCommit</code>用于提交事务，<code>txRollback</code>用于回滚事务，在通过<code>txSelect</code>开启事务之后，我们便可以发布消息给<code>broker</code>代理服务器了，如果<code>txCommit</code>提交成功了，则消息一定到达了<code>broker</code>了，如果在<code>txCommit</code>执行之前<code>broker</code>异常崩溃或者由于其他原因抛出异常，这个时候我们便可以捕获异常通过<code>txRollback</code>回滚事务了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    channel.txSelect();</div><div class="line">    channel.basicPublish(exchange, routingKey, MessageProperties.PERSISTENT_TEXT_PLAIN, msg.getBytes());</div><div class="line">    channel.txCommit();</div><div class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">    channel.txRollback();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="Confirm模式-常用模式"><a href="#Confirm模式-常用模式" class="headerlink" title="Confirm模式(常用模式)"></a>Confirm模式(常用模式)</h5><p>模仿了协议中已经存在的消费者<code>ACK</code>确认机制，生产者将信道设置成<code>confirm</code>模式，一旦信道进入<code>confirm</code>模式，所有在该信道上面发布的消息都会被指派一个唯一的ID，一旦消息被投递到所有匹配的队列之后，<code>broker</code>就会发送一个确认给生产者（包含消息的唯一ID）,这就使得生产者知道消息已经正确到达目的队列了；如果消息和队列是可持久化的，那么确认消息会将消息写入磁盘之后发出</p>
<p><code>confirm</code>模式最大的好处在于他是异步的，一旦发布一条消息，生产者应用程序就可以在等信道返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者应用便可以通过回调方法来处理该确认消息，如果RabbitMQ因为自身内部错误导致消息丢失，就会发送一条nack消息，生产者应用程序同样可以在回调方法中处理该nack消息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1. 对于可路由的消息，当所有的队列接收到消息后，broker向client发送basic.ack确认通知；</div><div class="line">2. 对于路由到持久队列的持久化消息，当消息持久化到磁盘后，broker向client发送basic.ack确认通知；</div><div class="line">3. 对于路由到镜像队列的消息，当所有的镜像队列都接收到消息后，broker向client发送basic.ack确认通知；</div><div class="line"></div><div class="line">4. 对于不可路由的消息，broker一旦确认该消息不可路由时，则向client发送basic.ack确认通知；</div><div class="line">5. 对于不可路由且mandatory强制投递的消息，broker一旦确认该消息不可路由时，先向client发送basic.return通知，然后发送basic.ack确认通知；</div></pre></td></tr></table></figure>
<ul>
<li><code>Spring Amqp配置</code></li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">rabbit:connection-factory</span> <span class="attr">id</span>=<span class="string">"connectionFactory"</span></span></div><div class="line">		<span class="attr">host</span>=<span class="string">"$&#123;rabbit.connect.host&#125;"</span> </div><div class="line">        <span class="attr">port</span>=<span class="string">"$&#123;rabbit.connect.port&#125;"</span> </div><div class="line">        <span class="attr">username</span>=<span class="string">"$&#123;rabbit.connect.username&#125;"</span></div><div class="line">		<span class="attr">password</span>=<span class="string">"$&#123;rabbit.connect.password&#125;"</span> </div><div class="line">        <span class="attr">channel-cache-size</span>=<span class="string">"$&#123;rabbit.connect.channelCacheSize&#125;"</span></div><div class="line">		<span class="attr">publisher-returns</span>=<span class="string">"true"</span> </div><div class="line">        <span class="attr">publisher-confirms</span>=<span class="string">"true"</span> /&gt;</div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"returnCallback"</span></span></div><div class="line">		<span class="attr">class</span>=<span class="string">"com.ximalaya.trump.business.message.callback.MessageReturnCallback"</span> /&gt;</div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"confirmCallback"</span></span></div><div class="line">		<span class="attr">class</span>=<span class="string">"com.ximalaya.trump.business.message.callback.MessageConfirmCallback"</span> /&gt;</div><div class="line"></div><div class="line"><span class="comment">&lt;!-- mandatory必须设置true,return-callback才生效 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">rabbit:template</span> <span class="attr">id</span>=<span class="string">"rabbitTemplate"</span></span></div><div class="line">		<span class="attr">connection-factory</span>=<span class="string">"connectionFactory"</span> </div><div class="line">        <span class="attr">confirm-callback</span>=<span class="string">"confirmCallback"</span></div><div class="line">		<span class="attr">return-callback</span>=<span class="string">"returnCallback"</span> </div><div class="line">        <span class="attr">message-converter</span>=<span class="string">"messageConverter"</span></div><div class="line">        <span class="attr">mandatory</span>=<span class="string">"true"</span> /&gt;</div></pre></td></tr></table></figure>
<p>当<code>mandatory</code>标志设置为true时，如果<code>exchange</code>根据自身类型和消息<code>routingKey</code>无法找到一个合适的<code>queue</code>存储消息，那么<code>broker</code>会调用<code>basic.return</code>方法将消息返还给生产者;当<code>mandatory</code>设置为false时，出现上述情况broker会直接将消息丢弃</p>
<ul>
<li><code>confirmCallback</code>回调方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageConfirmCallback</span> <span class="keyword">implements</span> <span class="title">ConfirmCallback</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG = LoggerFactory.getLogger(MessageConfirmCallback.class);</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">(CorrelationData correlationData, <span class="keyword">boolean</span> ack)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (ack) &#123;</div><div class="line">      <span class="comment">// 如果发送到交换器成功，但是没有匹配的队列（比如说取消了绑定），ack 返回值为还是 true（这是一个坑，需要注意）, 这种情况一般需要在returnCallBack中重新投递</span></div><div class="line">             LOG.info(<span class="string">"消息确认成功"</span>);</div><div class="line">     &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">// 如果发送到交换器都没有成功（比如说删除了交换器），ack 返回值为 false</span></div><div class="line">      <span class="comment">// 处理丢失的消息（nack）</span></div><div class="line">             LOG.warn(<span class="string">"消息确认失败"</span>);</div><div class="line">     &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>returnCallback</code>回调方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageReturnCallback</span> <span class="keyword">implements</span> <span class="title">ReturnCallback</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG = LoggerFactory.getLogger(MessageReturnCallback.class);</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Charset charset = Charset.forName(<span class="string">"UTF-8"</span>);</div><div class="line"></div><div class="line">  <span class="meta">@Autowired</span></div><div class="line">  <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> JsonParser jsonParser;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnedMessage</span><span class="params">(Message message, <span class="keyword">int</span> replyCode, String replyText, String exchange, String routingKey)</span> </span>&#123;</div><div class="line">    String messageContent = <span class="keyword">new</span> String(message.getBody(), charset);</div><div class="line">    LOG.warn(</div><div class="line">        <span class="string">"Return message from exchange &#123;&#125; and routing &#123;&#125;, reply-code is &#123;&#125;, reply-text is &#123;&#125;, message content is &#123;&#125;"</span>,</div><div class="line">        exchange, routingKey, replyCode, replyCode, messageContent);</div><div class="line">    Map&lt;String, Object&gt; map = jsonParser.toMap(messageContent);</div><div class="line">    String correlationId = (String) map.get(<span class="string">"id"</span>);</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == correlationId) &#123;</div><div class="line">      rabbitTemplate.convertAndSend(exchange, routingKey, message);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      CorrelationData correlationData = <span class="keyword">new</span> CorrelationData(correlationId);</div><div class="line">      rabbitTemplate.convertAndSend(exchange, routingKey, message, correlationData);</div><div class="line">    &#125;</div><div class="line">    LOG.info(<span class="string">"retry send message &#123;&#125; to exchange &#123;&#125; succeed."</span>, messageContent, exchange);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<ul>
<li><code>confirm</code> 主要是用来判断消息是否有正确到达交换机，如果有，那么就 ack 就返回 true；如果没有，则是 false。</li>
<li><code>return</code> 则表示如果你的消息已经正确到达交换机，但是后续处理出错了，那么就会回调 return，并且把信息送回给你（前提是需要设置了 Mandatory，不设置那么就丢弃）；如果消息没有到达交换机，那么不会调用 return 的东西。</li>
</ul>
<h4 id="消息消费可靠性"><a href="#消息消费可靠性" class="headerlink" title="消息消费可靠性"></a>消息消费可靠性</h4><p>为了保证消息从队列可靠地到达 <code>Consumer</code>，<code>RabbitMQ</code>提供消息确认机制。消费者在声明队列时，可以指定<code>noAck</code>参数，当<code>noAck=false</code>时，<code>RabbitMQ</code>会等待消费者显式发回<code>ack</code>信号后才从内存(和磁盘，如果是持久化消息的话)中移去消息。否则，<code>RabbitMQ</code>会在队列中消息被消费后立即删除它</p>
<p>消息生产、消费的流程图：</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1foqf1jfheyj313s0pqjvu.jpg" alt=""></p>
<h5 id="ack-模式"><a href="#ack-模式" class="headerlink" title="ack 模式"></a><code>ack</code> 模式</h5><ul>
<li><p><code>NONE</code></p>
<p>该模式下, 当 <code>broker</code> 发送消息成功后, 会立即将此消息从消息队列中删除, 而不会等待消费者的 <code>ACK</code> 回复</p>
</li>
</ul>
<ul>
<li><code>MANUAL</code></li>
</ul>
<ul>
<li><p><code>AUTO</code>(默认模式)</p>
<p>当 <code>broker</code> 发送消息给消费者时, 不会立即将此消息删除, 而是需要等待消费者的 ACK 回复后才会删除消息. 因此在手动 <code>ACK</code> 模式下, 当消费者收到消息并处理完成后, 需要向 <code>broker</code> 显示地发送 ACK 指令.</p>
</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://my.oschina.net/u/3523423/blog/1620885" target="_blank" rel="external">RabbitMQ 实战（四）消费者 ack 以及 生产者 confirms</a></p>
<p><a href="http://www.pandan.xyz/2017/03/05/rabbitmq%20%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%8A%95%E9%80%92%E5%8F%8A%E6%B6%88%E8%B4%B9%E6%9C%BA%E5%88%B6/" target="_blank" rel="external">rabbitmq 消息可靠投递及消费机制</a></p>
<p><a href="http://www.bijishequ.com/detail/52417?p=" target="_blank" rel="external">rabbitmq的发布确认和事务</a></p>
<p><a href="http://blog.csdn.net/u013256816/article/details/55515234" target="_blank" rel="external">RabbitMQ之消息确认机制（事务+Confirm）</a></p>
<p><a href="http://www.10tiao.com/html/773/201801/2247487341/1.html" target="_blank" rel="external">有货RabbitMQ双活实践</a></p>
<p><a href="https://laoyuan.me/posts/spring-rabbitmq-demo.html" target="_blank" rel="external">Spring Boot集成RabbitMQ与ACK确认模式</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java 线程状态]]></title>
      <url>http://zsr.github.io/2018/02/09/Java-%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/</url>
      <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">同一个线程能不能start执行2次？</div><div class="line">---不能</div></pre></td></tr></table></figure>
<p><code>Java</code>虚拟机所暴露的线程状态，与操作系统底层的线程状态是两个不同层面的事</p>
<h3 id="JVM线程状态"><a href="#JVM线程状态" class="headerlink" title="JVM线程状态"></a>JVM线程状态</h3><p><code>JVM</code>中定义的线程状态有以下几种：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 线程刚创建，还未start</div><div class="line">         */</div><div class="line">        NEW,</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 线程正在jvm中执行，对操作系统来说可能正在等待时间片执行(就绪态)</div><div class="line">         * I/O阻塞或网络等待，对应的JVM线程状态也是RUNNABLE</div><div class="line">         */</div><div class="line">        RUNNABLE,</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 程正在等待获取锁，阻塞状态</div><div class="line">         */</div><div class="line">        BLOCKED,</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 一般通过Object.wait()或者Thread.join()，进入waiting状态;前提是这个线程已经拥有锁了</div><div class="line">         * 如果一个线程调用了一个对象的wait方法，那么这个线程就会处于waiting状态直到另外一个线程调用这个对                          </div><div class="line">         * 象的notify或者notifyAll方法后才会解除这个状态</div><div class="line">         */</div><div class="line">        WAITING,</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 通过sleep(timeout)或wait(timeout)方法进入的限期等待的状态</div><div class="line">         * 需要注意2者区别</div><div class="line">         */</div><div class="line">        TIMED_WAITING,</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 线程执行结束</div><div class="line">         */</div><div class="line">        TERMINATED;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h4 id="blocked和waiting状态的区别"><a href="#blocked和waiting状态的区别" class="headerlink" title="blocked和waiting状态的区别"></a><code>blocked</code>和<code>waiting</code>状态的区别</h4><ul>
<li><code>blocked</code>是虚拟机认为程序还不能进入某个区域，因为同时进去就会有问题，这是一块临界区</li>
<li><code>wait</code>操作的先决条件是要进入临界区，也就是线程已经拿到锁了，自己可能进去做了一些事情，但此时通过判定业务上的参数，发现还有一些其他配合的资源没有准备充分，那么自己就等等再做其他事情。</li>
</ul>
<h4 id="sleep-和wait-操作的区别"><a href="#sleep-和wait-操作的区别" class="headerlink" title="sleep()和wait()操作的区别"></a><code>sleep()</code>和<code>wait()</code>操作的区别</h4><ul>
<li><code>sleep</code>是<code>Thread</code>类的静态方法,<code>wait</code>是<code>Object</code>类中定义的方法</li>
<li><code>Thread.sleep</code>不会导致锁行为的改变，如果当前线程是拥有锁的，那么<code>Thread.sleep</code>不会让线程释放锁；<code>Object.wait</code>会释放锁，进入等待队列中</li>
<li><code>wait</code>不带计时参数是<code>WAITING</code>状态，带计时参数是<code>TIMED_WAITING</code>状态；不管是通过<code>notify()</code>唤醒还是超时时间已到，都需要重新获取锁才能继续执行</li>
</ul>
<h3 id="线程start方法"><a href="#线程start方法" class="headerlink" title="线程start方法"></a>线程start方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// threadStatus=0,表示当前为NEW状态</span></div><div class="line">        <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</div><div class="line">  </div><div class="line">        group.add(<span class="keyword">this</span>);</div><div class="line"></div><div class="line">        <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">           <span class="comment">// 本地方法执行线程</span></div><div class="line">            start0();</div><div class="line">            started = <span class="keyword">true</span>;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">if</span> (!started) &#123;</div><div class="line">                    group.threadStartFailed(<span class="keyword">this</span>);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</div><div class="line">                <span class="comment">/* do nothing. If start0 threw a Throwable then</span></div><div class="line">                  it will be passed up the call stack */</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><code>start()</code>方法是同步的，而且执行前会判断当前线程状态是否为<code>NEW</code>；也就是说，同一个线程只能执行一次</p>
<h3 id="网络阻塞线程状态"><a href="#网络阻塞线程状态" class="headerlink" title="网络阻塞线程状态"></a>网络阻塞线程状态</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testBlockedSocketState</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line"></div><div class="line">    Thread serverThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">      <span class="meta">@Override</span></div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        ServerSocket serverSocket = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">          serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">10086</span>);</div><div class="line">          <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            <span class="comment">// 阻塞的accept方法</span></div><div class="line">            Socket socket = serverSocket.accept();</div><div class="line">          &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">          e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">          <span class="keyword">try</span> &#123;</div><div class="line">            serverSocket.close();</div><div class="line">          &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;, <span class="string">"socket线程"</span>); <span class="comment">// 线程的名字</span></div><div class="line">    serverThread.start();</div><div class="line"></div><div class="line">    <span class="comment">// 确保run已经得到执行</span></div><div class="line">    Thread.sleep(<span class="number">500</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 状态为RUNNABLE</span></div><div class="line">    System.out.println(serverThread.getState());</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>使用<code>jstack</code>查看线程状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&quot;socket线程&quot; #9 prio=5 os_prio=31 tid=0x00007ff0bc026800 nid=0x4c03 runnable [0x00007000010c6000]</div><div class="line">   java.lang.Thread.State: RUNNABLE</div><div class="line">	at java.net.PlainSocketImpl.socketAccept(Native Method)</div><div class="line">	at java.net.AbstractPlainSocketImpl.accept(AbstractPlainSocketImpl.java:409)</div><div class="line">	at java.net.ServerSocket.implAccept(ServerSocket.java:545)</div><div class="line">	at java.net.ServerSocket.accept(ServerSocket.java:513)</div><div class="line">	at com.zsr.test.thread.ThreadBlockedIOState$1.run(ThreadBlockedIOState.java:19)</div><div class="line">	at java.lang.Thread.run(Thread.java:745)</div></pre></td></tr></table></figure>
<p>可见JVM线程状态为<code>RUNNABLE</code>；I/O 阻塞也是如此</p>
<p><strong>注意：进行传统上的 IO 操作时，我们也会说“阻塞”，但这个“阻塞”与线程的<code>BLOCKED</code> 状态是两码事</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">当进行阻塞式的 IO 操作时，底层的操作系统线程确实处在阻塞状态</div></pre></td></tr></table></figure>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://fangjian0423.github.io/2016/06/04/java-thread-state/" target="_blank" rel="external">Java线程状态分析</a></p>
<p><a href="https://my.oschina.net/goldenshaw/blog/705397" target="_blank" rel="external">Java 线程状态之 RUNNABLE</a></p>
<p><a href="http://www.java67.com/2012/08/what-are-difference-between-wait-and.html" target="_blank" rel="external">What is difference between wait and sleep in Java?</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[缓存更新分析]]></title>
      <url>http://zsr.github.io/2018/01/24/%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<h3 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h3><p>项目中为了加快响应时间以及减轻数据库压力，使用了<code>redis</code>缓存，同时缓存设置了过期时间(1天)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">2个线程并发：一个读数据，一个写数据；</div><div class="line">假使缓存过期，读缓存未命中，写数据还未开始，这个时候加载数据到缓存中(脏数据)；然后，写数据开始。</div><div class="line">结果导致，缓存失效前读到的数据都是脏数据，如何解决？</div></pre></td></tr></table></figure>
<h3 id="为什么要用缓存"><a href="#为什么要用缓存" class="headerlink" title="为什么要用缓存"></a>为什么要用缓存</h3><p>一般数据都存放在关系型数据库中，以常用的MySQL数据库为例，正常情况下响应时间在10ms以内甚至更短；但是当数据上亿条，任何一款关系型数据库的响应时间都不可能控制在10ms以内</p>
<p>同时高并发情况下，比如同时来1万次请求，MySQL单库TPS(每秒事务量)大概只有1500左右，其它的请求只能处于等待状态，严重情况下数据库崩溃</p>
<h3 id="使用缓存的场景"><a href="#使用缓存的场景" class="headerlink" title="使用缓存的场景"></a>使用缓存的场景</h3><p>对于缓存来说，数据变更少且查询比较频繁是最好的场景，如果查询量不够大或者数据变动太频繁，缓存也就是失去了意义。</p>
<h3 id="缓存类型"><a href="#缓存类型" class="headerlink" title="缓存类型"></a>缓存类型</h3><h4 id="本地缓存"><a href="#本地缓存" class="headerlink" title="本地缓存"></a>本地缓存</h4><p>有些数据量不常变化，但是访问十分频繁，例如省、市地区数据。针对这种场景，可以将数据加载到应用的内存中，以提升系统的访问效率，减少数据库访问同时加快响应时间。</p>
<ul>
<li><strong>Guava Cache</strong></li>
</ul>
<p>比较常见的本地缓存有<code>Guava Cache</code>，使用方式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">LoadingCache&lt;String, String&gt; cache = CacheBuilder.newBuilder()</div><div class="line">        .maximumSize(<span class="number">1000</span>) <span class="comment">// 设置最大大小</span></div><div class="line">        .expireAfterWrite(<span class="number">10</span>, TimeUnit.MINUTES) <span class="comment">// 设置过期时间， 10分钟</span></div><div class="line">        .build(</div><div class="line">            <span class="keyword">new</span> CacheLoader&lt;String, String&gt;() &#123;</div><div class="line">                <span class="comment">// 加载缓存内容</span></div><div class="line">                <span class="function"><span class="keyword">public</span> String <span class="title">load</span><span class="params">(String key)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                    <span class="keyword">return</span> getFromDB(key);</div><div class="line">                &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<ul>
<li><strong>本地缓存的缺点</strong><ol>
<li>数据保存在当前<code>JVM</code>中，无法共享</li>
<li>重启应用缓存丢失</li>
</ol>
</li>
</ul>
<h4 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h4><p>提到分布式缓存基本上都会说到 <code>Redis</code>，<code>Redis</code>使用内存作为存储，所以性能上要比数据库要好很多，再加上<code>Redis</code> 还支持很多种数据结构，使用起来比较方便；但是，<code>Redis</code>需要通过网络来访问，所以网络的性能决定了 <code>Reids</code> 的瓶颈</p>
<h3 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h3><p>更多策略见<a href="https://coolshell.cn/articles/17416.html" target="_blank" rel="external">缓存更新的套路</a>，这里具体分析喜马拉雅的缓存更新策略：先更新数据库，再失效缓存</p>
<h4 id="Cache-Aside-Pattern"><a href="#Cache-Aside-Pattern" class="headerlink" title="Cache Aside Pattern"></a><strong>Cache Aside Pattern</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1. 失效：先从缓存中读取数据，没有得到，则从数据库中读取，成功后，放到缓存中。</div><div class="line">2. 命中：从缓存中读取数据，取到后返回。</div><div class="line">3. 更新：先把数据存到数据库中，成功后，再让缓存失效。</div></pre></td></tr></table></figure>
<p>这种策略也会产生问题，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">两个并发操作，一个是更新操作，一个是查询操作；</div><div class="line">读操作先到，没有命中缓存，然后就到数据库中读取。</div><div class="line">这时来了一个写操作，写完数据库后，然缓存失效。</div><div class="line">然后，之前的读操作再把旧数据写到缓存中，还是会造成脏数据。</div></pre></td></tr></table></figure>
<p>但是，这种情况出现的概率非常低。这个场景需要发生在读缓存时缓存失效，并发着有一个写操作。而实际上数据库的写操作比读操作慢得多，而且还要锁表，而<strong>读操作需要在写操作之前进入数据库操作，又要在写操作完成后更新缓存</strong>，所有的这些条件都具备的概率并不大。所以，Cache Aside Pattern 还是相对靠谱的方式。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://zhaoqqi.github.io/2017/06/14/cache-system-design/" target="_blank" rel="external">缓存系统设计与更新机制</a></p>
<p><a href="https://coolshell.cn/articles/17416.html" target="_blank" rel="external">缓存更新的套路</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[rabbitmq消息重试]]></title>
      <url>http://zsr.github.io/2018/01/17/rabbitmq%E6%B6%88%E6%81%AF%E9%87%8D%E8%AF%95/</url>
      <content type="html"><![CDATA[<h3 id="如何实现消息重试"><a href="#如何实现消息重试" class="headerlink" title="如何实现消息重试"></a>如何实现消息重试</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">rabbit:connection-factory</span> <span class="attr">id</span>=<span class="string">"connectionFactory"</span> /&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">rabbit:template</span> <span class="attr">id</span>=<span class="string">"amqpTemplate"</span> <span class="attr">connection-factory</span>=<span class="string">"connectionFactory"</span> /&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">rabbit:admin</span> <span class="attr">connection-factory</span>=<span class="string">"connectionFactory"</span> /&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"messageConverter"</span> <span class="attr">class</span>=<span class="string">"org.springframework.amqp.support.converter.SimpleMessageConverter"</span>/&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">rabbit:queue</span> <span class="attr">name</span>=<span class="string">"microlesson.reward.msg.queue"</span> /&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">rabbit:direct-exchange</span> <span class="attr">name</span>=<span class="string">"business.common.order.confirmed.direct.exchange"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">rabbit:bindings</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">rabbit:binding</span> <span class="attr">key</span>=<span class="string">"1245"</span> <span class="attr">queue</span>=<span class="string">"microlesson.reward.msg.queue"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">rabbit:bindings</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">rabbit:direct-exchange</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">rabbit:listener-container</span>   <span class="attr">prefetch</span>=<span class="string">"20"</span></span></div><div class="line">                             <span class="attr">concurrency</span>=<span class="string">"10"</span></div><div class="line">                             <span class="attr">connection-factory</span>=<span class="string">"connectionFactory"</span></div><div class="line">                             <span class="attr">message-converter</span>=<span class="string">"messageConverter"</span></div><div class="line">                             <span class="attr">requeue-rejected</span>=<span class="string">"false"</span></div><div class="line">                             <span class="attr">advice-chain</span>=<span class="string">"retryInterceptor"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">rabbit:listener</span> <span class="attr">ref</span>=<span class="string">"rewordMsgListener"</span> <span class="attr">queue-names</span>=<span class="string">"microlesson.reward.msg.queue"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">rabbit:listener-container</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"rewordMsgListener"</span> <span class="attr">class</span>=<span class="string">"com.ximalaya.microlesson.listener.listener.RewardMsgListener"</span>/&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"retryTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.retry.support.RetryTemplate"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"backOffPolicy"</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.retry.backoff.ExponentialBackOffPolicy"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"initialInterval"</span> <span class="attr">value</span>=<span class="string">"10000"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxInterval"</span> <span class="attr">value</span>=<span class="string">"600000"</span>/&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"retryPolicy"</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.retry.policy.SimpleRetryPolicy"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxAttempts"</span> <span class="attr">value</span>=<span class="string">"7"</span>/&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!--retry Interceptor --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"retryInterceptor"</span></span></div><div class="line">        <span class="attr">class</span>=<span class="string">"org.springframework.amqp.rabbit.config.StatelessRetryOperationsInterceptorFactoryBean"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"messageRecoverer"</span> <span class="attr">ref</span>=<span class="string">"messageRecoverer"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"retryOperations"</span> <span class="attr">ref</span>=<span class="string">"retryTemplate"</span>/&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li><code>requeue-rejected</code>设为false表示一条消息即使没有被ack，也不会再重新发送（默认是会重新加入队列）</li>
</ul>
<h3 id="如何实现消息延时"><a href="#如何实现消息延时" class="headerlink" title="如何实现消息延时"></a>如何实现消息延时</h3><p><code>RabbitMQ</code>可以针对<code>Queue</code>和<code>Message</code>设置<code>x-message-tt</code>，来控制消息的生存时间，如果超时，则消息变为<code>dead letter</code></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://www.pandan.xyz/2017/03/05/rabbitmq%20%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%8A%95%E9%80%92%E5%8F%8A%E6%B6%88%E8%B4%B9%E6%9C%BA%E5%88%B6/" target="_blank" rel="external">rabbitmq 消息可靠投递及消费机制</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[EventBus]]></title>
      <url>http://zsr.github.io/2017/12/27/EventBus/</url>
      <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><code>Guava</code>提供了事件总线<code>EventBus</code>库，是一个基于事件的<strong>发布/订阅框架</strong>（观察者模式），通过解耦发布者和订阅者简化事件传递，可以用它在单进程中替代<code>RabbitMQ</code>来做事件分发。</p>
<h3 id="Observer模式"><a href="#Observer模式" class="headerlink" title="Observer模式"></a>Observer模式</h3><p>Java把<code>Observer</code>放到了JDK里面：Observable和Observer，它简化了Observer模式的开发，至少不用再手工维护自己的<code>Observer</code>列表了。不过，JDK里的<code>Observer</code>从1.0就在那里了，直到<code>Java 7</code>，它都没有什么改变，就连通知的参数还是<code>Object</code>类型。目前很少会直接应用JDK中的<code>Observer</code>，<code>Guava</code>的<code>EventBus</code>也实现了<code>Observer</code>模式</p>
<h3 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h3><ul>
<li><strong>事件(Event)：</strong>又可称为消息，用于订阅者和发布者之间的消息传递媒介。<code>事件类型(EventType)</code>一般是指一个消息对象。</li>
<li><strong>订阅者(Subscriber)：</strong>订阅某种事件类型的对象。当有发布者发布这类事件后，<code>EventBus</code> 会执行订阅者的 <code>onEvent</code> 函数，这个函数叫<code>事件响应函数</code>。订阅者通过 <code>register</code> 接口订阅某个事件类型，<code>unregister</code> 接口退订。</li>
<li><strong>发布者(Publisher)：</strong>发布某事件的对象，通过 post 接口发布事件。</li>
</ul>
<h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><img src="https://raw.githubusercontent.com/android-cn/android-open-project-analysis/master/tool-lib/event-bus/event-bus/image/relation-flow-chart.png" alt="eventbus img"></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://www.iteye.com/topic/1132705" target="_blank" rel="external">深入理解EventBus的设计思想</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[浏览器跨域请求]]></title>
      <url>http://zsr.github.io/2017/12/14/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82/</url>
      <content type="html"><![CDATA[<p>在跨域情况下（源域名与目的域名不一样），浏览器可能会发起一个<code>HTTP OPTIONS</code> 的请求预检（<code>preflighting</code>）服务端是否支持<code>CORS</code>。如果服务端允许当前域名(源域名)<code>CORS</code>，则浏览器会再发起真正的请求。</p>
<h3 id="跨域请求"><a href="#跨域请求" class="headerlink" title="跨域请求"></a>跨域请求</h3><p>浏览器将<code>CORS</code>请求分成两类：简单请求（<code>simple request</code>）和非简单请求（<code>not-so-simple request</code>）。只要同时满足以下两大条件，就属于简单请求。</p>
<ul>
<li>请求方法是以下三种方法之一：<code>HEAD,GET,POST</code></li>
<li><code>HTTP</code>的头信息不超出以下几种字段：<ul>
<li><code>Accept</code></li>
<li><code>Accept-Language</code></li>
<li><code>Content-Language</code></li>
<li><code>Last-Event-ID</code></li>
<li><code>Content-Type</code>(只限于三个值<code>application/x-www-form-urlencoded</code>、 <code>multipart/form-data</code>、<code>text/plain</code>)</li>
</ul>
</li>
</ul>
<p>凡是不同时满足上面两个条件，就属于非简单请求。</p>
<h4 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h4><p>对于简单请求，浏览器直接发出<code>CORS</code>请求。浏览器会自动在头信息(<code>Request Headers</code>)中，添加一个<code>Origin</code> 字段,来表明本次请求来自哪个域。</p>
<ul>
<li>如果<code>Origin</code>不在许可范围内，会报错：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">No &apos;Access-Control-Allow-Origin&apos; header is present on the requested resource.</div></pre></td></tr></table></figure>
<ul>
<li>如果<code>Origin</code>指定的域名在许可范围内(必须是跨域的），<code>Response Headers</code>中会多出几个头信息字段:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Access-Control-Allow-Credentials:true //值为true表示允许发送cookie</div><div class="line">Access-Control-Allow-Methods:GET, POST, OPTIONS</div><div class="line">Access-Control-Allow-Origin:http://localhost:8080</div></pre></td></tr></table></figure>
<p>这几个字端要么在服务器端直接返回，要么配置在<code>nginx</code>中，具体实现看下文</p>
<ul>
<li><code>withCredentials</code>属性</li>
</ul>
<p><code>CORS</code>默认不发送<code>cookie</code>和<code>http</code>认证，如果要把<code>Cookie</code>发到服务器，就要指定<code>Access-Control-Allow-Credentials:true;</code><strong>另外<code>ajax</code>中也要打开<code>withCredentials</code>属性</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">headers: &#123;</div><div class="line">        withCredentials: true,</div><div class="line">    &#125;,</div></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h4><p>比如：请求方法是<code>PUT</code>或<code>DELETE</code>，或者<code>Content-Type</code>字段的类型是<code>application/json</code></p>
<p><strong>结果发现浏览器连续向同一地址请求了两次，而第一次请求什么值也没拿到</strong></p>
<ul>
<li>第一次请求信息</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">General</div><div class="line">Request URL:http:/mobile.test.ximalaya.com/v1/lesson</div><div class="line">Request Method:OPTIONS  </div><div class="line">Status Code:200 OK</div><div class="line"></div><div class="line">Response Headers</div><div class="line">Access-Control-Request-Headers:content-type  </div><div class="line">Access-Control-Request-Method:GET, POST, OPTIONS  </div><div class="line">Access-Control-Allow-Origin:http://localhost:8080</div><div class="line">Content-Length:0</div></pre></td></tr></table></figure>
<ul>
<li>第二次请求信息</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">General</div><div class="line">Request URL:http:/mobile.test.ximalaya.com/v1/lesson</div><div class="line">Request Method:POST  </div><div class="line">Status Code:200 OK</div><div class="line"></div><div class="line">Response Headers</div><div class="line">Access-Control-Request-Headers:content-type  </div><div class="line">Access-Control-Request-Method:GET, POST, OPTIONS  </div><div class="line">Access-Control-Allow-Origin:http://localhost:8080</div></pre></td></tr></table></figure>
<p>这是因为浏览器发现，这是一个非简单请求，就自动发出一个”预检”请求，要求服务器确认可以这样请求。”预检”请求用的请求方法是<code>OPTIONS</code>，表示这个请求是用来询问的。”预检”请求之后，浏览器球会进行正常<code>CORS</code>请求。</p>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><h4 id="背景说明"><a href="#背景说明" class="headerlink" title="背景说明"></a>背景说明</h4><p>前端H5通过<code>ajax</code>调用后端<code>restful api</code>，并且页面访问域名与<code>api</code>访问域名(<code>mobile.test.ximalaya.com</code>)不同，导致访问报错:</p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fmomo2jmabj31kw045n0e.jpg" alt="05C9331E-30FD-4685-AB61-02F308FC3695"></p>
<p>出现这种情况的原因如下：</p>
<ul>
<li>本次<code>ajax</code>请求是“非简单请求”,所以请求前会发送一次预检请求(OPTIONS)</li>
<li>服务器端后台接口没有允许OPTIONS请求,导致无法找到对应接口地址</li>
</ul>
<h4 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h4><ol>
<li><strong>前端<code>ajax</code>请求代码</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$.ajax(&#123;</div><div class="line">    url: &apos;http://mobile.test.ximalaya.com/weikemsg-web/v1/room/110001/discuss/send&apos;,</div><div class="line">    headers: &#123;</div><div class="line">        &apos;Content-Type&apos;:&apos;application/json&apos;</div><div class="line">    &#125;,</div><div class="line">    method: &apos;POST&apos;,</div><div class="line">    data: &#123;id = 1&#125;,</div><div class="line">    success: function(data)&#123;</div><div class="line">      console.log(&apos;succes: &apos;+data);</div><div class="line">    &#125;</div><div class="line">  &#125;);</div></pre></td></tr></table></figure>
<p>这里请求类型使用<code>post</code>，数据类型是<code>json</code></p>
<ol>
<li><strong><code>http</code>请求信息</strong></li>
</ol>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fmomo3etz5j30za0f6tbg.jpg" alt="F003603E-2FE9-4009-BF3D-CAA5EE0201F9"></p>
<p>从<code>request header</code>信息中可以发现，实际请求类型是<code>OPTIONS</code>，注意：</p>
<ul>
<li><code>Access-Control-Request-Method</code>：在发出预检请求时带有这个头信息, 告诉服务器在实际请求时会使用的请求方式</li>
<li><code>Access-Control-Request-Headers</code>：在发出预检请求时带有这个头信息, 告诉服务器在实际请求时会携带的自定义头信息. 如有多个, 可以用逗号分开.</li>
<li><code>Origin</code>：表明发送请求或者预请求的域</li>
</ul>
<ol>
<li><strong>失败分析</strong></li>
</ol>
<ul>
<li><code>Status Code:401</code></li>
</ul>
<p>这里的<code>http</code>返回状态码<code>401</code>(未授权)，是因为服务端这边设置了登录验证过滤器，服务端返回结果如下：</p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fmomo4slblj30fg03eq32.jpg" alt="F2AFC4E1-4CDE-4B6C-8237-A185565213D9"></p>
<ul>
<li>跨域</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Response to preflight request doesn&apos;t pass access control check: No &apos;Access-Control-Allow-Origin&apos; header is present on the requested resource. Origin &apos;http://127.0.0.1:9000&apos; is therefore not allowed access</div></pre></td></tr></table></figure>
<p>从控制台错误信息中，可以发现浏览器发送的<code>OPTIONS</code>预检请求不允许访问服务器，也就是不允许跨域访问</p>
<ol>
<li><strong>第一次尝试解决</strong></li>
</ol>
<p><code>Nginx</code>添加如下配置：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">location ^~ /weikemsg-web &#123;</div><div class="line">        add_header 'Access-Control-Allow-Origin' "*"; // 允许所有域名访问</div><div class="line">        add_header 'Access-Control-Allow-Credentials' 'true';  // 允许携带Cookie</div><div class="line">        add_header 'Access-Control-Allow-Methods' 'POST, GET, OPTIONS'; // 支持访问方式</div><div class="line">        proxy_pass http://weikemsg-web/weikemsg-web;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>同时用户先登录，保留<code>Cookie</code>，再次访问目的地址，结果如下：</p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fmomo2zcwoj31kw03641g.jpg" alt="01807CD6-DD4D-4F17-BF94-F5F75CE7E93E"></p>
<p>结果没有任何变化，跨域访问没有成功，服务端还是没有拿到<code>Cookie</code>信息</p>
<ol>
<li><strong>第二次尝试解决</strong></li>
</ol>
<p><strong>如果<code>http</code>请求需要带上<code>Cookie</code>，必须设置<code>Access-Control-Allow-Credentials</code>为<code>true</code>，同时不能设置<code>Access-Control-Allow-Origin</code>为<code>*</code></strong></p>
<p>重新配置<code>Nginx</code>:</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">location</span><span class="regexp"> ^~</span> /weikemsg-web &#123;</div><div class="line">        <span class="attribute">add_header</span> <span class="string">'Access-Control-Allow-Origin'</span> <span class="string">"<span class="variable">$http_origin</span>"</span>;</div><div class="line">        <span class="attribute">add_header</span> <span class="string">'Access-Control-Allow-Credentials'</span> <span class="string">'true'</span>;</div><div class="line">        <span class="attribute">add_header</span> <span class="string">'Access-Control-Allow-Methods'</span> <span class="string">'POST, GET, OPTIONS'</span>;</div><div class="line">        <span class="attribute">proxy_pass</span> http://weikemsg-web/weikemsg-web;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>再次访问，但是结果没有任何变化</p>
<ol>
<li><strong>第三次尝试解决</strong></li>
</ol>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fmomo3wo7rj312w09240h.jpg" alt="F570147A-895F-4223-AAD5-4E92C885BAB9"></p>
<p>重新观察请求头信息，浏览器发送<code>OPTIONS</code>请求并没有携带<code>Cookie</code>，该请求进入服务器后被判断未登录，所以一直返回<code>401</code>错误，首先需要解决的是处理<code>OPTIONS</code>请求</p>
<p>重新配置<code>Nginx</code>:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">location ^~ /weikemsg-web &#123;</div><div class="line">        if ($request_method = 'OPTIONS') &#123;</div><div class="line">            return 204; // 等同于请求执行成功，但是没有数据，浏览器不用刷新页面.也不用导向新的页面</div><div class="line">        &#125;</div><div class="line">        add_header 'Access-Control-Allow-Origin' "$http_origin";</div><div class="line">        add_header 'Access-Control-Allow-Credentials' 'true';</div><div class="line">        add_header 'Access-Control-Allow-Methods' 'POST, GET, OPTIONS';</div><div class="line">       </div><div class="line">        proxy_pass http://weikemsg-web/weikemsg-web;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>再次跨域访问，结果如下：</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fmomo4d3wbj31kw026wfq.jpg" alt="5EC9BD61-4FF4-4ED3-A69F-E73E0E9D0475"></p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fmomo1pawej31040cego7.jpg" alt="676169C7-A9CF-4737-8B1B-25546C423DDB"></p>
<p>跨域的问题已经解决，但是由于我的请求头中设置了<code>&#39;Content-Type&#39;:&#39;application/json&#39;</code>，需要服务端支持该类型</p>
<ol>
<li><strong>第三次尝试解决: 终极方案</strong></li>
</ol>
<p>重新配置<code>Nginx</code>：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">location</span><span class="regexp"> ^~</span> /weikemsg-web &#123;</div><div class="line">        <span class="attribute">if</span> (<span class="variable">$request_method</span> = <span class="string">'OPTIONS'</span>) &#123;</div><div class="line">            <span class="attribute">return</span> <span class="number">204</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="attribute">add_header</span> <span class="string">'Access-Control-Allow-Origin'</span> <span class="string">"<span class="variable">$http_origin</span>"</span>;</div><div class="line">        <span class="attribute">add_header</span> <span class="string">'Access-Control-Allow-Credentials'</span> <span class="string">'true'</span>;</div><div class="line">        <span class="attribute">add_header</span> <span class="string">'Access-Control-Allow-Methods'</span> <span class="string">'POST, GET, OPTIONS'</span>;</div><div class="line">        <span class="attribute">add_header</span> <span class="string">'Access-Control-Allow-Headers'</span> <span class="string">'Content-Type'</span>;</div><div class="line">        <span class="attribute">proxy_pass</span> http://weikemsg-web/weikemsg-web;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>Access-Control-Allow-Headers</code> ：指明了实际请求中允许携带的首部字段。</li>
</ul>
<p>结果如下：</p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fmomo20v2qj30t00fotay.jpg" alt="75C9B3DC-40DE-4F2D-BDE3-7E9B8E40E803"></p>
<p>到此，跨域问题终于解决了</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>Ajax</code>跨域可以用2种方式解决：<code>Nginx</code>跨域配置，<a href="https://dailc.github.io/2017/03/22/ajaxCrossDomainSolution.html" target="_blank" rel="external"><code>Java</code>服务端配置</a></p>
<h4 id="Nginx跨域配置-推荐"><a href="#Nginx跨域配置-推荐" class="headerlink" title="Nginx跨域配置(推荐)"></a><code>Nginx</code>跨域配置(推荐)</h4><ul>
<li><strong>简单跨域请求</strong></li>
</ul>
<p>如果需要跨域的服务接口提供简单的http请求，可以在<code>Nginx</code>中配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">location ^~ /microlesson-web &#123;</div><div class="line">        add_header &apos;Access-Control-Allow-Origin&apos; &quot;*&quot;;</div><div class="line">        add_header &apos;Access-Control-Allow-Methods&apos; &apos;POST, GET, OPTIONS&apos;;</div><div class="line"></div><div class="line">        proxy_pass http://192.168.3.58:9280/microlesson-web;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><strong>注意：如果<code>http</code>请求需要带上<code>Cookie</code>，必须设置<code>Access-Control-Allow-Credentials</code>为<code>true</code>，同时不能设置<code>Access-Control-Allow-Origin</code>为<code>*</code></strong></p>
<p>跨域发送<code>Cookie</code>还要求<code>Access-Control-Allow-Origin</code><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="external">不允许使用通配符</a>。 事实上不仅不允许通配符，而且<a href="https://www.w3.org/TR/2010/WD-cors-20100727/#resource-sharing-check0" target="_blank" rel="external">只能指定单一域名</a>：</p>
<blockquote>
<p>If the credentials flag is true and the response includes zero or more than one Access-Control-Allow-Credentials header values return fail and terminate this algorithm. –W3C Cross-Origin Resource Sharing</p>
</blockquote>
<p>修改如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">location ^~ /microlesson-web &#123;</div><div class="line">        add_header &apos;Access-Control-Allow-Origin&apos; &quot;$http_origin&quot;; //允许http访问源地址</div><div class="line">        add_header &apos;Access-Control-Allow-Credentials&apos; &apos;true&apos;;</div><div class="line">        add_header &apos;Access-Control-Allow-Methods&apos; &apos;POST, GET, OPTIONS&apos;;</div><div class="line">        add_header &apos;Access-Control-Allow-Headers&apos; &apos;Accept,Authorization,Cache-Control,Content-Type,DNT,If-Modified-Since,Keep-Alive,Origin,User-Agent,X-Mx-ReqToken,X-Requested-With&apos;;</div><div class="line"></div><div class="line">        proxy_pass http://192.168.3.58:9280/microlesson-web;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>非简单跨域请求</strong></li>
</ul>
<p>项目中常见的非简单跨域请求一般是：<code>post</code>请求，以及<code>json</code>数据；<code>Nginx</code>配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">location ^~ /microlesson-web &#123;</div><div class="line">   if ($request_method = &apos;OPTIONS&apos;) &#123;</div><div class="line">       add_header Access-Control-Allow-Origin *; </div><div class="line">       add_header Access-Control-Allow-Methods GET,POST,PUT,DELETE,OPTIONS;</div><div class="line">       #其他头部信息配置，省略...</div><div class="line">       return 204;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">	add_header &apos;Access-Control-Allow-Origin&apos; &quot;$http_origin&quot;;</div><div class="line">	add_header &apos;Access-Control-Allow-Credentials&apos; &apos;true&apos;;</div><div class="line">	add_header &apos;Access-Control-Allow-Methods&apos; &apos;POST, GET, OPTIONS&apos;;</div><div class="line">	add_header &apos;Access-Control-Allow-Headers&apos; &apos;Accept,Authorization,Cache-Control,Content-Type,DNT,If-Modified-Since,Keep-Alive,Origin,User-Agent,X-Mx-ReqToken,X-Requested-With&apos;;</div><div class="line"></div><div class="line">    proxy_pass http://192.168.3.58:9280/microlesson-web;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>关键的地方在于先判断请求类型如果是<code>OPTIONS</code>，设置<code>Allow</code>的响应头，重新处理这次请求。</p>
<ul>
<li><strong>过滤请求域名</strong></li>
</ul>
<p>如果需要指定一些域名跨域访问服务，可以如下配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">location ^~ /microlesson-web &#123;</div><div class="line">        set $cors &apos;&apos;;</div><div class="line">		if ($http_origin ~* &apos;http?://(localhost|www\.ximalaya\.com)&apos;) &#123;</div><div class="line">        	set $cors &apos;true&apos;;</div><div class="line">		&#125;</div><div class="line">		if ($cors = &apos;true&apos;) &#123;</div><div class="line">        	add_header &apos;Access-Control-Allow-Origin&apos; &quot;$http_origin&quot;;</div><div class="line">        	add_header &apos;Access-Control-Allow-Credentials&apos; &apos;true&apos;;</div><div class="line">        	add_header &apos;Access-Control-Allow-Methods&apos; &apos;GET, POST, OPTIONS&apos;;</div><div class="line">        	add_header &apos;Access-Control-Allow-Headers&apos; &apos;Accept,Authorization,Cache-Control,Content-Type,DNT,If-Modified-Since,Keep-Alive,Origin,User-Agent,X-Mx-ReqToken,X-Requested-With&apos;;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">        proxy_pass http://192.168.3.58:9280/microlesson-web;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="external">HTTP访问控制(CORS)</a></p>
<p><a href="http://todoit.me/ajax-preflight/" target="_blank" rel="external">为什么我的跨域 AJAX 发了两个请求?</a></p>
<p><a href="http://kaifage.com/notes/181/configuration-cors-on-nginx.html" target="_blank" rel="external">Nginx配置支持CORS</a></p>
<p><a href="https://github.com/zhongxia245/blog/issues/33" target="_blank" rel="external">Nginx跨域配置</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="external">跨域资源共享 CORS 详解</a></p>
<p><a href="https://dailc.github.io/2017/03/22/ajaxCrossDomainSolution.html" target="_blank" rel="external">ajax跨域解决方案</a></p>
<p><a href="http://harttle.land/2016/12/28/cors-with-cookie.html" target="_blank" rel="external">CORS 跨域发送 Cookie</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Spring AOP源码分析]]></title>
      <url>http://zsr.github.io/2017/11/30/Spring-AOP%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>启动<code>Spring AOP</code>需要配置 <code>&lt;aop:config&gt;</code> 标签或者<code>aspectj-autoproxy</code>标签</p>
<h3 id="lt-aop-gt-标签解析"><a href="#lt-aop-gt-标签解析" class="headerlink" title="&lt;aop&gt;标签解析"></a><code>&lt;aop&gt;</code>标签解析</h3><p>如果使用<code>&lt;aop:xxxx /&gt;</code>标签来自动生成代理的话，入口程序是<code>AopNamespaceHandler</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="comment">// In 2.0 XSD as well as in 2.1 XSD.</span></div><div class="line">  registerBeanDefinitionParser(<span class="string">"config"</span>, <span class="keyword">new</span> ConfigBeanDefinitionParser());</div><div class="line">  registerBeanDefinitionParser(<span class="string">"aspectj-autoproxy"</span>, <span class="keyword">new</span> AspectJAutoProxyBeanDefinitionParser());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>如果使用了<code>&lt;aop:config&gt;</code>标签，使用 <code>ConfigBeanDefinitionParser</code> 解析</li>
<li>如果使用了<code>&lt;aop:aspectj-autoproxy&gt;</code>标签，使用 <code>AspectJAutoProxyBeanDefinitionParser</code> 解析</li>
</ul>
<h3 id="类结构图"><a href="#类结构图" class="headerlink" title="类结构图"></a>类结构图</h3><p>这里放一张<code>Spring AOP</code>代理自动生成器的类图</p>
<ul>
<li><code>&lt;aop:config&gt;</code>方式使用<code>AspectJAwareAdvisorAutoProxyCreator</code>创建代理，`</li>
<li><code>&lt;aop:aspectj-autoproxy&gt;</code>使用<code>AnnotationAwareAspectJAutoProxyCreator</code>创建代理，具体见下文</li>
</ul>
<p><img src="http://img.my.csdn.net/uploads/201303/04/1362374823_4701.png" alt="img"></p>
<a id="more"></a>
<h3 id="aop-config-解析"><a href="#aop-config-解析" class="headerlink" title="aop:config`解析"></a>aop:config`解析</h3><ul>
<li><code>ConfigBeanDefinitionParser.java</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</div><div class="line">		CompositeComponentDefinition compositeDef =</div><div class="line">				<span class="keyword">new</span> CompositeComponentDefinition(element.getTagName(), parserContext.extractSource(element));</div><div class="line">		parserContext.pushContainingComponent(compositeDef);</div><div class="line"></div><div class="line">        <span class="comment">// 注册AspectJAwareAdvisorAutoProxyCreator</span></div><div class="line">		configureAutoProxyCreator(parserContext, element);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">configureAutoProxyCreator</span><span class="params">(ParserContext parserContext, Element element)</span> </span>&#123;</div><div class="line">		AopNamespaceUtils.registerAspectJAutoProxyCreatorIfNecessary(parserContext, element);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>AopNamespaceUtils.java</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerAspectJAutoProxyCreatorIfNecessary</span><span class="params">(</span></span></div><div class="line">			ParserContext parserContext, Element sourceElement) &#123;</div><div class="line"><span class="comment">// 注册或更新 AutoProxyCreator 定义 beanName 为 org.Springframework.aop.config.internalAutoProxyCreator的BeanDefinition</span></div><div class="line"><span class="comment">// 如果internalAutoProxyCreator的BeanDefinition已经存在，则根据优先级更新BeanDefinition</span></div><div class="line"><span class="comment">// 在这里注册的是AspectJAwareAdvisorAutoProxyCreator</span></div><div class="line">		BeanDefinition beanDefinition = AopConfigUtils.registerAspectJAutoProxyCreatorIfNecessary(</div><div class="line">				parserContext.getRegistry(), parserContext.extractSource(sourceElement));</div><div class="line">  </div><div class="line">        <span class="comment">// 对于proxy-target-class以及expose-proxy属性的处理</span></div><div class="line">		useClassProxyingIfNecessary(parserContext.getRegistry(), sourceElement);</div><div class="line">        <span class="comment">// 注册组件，其中beanDefinition的className为AspectJAwareAdvisorAutoProxyCreator</span></div><div class="line">		registerComponentIfNecessary(beanDefinition, parserContext);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>AspectJAwareAdvisorAutoProxyCreator.java</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectJAwareAdvisorAutoProxyCreator</span> <span class="keyword">extends</span> <span class="title">AbstractAdvisorAutoProxyCreator</span></span></div><div class="line">  </div><div class="line"><span class="title">public</span> <span class="title">abstract</span> <span class="title">class</span> <span class="title">AbstractAdvisorAutoProxyCreator</span> <span class="keyword">extends</span> <span class="title">AbstractAutoProxyCreator</span></div><div class="line">  </div><div class="line"><span class="title">public</span> <span class="title">abstract</span> <span class="title">class</span> <span class="title">AbstractAutoProxyCreator</span> <span class="keyword">extends</span> <span class="title">ProxyConfig</span></div><div class="line">		<span class="keyword">implements</span> <span class="title">SmartInstantiationAwareBeanPostProcessor</span>, <span class="title">BeanClassLoaderAware</span>, <span class="title">BeanFactoryAware</span>,</div><div class="line">		<span class="title">Ordered</span>, <span class="title">AopInfrastructureBean</span></div><div class="line">  </div><div class="line"><span class="title">public</span> <span class="title">interface</span> <span class="title">SmartInstantiationAwareBeanPostProcessor</span> <span class="keyword">extends</span> <span class="title">InstantiationAwareBeanPostProcessor</span></div></pre></td></tr></table></figure>
<p>可见<code>AspectJAwareAdvisorAutoProxyCreator</code>实现了<code>BeanPostProcessor</code>接口，<code>BeanPostProcessor</code>主要作用于<code>Bean</code>实例化后，初始化前后，所有的<code>Bean</code>都被作用到。<code>InstantiationAwareBeanPostProcessor</code>虽然是<code>BeanPostProcessor</code>的子接口，但它的调用时间点发生在Bean实例化前，在真正调用<code>doCreateBean()</code>创建bean实例之前执行<code>postProcessBeforeInstantiation()</code></p>
<ul>
<li><code>postProcessBeforeInstantiation()</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// AbstractAutoProxyCreator.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">         <span class="comment">//1、得到一个缓存的唯一key（根据beanClass和beanName生成唯一key）</span></div><div class="line">		Object cacheKey = getCacheKey(beanClass, beanName);</div><div class="line">        <span class="comment">//2、如果当前targetSourcedBeans（通过自定义TargetSourceCreator创建的TargetSource）不包含cacheKey </span></div><div class="line">		<span class="keyword">if</span> (beanName == <span class="keyword">null</span> || !<span class="keyword">this</span>.targetSourcedBeans.containsKey(beanName)) &#123;</div><div class="line">            <span class="comment">//2.1、advisedBeans（已经被增强的Bean，即AOP代理对象）中包含当前cacheKey，返回null，即走Spring默认流程  </span></div><div class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.advisedBeans.containsKey(cacheKey)) &#123;</div><div class="line">				<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">			&#125;</div><div class="line">            <span class="comment">//2.2、如果是基础设施类（如Advisor、Advice、AopInfrastructureBean的实现）不进行处理  </span></div><div class="line">            <span class="comment">//2.2、shouldSkip 默认false，可以生成子类覆盖，如AspectJAwareAdvisorAutoProxyCreator覆盖（if (((AbstractAspectJAdvice) advisor.getAdvice()).getAspectName().equals(beanName)) return true;  即如果是自己就跳过）  </span></div><div class="line">			<span class="keyword">if</span> (isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName)) &#123;</div><div class="line">				<span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</div><div class="line">				<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">        <span class="comment">//3、开始创建AOP代理对象  </span></div><div class="line">		<span class="keyword">if</span> (beanName != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">//3.1、配置自定义的TargetSourceCreator进行TargetSource创建 </span></div><div class="line">			TargetSource targetSource = getCustomTargetSource(beanClass, beanName);</div><div class="line">            <span class="comment">//3.2、如果targetSource不为null 添加到targetSourcedBeans缓存，并创建AOP代理对象</span></div><div class="line">			<span class="keyword">if</span> (targetSource != <span class="keyword">null</span>) &#123;</div><div class="line">				<span class="keyword">this</span>.targetSourcedBeans.put(beanName, Boolean.TRUE);</div><div class="line">               <span class="comment">// specificInterceptors即增强（包括前置增强、后置增强等等）  </span></div><div class="line">				Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource);</div><div class="line">              <span class="comment">//3.3、创建代理对象  </span></div><div class="line">				Object proxy = createProxy(beanClass, beanName, specificInterceptors, targetSource);</div><div class="line">              <span class="comment">//3.4、将代理类型放入proxyTypes从而允许后续的predictBeanType()调用获取  </span></div><div class="line">				<span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</div><div class="line">				<span class="keyword">return</span> proxy;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>当我们配置<code>TargetSourceCreator</code>进行自定义<code>TargetSource</code>创建时，会创建代理对象并中断默认<code>Spring</code>创建流程(目标对象没有创建，可见<code>bean</code>创建过程: <code>BeanDefinitionValueResolver.resolveInnerBean()</code>)。</p>
<ul>
<li><code>getEarlyBeanReference()</code></li>
</ul>
<p><code>Spring Bean</code>实例化过程，解决单例<code>bean</code>之间的循环依赖问题，提前将代理对象暴露出去</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// AbstractAutoProxyCreator.java</span></div><div class="line"><span class="comment">//获取early Bean引用（只有单例Bean在创建）  </span></div><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getEarlyBeanReference</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;  </div><div class="line">    Object cacheKey = getCacheKey(bean.getClass(), beanName);  </div><div class="line">    <span class="comment">//1、将cacheKey添加到earlyProxyReferences缓存，从而避免多次重复创建  </span></div><div class="line">    <span class="keyword">this</span>.earlyProxyReferences.add(cacheKey);  </div><div class="line">    <span class="comment">//2、包装目标对象到AOP代理对象（如果需要）  </span></div><div class="line">    <span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>详细可见<code>bean</code>创建过程：<code>AbstractAutowireCapableBeanFactory.doCreateBean() =&gt; getEarlyBeanReference()</code></p>
<ul>
<li><strong><code>postProcessAfterInitialization()</code>：创建AOP代理</strong></li>
</ul>
<p>默认情况下，代理是通过<code>AbstractAutoProxyCreator</code>中的<code>postProcessAfterInitialization()</code>创建的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// AbstractAutoProxyCreator.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">		<span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</div><div class="line">			Object cacheKey = getCacheKey(bean.getClass(), beanName);</div><div class="line">          <span class="comment">//1、如果之前调用过getEarlyBeanReference获取包装目标对象到AOP代理对象（如果需要），则不再执行  </span></div><div class="line">			<span class="keyword">if</span> (!<span class="keyword">this</span>.earlyProxyReferences.containsKey(cacheKey)) &#123;</div><div class="line">              <span class="comment">//2、包装目标对象到AOP代理对象（如果需要）  </span></div><div class="line">				<span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> bean;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">wrapIfNecessary</span><span class="params">(Object bean, String beanName, Object cacheKey)</span> </span>&#123;</div><div class="line">        <span class="comment">//通过TargetSourceCreator进行自定义TargetSource不需要包装  </span></div><div class="line">		<span class="keyword">if</span> (beanName != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.targetSourcedBeans.containsKey(beanName)) &#123;</div><div class="line">			<span class="keyword">return</span> bean;</div><div class="line">		&#125;</div><div class="line">        <span class="comment">//不应该被增强对象不需要包装 </span></div><div class="line">		<span class="keyword">if</span> (Boolean.FALSE.equals(<span class="keyword">this</span>.advisedBeans.get(cacheKey))) &#123;</div><div class="line">			<span class="keyword">return</span> bean;</div><div class="line">		&#125;</div><div class="line">        <span class="comment">//基础设施或应该skip的不需要保证</span></div><div class="line">		<span class="keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName))     &#123;</div><div class="line">			<span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</div><div class="line">			<span class="keyword">return</span> bean;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">// 如果有增强就执行包装目标对象到代理对象</span></div><div class="line">		Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="keyword">null</span>);</div><div class="line">		<span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</div><div class="line">            <span class="comment">// 将cacheKey添加到已经被增强列表，防止多次增强</span></div><div class="line">			<span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);</div><div class="line">            <span class="comment">// 创建代理对象  </span></div><div class="line">			Object proxy = createProxy(bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> SingletonTargetSource(bean));</div><div class="line">            <span class="comment">// 缓存代理类型</span></div><div class="line">			<span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</div><div class="line">			<span class="keyword">return</span> proxy;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</div><div class="line">		<span class="keyword">return</span> bean;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>可以看出 <code>getEarlyBeanReference</code>和<code>postProcessAfterInitialization</code>是二者选一的，而且单例<code>Bean</code>目标对象只能被增强一次</p>
<p>当<code>SimpleServiceImpl bean</code>初始化到这步后，会从容器中找出所有匹配当前<code>bean</code>的通知（如果有对业务方法做增强处理），如果找到对应的通知则创建代理。</p>
<ul>
<li><code>createAopProxy()</code></li>
</ul>
<p>具体怎么创建代理以及用哪种方式创建代理，由 <code>createAopProxy</code> 决定</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// DefaultAopProxyFactory.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</div><div class="line">        <span class="comment">// 如果没有实现接口或者设置proxy-target-class=true, 采用CGLIB代理</span></div><div class="line">		<span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</div><div class="line">			Class targetClass = config.getTargetClass();</div><div class="line">			<span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</div><div class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"TargetSource cannot determine target class: "</span> +</div><div class="line">						<span class="string">"Either an interface or a target is required for proxy creation."</span>);</div><div class="line">			&#125;</div><div class="line">            <span class="comment">// 如果目标类是接口, 使用JDK动态代理来生成代理类</span></div><div class="line">			<span class="keyword">if</span> (targetClass.isInterface()) &#123;</div><div class="line">				<span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">return</span> CglibProxyFactory.createCglibProxy(config);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> &#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</div><div class="line">		&#125;</div></pre></td></tr></table></figure>
<h3 id="aspectj-autoproxy标签解析"><a href="#aspectj-autoproxy标签解析" class="headerlink" title="aspectj-autoproxy标签解析"></a><code>aspectj-autoproxy</code>标签解析</h3><ul>
<li><code>AspectJAutoProxyBeanDefinitionParser.java</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</div><div class="line">        <span class="comment">// 注册AnnotationAwareAspectJAutoProxyCreator</span></div><div class="line">		AopNamespaceUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(parserContext, element);</div><div class="line">		extendBeanDefinition(element, parserContext);</div><div class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>AopNamespaceUtils.java</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerAspectJAnnotationAutoProxyCreatorIfNecessary</span><span class="params">(</span></span></div><div class="line">			ParserContext parserContext, Element sourceElement) &#123;</div><div class="line">    <span class="comment">// 注册或更新 AutoProxyCreator 定义 beanName 为 org.Springframework.aop.config.internalAutoProxyCreator的BeanDefinition</span></div><div class="line">    <span class="comment">// 如果internalAutoProxyCreator的BeanDefinition已经存在，而根据优先级更新BeanDefinition</span></div><div class="line">    <span class="comment">// 在这里注册的是AnnotationAwareAspectJAutoProxyCreator</span></div><div class="line">		BeanDefinition beanDefinition = AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(</div><div class="line">				parserContext.getRegistry(), parserContext.extractSource(sourceElement));</div><div class="line">		useClassProxyingIfNecessary(parserContext.getRegistry(), sourceElement);</div><div class="line">        <span class="comment">// 注册组件</span></div><div class="line">		registerComponentIfNecessary(beanDefinition, parserContext);</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>AnnotationAwareAspectJAutoProxyCreator.java</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationAwareAspectJAutoProxyCreator</span> <span class="keyword">extends</span> <span class="title">AspectJAwareAdvisorAutoProxyCreator</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以发现<code>AnnotationAwareAspectJAutoProxyCreator</code>继承了<code>AspectJAwareAdvisorAutoProxyCreator</code>， 执行流程和<code>aop:config</code>基本一致，但是需要注意注解的特殊标签<code>@Aspect</code>，下面分析<code>@Aspect</code>注解是如何起作用的？</p>
<p>使用注解配置<code>AOP</code>，需要在切面类中配置<code>@Aspect</code>，再来看看<code>AOP</code>代理生成过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// AbstractAutoProxyCreator.java</span></div><div class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">wrapIfNecessary</span><span class="params">(Object bean, String beanName, Object cacheKey)</span> </span>&#123;</div><div class="line">    <span class="comment">// 获取该类所有增强</span></div><div class="line">    Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="keyword">null</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不管是<code>aop:config</code>还是<code>aspectj-autoproxy</code>都是由<code>AbstractAutoProxyCreator</code>这个类在后置处理器中生成<code>AOP</code>代理，具体看看<code>getadvicesAndAdvisorsForBean()</code>方法是如何获取增强</p>
<ul>
<li><code>getAdvicesAndAdvisorsForBean()</code></li>
</ul>
<p><code>getAdvicesAndAdvisorsForBean()</code>方法具体由子类<code>AbstractAdvisorAutoProxyCreator</code>实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// AbstractAdvisorAutoProxyCreator.class</span></div><div class="line"><span class="keyword">protected</span> Object[] getAdvicesAndAdvisorsForBean(Class&lt;?&gt; beanClass, String beanName, TargetSource targetSource) &#123;</div><div class="line">		List&lt;Advisor&gt; advisors = findEligibleAdvisors(beanClass, beanName);</div><div class="line">		<span class="keyword">if</span> (advisors.isEmpty()) &#123;</div><div class="line">			<span class="keyword">return</span> DO_NOT_PROXY;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> advisors.toArray();</div><div class="line">	&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findEligibleAdvisors</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</div><div class="line">        <span class="comment">// 找到容器中所有增强</span></div><div class="line">		List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();</div><div class="line">        <span class="comment">// 从所有增强中找出指定类(正常业务类)的增强</span></div><div class="line">		List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);</div><div class="line">		extendAdvisors(eligibleAdvisors);</div><div class="line">		<span class="keyword">if</span> (!eligibleAdvisors.isEmpty()) &#123;</div><div class="line">			eligibleAdvisors = sortAdvisors(eligibleAdvisors);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> eligibleAdvisors;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>这里的<code>findCandidateAdvisors</code>方法，如果配置<code>aop:config</code>则由<code>AbstractAdvisorAutoProxyCreator</code>本类中实现，如果配置<code>aspectj-autoproxy</code>则由<code>AnnotationAwareAspectJAutoProxyCreator</code>子类中实现。现在来看看子类实现：</p>
<ul>
<li><code>findCandidateAdvisors()</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// AnnotationAwareAspectJAutoProxyCreator.java</span></div><div class="line"><span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findCandidateAdvisors</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// 当使用注解方式配置AOP的时候并不是丢弃了对xml的配置，调用父类加载配置文件中的AOP声明</span></div><div class="line">		List&lt;Advisor&gt; advisors = <span class="keyword">super</span>.findCandidateAdvisors();</div><div class="line">		<span class="comment">// 如果使用了aspectJ注解配置aop</span></div><div class="line">		advisors.addAll(<span class="keyword">this</span>.aspectJAdvisorsBuilder.buildAspectJAdvisors());</div><div class="line">		<span class="keyword">return</span> advisors;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>从方法中<code>aop</code>可以配置在<code>xml</code>中，同时也可以使用注解，2这都会同时生效。</p>
<h3 id="目标对象"><a href="#目标对象" class="headerlink" title="目标对象"></a>目标对象</h3><ul>
<li>配置增强</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Aspect</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoBeforeAspect</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="meta">@Before</span>(<span class="string">"execution(* com.zsr.test.aop.SimpleService.sayHello(..))"</span>)</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</div><div class="line"></div><div class="line">    System.out.println(<span class="string">"***AspectJ*** DoBefore() is running!! intercepted : "</span> + joinPoint.getSignature().getName());</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>业务逻辑</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span>(<span class="string">"simpleService"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleServiceImpl</span> <span class="keyword">implements</span> <span class="title">SimpleService</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String message)</span> </span>&#123;</div><div class="line">    System.out.println(<span class="string">"SimpleService : Method sayHello() : Hello "</span> + message);</div><div class="line">    <span class="keyword">return</span> message;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>测试发现当配置了增强后，再去容器中获取目标<code>bean</code>，结果该<code>bean</code>其实是个代理，代理最终还是要通过执行<code>invoke()</code>方法调用目标对象的<code>sayHello()</code>方法，那么目标对象到底放在什么地方？</strong></p>
<h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><p>下面是代理模式的结构：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1735418-ad5e3aed11ebc4b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="img"></p>
<ul>
<li>Subject：抽象主题，它是代理对象的真实对象要实现的接口，当然这可以是多个接口组成</li>
<li>Proxy：代理类除了实现抽象主题定义的接口外，还必须持有所代理对象的引用</li>
<li>RealSubject：被代理的类，是目标对象</li>
</ul>
<h4 id="JdkDynamicAopProxy"><a href="#JdkDynamicAopProxy" class="headerlink" title="JdkDynamicAopProxy"></a><code>JdkDynamicAopProxy</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkDynamicAopProxy</span> <span class="keyword">implements</span> <span class="title">AopProxy</span>, <span class="title">InvocationHandler</span>, <span class="title">Serializable</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">/** Config used to configure this proxy */</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> AdvisedSupport advised;</div><div class="line">  </div><div class="line">  <span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">      <span class="comment">// 这里会去执行增强和目标对象方法</span></div><div class="line">      <span class="comment">// Get the interception chain for this method.</span></div><div class="line">			List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</div><div class="line">      </div><div class="line">      <span class="keyword">if</span> (chain.isEmpty()) &#123;</div><div class="line">				Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</div><div class="line">				retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);</div><div class="line">			&#125;</div><div class="line">	  <span class="keyword">else</span> &#123;</div><div class="line">				<span class="comment">// We need to create a method invocation...</span></div><div class="line">				invocation = <span class="keyword">new</span> ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);</div><div class="line">				<span class="comment">// Proceed to the joinpoint through the interceptor chain.</span></div><div class="line">				retVal = invocation.proceed();</div><div class="line">			&#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>需要注意<code>JdkDynamicAopProxy</code>持有的<code>AdvisedSupport</code>实例，<code>AdvisedSupport</code>类中包含了一个<code>TargetSource</code>实例，目标对象就在<code>TargetSource</code>中，也就是说代理间接持有了目标对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdvisedSupport</span> <span class="keyword">extends</span> <span class="title">ProxyConfig</span> <span class="keyword">implements</span> <span class="title">Advised</span> </span>&#123;</div><div class="line">  TargetSource targetSource = EMPTY_TARGET_SOURCE;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>回过头来，再看看动态代理的创建过程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// AbstractAutoProxyCreator.java</span></div><div class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">wrapIfNecessary</span><span class="params">(Object bean, String beanName, Object cacheKey)</span> </span>&#123;</div><div class="line">       <span class="comment">// 创建代理对象  </span></div><div class="line">	   Object proxy = createProxy(bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> SingletonTargetSource(bean));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看到这里的<code>SingletonTargetSource</code>就是<code>TargetSource</code>的实现类，其实在创建代理的时候就已经把目标对象放到<code>TargetSource</code>中，换句话说，<strong>proxy（代理对象）代理的不是target，而是TargetSource</strong></p>
<p><strong>注意：</strong></p>
<ul>
<li><strong>目标bean的生命周期不受<code>Spring</code>容器管理，我们以往的<code>XML</code>中的<code>AOP</code>配置，只是对受容器管理的<code>bean</code>而言的</strong></li>
<li><strong>代理类会代理接口中所有方法，非增强方法同样需要通过代理类去访问(只是没有执行增强切面)</strong></li>
<li><strong><code>Spring</code>的<code>AOP</code>框架默认为目标bean创建静态目标源<code>SingletonTargetSource</code>，如果bean被配置为<code>prototype</code>，则<code>spring</code>会在每次<code>getBean</code>时创建新的<code>SingletonTargetSource</code>实例</strong></li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://www.jianshu.com/p/867991f3daa0" target="_blank" rel="external">Spring AOP源码解读1 - 程序入口</a></p>
<p><a href="https://my.oschina.net/lixin91/blog/688188?p=1" target="_blank" rel="external">spring-aop组件详解——TargetSource目标源</a></p>
<p><a href="http://www.jianshu.com/p/ef8c828798ca" target="_blank" rel="external">Spring源码-AOP(七)-增强器的获取</a></p>
<p><a href="http://jinnianshilongnian.iteye.com/blog/1492424" target="_blank" rel="external">Spring开闭原则的表现-BeanPostProcessor扩展点-2</a></p>
<p><a href="https://fangjian0423.github.io/2017/06/20/spring-bean-post-processor/" target="_blank" rel="external">Spring内部的BeanPostProcessor接口总结</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Spring AOP配置]]></title>
      <url>http://zsr.github.io/2017/11/29/Spring-AOP%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<p>前文介绍了<code>Spring AOP</code>的一些概念，本文主要介绍<code>Spring AOP</code>的使用方式：基于注解和xml配置</p>
<h3 id="代理原则"><a href="#代理原则" class="headerlink" title="代理原则"></a>代理原则</h3><p><code>Spring AOP</code> 框架对 <code>AOP</code> 代理类的处理原则是：如果目标对象的实现类实现了接口，<code>Spring AOP</code> 将会采用 JDK 动态代理来生成 <code>AOP</code> 代理类；如果目标对象的实现类没有实现接口，<code>Spring AOP</code> 将会采用 <code>CGLIB</code> 来生成 <code>AOP</code> 代理类(可以强制使用<code>CGLIB</code>生成代理，设置<code>proxy-target-class＝true</code>)</p>
<h3 id="注解配置"><a href="#注解配置" class="headerlink" title="注解配置"></a>注解配置</h3><p>注解配置AOP（使用 <code>AspectJ</code> 类库实现的），大致分为三步： </p>
<ol>
<li>使用注解<code>@Aspect</code>来定义一个切面，在切面中定义切入点<code>@Pointcut</code>，通知类型<code>@Before</code>，<code>@AfterReturning</code>，<code>@After</code>，<code>@AfterThrowing</code>，<code>@Around</code></li>
<li>开发需要被拦截的类(普通的业务逻辑)</li>
<li>将切面配置到xml中，也可以使用自动扫描Bean的方式，这样切面bean交由<code>Spring IOC</code>容器管理。 </li>
</ol>
<p>注意：<code>Spring</code>只是使用了和 <code>AspectJ</code> 一样的注解，底层依然使用的是 <code>Spring AOP</code>，依然是在运行时动态生成代理</p>
<a id="more"></a>
<ul>
<li>依赖jar包</li>
</ul>
<p>要想使用<code>@Aspect</code>注解，需要引用 <code>aspectJ</code> 的jar包： <code>aspectjweaver.jar</code>和 <code>aspectjrt.jar</code></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjrt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li>定义接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SimpleService</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String message)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>目标类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleServiceImpl</span> <span class="keyword">implements</span> <span class="title">SimpleService</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String message)</span> </span>&#123;</div><div class="line">    System.out.println(<span class="string">"SimpleService : Method sayHello() : Hello! "</span> + message);</div><div class="line">    <span class="keyword">return</span> message;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>切面类`</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="meta">@Aspect</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoBeforeAspect</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="meta">@Before</span>(<span class="string">"execution(* com.zsr.test.aop.SimpleService.sayHello(..))"</span>)</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</div><div class="line">    System.out.println(<span class="string">"***AspectJ*** DoBefore() is running!! intercepted : "</span> + joinPoint.getSignature().getName());</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li><code>@Aspect</code>：意思是这个类为切面类  </li>
<li><code>@Componet</code>：因为作为切面类需要 <code>Spring</code> 管理起来，所以在初始化时就需要将这个类初始化加入 <code>Spring IOC</code> 的管理；  </li>
<li><code>@Befoe</code>：切入点的逻辑(<code>Advice</code>)</li>
<li><code>execution</code>…：切入点语法</li>
</ol>
<ul>
<li>启动注解</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></div><div class="line">  <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></div><div class="line">  <span class="attr">xmlns:util</span>=<span class="string">"http://www.springframework.org/schema/util"</span></div><div class="line">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></div><div class="line">    http://www.springframework.org/schema/beans </div><div class="line">    http://www.springframework.org/schema/beans/spring-beans-4.3.xsd</div><div class="line">    http://www.springframework.org/schema/context </div><div class="line">    http://www.springframework.org/schema/context/spring-context-4.3.xsd</div><div class="line">    http://www.springframework.org/schema/util</div><div class="line">    http://www.springframework.org/schema/util/spring-util-4.3.xsd</div><div class="line">    http://www.springframework.org/schema/aop </div><div class="line">    http://www.springframework.org/schema/aop/spring-aop-4.3.xsd"</div><div class="line">  <span class="attr">default-lazy-init</span>=<span class="string">"false"</span>&gt;</div><div class="line">  <span class="comment">&lt;!-- 注意需要添加aop schema --&gt;</span></div><div class="line">  </div><div class="line">  <span class="comment">&lt;!-- 自动扫描 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.zsr.test.aop"</span> /&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 启动 @AspectJ 支持 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li>执行结果</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">---------------</div><div class="line">***AspectJ*** DoBefore() is running!! intercepted : sayHello</div><div class="line">SimpleService : Method sayHello() : Hello zsr</div><div class="line">---------------</div></pre></td></tr></table></figure>
<h3 id="xml配置"><a href="#xml配置" class="headerlink" title="xml配置"></a>xml配置</h3><p>使用<code>xml</code>配置<code>aop</code>需要用到标签：<code>&lt;aop:config&gt;</code></p>
<ul>
<li>配置</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 自动扫描 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.zsr.test.aop"</span> /&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">"aspects"</span> <span class="attr">ref</span>=<span class="string">"doBeforeAspect"</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"pointCutBefore"</span></span></div><div class="line">        <span class="attr">expression</span>=<span class="string">"execution(* com.zsr.test.aop.SimpleService.sayHello(..))"</span> /&gt;</div><div class="line">      <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">"doBefore"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pointCutBefore"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li>执行结果</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">---------------</div><div class="line">***AspectJ*** DoBefore() is running!! intercepted : sayHello</div><div class="line">SimpleService : Method sayHello() : Hello zsr</div><div class="line">---------------</div></pre></td></tr></table></figure>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-springaopcglib/index.html" target="_blank" rel="external">Spring AOP 实现原理与 CGLIB 应用</a></p>
<p><a href="http://www.cnblogs.com/oumyye/p/4480196.html" target="_blank" rel="external">spring aop两种配置方式</a></p>
<p><a href="https://examples.javacodegeeks.com/enterprise-java/spring/aop/spring-aop-aspectj-example/" target="_blank" rel="external">Spring AOP AspectJ Example</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Spring AOP and AspectJ]]></title>
      <url>http://zsr.github.io/2017/11/27/Spring-AOP-and-AspectJ/</url>
      <content type="html"><![CDATA[<p><code>Spring AOP</code> 和 <code>AspectJ</code>是<code>Java</code>中最流行的 <code>AOP</code> 框架</p>
<h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p><code>AOP</code> 实现的关键就在于 <code>AOP</code> 框架自动创建的 <code>AOP</code> 代理，<code>AOP</code> 代理则可分为<strong>静态代理</strong>和<strong>动态代理</strong>两大类，其中静态代理是指在编译阶段修改目标类字节码，属于静态编入，不需要代理类，因此也称为编译时增强；而动态代理则在运行时借助于 <code>JDK</code> 动态代理、<code>CGLIB</code> 等在内存中“临时”生成 <code>AOP</code> 动态代理类，因此也被称为运行时增强。其中<code>aspectj</code>为静态代理，<code>Spring AOP</code>是动态代理</p>
<h4 id="AOP核心概念"><a href="#AOP核心概念" class="headerlink" title="AOP核心概念"></a>AOP核心概念</h4><ul>
<li><code>Advice</code>：通知，是指拦截到<code>jointpoint</code>之后所要做的事情即特定的<code>Jointpoint</code>处运行的代码。</li>
<li><code>JoinPoint</code>：连接点，它定义在哪里(哪些点)加入你的逻辑功能，基本每个方法的前后(两者都有也行)，或抛出异常时都可以是连接点，<code>spring</code>只支持方法连接点</li>
<li><code>PointCut</code>：切入点的集合，即一组<code>Joinpoint</code>，就是说一个<code>Advice</code>可能在多个地方织入。比如一个类里，有15个方法，那就有几十个连接点了，让切点来筛选连接点，选中那几个你想要的方法。</li>
<li><code>Aspect</code>：切面，实际是通知和切入点的组合，通知说明了干什么和什么时候干(什么时候通过方法名中的<code>before</code>，<code>after</code>，<code>around</code>等)，而切入点说明了在哪干(指定到底是哪个方法)。</li>
<li><code>Weaving</code>：织入，把切面应用到目标对象来创建新的代理对象的过程。</li>
</ul>
<h3 id="Aspectj"><a href="#Aspectj" class="headerlink" title="Aspectj"></a>Aspectj</h3><p><code>ApectJ</code>主要采用的是编译期织入，在这个期间使用<code>AspectJ</code>的<code>acj</code>编译器把<code>aspect</code>类编译成<code>class</code>字节码后，在java目标类编译时织入，即先编译<code>aspect</code>类再编译目标类。</p>
<p><img src="http://floodcool.com/wp-content/uploads/2017/08/apectj%E8%BF%87%E7%A8%8B.png" alt="img"></p>
<a id="more"></a>
<h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>安装 <code>AspectJ</code> 见：<a href="https://www.ibm.com/developerworks/cn/java/j-lo-springaopcglib/index.html" target="_blank" rel="external">https://www.ibm.com/developerworks/cn/java/j-lo-springaopcglib/index.html</a></p>
<ul>
<li>业务逻辑</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.zsr.test.aspectj;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</div><div class="line">  <span class="comment">// 模拟业务逻辑</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</div><div class="line">    System.out.println(<span class="string">"Hello AspectJ!"</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    HelloWorld h = <span class="keyword">new</span> HelloWorld();</div><div class="line">    h.sayHello();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>切面<code>Aspect</code></li>
</ul>
<p>使用<code>AspectJ</code>编写一个<code>Aspect</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.zsr.test.aspectj;</div><div class="line"></div><div class="line"><span class="keyword">public</span> aspect TestAspect &#123;</div><div class="line"><span class="comment">//指定执行 Hello.sayHello() 方法时执行下面代码块</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">around</span><span class="params">()</span>:<span class="title">call</span><span class="params">(<span class="keyword">void</span> HelloWorld.sayHello()</span>)</span>&#123;</div><div class="line">  System.out.println(<span class="string">"开始事务 ..."</span>);</div><div class="line">  proceed();</div><div class="line">  System.out.println(<span class="string">"事务结束 ..."</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>ajc</code>编译</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ajc -d . HelloWorld.java TestAspect.java</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// HelloWorld.class 反编译</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span></div><div class="line">&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span></div><div class="line">  &#123;</div><div class="line">    System.out.println(<span class="string">"Hello AspectJ!"</span>);</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> sayHello_aroundBody1$advice(HelloWorld target, TestAspect ajc$aspectInstance, AroundClosure ajc$aroundClosure)</div><div class="line">  &#123;</div><div class="line">    System.out.println(<span class="string">"开始事务 ..."</span>);</div><div class="line">    AroundClosure localAroundClosure = ajc$aroundClosure;</div><div class="line">    sayHello_aroundBody0(target);</div><div class="line">    System.out.println(<span class="string">"事务结束 ..."</span>);</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></div><div class="line">  &#123;</div><div class="line">    HelloWorld h = <span class="keyword">new</span> HelloWorld();</div><div class="line">    HelloWorld localHelloWorld1 = h;</div><div class="line">    sayHello_aroundBody1$advice(localHelloWorld1, TestAspect.aspectOf(), <span class="keyword">null</span>);</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">sayHello_aroundBody0</span><span class="params">(HelloWorld paramHelloWorld)</span></span></div><div class="line">  &#123;</div><div class="line">    paramHelloWorld.sayHello();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以发现切面代码织入了<code>HelloWorld.class</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// TestAspect.class 反编译</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAspect</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">void</span> ajc$around$com_zsr_test_aspectj_TestAspect$<span class="number">1</span>$<span class="number">8852f</span>95(AroundClosure ajc$aroundClosure)</div><div class="line">  &#123;</div><div class="line">    System.out.println(<span class="string">"开始事务 ..."</span>);</div><div class="line">    ajc$around$com_zsr_test_aspectj_TestAspect$<span class="number">1</span>$<span class="number">8852f</span>95proceed(ajc$aroundClosure);</div><div class="line">    System.out.println(<span class="string">"事务结束 ..."</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从<code>Aspect</code>编译后的<code>class</code>文件可以更明显的看出执行的逻辑。<code>proceed</code>方法就是回调执行被代理类中的方法。</p>
<ul>
<li>执行结果</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">➜  aspectj java com.zsr.test.aspectj.HelloWorld</div><div class="line">开始事务 ...</div><div class="line">Hello AspectJ!</div><div class="line">事务结束 ...</div><div class="line">➜  aspectj pwd</div><div class="line">/Users/nali/Documents/workspace/test/src/main/java/com/zsr/test/aspectj</div><div class="line">➜  aspectj</div></pre></td></tr></table></figure>
<h3 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h3><p><code>Spring AOP</code>使用的是动态代理增强，动态代理不会改变类的字节码，而是动态的生成代理对象。<code>Spring AOP</code>的动态代理机制有两种方式：<strong>JDK动态代理</strong>和<strong>CGLIB动态代理</strong>。</p>
<ul>
<li><p><strong>JDK动态代理</strong></p>
<p>JDK动态代理需要被代理的类必须实现一个接口，底层通过反射实现</p>
</li>
<li><p><strong>CGLIB动态代理</strong></p>
<p>CGLIB动态代理可以不用需要被代理类必须实现接口，底层通过继承实现，因此如果某个类被标记为<code>final</code>，那么它是无法使用CGLIB做动态代理的</p>
</li>
</ul>
<p><img src="http://www.baeldung.com/wp-content/uploads/2017/10/springaop-process.png" alt="img"></p>
<h4 id="创建AOP代理"><a href="#创建AOP代理" class="headerlink" title="创建AOP代理"></a>创建AOP代理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// DefaultAopProxyFactory.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</div><div class="line">        <span class="comment">// 如果目标类没有实现接口或者proxy-target-class="true"则采用CGLIB代理</span></div><div class="line">		<span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</div><div class="line">			Class&lt;?&gt; targetClass = config.getTargetClass();</div><div class="line">			<span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</div><div class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException()</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</div><div class="line">				<span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> &#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>如果配置了<code>&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt;</code>或者目标类没有实现接口，则使用<code>CGLIB</code>代理；如果目标类实现了接口，默认使用<code>JDK</code>代理</p>
<h4 id="Spring-AOP-vs-ApectJ"><a href="#Spring-AOP-vs-ApectJ" class="headerlink" title="Spring AOP  vs ApectJ"></a>Spring AOP  vs ApectJ</h4><p><code>Spring AOP</code> 与 <code>ApectJ</code> 的目的一致，都是为了统一处理横切业务，但与<code>AspectJ</code>不同的是:</p>
<ol>
<li><code>Spring AOP</code> 并不尝试提供完整的AOP功能，<code>Spring AOP</code> 更注重的是与<code>Spring IOC</code>容器的结合，并结合该优势来解决横切业务的问题，因此在<code>AOP</code>的功能完善方面，相对来说<code>AspectJ</code>具有更大的优势。</li>
<li><code>AspectJ</code>在<code>AOP</code>的实现方式上依赖于特殊编译器(ajc编译器)，而<code>Spring</code>回避了这点，转向采用动态代理技术的实现原理来构建<code>Spring AOP</code>的内部机制（动态织入），这是与<code>AspectJ</code>（静态织入）最根本的区别</li>
</ol>
<p><strong>注意：</strong></p>
<p><code>Spring 2.0</code>后便使用了与<code>AspectJ</code>一样的注解，新增了对<code>AspectJ</code>切点表达式支持。需要注意<code>Spring</code> 只是使用了与 <code>AspectJ</code> 一样的注解，但仍然没有使用 <code>AspectJ</code> 的编译器，底层仍然是动态代理技术的实现</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p> <a href="http://listenzhangbin.com/post/2016/09/spring-aop-cglib/" target="_blank" rel="external">Spring AOP的实现原理</a></p>
<p><a href="http://www.baeldung.com/spring-aop-vs-aspectj" target="_blank" rel="external">Comparing Spring AOP and AspectJ</a></p>
<p><a href="http://cxis.me/2017/04/12/AOP%E6%A6%82%E5%BF%B5%EF%BC%8C%E5%8E%9F%E7%90%86%EF%BC%8C%E5%BA%94%E7%94%A8%E4%BB%8B%E7%BB%8D/" target="_blank" rel="external">AOP概念，原理，应用介绍</a></p>
<p><a href="http://floodcool.com/blog/2220155.html" target="_blank" rel="external">Spring AOP (三) AspectJ</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Spring Task定时任务]]></title>
      <url>http://zsr.github.io/2017/11/17/Spring-Task%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
      <content type="html"><![CDATA[<p><code>Spring3.0</code>以后引入的定时任务工具：<code>spring task</code>，可以将它比作一个轻量级的<code>Quartz</code>，而且使用起来很简单，除<code>spring</code>相关的包外不需要额外的包，而且支持注解和配置文件两种。<code>spring</code>通过接口<code>TaskExecutor</code>和<code>TaskScheduler</code>这两个接口的方式为异步定时任务提供了一种抽象。</p>
<h3 id="XML配置"><a href="#XML配置" class="headerlink" title="XML配置"></a>XML配置</h3><p><code>Spring</code>提供了<code>task</code>命名空间，让配置定时任务非常简单。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.zsr.test.springTask"</span>/&gt;</span> </div><div class="line">  </div><div class="line"><span class="tag">&lt;<span class="name">task:scheduler</span> <span class="attr">id</span>=<span class="string">"scheduler"</span> <span class="attr">pool-size</span>=<span class="string">"10"</span> /&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">task:scheduled-tasks</span> <span class="attr">scheduler</span>=<span class="string">"scheduler"</span>&gt;</span>   </div><div class="line">        <span class="tag">&lt;<span class="name">task:scheduled</span> <span class="attr">ref</span>=<span class="string">"taskJob"</span> <span class="attr">method</span>=<span class="string">"execute"</span> <span class="attr">cron</span>=<span class="string">"0 * * * * ?"</span>/&gt;</span>   </div><div class="line"><span class="tag">&lt;/<span class="name">task:scheduled-tasks</span>&gt;</span></div></pre></td></tr></table></figure>
<p><strong>说明：</strong><code>ref</code>参数指定的即任务类，<code>method</code>指定的即需要运行的方法，<code>cron</code>指定<code>cronExpression</code>表达式</p>
<p><strong>注意：</strong><code>&lt;task:schedule-tasks scheduler=&quot;scheduler&quot;&gt;</code> 这里的<code>scheduler</code>必须显式指定，否则它只会使用默认的值，默认为单线程的。</p>
<h4 id="任务Job"><a href="#任务Job" class="headerlink" title="任务Job"></a>任务Job</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskJob</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</div><div class="line">    System.out.println(<span class="string">"任务进行中."</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="TaskExecutor"><a href="#TaskExecutor" class="headerlink" title="TaskExecutor"></a>TaskExecutor</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TaskExecutor</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>task:executor</code>会注册一个<strong>ThreadPoolTaskExecutor</strong>执行器，可以使用它的相关属性来配置该执行器。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">task:executor</span></span></div><div class="line">        <span class="attr">id</span>=<span class="string">"executor"</span></div><div class="line">        <span class="attr">pool-size</span>=<span class="string">"10"</span></div><div class="line">        <span class="attr">queue-capacity</span>=<span class="string">"100"</span></div><div class="line">        <span class="attr">rejection-policy</span>=<span class="string">"CALLER_RUNS"</span>/&gt;</div></pre></td></tr></table></figure>
<ul>
<li><code>pool-size</code>：线程池大小，如果只是设置了一个值。则<code>corePoolsize和maxPoolSize</code>都是这个值。</li>
<li><code>queue-capacity</code>：队列大小</li>
<li><code>rejection-policy</code>: 队列满的时候，使用的拒绝策略。</li>
</ul>
<a id="more"></a>
<p>拒绝策略有:</p>
<ul>
<li><code>ABORT（默认）</code>：抛出<code>TaskRejectedException</code>异常，然后不执行</li>
<li><code>DISCARD</code>：不执行，也不抛出异常</li>
<li><code>DISCARD_OLDEST</code>：丢弃<code>queue</code>中最旧的那个任务</li>
<li><code>CALLER_RUNS</code>：不在新线程中执行任务，而是由调用者所在的线程来执行</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolTaskExecutor</span> <span class="keyword">extends</span> <span class="title">ExecutorConfigurationSupport</span> <span class="keyword">implements</span> <span class="title">SchedulingTaskExecutor</span> </span>&#123;</div><div class="line">  <span class="comment">// 初始化Executor</span></div><div class="line">  <span class="function"><span class="keyword">protected</span> ExecutorService <span class="title">initializeExecutor</span><span class="params">(</span></span></div><div class="line">			ThreadFactory threadFactory, RejectedExecutionHandler rejectedExecutionHandler) &#123;</div><div class="line"></div><div class="line">		BlockingQueue&lt;Runnable&gt; queue = createQueue(<span class="keyword">this</span>.queueCapacity);</div><div class="line">        <span class="comment">// 线程池，默认情况下类似于Executors.newFixedThreadPool()</span></div><div class="line">		ThreadPoolExecutor executor  = <span class="keyword">new</span> ThreadPoolExecutor(</div><div class="line">				<span class="keyword">this</span>.corePoolSize, <span class="keyword">this</span>.maxPoolSize, <span class="keyword">this</span>.keepAliveSeconds, TimeUnit.SECONDS,</div><div class="line">				queue, threadFactory, rejectedExecutionHandler);</div><div class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.allowCoreThreadTimeOut) &#123;</div><div class="line">			executor.allowCoreThreadTimeOut(<span class="keyword">true</span>);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">this</span>.threadPoolExecutor = executor;</div><div class="line">		<span class="keyword">return</span> executor;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>默认情况下执行队列是无限的，可能会导致JVM使用完所有内存，因此最好指定一个确定的数值。</p>
<h4 id="TaskScheduler"><a href="#TaskScheduler" class="headerlink" title="TaskScheduler"></a>TaskScheduler</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TaskScheduler</span> </span>&#123;</div><div class="line">  <span class="function">ScheduledFuture <span class="title">schedule</span><span class="params">(Runnable task, Trigger trigger)</span></span>;</div><div class="line">  ......</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>task:scheduler</code>会注册一个<strong>ThreadPoolTaskScheduler </strong>定时器，它只有一个属性线程池大小。默认是1，我们需要根据任务的数量指定一个合适的大小。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">task:scheduler</span> <span class="attr">id</span>=<span class="string">"scheduler"</span></span></div><div class="line">                   <span class="attr">pool-size</span>=<span class="string">"10"</span>/&gt;</div></pre></td></tr></table></figure>
<p><code>TaskScheduler</code>就是为了提供定时任务的支持。<code>TaskScheduler</code>需要传入一个<code>Runnable</code>的任务做为参数，并指定需要周期执行的时间或者触发器，这样<code>Runnable</code>任务就可以周期性执行了。</p>
<p><code>ThreadPoolTaskScheduler</code>实际上代理了<code>jdk</code>中的<code>SchedulingTaskExecutor</code>，并且也实现了<code>TaskScheduler</code>接口，所以一个<code>ThreadPoolTaskScheduler</code>实例即可同时用于执行定时任务(任务调度和执行都是该线程池)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolTaskScheduler</span> <span class="keyword">extends</span> <span class="title">ExecutorConfigurationSupport</span></span></div><div class="line">		<span class="keyword">implements</span> <span class="title">TaskScheduler</span>, <span class="title">SchedulingTaskExecutor</span> &#123;</div><div class="line">  <span class="function"><span class="keyword">protected</span> ExecutorService <span class="title">initializeExecutor</span><span class="params">(</span></span></div><div class="line">			ThreadFactory threadFactory, RejectedExecutionHandler rejectedExecutionHandler) &#123;</div><div class="line"></div><div class="line">		<span class="keyword">this</span>.scheduledExecutor = createExecutor(<span class="keyword">this</span>.poolSize, threadFactory, rejectedExecutionHandler);</div><div class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.scheduledExecutor;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="执行任务"><a href="#执行任务" class="headerlink" title="执行任务"></a>执行任务</h4><p>使用<code>&lt;task:scheduled-tasks&gt;</code>指定要执行的<code>Bean</code>和方法即可执行任务。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">task:scheduler</span> <span class="attr">id</span>=<span class="string">"scheduler"</span> <span class="attr">pool-size</span>=<span class="string">"10"</span> /&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">task:scheduled-tasks</span> <span class="attr">scheduler</span>=<span class="string">"scheduler"</span>&gt;</span>   </div><div class="line">        <span class="tag">&lt;<span class="name">task:scheduled</span> <span class="attr">ref</span>=<span class="string">"taskJob"</span> <span class="attr">method</span>=<span class="string">"execute"</span> <span class="attr">cron</span>=<span class="string">"0 * * * * ?"</span>/&gt;</span>   </div><div class="line"><span class="tag">&lt;/<span class="name">task:scheduled-tasks</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h3><h4 id="Schedule：调度任务"><a href="#Schedule：调度任务" class="headerlink" title="@Schedule：调度任务"></a>@Schedule：调度任务</h4><p>从<code>spring 2.5</code>开始，可以方便的使用注解来声明<code>bean</code>，对于定时任务，同样提供了注解<code>@Scheduled</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Scheduled  </div><div class="line">&#123;  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">cron</span><span class="params">()</span></span>;  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">fixedDelay</span><span class="params">()</span></span>;  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">fixedRate</span><span class="params">()</span></span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>cron</code>：指定<code>cron</code>表达式</li>
<li><code>fixedDelay</code>：表示从上一个任务完成开始到下一个任务开始的间隔，单位是毫秒。</li>
<li><code>fixedRate</code>：表示从上一个任务开始到下一个任务开始的间隔，单位是毫秒。</li>
</ul>
<h5 id="注解配置"><a href="#注解配置" class="headerlink" title="注解配置"></a>注解配置</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 任务调度器 --&gt;</span>  </div><div class="line"><span class="tag">&lt;<span class="name">task:scheduler</span> <span class="attr">id</span>=<span class="string">"scheduler"</span> <span class="attr">pool-size</span>=<span class="string">"10"</span> /&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!--开启这个配置，spring才能识别@Scheduled注解, @Async注解--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">task:annotation-driven</span> <span class="attr">scheduler</span>=<span class="string">"scheduler"</span> <span class="attr">proxy-target-class</span>=<span class="string">"true"</span>/&gt;</span></div></pre></td></tr></table></figure>
<p><code>proxy-target-class=&quot;true&quot;</code>：表示使用<code>cglib</code>代理</p>
<h5 id="任务Job-1"><a href="#任务Job-1" class="headerlink" title="任务Job"></a>任务Job</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskJob</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="meta">@Scheduled</span>(cron = <span class="string">"0 * * * * ?"</span>)</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</div><div class="line">    System.out.println(<span class="string">"任务进行中."</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>@Schedule</code>注解表示该任务既由<code>ThreadPoolTaskScheduler</code>调度同时也有该线程池执行(与上面的xml配置作用相同)</p>
<h4 id="Async：异步任务"><a href="#Async：异步任务" class="headerlink" title="@Async：异步任务"></a>@Async：异步任务</h4><p>对于异步任务，可以使用注解<code>@Async</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Async &#123;</div><div class="line">  </div><div class="line">	<span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以在注解的地方指定任务执行的线程池(作用与<code>executor=&quot;executor&quot;</code>相同)，方式：<code>@Async(&quot;executor&quot;)</code></p>
<h5 id="注解配置-1"><a href="#注解配置-1" class="headerlink" title="注解配置"></a>注解配置</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 任务执行器 --&gt;</span>  </div><div class="line"><span class="tag">&lt;<span class="name">task:executor</span> <span class="attr">id</span>=<span class="string">"executor"</span> <span class="attr">pool-size</span>=<span class="string">"10"</span>/&gt;</span>  </div><div class="line">  </div><div class="line"><span class="comment">&lt;!--开启注解调度支持 @Async @Scheduled--&gt;</span>  </div><div class="line"><span class="tag">&lt;<span class="name">task:annotation-driven</span> <span class="attr">executor</span>=<span class="string">"executor"</span> <span class="attr">proxy-target-class</span>=<span class="string">"true"</span>/&gt;</span></div></pre></td></tr></table></figure>
<h5 id="任务Job-2"><a href="#任务Job-2" class="headerlink" title="任务Job"></a>任务Job</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskJob</span> </span>&#123;</div><div class="line">  </div><div class="line">  <span class="meta">@Async</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</div><div class="line">    System.out.println(<span class="string">"任务进行中."</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="同时使用-Schedule-Async"><a href="#同时使用-Schedule-Async" class="headerlink" title="同时使用@Schedule @Async"></a>同时使用@Schedule @Async</h4><p>有时候执行任务需要的时间比较长，可以让<code>scheduler</code>只做调度，而让 <code>executor</code> 来执行我们的任务</p>
<h5 id="注解配置-2"><a href="#注解配置-2" class="headerlink" title="注解配置"></a>注解配置</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">task:scheduler</span> <span class="attr">id</span>=<span class="string">"scheduler"</span> <span class="attr">pool-size</span>=<span class="string">"10"</span> /&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!--配置定时任务--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">task:scheduled-tasks</span> <span class="attr">scheduler</span>=<span class="string">"scheduler"</span>&gt;</span>   </div><div class="line">        <span class="tag">&lt;<span class="name">task:scheduled</span> <span class="attr">ref</span>=<span class="string">"taskJob"</span> <span class="attr">method</span>=<span class="string">"execute"</span> <span class="attr">cron</span>=<span class="string">"0 * * * * ?"</span>/&gt;</span>   </div><div class="line"><span class="tag">&lt;/<span class="name">task:scheduled-tasks</span>&gt;</span>  </div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 任务执行器 --&gt;</span>  </div><div class="line"><span class="tag">&lt;<span class="name">task:executor</span> <span class="attr">id</span>=<span class="string">"executor"</span> <span class="attr">pool-size</span>=<span class="string">"10"</span>/&gt;</span>  </div><div class="line">  </div><div class="line"><span class="comment">&lt;!--开启注解调度支持 @Async @Scheduled--&gt;</span>  </div><div class="line"><span class="tag">&lt;<span class="name">task:annotation-driven</span> <span class="attr">executor</span>=<span class="string">"executor"</span> <span class="attr">scheduler</span>=<span class="string">"scheduler"</span> <span class="attr">proxy-target-class</span>=<span class="string">"true"</span>/&gt;</span></div></pre></td></tr></table></figure>
<p><strong>注意：</strong>上述XML配置信息，其中处理任务的<code>executor</code>引用配置，相当于<code>@Async</code>注解；管理任务的<code>Scheduler</code>相当于<code>@Scheduled</code>注解。</p>
<h5 id="任务Job-3"><a href="#任务Job-3" class="headerlink" title="任务Job"></a>任务Job</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskJob</span> </span>&#123;</div><div class="line">  </div><div class="line">  <span class="meta">@Async</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</div><div class="line">    System.out.println(<span class="string">"任务进行中."</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样子，<code>execute</code>的方法，就会由<code>executor</code> 线程池来执行了。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://emacsist.github.io/2015/11/10/Spring-Task-%E4%BD%BF%E7%94%A8/" target="_blank" rel="external">Spring Task 使用</a></p>
<p><a href="https://www.dexcoder.com/selfly/article/3951" target="_blank" rel="external">Spring 3实现定时任务</a></p>
<p><a href="https://sanjay-f.github.io/2015/08/24/Spring%E7%9A%84%E4%B8%A4%E7%A7%8D%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6Scheduled%E5%92%8CAsync/" target="_blank" rel="external">Spring的两种任务调度Scheduled和Async</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[tomcat filter分析]]></title>
      <url>http://zsr.github.io/2017/11/15/tomcat-filter%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<h3 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h3><ul>
<li><code>Filter</code>是<code>servlet</code>规范中定义的<code>java web</code>组件, 在所有支持<code>java web</code>的容器中都可以使用</li>
<li><code>Filter</code>和<code>FilterChain</code>密不可分, <code>Filter</code>可以实现依次调用正是因为有了<code>FilterChain</code></li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2017/1/16/7714d7aa0f6632da5463aef03464fc54?imageView2/0/w/1280/h/960/ignore-error/1" alt="img"></p>
<h4 id="Filter接口"><a href="#Filter接口" class="headerlink" title="Filter接口"></a>Filter接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Filter.class</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Filter</span> </span>&#123;</div><div class="line"></div><div class="line">         <span class="comment">// 容器创建的时候调用, 即启动tomcat的时候调用</span></div><div class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException</span>;</div><div class="line"></div><div class="line">         <span class="comment">// 由FilterChain调用, 并且传入FilterChain本身, 最后回调FilterChain的doFilter()方法</span></div><div class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response,</span></span></div><div class="line">                 FilterChain chain) <span class="keyword">throws</span> IOException, ServletException;</div><div class="line"></div><div class="line">         <span class="comment">// 容器销毁的时候调用, 即关闭tomcat的时候调用</span></div><div class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</div><div class="line">     &#125;</div></pre></td></tr></table></figure>
<h4 id="FilterChain接口"><a href="#FilterChain接口" class="headerlink" title="FilterChain接口"></a>FilterChain接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// FilterChain.class</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FilterChain</span> </span>&#123;</div><div class="line"></div><div class="line">         <span class="comment">// 由Filter.doFilter()中的chain.doFilter调用</span></div><div class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response)</span></span></div><div class="line">             <span class="keyword">throws</span> IOException, ServletException;</div><div class="line"></div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h3 id="Tomcat-filter源码"><a href="#Tomcat-filter源码" class="headerlink" title="Tomcat filter源码"></a>Tomcat filter源码</h3><h4 id="创建FilterChain"><a href="#创建FilterChain" class="headerlink" title="创建FilterChain"></a>创建FilterChain</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// StandardWrapperValve.class</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Request request, Response response)</span></span></div><div class="line">        <span class="keyword">throws</span> IOException, ServletException &#123;</div><div class="line">    <span class="comment">// .....省略......</span></div><div class="line">      </div><div class="line">      MessageBytes requestPathMB = request.getRequestPathMB();</div><div class="line">      DispatcherType dispatcherType = DispatcherType.REQUEST;</div><div class="line">      <span class="keyword">if</span> (request.getDispatcherType()==DispatcherType.ASYNC) </div><div class="line">          dispatcherType = DispatcherType.ASYNC;</div><div class="line">      request.setAttribute(Globals.DISPATCHER_TYPE_ATTR,dispatcherType);</div><div class="line">      request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR,</div><div class="line">                requestPathMB);</div><div class="line">      <span class="comment">// Create the filter chain for this request</span></div><div class="line">      ApplicationFilterChain filterChain =</div><div class="line">                ApplicationFilterFactory.createFilterChain(request, wrapper, servlet);</div><div class="line">  </div><div class="line">      <span class="comment">// Call the filter chain for this request</span></div><div class="line">      <span class="comment">// <span class="doctag">NOTE:</span> This also calls the servlet's service() method</span></div><div class="line">      <span class="comment">// .....省略......</span></div><div class="line">      <span class="comment">// 执行过滤器链doFilter()</span></div><div class="line">      filterChain.doFilter(request.getRequest(), response.getResponse());</div><div class="line">      <span class="comment">// .....省略......</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>每次请求过来都会创建一个过滤器链(<code>filterChain</code>)，并把待执行的<code>servlet</code>对象存放到过滤器链中。对于每个url，对应的<code>filter</code>个数都是不固定的，<code>filterchain</code>需要保存每个请求所对应的一个<code>filter</code>数组，以及调用到的<code>filter</code>的<code>position</code>，以便继续向下调用<code>filter</code></p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ApplicationFilterFactory.class</span></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ApplicationFilterChain <span class="title">createFilterChain</span><span class="params">(ServletRequest request,</span></span></div><div class="line">            Wrapper wrapper, Servlet servlet) &#123;</div><div class="line"> 	<span class="comment">// .....省略......</span></div><div class="line">   </div><div class="line">    <span class="comment">// Acquire the filter mappings for this Context</span></div><div class="line">    StandardContext context = (StandardContext) wrapper.getParent();</div><div class="line">        FilterMap filterMaps[] = context.findFilterMaps();</div><div class="line"></div><div class="line">    <span class="comment">// If there are no filter mappings, we are done</span></div><div class="line">    <span class="keyword">if</span> ((filterMaps == <span class="keyword">null</span>) || (filterMaps.length == <span class="number">0</span>))</div><div class="line">            <span class="keyword">return</span> (filterChain);</div><div class="line">   </div><div class="line">   <span class="comment">// Add the relevant path-mapped filters to this filter chain </span></div><div class="line">   <span class="comment">// 根据请求url找到匹配的filter，添加进来</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; filterMaps.length; i++) &#123;</div><div class="line">         <span class="keyword">if</span> (!matchFiltersURL(filterMaps[i], requestPath))</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        ...</div><div class="line">        filterChain.addFilter(filterConfig);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Add filters that match on servlet name second</span></div><div class="line">    <span class="comment">// 如果配置了根据servlet名称过滤，则再寻找一遍filter</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; filterMaps.length; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (!matchFiltersServlet(filterMaps[i], servletName))</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        ...</div><div class="line">        filterChain.addFilter(filterConfig);</div><div class="line">    &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>创建顺序：</p>
<ol>
<li>把要执行的<code>servlet</code>存放到过滤器链中。</li>
<li>如果没有配置过滤器则<code>return</code>一个空的过滤器链（只包含上面设置的servlet）。</li>
<li>如果配置<code>url-pattern</code>过滤器，则把匹配的过滤器加入到过滤器链中</li>
<li>如果配置<code>servlet-name</code>过滤器，则把匹配的过滤器加入到过滤器链中</li>
</ol>
<p><strong>注意: <code>filterChain.addFilter()</code>顺序与<code>web.xml</code>中定义的<code>Filter</code>顺序一致，所以过滤器的执行顺序是按定义的上下顺序决定的。</strong></p>
<h4 id="过滤器链执行"><a href="#过滤器链执行" class="headerlink" title="过滤器链执行"></a>过滤器链执行</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// StandardWrapperValve.class</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Request request, Response response)</span></span></div><div class="line">        <span class="keyword">throws</span> IOException, ServletException &#123;</div><div class="line">      <span class="comment">// .....省略......</span></div><div class="line">     <span class="keyword">if</span> ((servlet != <span class="keyword">null</span>) &amp;&amp; (filterChain != <span class="keyword">null</span>)) &#123;</div><div class="line">      <span class="comment">// 执行过滤器链doFilter()</span></div><div class="line">      filterChain.doFilter(request.getRequest(), response.getResponse());</div><div class="line">      <span class="comment">// .....省略......</span></div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果<code>servlet</code>和过滤器链都不为空，则开始调用过滤器链的<code>doFilter()</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response)</span></span></div><div class="line">        <span class="keyword">throws</span> IOException, ServletException &#123;</div><div class="line">    <span class="comment">// .....省略......</span></div><div class="line">    <span class="comment">// ***整个Filter流程的实现就是由这个方法完成***</span></div><div class="line">  	internalDoFilter(request,response);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="ApplicationFilterChain-internalDoFilter"><a href="#ApplicationFilterChain-internalDoFilter" class="headerlink" title="ApplicationFilterChain.internalDoFilter()"></a>ApplicationFilterChain.internalDoFilter()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">internalDoFilter</span><span class="params">(ServletRequest request,</span></span></div><div class="line">                                 ServletResponse response)</div><div class="line">       <span class="keyword">throws</span> IOException, ServletException &#123;</div><div class="line">	<span class="comment">// Call the next filter if there is one</span></div><div class="line">   <span class="keyword">if</span> (pos &lt; n) &#123;</div><div class="line">       ApplicationFilterConfig filterConfig = filters[pos++];</div><div class="line">       <span class="comment">// 获取Filter</span></div><div class="line">       Filter filter = filterConfig.getFilter();</div><div class="line">       <span class="comment">// .....省略......</span></div><div class="line">       <span class="comment">// 调用Filter的doFilter方法并把FilterChain本身传进去(this)</span></div><div class="line">       filter.doFilter(request, response, <span class="keyword">this</span>);</div><div class="line">     </div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">  </div><div class="line">    <span class="comment">// We fell off the end of the chain -- call the servlet instance</span></div><div class="line">    <span class="comment">// .....省略......</span></div><div class="line">    <span class="comment">// 过滤器全部执行后，执行Servlet的service方法(自己的业务逻辑)</span></div><div class="line">    servlet.service(request, response); </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> <code>FilterChain</code>调用<code>Filter</code>后，<code>Filter</code>再执行<code>FilterChain.doFilter(request, response)</code>，可见<code>FilterChain</code>与<code>Filter</code>构成回调模式(这个也是与<code>Spring Interceptor</code>不同点, <code>Interceptor</code>基于<code>java</code>反射机制)</p>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>假设下面的<code>Filter</code>就是调用链中的最后一个<code>Filter</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response,</span></span></div><div class="line">            FilterChain chain) <span class="keyword">throws</span> IOException, ServletException &#123;</div><div class="line"></div><div class="line">        Log.info(<span class="string">"before"</span>);</div><div class="line">        chain.doFilter(request, response);       </div><div class="line">        Log.info(<span class="string">"after"</span>);</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>在<code>LogFilter</code>调用<code>chain.doFilter</code>之后就跳过了<code>if</code>语句从而调用了真正的<code>servlet</code>, 然后<code>internalDoFilter</code>方法就结束(出栈)了, 紧接着就是调用<code>Log.info(&quot;after&quot;)</code>了, 然后<code>LogFilter的doFilter就结束了(也出栈了)</code>, 紧接着就是<code>internalDoFilter</code>中<code>filter.doFilter(request, response, this)</code>的结束然后<code>return</code>, 然后就是调用上一个<code>filter</code>的<code>chain.doFilter()</code>之后的代码, 以此类推.</li>
<li><code>Filter</code>调用链的实现其实就是一个方法调用链的过程. 刚开始, <code>Filter Chain</code>每调用一个<code>Filter.doFilter()</code>方法就是向方法调用栈中进行压栈操作(代码上的体现就是执行<code>Filter.doFilter</code>之前的代码), 当<code>Filter</code>全部调用完成之后就调用真正处理请求的<code>servlet</code>, 然后由方法调用链自动进行出栈操作(代码上的体现就是执行<code>Filter.doFilter</code>之后的代码), 从而完成整个<code>Filter</code>的调用链. <strong>因为<code>Filter</code>功能实现实际上就是利用了方法的压栈出栈</strong>, 所以可以在调用<code>chain.doFilter</code>之前将方法返回, 让容器不在调用<code>servlet</code>方法, 从而实现权限的控制, 关键词的过滤等功能.</li>
</ol>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://www.bijishequ.com/detail/519398?p=" target="_blank" rel="external">Tomcat Filter 源码分析</a></p>
<p><a href="https://juejin.im/entry/587c3a125c497d0058a84537" target="_blank" rel="external">Filter 和 Interceptor 的比较</a></p>
<p>​     </p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[中文乱码]]></title>
      <url>http://zsr.github.io/2017/10/26/%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/</url>
      <content type="html"><![CDATA[<h3 id="乱码原因"><a href="#乱码原因" class="headerlink" title="乱码原因"></a>乱码原因</h3><p>字符在保存时的编码格式如果和要显示的编码格式不一样的话，就会出现乱码问题。Java在运行期一律以<code>Unicode</code>来存储字符,这样有利的支持了多语言环境。Java读文件的时候会用到系统默认的编码来解码文件。所以在用<code>FileInputStream</code>类读取文件可以指定编码读取。　</p>
<p><code>JAVA</code>在网络传输中使用的编码是<code>ISO-8859-1</code>，故在输出时需要进行转化，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String str=<span class="keyword">new</span> String(str.getBytes(<span class="string">"开发环境编码"</span>),<span class="string">"ISO-8859-1"</span>);</div></pre></td></tr></table></figure>
<p>经过网络编码后的中文，要正确显示在页面上必须要用类似于:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Stirng str=<span class="keyword">new</span> String(str.getBytes(<span class="string">"ISO-8859-1"</span>),<span class="string">"开发环境编码"</span>);</div></pre></td></tr></table></figure>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>浏览器请求服务，服务器返回响应</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http request——————————&gt;http response</div></pre></td></tr></table></figure>
<p><code>request</code>请求过程：</p>
<ul>
<li>浏览器<code>http</code>响应增加一个<code>Content-Type:text/html; charset=utf-8</code>,发送请求</li>
<li><code>Tomcat</code>接受请求(不设置<code>URIEncodng</code>)</li>
<li><code>java</code>服务端处理请求</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</div><div class="line">    System.out.println(<span class="string">"name: "</span>+newString(req.getParameter(<span class="string">"name"</span>).getBytes(<span class="string">"iso8859-1"</span>),<span class="string">"utf-8"</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编码转换过程：</p>
<ul>
<li>浏览器对字符做百分号编码</li>
<li><code>Tomcat</code>解百分号编码</li>
<li><code>ISO8859-1</code>编码转<code>Java</code>内码</li>
<li><code>Java</code>内码转<code>ISO8859-1</code>编码</li>
<li>把字节数组当成<code>utf-8</code>编码转<code>Java</code>内码</li>
<li><p><code>Java</code>内码转输出编码</p>
<p><strong>注：</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String.getBytes(<span class="string">"utf-8"</span>): 把java内码转成utf-<span class="number">8</span>编码</div><div class="line"><span class="keyword">new</span> String(bytes[],<span class="string">"utf-8"</span>): 把字节数组当成utf-<span class="number">8</span>编码转成java内码</div></pre></td></tr></table></figure>
<h4 id="浏览器对字符做百分号编码"><a href="#浏览器对字符做百分号编码" class="headerlink" title="浏览器对字符做百分号编码"></a><strong>浏览器对字符做百分号编码</strong></h4><p>对于[中国]这两个字符，他们的<code>utf-8</code>编码分别是<code>0xE4B8AD</code>、<code>0xE59BBD</code>，每个字符占用三个字节。经过百分号编码后变成了<code>%E4%B8%AD</code>、<code>%E5%9B%BD</code>，可以看到百分号编码对原始编码是无损的，它只是把<strong>原始字节</strong>变成了<strong>%+原始字节</strong>的16进制表示。比如字节<code>0xE4</code>，转成百分号编码为<code>%E4</code>，有一个字节变成了三个字节。</p>
<h4 id="Tomcat解码百分号编码"><a href="#Tomcat解码百分号编码" class="headerlink" title="Tomcat解码百分号编码"></a><strong>Tomcat解码百分号编码</strong></h4><p>解码百分号编码也很简单，其实就是去掉百分号，然后将百分号后的两个字节合并成一个字节，如百分号编码<code>%E4</code>，解码后变为字节<code>0xE4</code>。到这一步“中国”这两个字符就变成了<code>0xE4B8AD</code>、<code>0xE59BBD</code>。</p>
<h4 id="ISO8859-1转java内码"><a href="#ISO8859-1转java内码" class="headerlink" title="ISO8859-1转java内码"></a>ISO8859-1转java内码</h4><p><code>ISO8859-1</code>与<code>ascii</code>一样都是单字节字符集，不同的是它把最高位利用起来了，增加了一些西方字符(如±、÷等字符)</p>
<p>这里说的<code>java</code>内码是<code>java</code>程序运行时，在内存中存储字符的编码，用的是<code>unicode</code>标准中定义的<code>utf-16</code>编码</p>
<p><code>utf-16</code>是把<code>unicode</code>字符编码成2字节或4字节。<code>ISO8859-1</code>是8位长的单字节字符编码，所以<code>utf-16</code>编码和<code>ISO8859-1</code>编码是不兼容的，但是utf-16包含ISO8859-1中的所有字符.</p>
<p>Tomcat解码百分号编码后，[中国]这两个字符在内存中是这样的<code>0xE4B8ADE59BBD</code>，正好六个字节。这其实是这两个字符的<code>utf-8</code>编码序列，但是由于并没有告诉<code>tomcat</code>这是什么字符编码序列，所以<code>tomcat</code>就认为这是一个<code>ISO8859-1</code>编码序列，并把它告诉了java程序，java程序要做的就是把这个字节序列按照<code>ISO8859-1</code>转换成<code>utf-16</code>，转换成功后的对应关系是这样的:</p>
<table>
<thead>
<tr>
<th>ISO8859-1</th>
<th>0xE4</th>
<th>0xB8</th>
<th>0xAD</th>
<th>0xE5</th>
<th>0x9B</th>
<th>0xBD</th>
</tr>
</thead>
<tbody>
<tr>
<td>UTF-16</td>
<td>0x00E4</td>
<td>0x00B8</td>
<td>0x00AD</td>
<td>0x00E5</td>
<td>0x009B</td>
<td>0x00BD</td>
</tr>
</tbody>
</table>
<p>可以看到原本的两个字符，在java中变成了六个字符;原本的六个字节，在java中变成了12个字节。</p>
<h4 id="Java内码转换成ISO8859-1编码"><a href="#Java内码转换成ISO8859-1编码" class="headerlink" title="Java内码转换成ISO8859-1编码"></a>Java内码转换成ISO8859-1编码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">req.getParameter(<span class="string">"name"</span>).getBytes(<span class="string">"iso8859-1"</span>)</div></pre></td></tr></table></figure>
<p><code>getBytes(“iso8859-1”)</code>这个方法，也就是把<code>utf-16</code>转换成<code>ISO8859-1</code>。有第三步(ISO8859-1转java内码)中的对应表格可以看到，<code>utf-16</code>转<code>ISO8859-1</code>只需要把每个字符前面的8位0去掉就可以了，转换成功后俩个字符就又变成了<code>0xE4B8ADE59BBD</code>。虽然两次转换过程中，对字节的解释是错误的，但是并没有丢失原始字节信息。</p>
<h4 id="把字节数组当成utf-8编码转java内码"><a href="#把字节数组当成utf-8编码转java内码" class="headerlink" title="把字节数组当成utf-8编码转java内码"></a>把字节数组当成utf-8编码转java内码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> String(<span class="number">0xE4B8ADE59BBD</span>,<span class="string">"utf-8"</span>)</div></pre></td></tr></table></figure>
<p>因为字节数组本来就是utf-8编码，所以按照utf-8来转码肯定是没问题的，转换成功后的对应关系是这一样的：</p>
<table>
<thead>
<tr>
<th>UTF-8</th>
<th>0xE4B8AD</th>
<th>0xE59BBD</th>
</tr>
</thead>
<tbody>
<tr>
<td>UTF-16</td>
<td>0x4E2D</td>
<td>0x56FD</td>
</tr>
</tbody>
</table>
<p>到这里[中国]这两个字符在java内部才得到了正确的表示。 </p>
<h4 id="Java内码转输出编码"><a href="#Java内码转输出编码" class="headerlink" title="Java内码转输出编码"></a>Java内码转输出编码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">System.out.println(<span class="string">"中国"</span>)</div></pre></td></tr></table></figure>
<p>现在[中国]这两个字符在java内部用<code>utf-16</code>得到了正确的表示，剩下的最后一步就是对外输出，也就是对外翻译的过程，我们这里用的java自带的<code>println</code>方法，这个方法会根据当前平台的自身编码进行输出，比如你的平台环境是中文，那输出的可能就是<code>GBK</code>编码。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Unicode和UTF-8字符编码]]></title>
      <url>http://zsr.github.io/2017/10/25/Unicode%E5%92%8CUTF-8%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/</url>
      <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul>
<li><p><strong>Unicode: </strong>(<code>Universal Code</code> 统一码)是一个囊括了世界上所有字符的字符集，其中每一个字符都对应有唯一的编码值（<code>code point</code>），然而它并不是一种什么编码格式，仅仅是字符集而已</p>
<p><code>Unicode</code> 字符不管具体怎么编码和存储，可以用 <code>UTF-8</code>、<code>UTF-16</code>来编码</p>
<p><code>UTF-16</code> 表示字符非常方便，每两个字节表示一个字符，这个在字符串操作时就大大简化了操作，这也是 Java 以 <code>UTF-16</code> 作为内存的字符存储格式的一个很重要的原因</p>
</li>
<li><p><strong>UTF-8:</strong> (<code>Unicode Transformation Format</code>)就是在互联网上使用最广的一种<code>Unicode</code>的实现方式(怎么编码，怎么存储)。其他实现方式还包括<code>UTF-16</code>（字符用两个字节或四个字节表示）和<code>UTF-32</code> (字符用四个字节表示）</p>
<p><code>UTF-8</code>最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">UTF-8 and Unicode cannot be compared. UTF-8 is an encoding used to translate numbers into binary data. Unicode is a character set used to translate characters into numbers.</div></pre></td></tr></table></figure>
<h3 id="UTF-8编码"><a href="#UTF-8编码" class="headerlink" title="UTF-8编码"></a>UTF-8编码</h3><table>
<thead>
<tr>
<th>字符</th>
<th>Unicode</th>
<th>UTF-8</th>
<th>GBK</th>
</tr>
</thead>
<tbody>
<tr>
<td>中</td>
<td>01001110  00101101（4e2d）</td>
<td>01001110  00101101（e4b8ad）</td>
<td>11010110 11010000（d6d0）</td>
</tr>
</tbody>
</table>
<p><code>UTF-8</code>常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4个字节.如果要传输的文本包含大量英文字符，用UTF-8编码就能节省空间：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">u"中"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a</div><div class="line"><span class="string">u'\u4e2d'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b = a.encode(<span class="string">"utf-8"</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b</div><div class="line"><span class="string">'\xe4\xb8\xad'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>c = a.encode(<span class="string">"gbk"</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>c</div><div class="line"><span class="string">'\xd6\xd0'</span></div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<p>「中」用 GBK 编码转后就是用2个字节表示，用 UTF-8 编码就是 3 个字节，同一个字符用不同的编码方式占用的字节长度可能不一。</p>
<a id="more"></a>
<h4 id="编码规则"><a href="#编码规则" class="headerlink" title="编码规则"></a>编码规则</h4><p>1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的<code>unicode</code>码。因此对于英语字母，<code>UTF-8</code>编码和<code>ASCII</code>码是相同的。</p>
<p>2）对于n字节的符号（n&gt;1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的<code>unicode</code>码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Unicode符号范围 | UTF-8编码方式</div><div class="line">(十六进制) | （二进制）</div><div class="line">--------------------+---------------------------------------------</div><div class="line">0000 ~ 007F | 0xxxxxxx</div><div class="line">0080 ~ 07FF | 110xxxxx 10xxxxxx</div><div class="line">0800 ~ FFFF | 1110xxxx 10xxxxxx 10xxxxxx</div><div class="line">1 0000 ~1F FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</div></pre></td></tr></table></figure>
<p>如果一个字节的第一位是0，则这个字节单独就是一个字符；如果第一位是1，则连续有多少个1，就表示当前字符占用多少个字节。</p>
<h4 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h4><p><code>BOM</code>：在一个文本文件或者一段字符编码前加上几个固定的字节用于识别，这些字节保证不对应任何一个字符，所以软件一读就能验明正身：</p>
<ul>
<li><code>EF BB BF</code> － <code>UTF-8</code></li>
<li><code>FF FE</code> － <code>UTF-16LE</code>(<code>Little endian</code>)</li>
<li><code>FE FF</code> － <code>UTF-16BE</code>(<code>Big endian</code>)</li>
</ul>
<p>以汉字「中」为例，<code>Unicode</code>码是4e2d，需要用两个字节存储，一个字节是4e，另一个字节是2d。存储的时候，4e在前，2d在后，就是<code>Big endian</code>(高位字节在前，阅读顺序)方式；2d在前，4e在后，就是<code>Little endian</code>(低位字节在前)方式。<code>Windows</code>的记事本还有<code>Windows</code>其它地方所谓的<code>Unicode</code>编码，其实是<code>UTF-16LE</code></p>
<h3 id="其他编码"><a href="#其他编码" class="headerlink" title="其他编码"></a>其他编码</h3><h4 id="ISO-8859-1"><a href="#ISO-8859-1" class="headerlink" title="ISO-8859-1"></a>ISO-8859-1</h4><p><code>ISO-8859-1</code>仍然是单字节编码，它总共能表示 256 个字符。</p>
<h4 id="GB2312"><a href="#GB2312" class="headerlink" title="GB2312"></a>GB2312</h4><p>全称是《信息交换用汉字编码字符集 基本集》，它是<strong>双字节编码</strong>，总的编码范围是 A1-F7，其中从 A1-A9 是符号区，总共包含 682 个符号，从 B0-F7 是汉字区，包含 6763 个汉字。</p>
<h4 id="GBK"><a href="#GBK" class="headerlink" title="GBK"></a>GBK</h4><p>为了扩展<code>GB2312</code>，加入更多的汉字，它的编码范围是<code>8140~FEFE</code>（去掉 XX7F）总共有 23940 个码位，它能表示 21003 个汉字，它的编码是和 <code>GB2312</code> 兼容的，也就是说用 <code>GB2312</code> 编码的汉字可以用 <code>GBK</code> 来解码，并且不会有乱码。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://stackoverflow.com/questions/3951722/whats-the-difference-between-unicode-and-utf-8" target="_blank" rel="external">https://stackoverflow.com/questions/3951722/whats-the-difference-between-unicode-and-utf-8</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html" target="_blank" rel="external">字符编码笔记：ASCII，Unicode和UTF-8</a></p>
<p><a href="https://foofish.net/unicode_utf-8.html" target="_blank" rel="external">常识性错误之 Unicode 与 UTF-8</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[SimpleDateFormat线程安全]]></title>
      <url>http://zsr.github.io/2017/10/24/SimpleDateFormat%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</url>
      <content type="html"><![CDATA[<p><code>SimpleDateFormat</code> 是 Java 中非常常用的一个类，用于解析和格式化日期字符串，但是 <code>SimpleDateFormat</code> 在多线程环境中并不是线程安全的。</p>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        System.out.println(sdf.parse(<span class="string">"2016-03-21 12:00:00"</span>).getTime());</div><div class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    Task task = <span class="keyword">new</span> Task();</div><div class="line">    Thread t1 = <span class="keyword">new</span> Thread(task);</div><div class="line">    t1.start();</div><div class="line">    Thread t2 = <span class="keyword">new</span> Thread(task);</div><div class="line">    t2.start();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果报错，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">java.lang.NumberFormatException: multiple points</div><div class="line">	at sun.misc.FloatingDecimal.readJavaFormatString(FloatingDecimal.java:<span class="number">1110</span>)</div><div class="line">	at java.lang.Double.parseDouble(Double.java:<span class="number">540</span>)</div><div class="line">	at java.text.DigitList.getDouble(DigitList.java:<span class="number">168</span>)</div><div class="line">	at java.text.DecimalFormat.parse(DecimalFormat.java:<span class="number">1321</span>)</div><div class="line">	at java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:<span class="number">1793</span>)</div><div class="line">	at java.text.SimpleDateFormat.parse(SimpleDateFormat.java:<span class="number">1455</span>)</div><div class="line">	at java.text.DateFormat.parse(DateFormat.java:<span class="number">355</span>)</div></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>在 JDK 的文档中提到了 <code>SimpleDateFormat</code> 的线程安全问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Date formats are not synchronized. It is recommended to create separate format instances for each thread. If multiple threads access a format concurrently, it must be synchronized externally.</div></pre></td></tr></table></figure>
<p>就是说DateFormat不是同步的，建议每个线程都分别创建format实例变量；或者如果多个线共享一个format的话，必须保持在使用format时是同步的.</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>以<code>SimpleDateFormat</code>类<code>format()</code>方法为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> Calendar calendar;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> StringBuffer <span class="title">format</span><span class="params">(Date date, StringBuffer toAppendTo,</span></span></div><div class="line">                            FieldDelegate delegate) &#123;</div><div class="line">    <span class="comment">// Convert input date to time field list</span></div><div class="line">    calendar.setTime(date);</div><div class="line"></div><div class="line">    <span class="keyword">boolean</span> useDateFormatSymbols = useDateFormatSymbols();</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; compiledPattern.length; ) &#123;</div><div class="line">       ..........</div><div class="line">         </div><div class="line">        <span class="keyword">switch</span> (tag) &#123;</div><div class="line">        .........</div><div class="line">          </div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            subFormat(tag, count, delegate, toAppendTo, useDateFormatSymbols);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> toAppendTo;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 <code>format()</code> 方法中先将日期存放到一个 <code>Calendar</code> 对象中，而这个 <code>Calender</code>对象在 <code>SimpleDateFormat</code> 中还是以成员变量存在的。在随后调用 <code>subFormat()</code> 时会再次用到成员变量 <code>calendar</code>。这就是引发问题的根源。在 <code>parse()</code> 方法中也会存在相应的问题。</p>
<p>在多线程环境下，如果两个线程都使用同一个 <code>SimpleDateFormat</code> 实例，那么就有可能存在其中一个线程修改了 <code>calendar</code> 后紧接着另一个线程也修改了 <code>calendar</code>，那么随后第一个线程用到 <code>calendar</code> 时已经不是它所期待的值了。</p>
<p><code>SimpleDateFormat</code> 其实是有状态的，它使用一个 <code>Calendar</code> 成员变量来保存状态；如果要求 <code>SimpleDateFormat</code> 的 <code>parse()</code> 和 <code>format()</code> 是线程安全的，那么它其实应该是无状态的。将 <code>Calendar</code> 对象作为局部变量，内部在进行方法调用时每次都把它作为参数进行传递，其实就应该可以做到线程安全了。JDK 中 <code>SimpleDateFormat</code> 的实现之所以没有这样做可能是出于性能上的考虑，可以节约每次方法调用时都要创建 <code>Calendar</code> 对象的开销。但这种有状态的设计在某些场景下却反而带来了使用上的不便。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="创建局部变量"><a href="#创建局部变量" class="headerlink" title="创建局部变量"></a>创建局部变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">formatDate</span><span class="params">(Date d)</span> </span>&#123;</div><div class="line">    SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</div><div class="line">    <span class="keyword">return</span> sdf.parse(d);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="SimpleDateFormat-进行加锁"><a href="#SimpleDateFormat-进行加锁" class="headerlink" title="SimpleDateFormat 进行加锁"></a><code>SimpleDateFormat</code> 进行加锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</div><div class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">formatDate</span><span class="params">(Date d)</span> </span>&#123;</div><div class="line">    <span class="keyword">synchronized</span>(sdf) &#123;</div><div class="line">        <span class="keyword">return</span> sdf.parse(d);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="使用-ThreadLocal"><a href="#使用-ThreadLocal" class="headerlink" title="使用 ThreadLocal"></a>使用 <code>ThreadLocal</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> ThreadLocal&lt;SimpleDateFormat&gt; tl = <span class="keyword">new</span> ThreadLocal&lt;SimpleDateFormat&gt;();</div><div class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">formatDate</span><span class="params">(Date d)</span> </span>&#123;</div><div class="line">    SimpleDateFormat sdf = tl.get();</div><div class="line">    <span class="keyword">if</span>(sdf == <span class="keyword">null</span>) &#123;</div><div class="line">        sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</div><div class="line">        tl.set(sdf);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> sdf.parse(d);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="使用-Joda-Time-推荐"><a href="#使用-Joda-Time-推荐" class="headerlink" title="使用 Joda-Time(推荐)"></a>使用 Joda-Time(推荐)</h4><p><a href="http://www.oschina.net/p/joda-time" target="_blank" rel="external">Joda-Time</a> 是一个很棒的开源的 JDK 的日期和日历 API 的替代品，其 DateTimeFormat 是线程安全而且不变的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateFormatTest</span> </span>&#123;</div><div class="line"> </div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> DateTimeFormatter fmt =</div><div class="line">       DateTimeFormat.forPattern(<span class="string">"yyyyMMdd"</span>);</div><div class="line"> </div><div class="line">  <span class="function"><span class="keyword">public</span> Date <span class="title">convert</span><span class="params">(String source)</span></span>&#123;</div><div class="line">    DateTime d = fmt.parseDateTime(source);</div><div class="line">    <span class="keyword">return</span>.toDate();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://zclau.com/2016/03/22/Java-SimpleDateFormat%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E9%97%AE%E9%A2%98/" target="_blank" rel="external">Java SimpleDateFormat的线程安全性问题</a></p>
<p><a href="http://blog.jrwang.me/2016/java-simpledateformat-multithread-threadlocal/" target="_blank" rel="external">SimpleDateFormat 的线程安全问题与 ThreadLocal</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Spring事件监听器]]></title>
      <url>http://zsr.github.io/2017/10/23/Spring%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E5%99%A8/</url>
      <content type="html"><![CDATA[<h3 id="Spring-事件框架"><a href="#Spring-事件框架" class="headerlink" title="Spring 事件框架"></a>Spring 事件框架</h3><p><code>Spring</code>事件框架包含三个部件：</p>
<ul>
<li>事件：<code>ApplicationEvent</code></li>
<li>事件监听器：<code>ApplicationListener</code>，对监听到的事件进行处理</li>
<li>事件发布：<code>ApplicationEventPublisher</code>，<code>ApplicationContext</code>继承了该接口，在<code>ApplicationContext</code>的抽象实现类<code>AbstractApplicationContext</code>中做了实现</li>
</ul>
<h3 id="Spring-事件原理"><a href="#Spring-事件原理" class="headerlink" title="Spring 事件原理"></a>Spring 事件原理</h3><h4 id="Spring提供的事件类型"><a href="#Spring提供的事件类型" class="headerlink" title="Spring提供的事件类型"></a>Spring提供的事件类型</h4><p><img src="http://dl2.iteye.com/upload/attachment/0086/6532/8637476c-9877-3432-ae82-e85745f27cc3.png" alt="img"></p>
<ul>
<li><code>ContextStartedEvent</code>：<code>ApplicationContext</code>启动后触发的事件；</li>
<li><code>ContextStoppedEvent</code>：<code>ApplicationContext</code>停止后触发的事件；</li>
<li><code>ContextRefreshedEvent</code>：<code>ApplicationContext</code>初始化或刷新完成后触发的事件；（容器初始化完成后调用）</li>
<li><code>ContextClosedEvent</code>：<code>ApplicationContext</code>关闭后触发的事件；（如web容器关闭时自动会触发spring容器的关闭)</li>
</ul>
<h4 id="事件发布者"><a href="#事件发布者" class="headerlink" title="事件发布者"></a>事件发布者</h4><p><code>ApplicationContext</code>接口继承了<code>ApplicationEventPublisher</code>，并在<code>AbstractApplicationContext</code>实现了具体代码，实际执行是委托给<code>ApplicationEventMulticaster</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// AbstractApplicationContext.class</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;  </div><div class="line">    <span class="comment">//省略部分代码  </span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 事件发布委托给ApplicationEventMulticaster来执行</span></div><div class="line">    getApplicationEventMulticaster().multicastEvent(event);  </div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.parent != <span class="keyword">null</span>) &#123;  </div><div class="line">        <span class="keyword">this</span>.parent.publishEvent(event);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>常用的<code>ApplicationContext</code>都继承自<code>AbstractApplicationContext</code>，如<code>ClassPathXmlApplicationContext</code>、<code>XmlWebApplicationContext</code>等，自动拥有这个功能</p>
<a id="more"></a>
<ul>
<li><code>ApplicationEventMulticaster</code> 初始化</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// AbstractApplicationContext.class</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</div><div class="line">   <span class="comment">// 初始化ApplicationEventMulticaster</span></div><div class="line">   initApplicationEventMulticaster();</div><div class="line"></div><div class="line">   <span class="comment">// Initialize other special beans in specific context subclasses.</span></div><div class="line">   onRefresh();</div><div class="line"></div><div class="line">   <span class="comment">// 注册监听器</span></div><div class="line">   registerListeners();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initApplicationEventMulticaster</span><span class="params">()</span> </span>&#123;</div><div class="line">		ConfigurableListableBeanFactory beanFactory = getBeanFactory();</div><div class="line">       <span class="comment">//先查找BeanFactory中是否有ApplicationEventMulticaster(自定义)</span></div><div class="line">		<span class="keyword">if</span> (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) &#123;</div><div class="line">			<span class="keyword">this</span>.applicationEventMulticaster =</div><div class="line">					beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> &#123;</div><div class="line">          <span class="comment">// 创建默认的SimpleApplicationEventMulticaster</span></div><div class="line">			<span class="keyword">this</span>.applicationEventMulticaster = <span class="keyword">new</span> SimpleApplicationEventMulticaster(beanFactory);</div><div class="line">			beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, <span class="keyword">this</span>.applicationEventMulticaster);</div><div class="line">		&#125;</div></pre></td></tr></table></figure>
<p><code>Spring</code>容器初始化的时候会调用<code>initApplicationEventMulticaster()</code>初始化    <code>ApplicationEventMulticaster</code>，如果没有自定义的<code>applicationEventMulticaster</code>则默认创建一个<code>SimpleApplicationEventMulticaster</code>。</p>
<ul>
<li><code>multicastEvent</code>发布事件</li>
</ul>
<p>其中<code>SimpleApplicationEventMulticaster</code>发布事件的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// SimpleApplicationEventMulticaster.class</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multicastEvent</span><span class="params">(<span class="keyword">final</span> ApplicationEvent event)</span> </span>&#123;</div><div class="line">    <span class="comment">//获得监听器集合，遍历监听器，可支持同步和异步的广播事件</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> ApplicationListener listener : getApplicationListeners(event)) &#123;  </div><div class="line">        Executor executor = getTaskExecutor();  </div><div class="line">        <span class="keyword">if</span> (executor != <span class="keyword">null</span>) &#123;  </div><div class="line">            executor.execute(<span class="keyword">new</span> Runnable() &#123;  </div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </div><div class="line">                    listener.onApplicationEvent(event);  </div><div class="line">                &#125;  </div><div class="line">            &#125;);  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 执行监听器逻辑</span></div><div class="line">            listener.onApplicationEvent(event);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果给它一个<code>executor</code>，它就可以异步支持发布事件了。</p>
<h4 id="事件监听器"><a href="#事件监听器" class="headerlink" title="事件监听器"></a>事件监听器</h4><ul>
<li><code>registerListeners</code>注册事件监听器</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// AbstractApplicationContext.class</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerListeners</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></div><div class="line">		<span class="comment">// uninitialized to let post-processors apply to them!</span></div><div class="line">		String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</div><div class="line">		<span class="keyword">for</span> (String lisName : listenerBeanNames) &#123;</div><div class="line">			getApplicationEventMulticaster().addApplicationListenerBean(lisName);</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p><code>Spring</code>使用反射机制，通过方法<code>getBeanNamesForType</code>获取所有实现了<code>ApplicationListener</code>接口的<code>Bean</code>，并调用<code>addApplicationListenerBean</code>方法将其注册到<code>applicationEventMulticaster</code>中。所以可以在<code>Spring</code>配置文件中配置自定义监听器，在<code>Spring</code>初始化的时候，会把监听器自动注册到注册表中去。</p>
<ul>
<li><code>SmartApplicationListener</code>监听器</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationListener</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span>&gt; <span class="keyword">extends</span> <span class="title">EventListener</span> </span>&#123;</div><div class="line">	<span class="comment">// 处理收到的事件</span></div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(E event)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SmartApplicationListener</span> <span class="keyword">extends</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ApplicationEvent</span>&gt;, <span class="title">Ordered</span> </span>&#123;</div><div class="line">	<span class="comment">// 如果实现支持该事件类型 那么返回true</span></div><div class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">supportsEventType</span><span class="params">(Class&lt;? extends ApplicationEvent&gt; eventType)</span></span>;</div><div class="line">    </div><div class="line">    <span class="comment">// 如果实现支持“目标”类型，那么返回true  </span></div><div class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">supportsSourceType</span><span class="params">(Class&lt;?&gt; sourceType)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该接口可方便实现去判断支持的事件类型、目标类型。</p>
<ol>
<li><code>supportsEventType</code>：用于指定支持的事件类型，只有支持的才调用<code>onApplicationEvent</code>；</li>
<li><code>supportsSourceType</code>：支持的目标类型，只有支持的才调用<code>onApplicationEvent</code>；</li>
</ol>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><ul>
<li>定义事件</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TestEvent</span><span class="params">(String source)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>(source);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>定义监听器</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestListener</span> <span class="keyword">implements</span> <span class="title">SmartApplicationListener</span> </span>&#123;</div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</div><div class="line">    System.out.println(<span class="string">"hello: "</span> + event.getSource());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 监听器执行的顺序，值越小优先级越高 </span></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsEventType</span><span class="params">(Class&lt;? extends ApplicationEvent&gt; eventType)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> eventType == TestEvent.class;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsSourceType</span><span class="params">(Class&lt;?&gt; sourceType)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> sourceType == String.class;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>测试</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</div><div class="line"><span class="meta">@ContextConfiguration</span>(locations = &#123; <span class="string">"classpath:spring-listener-config.xml"</span> &#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="meta">@Autowired</span></div><div class="line">  <span class="keyword">private</span> ApplicationContext applicationContext;</div><div class="line"></div><div class="line">  <span class="meta">@Test</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPublishEvent</span><span class="params">()</span> </span>&#123;</div><div class="line">    applicationContext.publishEvent(<span class="keyword">new</span> TestEvent(<span class="string">"world."</span>));</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.limisky.com/125.html" target="_blank" rel="external">Spring的事件与异步事件</a></p>
<p><a href="http://cxis.me/2017/02/15/Spring-ApplicationContext%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/" target="_blank" rel="external">Spring ApplicationContext事件机制</a></p>
<p><a href="http://jinnianshilongnian.iteye.com/blog/1902886" target="_blank" rel="external">详解Spring事件驱动模型</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[scala Execution Context]]></title>
      <url>http://zsr.github.io/2017/10/19/scala-Execution-Context/</url>
      <content type="html"><![CDATA[<h2 id="Implicits-global-vs-Implicits-defaultContext"><a href="#Implicits-global-vs-Implicits-defaultContext" class="headerlink" title="Implicits.global  vs  Implicits.defaultContext"></a>Implicits.global  vs  Implicits.defaultContext</h2><hr>
<p><code>Scala Future</code>需要放在执行上下文(线程池)中执行，一般常见的线程池有2种：</p>
<ul>
<li><code>Scala  Execution Context</code>：</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> scala.concurrent.<span class="type">ExecutionContext</span>.<span class="type">Implicits</span>.global</div></pre></td></tr></table></figure>
<p>该线程池是由<code>Scala</code>标准库提供的，它是一种特殊的<code>ForkJoinPool</code>线程池，在高负载时，使用的线程可能比优化时多(对比<code>play</code>或者<code>akka framework</code>)，因此性能可能会降低</p>
<ul>
<li><code>Play Default  Execution Context</code>：</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> play.api.libs.concurrent.<span class="type">Execution</span>.<span class="type">Implicits</span>.defaultContext</div></pre></td></tr></table></figure>
<p>该线程池是由play提供，play应用应该使用这种执行上下文。同时，应该避免阻塞操作放入<code>play execution context</code>，好的办法是放入其他的<code>execution context</code>，避免play应用资源用尽。</p>
<p>注意：理解哪个线程运行了<code>future</code>非常重要，导入play的默认执行环境（<code>execution context</code>）。这是一个隐式（<code>implicit</code>）的参数，会被传入所有接受回调的<code>future API</code>方法中。执行环境（<code>execution context</code>）通常等价于线程池，但这并不是一定的。</p>
<p>简单的把同步IO封装入<code>Future</code>并不能将其转换为异步的。如果你不能通过改变应用架构来避免阻塞操作，那么该操作总会在某一时刻被执行的，而相应的线程则会被阻塞。所以，除了将操作封装于<code>Future</code>中，还必须让它运行在配置了足够线程来处理可预计并发的独立执行环境（<code>execution context</code>）中。更多信息请见<a href="https://www.playframework.com/documentation/2.3.x/ThreadPools" target="_blank" rel="external">理解Play线程池</a></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://stackoverflow.com/questions/40301032/what-is-the-difference-between-scalas-execution-context-and-plays-execution-co" target="_blank" rel="external">https://stackoverflow.com/questions/40301032/what-is-the-difference-between-scalas-execution-context-and-plays-execution-co</a></p>
<p><a href="https://stackoverflow.com/questions/30805337/plays-internal-execution-context" target="_blank" rel="external">https://stackoverflow.com/questions/30805337/plays-internal-execution-context</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ForkJoinPool]]></title>
      <url>http://zsr.github.io/2017/10/18/ForkJoinPool/</url>
      <content type="html"><![CDATA[<p><code>Java 1.7</code> 引入了一种新的并发框架—— <code>Fork/Join Framework</code></p>
<p><code>Fork/Join</code>的思路：通过分而治之(把大任务分割成若干个小任务)，只不过划分之后的任务更适合分派给不同的计算资源，可以并行的完成任务。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><code>Fork/Join</code>框架主要依靠<code>fork</code>和<code>join</code>两个操作，一般对这两个操作的解释如下：</p>
<ul>
<li><code>fork()</code>：开启一个新线程（或是重用线程池内的空闲线程），将任务交给该线程处理。</li>
<li><code>join()</code>：等待该任务的处理线程处理完毕，获得返回值。</li>
</ul>
<p>这里有个问题，不断的<code>fork()</code>如果是不断创建线程，岂不是要“线程数量爆炸”？事实上，<code>ForkJoinPool</code>用了一种<code>work stealing</code>的算法，避免产生大量线程。所以如果一开始设置线程池的线程数为N，实际上使用<code>ForkJoinPool</code>的时候也只会有固定的线程数(默认和CPU核数一样)。</p>
<h4 id="Fork-Join的基本用法"><a href="#Fork-Join的基本用法" class="headerlink" title="Fork/Join的基本用法"></a>Fork/Join的基本用法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if (当前这个任务工作量足够小)</div><div class="line">    直接完成这个任务</div><div class="line">else</div><div class="line">    将这个任务分解成两个部分</div><div class="line">    分别触发(invoke)这两个子任务的执行，并等待结果</div></pre></td></tr></table></figure>
<h4 id="ForkJoin框架组成"><a href="#ForkJoin框架组成" class="headerlink" title="ForkJoin框架组成"></a>ForkJoin框架组成</h4><ul>
<li><code>ForkJoinPool</code>：管理<code>worker</code>线程，类似<code>ThreadPoolExecutor</code>，提供接口用于提交或者执行任务；</li>
<li><code>ForkJoinWorkerThread</code>：<code>worker</code>线程，任务保存在一个<code>deque</code>中；</li>
<li><code>ForkJoinTask</code>：<code>ForkJoin</code>框架中运行的任务，可以<code>fork</code>子任务，可以<code>join</code>子任务完成。</li>
</ul>
<a id="more"></a>
<h4 id="ForkJoinPool构造函数"><a href="#ForkJoinPool构造函数" class="headerlink" title="ForkJoinPool构造函数"></a>ForkJoinPool构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinPool</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ForkJoinPool</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 默认并行数为CPU核数</span></div><div class="line">        <span class="keyword">this</span>(Math.min(MAX_CAP, Runtime.getRuntime().availableProcessors()),</div><div class="line">             defaultForkJoinWorkerThreadFactory, <span class="keyword">null</span>, <span class="keyword">false</span>);</div><div class="line">    &#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ForkJoinPool</span><span class="params">(<span class="keyword">int</span> parallelism)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(parallelism, defaultForkJoinWorkerThreadFactory, <span class="keyword">null</span>, <span class="keyword">false</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="work-stealing-窃取-算法"><a href="#work-stealing-窃取-算法" class="headerlink" title="work stealing(窃取)算法"></a>work stealing(窃取)算法</h4><p>一个任务通过<code>fork()</code>被分割成若干个小任务。比如线程1和线程2都被分割成4个小任务，如果线程1执行完毕，那么他可以去窃取线程2的工作。当要发生线程窃取的时候，两个线程内的任务可以理解成放在一个线程自己的双端队列中。例如下图线程2中的任务被分割成若干个小任务（就<code>WorkQueue</code>里面的一个个小方块）放在其线程的双端队列中。被窃取任务线程从其他双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行。</p>
<p><img src="http://kaimingwan.com/java/_image/forkjoinpool%E8%A7%A3%E8%AF%BB/15-21-18.jpg" alt="img"></p>
<ul>
<li><code>ForkJoinPool</code> 的每个工作线程都维护着一个<strong>工作队列</strong>（<code>WorkQueue</code>），这是一个双端队列（Deque），里面存放的对象是<strong>任务</strong>（<code>ForkJoinTask</code>）。</li>
<li>每个工作线程在运行中产生新的任务（通常是因为调用了 <code>fork()</code>）时，会放入工作队列的队尾，并且工作线程在处理自己的工作队列时，使用的是 <em>LIFO</em> 方式，也就是说每次从队尾取出任务来执行。</li>
<li>每个工作线程在处理自己的工作队列同时，会尝试<strong>窃取</strong>一个任务（或是来自于刚刚提交到 pool 的任务，或是来自于其他工作线程的工作队列），窃取的任务位于其他线程的工作队列的队首，也就是说工作线程在窃取其他工作线程的任务时，使用的是 <em>FIFO</em> 方式。</li>
<li>在遇到 <code>join()</code> 时，如果需要<code>join</code>的任务尚未完成，则会先处理其他任务，并等待其完成。</li>
<li>在既没有自己的任务，也没有可以窃取的任务时，进入休眠</li>
</ul>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p><code>work stealing</code>算法的优点：利用了线程进行并行计算，减少了线程间的竞争。</p>
<p><code>work stealing</code>算法的缺点：</p>
<ul>
<li>如果双端队列中只有一个任务时，线程间会存在竞争。</li>
<li>额外的开销，例如双端队列</li>
</ul>
<h4 id="fork"><a href="#fork" class="headerlink" title="fork()"></a>fork()</h4><p><code>fork()</code> 做的工作只有一件事，既是<strong>把任务推入当前工作线程的工作队列里</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ForkJoinTask&lt;V&gt; <span class="title">fork</span><span class="params">()</span> </span>&#123;</div><div class="line">    Thread t;</div><div class="line">    <span class="keyword">if</span> ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread)</div><div class="line">        ((ForkJoinWorkerThread)t).workQueue.push(<span class="keyword">this</span>);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        ForkJoinPool.common.externalPush(<span class="keyword">this</span>);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h4><ol>
<li>检查调用 <code>join()</code> 的线程是否是 <code>ForkJoinThread</code>线程。如果不是，则阻塞当前线程，等待任务完成。如果是，则不阻塞。</li>
<li>查看任务的完成状态，如果已经完成，直接返回结果。</li>
<li>如果任务尚未完成，但处于自己的工作队列内，则完成它。</li>
<li>如果任务已经被其他的工作线程偷走，则窃取这个任务的worker执行(以 <em>FIFO</em> 方式)，以期帮助它早日完成<code>join</code>的任务。</li>
<li>如果偷走任务的worker也已经把自己的任务全部做完，正在等待需要<code>join</code>的任务时，则找到该小偷的小偷，帮助它完成它的任务。</li>
<li>递归地执行第5步。</li>
</ol>
<p><img src="http://kaimingwan.com/java/_image/forkjoinpool%E8%A7%A3%E8%AF%BB/16-42-15.jpg" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">doJoin</span><span class="params">()</span> </span>&#123;</div><div class="line">        Thread t; ForkJoinWorkerThread w; <span class="keyword">int</span> s; <span class="keyword">boolean</span> completed;</div><div class="line">        <span class="keyword">if</span> ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread) &#123;</div><div class="line">          <span class="comment">// status值的初始化值是0，在任务没有完成以前一直是非负值</span></div><div class="line">            <span class="keyword">if</span> ((s = status) &lt; <span class="number">0</span>)</div><div class="line">                <span class="keyword">return</span> s;</div><div class="line">            <span class="comment">// 从当前工作线程的栈顶中 pop 该任务，准备执行</span></div><div class="line">            <span class="keyword">if</span> ((w = (ForkJoinWorkerThread)t).unpushTask(<span class="keyword">this</span>)) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    completed = exec();</div><div class="line">                &#125; <span class="keyword">catch</span> (Throwable rex) &#123;</div><div class="line">                    <span class="keyword">return</span> setExceptionalCompletion(rex);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (completed)</div><div class="line">                    <span class="keyword">return</span> setCompletion(NORMAL);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 当工作线程队列为空或者任务没有正常完成，则会给helpJoinTask stolen-&gt;joining 方式执行</span></div><div class="line">            <span class="keyword">return</span> w.joinTask(<span class="keyword">this</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">          <span class="comment">// 不是worker线程，直接调用Object.wait等待任务完成(阻塞)。</span></div><div class="line">            <span class="keyword">return</span> externalAwaitDone();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>统计1～1000整数之和</p>
<h4 id="单线程For循环"><a href="#单线程For循环" class="headerlink" title="单线程For循环"></a>单线程For循环</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForLoopCalculator</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">sum</span><span class="params">(<span class="keyword">long</span>[] numbers)</span> </span>&#123;</div><div class="line">    <span class="keyword">long</span> sum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> i : numbers) &#123;</div><div class="line">      sum += i;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> sum;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    <span class="keyword">long</span>[] numbers = LongStream.rangeClosed(<span class="number">1</span>, <span class="number">1000</span>).toArray();</div><div class="line">    System.out.println(sum(numbers));</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="ExecutorService线程池"><a href="#ExecutorService线程池" class="headerlink" title="ExecutorService线程池"></a>ExecutorService线程池</h4><p>把大任务分割成若干个小任务，并行计算再合并结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//任务Task</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SumTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">long</span>[] numbers;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SumTask</span><span class="params">(<span class="keyword">long</span>[] numbers)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.numbers = numbers;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> Long <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="keyword">return</span> Arrays.stream(numbers).sum();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Task执行线程池</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorServiceCalculator</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> parallism;</div><div class="line">  <span class="keyword">private</span> ExecutorService pool;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ExecutorServiceCalculator</span><span class="params">(<span class="keyword">int</span> parallism)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.parallism = parallism;</div><div class="line">    pool = Executors.newFixedThreadPool(parallism);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sum</span><span class="params">(<span class="keyword">long</span>[] numbers)</span> </span>&#123;</div><div class="line">    List&lt;Future&lt;Long&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="comment">// 把任务分解为 n 份，交给 n 个线程处理</span></div><div class="line">    <span class="keyword">int</span> part = numbers.length / parallism;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parallism; i++) &#123;</div><div class="line">      <span class="keyword">int</span> from = i * part + <span class="number">1</span>;</div><div class="line">      <span class="keyword">int</span> to = (i + <span class="number">1</span>) * part;</div><div class="line">      results.add(pool.submit(<span class="keyword">new</span> SumTask(LongStream.rangeClosed(from, to).toArray())));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 把每个线程的结果相加，得到最终结果</span></div><div class="line">    <span class="keyword">long</span> sum = results.stream().map(f -&gt; &#123;</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">return</span> f.get();</div><div class="line">      &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</div><div class="line">      &#125;</div><div class="line">    &#125;).reduce(<span class="number">0L</span>, Long::sum);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> sum;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="ForkJoinPool线程池"><a href="#ForkJoinPool线程池" class="headerlink" title="ForkJoinPool线程池"></a>ForkJoinPool线程池</h4><p><code>ForkJoinPool</code>主要用于实现“分而治之”的算法，特别是分治之后递归调用的函数，例如<code>quick sort</code> 等</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinCalculator</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> ForkJoinPool pool;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ForkJoinCalculator</span><span class="params">()</span> </span>&#123;</div><div class="line">    pool = <span class="keyword">new</span> ForkJoinPool();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sum</span><span class="params">(<span class="keyword">long</span>[] numbers)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> pool.invoke(<span class="keyword">new</span> SumTask(numbers, <span class="number">0</span>, numbers.length - <span class="number">1</span>));</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SumTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span>[] numbers;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> from;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> to;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SumTask</span><span class="params">(<span class="keyword">long</span>[] numbers, <span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</div><div class="line">      <span class="keyword">this</span>.numbers = numbers;</div><div class="line">      <span class="keyword">this</span>.from = from;</div><div class="line">      <span class="keyword">this</span>.to = to;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">if</span> (to - from &lt;= <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> numbers[from];</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span> (to - from &lt;= <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> numbers[from] + numbers[to];</div><div class="line">        <span class="comment">// 否则，把任务一分为二，递归计算</span></div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">int</span> middle = (from + to) / <span class="number">2</span>;</div><div class="line">        SumTask taskLeft = <span class="keyword">new</span> SumTask(numbers, from, middle);</div><div class="line">        SumTask taskRight = <span class="keyword">new</span> SumTask(numbers, middle + <span class="number">1</span>, to);</div><div class="line">        taskLeft.fork();</div><div class="line">        taskRight.fork();</div><div class="line">        <span class="keyword">return</span> taskLeft.join() + taskRight.join();</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这段代码里没有显式地“把任务分配给线程”，只是分解了任务，而把具体的任务到线程的映射交给了 <code>ForkJoinPool</code> 来完成。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://blog.dyngr.com/blog/2016/09/15/java-forkjoinpool-internals" target="_blank" rel="external">如何使用 ForkJoinPool 以及原理</a></p>
<p><a href="http://kaimingwan.com/post/java/forkjoinpooljie-du" target="_blank" rel="external">ForkJoinPool解读</a></p>
<p><a href="https://ketao1989.github.io/2014/05/24/Java-Fork-Join-Task-Framework-API-Introduce/" target="_blank" rel="external">Java Fork&amp;Join框架使用和实现分析</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[RabbitMQ生产者分析]]></title>
      <url>http://zsr.github.io/2017/09/28/RabbitMQ%E7%94%9F%E4%BA%A7%E8%80%85%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<h3 id="分布式消息中间件"><a href="#分布式消息中间件" class="headerlink" title="分布式消息中间件"></a>分布式消息中间件</h3><p>在使用<code>RabbitMQ</code>做消息分发时，主要有三个概念要注意：<code>Exchange</code>，<code>RoutingKey</code>，<code>Queue</code>。</p>
<p><code>Exchange</code>可以理解为交换器，<code>RoutingKey</code>可以理解为路由，<code>Queue</code>作为真实存储消息的队列和某个<code>Exchange</code>绑定，具体如何路由到感兴趣的<code>Queue</code>则由<code>Exchange</code>的三种模式决定：</p>
<ul>
<li><code>fanout</code>：生产者往此Exchange发送的消息会发给每个和其绑定的Queue，此时RoutingKey并不起作用</li>
<li><code>topic</code> : 生产者可以指定一个支持通配符的RoutingKey（如demo.*）发向此Exchange，凡是Exchange上RoutingKey满足此通配符的Queue就会收到消息</li>
<li><code>direct</code>：生产者指定Exchange和RoutingKey，然后往其发送消息，消息只能被绑定的满足RoutingKey的Queue接受消息。(如果不指定RoutingKey的具体名字，那么默认的名字其实是Queue的名字）</li>
</ul>
<h3 id="生产者配置"><a href="#生产者配置" class="headerlink" title="生产者配置"></a>生产者配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">rabbit:connection-factory</span> <span class="attr">id</span>=<span class="string">"connectionFactory"</span></span></div><div class="line">		<span class="attr">host</span>=<span class="string">"$&#123;rabbit.connect.host&#125;"</span> <span class="attr">port</span>=<span class="string">"$&#123;rabbit.connect.port&#125;"</span> <span class="attr">username</span>=<span class="string">"$&#123;rabbit.connect.username&#125;"</span></div><div class="line">		<span class="attr">password</span>=<span class="string">"$&#123;rabbit.connect.password&#125;"</span> <span class="attr">channel-cache-size</span>=<span class="string">"$&#123;rabbit.connect.channelCacheSize&#125;"</span></div><div class="line">		<span class="attr">publisher-returns</span>=<span class="string">"true"</span> <span class="attr">publisher-confirms</span>=<span class="string">"true"</span> /&gt;</div><div class="line"></div><div class="line">	<span class="tag">&lt;<span class="name">rabbit:admin</span> <span class="attr">id</span>=<span class="string">"rabbitAdmin"</span> <span class="attr">connection-factory</span>=<span class="string">"connectionFactory"</span> /&gt;</span></div><div class="line"></div><div class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"messageConverter"</span></span></div><div class="line">		<span class="attr">class</span>=<span class="string">"org.springframework.amqp.support.converter.SimpleMessageConverter"</span> /&gt;</div><div class="line"></div><div class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"returnCallback"</span></span></div><div class="line">		<span class="attr">class</span>=<span class="string">"com.zsr.test.callback.MessageReturnCallback"</span> /&gt;</div><div class="line"></div><div class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"confirmCallback"</span></span></div><div class="line">		<span class="attr">class</span>=<span class="string">"com.zsr.test.callback.MessageConfirmCallback"</span> /&gt;</div><div class="line"></div><div class="line">	<span class="tag">&lt;<span class="name">rabbit:template</span> <span class="attr">id</span>=<span class="string">"rabbitTemplate"</span></span></div><div class="line">		<span class="attr">connection-factory</span>=<span class="string">"connectionFactory"</span> <span class="attr">confirm-callback</span>=<span class="string">"confirmCallback"</span></div><div class="line">		<span class="attr">return-callback</span>=<span class="string">"returnCallback"</span> <span class="attr">message-converter</span>=<span class="string">"messageConverter"</span> /&gt;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    ConnectionFactory connectionFactory = <span class="keyword">new</span> CachingConnectionFactory(<span class="number">5672</span>);</div><div class="line">    RabbitAdmin admin = <span class="keyword">new</span> RabbitAdmin(connectionFactory);</div><div class="line">    admin.declareQueue(<span class="keyword">new</span> Queue(<span class="string">"test.queue"</span>));</div><div class="line">    RabbitTemplate template = admin.getRabbitTemplate();</div><div class="line">    template.convertAndSend(<span class="string">"spring"</span>, <span class="string">"test"</span>);</div><div class="line">    String foo = (String) template.receiveAndConvert(<span class="string">"spring"</span>);</div><div class="line">    System.out.println(foo);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h4 id="ConnectionFactory分析"><a href="#ConnectionFactory分析" class="headerlink" title="ConnectionFactory分析"></a>ConnectionFactory分析</h4><p><code>org.springframework.amqp.rabbit.connection.ConnectionFactory</code> 是 Spring AMQP 定义的连接工厂接口，负责创建连接.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// CachingConnectionFactory.class</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">CachingConnectionFactory</span><span class="params">(String hostname, <span class="keyword">int</span> port)</span> </span>&#123;</div><div class="line">        <span class="comment">// 真正的RabbitMQ连接工厂, 实际连接都是通过这个rabbitConnectionFactory创建的</span></div><div class="line">		<span class="keyword">super</span>(<span class="keyword">new</span> com.rabbitmq.client.ConnectionFactory());</div><div class="line">		<span class="keyword">if</span> (!StringUtils.hasText(hostname)) &#123;</div><div class="line">			hostname = getDefaultHostName();</div><div class="line">		&#125;</div><div class="line">		setHost(hostname);</div><div class="line">		setPort(port);</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p><code>CachingConnectionFactory</code>实现支持对这些通道的缓存，并且基于它们是否是事务来维护单独的通道高速缓存。如果要配置通道缓存的大小(默认值为25)，可以调用<code>setChannelCacheSize()</code>方法。</p>
<h4 id="RabbitAdmin分析"><a href="#RabbitAdmin分析" class="headerlink" title="RabbitAdmin分析"></a>RabbitAdmin分析</h4><p><code>org.springframework.amqp.core.AmqpAdmin</code>接口定义了AMQP基础管理操作，主要是对各种资源（交换机、队列、绑定）的申明和删除操作.<code>org.springframework.amqp.rabbit.core.RabbitAdmin</code>实现了<code>AmqpAdmin</code>接口.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// RabbitAdmin.class</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">RabbitAdmin</span><span class="params">(ConnectionFactory connectionFactory)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.connectionFactory = connectionFactory;</div><div class="line">		Assert.notNull(connectionFactory, <span class="string">"ConnectionFactory must not be null"</span>);</div><div class="line">        <span class="comment">// 创建了一个RabbitTemplate实例</span></div><div class="line">		<span class="keyword">this</span>.rabbitTemplate = <span class="keyword">new</span> RabbitTemplate(connectionFactory);</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>如果使用xml配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">rabbit:connection-factory</span> <span class="attr">id</span>=<span class="string">"connectionFactory"</span>/&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">rabbit:admin</span> <span class="attr">id</span>=<span class="string">"amqpAdmin"</span> <span class="attr">connection-factory</span>=<span class="string">"connectionFactory"</span>/&gt;</span></div></pre></td></tr></table></figure>
<p>当<code>CachingConnectionFactory</code>缓存模式是CHANNEL(默认值)时，<code>RabbitAdmin</code>实现会在同一个<code>ApplicationContext</code>中声明的<code>Queue</code>，<code>Exchanges</code>和<code>Bindings</code>自动延迟声明.</p>
<h5 id="declareQueue"><a href="#declareQueue" class="headerlink" title="declareQueue"></a>declareQueue</h5><p><code>declareQueue</code>方法用来申明队列。<code>org.springframework.amqp.core.Queue</code>是 Spring AMQP 对队列的封装，其属性与<code>RabbitMQ Java client</code>中定义的<code>Queue</code>的属性基本一致，<code>new Queue(&quot;spring&quot;)</code>相当于<code>RabbitMQ Java client</code>中 <code>channel.queueDeclare(&quot;spring&quot;, true, false, false, null)</code>指定的队列特性，即队列是持久化、非排他性、非自动删除的.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Queue.class</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Queue</span><span class="params">(String name, <span class="keyword">boolean</span> durable, <span class="keyword">boolean</span> exclusive, <span class="keyword">boolean</span> autoDelete, Map&lt;String, Object&gt; arguments)</span> </span>&#123;</div><div class="line">		Assert.notNull(name, <span class="string">"'name' cannot be null"</span>);</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">		<span class="keyword">this</span>.durable = durable;</div><div class="line">		<span class="keyword">this</span>.exclusive = exclusive;</div><div class="line">		<span class="keyword">this</span>.autoDelete = autoDelete;</div><div class="line">		<span class="keyword">this</span>.arguments = arguments;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// RabbitAdmin.class</span></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">declareQueue</span><span class="params">(<span class="keyword">final</span> Queue queue)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.rabbitTemplate.execute(<span class="keyword">new</span> ChannelCallback&lt;String&gt;() &#123;</div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> String <span class="title">doInRabbit</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">				<span class="keyword">return</span> declareQueues(channel, queue)[<span class="number">0</span>].getQueue();</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p><code>declareQueue</code>调用<code>rabbitTemplate</code>的<code>execute(ChannelCallback)</code>方法，在<code>ChannelCallback</code>的回调方法 <code>doInRabbit(Channel channel)</code> 中通过入參<code>channel</code>调用<code>RabbitMQ Java client</code>提供的<code>channel.queueDeclare</code>方法申明队列。</p>
<h4 id="RabbitTemplate分析"><a href="#RabbitTemplate分析" class="headerlink" title="RabbitTemplate分析"></a>RabbitTemplate分析</h4><p><code>org.springframework.amqp.core.AmqpTemplate</code>接口定义了 AMQP 基础操作，主要为同步的消息收发方法。<code>org.springframework.amqp.rabbit.core.RabbitTemplate</code>实现了 AmqpTemplate 接口。</p>
<p><code>RabbitTemplate</code>就是 RabbitMQ 收发消息的模板方法，所以，<code>RabbitTemplate</code>要实现创建连接、获取channel、收发消息、消息格式转换、关闭信道与连接等模板代码。</p>
<h5 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// RabbitTemplate.class</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">convertAndSend</span><span class="params">(String exchange, String routingKey, <span class="keyword">final</span> Object object, CorrelationData correlationData)</span> <span class="keyword">throws</span> AmqpException </span>&#123;</div><div class="line">        <span class="comment">// convertMessageIfNecessary方法将Object转化为Message实例</span></div><div class="line">		send(exchange, routingKey, convertMessageIfNecessary(object), correlationData);</div><div class="line">	&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(<span class="keyword">final</span> String exchange, <span class="keyword">final</span> String routingKey,</span></span></div><div class="line">			<span class="keyword">final</span> Message message, <span class="keyword">final</span> CorrelationData correlationData)</div><div class="line">			<span class="keyword">throws</span> AmqpException &#123;</div><div class="line">  <span class="comment">// 实际在ChannelCallback接口的匿名实现类的doInRabbit(Channel)方法中实现发送消息功能</span></div><div class="line">		execute(<span class="keyword">new</span> ChannelCallback&lt;Object&gt;() &#123;</div><div class="line"></div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> Object <span class="title">doInRabbit</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">				doSend(channel, exchange, routingKey, message, correlationData);</div><div class="line">				<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">	&#125;</div><div class="line"></div><div class="line"><span class="comment">// Message类是Spring AMQP对消息的封装</span></div><div class="line"><span class="function"><span class="keyword">protected</span> Message <span class="title">convertMessageIfNecessary</span><span class="params">(<span class="keyword">final</span> Object object)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (object <span class="keyword">instanceof</span> Message) &#123;</div><div class="line">			<span class="keyword">return</span> (Message) object;</div><div class="line">		&#125;</div><div class="line">       <span class="comment">// 获取在RabbitTemplate构造函数中创建的MessageConverter,默认是SimpleMessageConverter</span></div><div class="line">		<span class="keyword">return</span> getRequiredMessageConverter().toMessage(object, <span class="keyword">new</span> MessageProperties());</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p><code>execute</code>方法中通过传入的<code>ConnectionFactory</code>获取连接和信道，<code>ChannelCallback</code>接口的<code>doInRabbit(Channel channel)</code>方法作为回调函数，通过<code>channel</code>参数接受<code>execute</code>方法中获取的信道，完成消息发送的具体业务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// RabbitTemplate.class</span></div><div class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">doExecute</span><span class="params">(ChannelCallback&lt;T&gt; action)</span> </span>&#123;</div><div class="line">		Assert.notNull(action, <span class="string">"Callback object must not be null"</span>);</div><div class="line">        <span class="comment">// resourceHolder包装了connection和channel</span></div><div class="line">		RabbitResourceHolder resourceHolder = getTransactionalResourceHolder();</div><div class="line">        <span class="comment">// 获取channel</span></div><div class="line">		Channel channel = resourceHolder.getChannel();</div><div class="line">        <span class="comment">// 如果有confirmCallback或者returnCallback，则添加监听器，用于发送结果异步回调</span></div><div class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.confirmCallback != <span class="keyword">null</span> || <span class="keyword">this</span>.returnCallback != <span class="keyword">null</span>) &#123;</div><div class="line">			addListener(channel);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line">				logger.debug(<span class="string">"Executing callback on RabbitMQ Channel: "</span> + channel);</div><div class="line">			&#125;</div><div class="line">            <span class="comment">// 调用doSend方法，通过channel执行消息发送</span></div><div class="line">			<span class="keyword">return</span> action.doInRabbit(channel);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">catch</span> (Exception ex) &#123;</div><div class="line">			<span class="keyword">if</span> (isChannelLocallyTransacted(channel)) &#123;</div><div class="line">				resourceHolder.rollbackAll();</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">throw</span> convertRabbitAccessException(ex);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">finally</span> &#123;</div><div class="line">           <span class="comment">// 回收连接和信道资源</span></div><div class="line">			ConnectionFactoryUtils.releaseResources(resourceHolder);</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>不管是生产者还是消费者都需要与RabbitMQ建立连接，这是一个TCP连接，在TCP连接上RabbitMQ会创建一个个虚拟的<code>channel</code>，所有的RabbitMQ操作必须在<code>channel</code>之上执行，使用<code>channel</code>的好处是比TCP更节省系统资源。TCP连接就像电缆，AMQP channel就像纤维束.</p>
<p><code>doSend</code>方法实现消息发送这个具体操作。实际上调用RabbitMQ Java client提供的<code>channel.basicPublish</code>方法发送消息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doSend</span><span class="params">(Channel channel, String exchange, String routingKey, Message message,</span></span></div><div class="line">			CorrelationData correlationData) <span class="keyword">throws</span> Exception &#123;</div><div class="line">		...some code...</div><div class="line">          </div><div class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.confirmCallback != <span class="keyword">null</span> &amp;&amp; channel <span class="keyword">instanceof</span> PublisherCallbackChannel) &#123;</div><div class="line">			PublisherCallbackChannel publisherCallbackChannel = (PublisherCallbackChannel) channel;</div><div class="line">			publisherCallbackChannel.addPendingConfirm(<span class="keyword">this</span>, channel.getNextPublishSeqNo(),</div><div class="line">					<span class="keyword">new</span> PendingConfirm(correlationData, System.currentTimeMillis()));</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">boolean</span> mandatory = <span class="keyword">this</span>.returnCallback != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.mandatory;</div><div class="line">		MessageProperties messageProperties = message.getMessageProperties();</div><div class="line">		<span class="keyword">if</span> (mandatory) &#123;</div><div class="line">			messageProperties.getHeaders().put(PublisherCallbackChannel.RETURN_CORRELATION, <span class="keyword">this</span>.uuid);</div><div class="line">		&#125;</div><div class="line">		BasicProperties convertedMessageProperties = <span class="keyword">this</span>.messagePropertiesConverter</div><div class="line">				.fromMessageProperties(messageProperties, encoding);</div><div class="line">        <span class="comment">// 发送消息</span></div><div class="line">		channel.basicPublish(exchange, routingKey, mandatory, convertedMessageProperties, message.getBody());</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>通过将<code>CachingConnectionFactory</code>的<code>publisherConfirms</code>和<code>publisherReturns</code>属性分别设置为“true”，支持确认和返回的消息。设置这些选项时，工厂创建的通道将被包装在<code>PublisherCallbackChannel</code>中，该通道用于方法回调。当获得这样的频道时，客户端可以使用该<code>channel</code>注册一个<code>PublisherCallbackChannel.Listener</code>。 ｀<code>PublisherCallbackChannel</code>实现包含将“确认”或“返回”路由到适当的监听器的逻辑。</p>
<p>业务操作完成后，<code>execute</code>方法会回收连接和信道资源，整个消息发送模板功能完成。</p>
<h4 id="Publisher的消息确认机制"><a href="#Publisher的消息确认机制" class="headerlink" title="Publisher的消息确认机制"></a>Publisher的消息确认机制</h4><p>当生产者发送消息的时候，需要考虑一个事情，就是这个消息是否提交成功, 是否送达到了队列中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Returns are when the broker returns a message because it&apos;s undeliverable (no matching bindings on the exchange to which the message was published, and the mandatory bit is set).</div><div class="line"></div><div class="line">Confirms are when the broker sends an ack back to the publisher, indicating that a message was successfully routed.</div></pre></td></tr></table></figure>
<p><code>returnCallback</code>：用来判断消息是否正确到达绑定的队列，如果没有队列绑定到该<code>exchange</code>，回调returnCallback接口</p>
<p><code>confirmCallback</code>：消息正确到达绑定的队列(如果设置了持久化，则消息必须持久化到磁盘)，broker返回ack，回调<code>confirmCallback</code>接口</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://www.cnblogs.com/gordonkong/p/7051220.html" target="_blank" rel="external">Spring AMQP 源码分析</a></p>
<p><a href="http://liuxing.info/%202017/06/30/Spring%20AMQP%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3/" target="_blank" rel="external">Spring AMQP中文文档</a></p>
<p><a href="https://stackoverflow.com/questions/30034092/spring-amqp-return-callback-vs-retry-callback" target="_blank" rel="external">ConfirmCallback vs ReturnCallback</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[RabbitMQ消费者分析]]></title>
      <url>http://zsr.github.io/2017/09/27/RabbitMQ%E6%B6%88%E8%B4%B9%E8%80%85%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>消息消费者有2种模式：pull或push，RabbitMQ通常使用push模式(也可以使用拉模式)，Kafka采用pull模式。push更关注实时性，pull更关注消费者消费能力。</p>
<h3 id="消费者配置"><a href="#消费者配置" class="headerlink" title="消费者配置"></a>消费者配置</h3><p><code>Java</code>项目中，一般会结合<code>spring-amqp</code>框架来使用<code>RabbitMQ</code>，<code>spring-amqp</code>底层调用<code>RabbitMQ</code>的java client来和<code>Broker</code>交互，比如我们会用如下配置来建立<code>RabbitMQ</code>的连接池、声明Queue以及指明监听者的监听行为：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">rabbit:connection-factory</span> <span class="attr">id</span>=<span class="string">"connectionFactory"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">rabbit:admin</span> <span class="attr">id</span>=<span class="string">"rabbitAdmin"</span> <span class="attr">connection-factory</span>=<span class="string">"connectionFactory"</span>/&gt;</span></div><div class="line"><span class="comment">&lt;!-- template非必须，主要用于生产者发送消息--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">rabbit:template</span> <span class="attr">id</span>=<span class="string">"template"</span> <span class="attr">connection-factory</span>=<span class="string">"connectionFactory"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">rabbit:queue</span> <span class="attr">name</span>=<span class="string">"test.queue"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">rabbit:listener-container</span> <span class="attr">connection-factory</span>=<span class="string">"connectionFactory"</span> <span class="attr">concurrency</span>=<span class="string">"1"</span> <span class="attr">prefetch</span>=<span class="string">"1"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">rabbit:listener</span> <span class="attr">ref</span>=<span class="string">"listener"</span> <span class="attr">queue-names</span>=<span class="string">"test.queue"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">rabbit:listener-container</span>&gt;</span></div></pre></td></tr></table></figure>
<p><code>concurrency</code>设置的是对每个<code>listener</code>在初始化的时候设置的并发消费者的个数，<code>prefetch</code>是每次从一次性从broker里面取的待消费的消息的个数(默认为1).</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    ConnectionFactory connectionFactory = <span class="keyword">new</span> CachingConnectionFactory(<span class="number">5672</span>);</div><div class="line">    SimpleMessageListenerContainer container = <span class="keyword">new</span> SimpleMessageListenerContainer(connectionFactory);</div><div class="line">    container.setConcurrentConsumers(<span class="number">1</span>);</div><div class="line">    container.setQueueNames(<span class="string">"spring"</span>);</div><div class="line">    container.setMessageListener(<span class="keyword">new</span> MessageListener() &#123;</div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"received: "</span> + message);</div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line">    container.start();</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="MessageListenerContainer分析"><a href="#MessageListenerContainer分析" class="headerlink" title="MessageListenerContainer分析"></a>MessageListenerContainer分析</h4><p><code>org.springframework.amqp.rabbit.listener.MessageListenerContainer</code>可以看作<code>MessageLinstener</code>的容器。<code>MessageListenerContainer</code>只包含一个<code>MessageListener</code>，可以生成多个线程使用相同的<code>MessageListener</code>同时消费消息.</p>
<p><code>MessageListenerContainer</code>继承自<code>SmartLifecycle</code>接口，该接口是Spring容器提供的与生命周期管理相关的接口，实现该接口的类会由Spring容器负责启动与停止。Spring加载和初始化所有bean后，会接着回调实现该接口的类中对应的<code>start()</code>方法.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// SimpleMessageListenerContainer.class</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doStart</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">  <span class="comment">//some code</span></div><div class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>.consumersMonitor) &#123;</div><div class="line">    <span class="keyword">int</span> newConsumers = initializeConsumers();</div><div class="line">    <span class="comment">//some code</span></div><div class="line">    Set&lt;AsyncMessageProcessingConsumer&gt; processors = <span class="keyword">new</span> HashSet&lt;AsyncMessageProcessingConsumer&gt;();</div><div class="line">    <span class="keyword">for</span> (BlockingQueueConsumer consumer : <span class="keyword">this</span>.consumers.keySet()) &#123;</div><div class="line">    	AsyncMessageProcessingConsumer processor = <span class="keyword">new</span> AsyncMessageProcessingConsumer(consumer);</div><div class="line">    	processors.add(processor);</div><div class="line">        <span class="comment">// 将消费者线程放在线程池中，每一个消费者一个线程，并发执行</span></div><div class="line">    	<span class="keyword">this</span>.taskExecutor.execute(processor);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//some code</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>doStart()</code>方法中调用<code>initializeConsumers()</code>来初始化所有的消费者，<code>AsyncMessageProcessingConsumer</code>作为真实的处理器包装了<code>BlockingQueueConsumer</code>，而且<code>AsyncMessageProcessingConsumer</code>其实实现了<code>Runnable</code>接口.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">initializeConsumers</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>.consumersMonitor) &#123;</div><div class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.consumers == <span class="keyword">null</span>) &#123;</div><div class="line">				cancellationLock.reset();</div><div class="line">				<span class="keyword">this</span>.consumers = <span class="keyword">new</span> HashSet&lt;BlockingQueueConsumer&gt;(<span class="keyword">this</span>.concurrentConsumers);</div><div class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.concurrentConsumers; i++) &#123;</div><div class="line">					BlockingQueueConsumer consumer = createBlockingQueueConsumer();</div><div class="line">					<span class="keyword">this</span>.consumers.add(consumer);</div><div class="line">					count++;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> count;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p><code>container</code>启动的时候会根据设置的<code>concurrency</code>的值创建n个<code>BlockingQueueConsumer</code></p>
<h5 id="AsyncMessageProcessingConsumer"><a href="#AsyncMessageProcessingConsumer" class="headerlink" title="AsyncMessageProcessingConsumer"></a>AsyncMessageProcessingConsumer</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// SimpleMessageListenerContainer$AsyncMessageProcessingConsumer.class</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncMessageProcessingConsumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueueConsumer consumer;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch start;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> FatalListenerStartupException startupException;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">AsyncMessageProcessingConsumer</span><span class="params">(BlockingQueueConsumer consumer)</span> </span>&#123;</div><div class="line">  	<span class="keyword">this</span>.consumer = consumer;</div><div class="line">  	<span class="keyword">this</span>.start = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">     ...some code...</div><div class="line">       </div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">      <span class="comment">// 消费者执行，每次从队列中获取prefetchCount数量的消息，放在消费者BlockingQueue中</span></div><div class="line">          consumer.start();</div><div class="line">          start.countDown();</div><div class="line">        &#125; <span class="keyword">catch</span> (FatalListenerStartupException ex) &#123;</div><div class="line">          <span class="keyword">throw</span> ex;</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">          start.countDown();</div><div class="line">          handleStartupFailure(t);</div><div class="line">          <span class="keyword">throw</span> t;</div><div class="line">        &#125;</div><div class="line">        ...some code...</div><div class="line">       </div><div class="line">        <span class="keyword">boolean</span> continuable = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">while</span> (isActive() || continuable) &#123;</div><div class="line">          <span class="comment">// isActive()表示MessageListenerContainer是否是活跃的，正常情况下都是true</span></div><div class="line">          <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// 不停的尝试从消费者queue中获取Delivery实例，将之转化为Message，然后执行MessageListener 的onMessage回调方法</span></div><div class="line">            continuable = receiveAndExecute(consumer) &amp;&amp; !isChannelTransacted();</div><div class="line">          &#125; <span class="keyword">catch</span> (ListenerExecutionFailedException ex) &#123;</div><div class="line">            <span class="comment">// 消息处理失败，不影响线程执行，继续获取消息进行处理</span></div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      ...some code...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="获取消息：consumer-start"><a href="#获取消息：consumer-start" class="headerlink" title="获取消息：consumer.start()"></a>获取消息：consumer.start()</h5><p><code>BlockingQueueConsumer</code>内部维护了一个阻塞队列<code>BlockingQueue</code>，这个queue不是对应RabbitMQ的队列，而是Consumer自己维护的内存级别的队列，用来暂时存储从RabbitMQ中取出来的消息.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// BlockingQueueConsumer.class</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Delivery&gt; queue = <span class="keyword">new</span> LinkedBlockingQueue&lt;Delivery&gt;();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> AmqpException </span>&#123;</div><div class="line">    <span class="keyword">this</span>.consumer = <span class="keyword">new</span> InternalConsumer(channel);</div><div class="line"></div><div class="line">    ...some code...</div><div class="line"></div><div class="line">    <span class="keyword">int</span> passiveDeclareTries = <span class="number">3</span>;</div><div class="line">    do &#123;</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">if</span> (!acknowledgeMode.isAutoAck()) &#123;</div><div class="line">          <span class="comment">// 声明每次获取消息数量</span></div><div class="line">          channel.basicQos(prefetchCount);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; queues.length; i++) &#123;</div><div class="line">          <span class="comment">// 声明每个队列，消息来源可能是多个队列</span></div><div class="line">          channel.queueDeclarePassive(queues[i]);</div><div class="line">        &#125;</div><div class="line">        passiveDeclareTries = <span class="number">0</span>;</div><div class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">        ...some code...</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">while</span> (passiveDeclareTries-- &gt; <span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; queues.length; i++) &#123;</div><div class="line">        <span class="comment">// 对每个队列，都会调用basicConsume方法让InternalConsumer监听当前队列</span></div><div class="line">        channel.basicConsume(queues[i], acknowledgeMode.isAutoAck(), consumer);</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">      <span class="keyword">throw</span> RabbitExceptionTranslator.convertRabbitAccessException(e);</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>调用<code>channel.basicConsume</code>后，<code>broker</code>就会不断往<code>consumer</code>投递<code>message</code>，每次<code>prefetch</code>条。<code>consumer</code>是通过异步方式来抓取<code>message</code>的，<code>BlockingQueue</code>的size是在异步地不断增长直到<code>prefetch</code>。</p>
<p>当队列接受到消息时，<code>amqp client</code>会主动调用<code>InternalConsumer</code>的<code>handleDelivery()</code>方法。该方法调用 <code>BlockingQueueConsumer.this.queue.put(new Delivery(consumerTag, envelope, properties, body))</code>将消息放到<code>BlockingQueueConsumer</code>的<code>BlockingQueue&lt;Delivery&gt; queue</code>中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// BlockingQueueConsumer$InternalConsumer.class</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span></span></div><div class="line">				<span class="keyword">throws</span> IOException &#123;</div><div class="line">		...some code...</div><div class="line">          </div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				queue.put(<span class="keyword">new</span> Delivery(envelope, properties, body));</div><div class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">				Thread.currentThread().interrupt();</div><div class="line">			&#125;</div><div class="line">		&#125;</div></pre></td></tr></table></figure>
<h5 id="处理消息"><a href="#处理消息" class="headerlink" title="处理消息"></a>处理消息</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// SimpleMessageListenerContainer$AsyncMessageProcessingConsumer.class</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doReceiveAndExecute</span><span class="params">(BlockingQueueConsumer consumer)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line"></div><div class="line">		Channel channel = consumer.getChannel();</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; txSize; i++) &#123;</div><div class="line">            <span class="comment">// 从消费者队列中获取Delivery，将之转化为 Message</span></div><div class="line">			Message message = consumer.nextMessage(receiveTimeout);</div><div class="line">			<span class="keyword">if</span> (message == <span class="keyword">null</span>) &#123;</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">              <span class="comment">// 执行MessageListener的onMessage回调方法</span></div><div class="line">				executeListener(channel, message);</div><div class="line">			&#125; <span class="keyword">catch</span> (ImmediateAcknowledgeAmqpException e) &#123;</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			&#125; <span class="keyword">catch</span> (Throwable ex) &#123;</div><div class="line">               <span class="comment">// 消息处理失败,执行channel.basicReject()</span></div><div class="line">				consumer.rollbackOnExceptionIfNecessary(ex);</div><div class="line">				<span class="keyword">throw</span> ex;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> consumer.commitIfNecessary(isChannelLocallyTransacted(channel));</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<ol>
<li>如果执行成功，则调用 AMQP 信道的<code>basicAck</code>方法确认消息消费成功。</li>
<li>如果执行过程中发生异常，则将异常转化为<code>ListenerExecutionFailedException</code>抛出。默认情况下，Spring AMQP 处理用户自定义异常的逻辑非常简单：调用 AMQP 信道的<code>basicReject</code>方法将消息退回队列，但不会打破<code>AsyncMessageProcessingConsumer</code>线程的while循环，消息消费继续进行。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">commitIfNecessary</span><span class="params">(<span class="keyword">boolean</span> locallyTransacted)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        ...some code...</div><div class="line">          </div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			<span class="keyword">boolean</span> ackRequired = !acknowledgeMode.isAutoAck() &amp;&amp; !acknowledgeMode.isManual();</div><div class="line"></div><div class="line">            <span class="comment">// 需要ack</span></div><div class="line">			<span class="keyword">if</span> (ackRequired) &#123;</div><div class="line">              ...some code...</div><div class="line">                </div><div class="line">					<span class="keyword">if</span> (!deliveryTags.isEmpty()) &#123;</div><div class="line">						<span class="keyword">long</span> deliveryTag = <span class="keyword">new</span> ArrayList&lt;Long&gt;(deliveryTags).get(deliveryTags.size() - <span class="number">1</span>);</div><div class="line">                        <span class="comment">// 发送broker消息确认，方便删除该条消息</span></div><div class="line">						channel.basicAck(deliveryTag, <span class="keyword">true</span>);</div><div class="line">					&#125;</div><div class="line">			&#125;</div><div class="line">          </div><div class="line">        ...some code...</div><div class="line">		&#125; <span class="keyword">finally</span> &#123;</div><div class="line">			deliveryTags.clear();</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p><code>org.springframework.amqp.core.AcknowledgeMode</code>定义了三种确认模式：</p>
<ul>
<li><code>NONE</code>：不确认，相当于 amqp client 中<code>Channel.basicConsume</code>方法中<code>autoAck</code>参数值设为“true”，如果是这种模式，不管业务执行是否成功，broker都会收到ack从而删除该消息</li>
<li><code>MANUAL</code>：用户通过手动控制消息确认，由业务自己确定什么时候ack(手动调用<code>channel.basicAck</code>)</li>
<li><code>AUTO</code>：Spring AMQP框架根据<code>MessageListener</code>的<code>onMessage</code>执行过程中是否抛出异常来决定是否确认消息消费</li>
</ul>
<p>Spring创建<code>CachingConnectionFactory</code>的时候，<code>AcknowledgeMode</code>默认为 AUTO；也就是业务执行失败则消息回退队列，否则broker收到ack删除该消息。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>设置并发消费除了能提高消费的速度，还有另外一个好处：当某个消费者长期阻塞，此时在当前消费者内部的<code>BlockingQueue</code>的消息也会被一直阻塞，但是新来的消息仍然可以投递给其他消费者消费，这种情况顶多会导致<code>prefetch</code>个数目的消息消费有问题，而不至于单消费者情况下整个RabbitMQ的队列会因为一个消息有问题而全部堵死。所有在合适的业务场景下，需要合理设置<code>concurrency</code>和<code>prefetch</code>值。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>[<a href="http://liuxing.info/%202017/06/30/Spring%20AMQP%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3/" target="_blank" rel="external">Spring AMQP中文文档</a>]</p>
<p>[<a href="http://www.cnblogs.com/gordonkong/p/7115155.html" target="_blank" rel="external">Spring AMQP 源码分析 MessageListener</a>]</p>
<p><a href="http://yuanwhy.com/2016/09/10/rabbitmq-concurrency-prefetch/" target="_blank" rel="external">RabbitMQ消费者的几个参数</a></p>
<p><a href="http://blog.csdn.net/catoop/article/details/71274561" target="_blank" rel="external">Spring SmartLifecycle 在容器所有bean加载和初始化完毕执行</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Spring Retry]]></title>
      <url>http://zsr.github.io/2017/09/25/Spring-Retry/</url>
      <content type="html"><![CDATA[<p>​    在很多场景中，我们需要“重试”，重试意味着反复执行一段代码直至成功，或者重试多次无果后标记失败。比如<code>MQ</code>发送消息失败，会采取重试手段，比如工程中使用<code>RPC</code>请求外部服务,可能因为网络波动出现超时而采取重试手段等等.</p>
<p>MQ自身也有重试机制,但是这种机制不是很灵活，如果某些功能没有使用MQ的话，那么就不是那么方便了.</p>
<h3 id="框架概览"><a href="#框架概览" class="headerlink" title="框架概览"></a>框架概览</h3><p><em>Spring Retry</em> 框架广泛使用于<code>Spring Batch</code>,<code>Spring Integration</code>,<code>Spring for Apache Hadoop</code>等spring项目</p>
<p>如下图所示：</p>
<p><img src="http://kriszhang.com/spring-retry/spring-retry.png" alt="spring"></p>
<p></p>
<ol>
<li><code>RetryTemplate</code>，重试模板，是进入spring-retry框架的整体流程入口</li>
<li><code>RetryCallback</code>，重试回调，用户包装业务流，第一次执行和产生重试执行都会调用这个callback代码</li>
<li><code>RetryPolicy</code>，重试策略，不同策略有不同的重试方式</li>
<li><code>BackOffPolicy</code>，两次重试之间的回避策略，一般采用超时时间机制</li>
<li><code>RecoveryCallback</code>，当所有重试都失败后，回调该接口，提供给业务重试回复机制</li>
<li><code>RetryContext</code>，每次重试都会将其作为参数传入RetryCallback中使用</li>
<li><code>RetryListener</code>，监听重试行为，主要用于监控。</li>
</ol>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">final</span> RetryTemplate retryTemplate = <span class="keyword">new</span> RetryTemplate();</div><div class="line">    </div><div class="line">    <span class="keyword">final</span> SimpleRetryPolicy policy = <span class="keyword">new</span> SimpleRetryPolicy(<span class="number">3</span>,</div><div class="line">        Collections.&lt;Class&lt;? extends Throwable&gt;, Boolean&gt; singletonMap(Exception.class, <span class="keyword">true</span>));</div><div class="line">    FixedBackOffPolicy fixedBackOffPolicy = <span class="keyword">new</span> FixedBackOffPolicy();</div><div class="line">    fixedBackOffPolicy.setBackOffPeriod(<span class="number">100</span>);</div><div class="line">    retryTemplate.setRetryPolicy(policy);</div><div class="line">    retryTemplate.setBackOffPolicy(fixedBackOffPolicy);</div><div class="line">    </div><div class="line">    <span class="keyword">final</span> RetryCallback&lt;Object, Exception&gt; retryCallback = <span class="keyword">new</span> RetryCallback&lt;Object, Exception&gt;() &#123;</div><div class="line">      <span class="function"><span class="keyword">public</span> Object <span class="title">doWithRetry</span><span class="params">(RetryContext context)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        System.out.println(<span class="string">"do some thing"</span>);</div><div class="line">        <span class="comment">// 设置context一些属性,给RecoveryCallback传递一些属性</span></div><div class="line">        context.setAttribute(<span class="string">"key"</span>, <span class="string">"value"</span>);</div><div class="line">        System.out.println(context.getRetryCount());</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"exception"</span>);</div><div class="line">      &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="comment">// 如果RetryCallback执行出现指定异常, 并且超过最大重试次数依旧出现指定异常的话,就执行RecoveryCallback动作</span></div><div class="line">    <span class="keyword">final</span> RecoveryCallback&lt;Object&gt; recoveryCallback = <span class="keyword">new</span> RecoveryCallback&lt;Object&gt;() &#123;</div><div class="line">      <span class="function"><span class="keyword">public</span> Object <span class="title">recover</span><span class="params">(RetryContext context)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        System.out.println(<span class="string">"do recory operation"</span>);</div><div class="line">        System.out.println(context.getAttribute(<span class="string">"key"</span>));</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      <span class="keyword">final</span> Object result = retryTemplate.execute(retryCallback, recoveryCallback);</div><div class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">      e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="重试策略-RetryPolicy"><a href="#重试策略-RetryPolicy" class="headerlink" title="重试策略:RetryPolicy"></a>重试策略:RetryPolicy</h4><p>重试策略定义了当操作失败时如何进行重试操作</p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fj6gaoq06cj30j00cemxi.jpg" alt="重试框架Spring retry实践"></p>
<ol>
<li><code>NeverRetryPolicy</code>：只调用RetryCallback一次，不重试</li>
<li><code>AlwaysRetryPolicy</code>：无限重试，最好不要用</li>
<li><code>SimpleRetryPolicy</code>：重试n次，默认3，也是模板默认的策略</li>
<li><code>TimeoutRetryPolicy</code>：在n毫秒内不断进行重试，超过这个时间后停止重试</li>
<li><code>ExceptionClassifierRetryPolicy</code>: 可以根据不同的异常，执行不同的重试策略</li>
</ol>
<h4 id="回退策略-BackOffPolicy-重试间隔"><a href="#回退策略-BackOffPolicy-重试间隔" class="headerlink" title="回退策略:BackOffPolicy(重试间隔)"></a>回退策略:BackOffPolicy(重试间隔)</h4><p>当操作执行失败时，根据设置的重试策略进行重试。通过BackoffPolicy可以设定再次重试的时间间隔。</p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fj6g6lddqtj30k0098mxj.jpg" alt="重试框架Spring retry实践"></p>
<ol>
<li><code>NoBackOffPolicy</code>：不回避</li>
<li><code>FixedBackOffPolicy</code>：n毫秒退避后再进行重试</li>
</ol>
<h5 id="有状态重试-OR-无状态重试"><a href="#有状态重试-OR-无状态重试" class="headerlink" title="有状态重试 OR 无状态重试"></a>有状态重试 OR 无状态重试</h5><p>所谓无状态重试是指重试在一个线程上下文中完成的重试，反之不在一个线程上下文完成重试的就是有状态重试。之前的SimpleRetryPolicy就属于无状态重试，因为重试是在一个循环中完成的。什么时候后会出现或者说需要有状态重试呢？通常有两种情况：事务回滚和熔断。</p>
<h4 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h4><p>每次有重试需求的时候都写一个<code>RetryTemplate</code>太臃肿了，使用注解可以大大简化开发，减少重复代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationService</span> </span>&#123;</div><div class="line">  <span class="keyword">public</span> Logger logger = LoggerFactory.getLogger(AnnotationService.class);</div><div class="line"></div><div class="line">  <span class="meta">@Retryable</span>(maxAttempts = <span class="number">5</span>, backoff = <span class="meta">@Backoff</span>(random = <span class="keyword">true</span>))</div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">someService</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> random = (<span class="keyword">int</span>) (Math.random() * <span class="number">10</span>);</div><div class="line">    <span class="keyword">if</span> (random &lt; <span class="number">4</span>) &#123;</div><div class="line">      logger.info(<span class="string">"random=&#123;&#125; Null Pointer Excep"</span>, random);</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (random &lt; <span class="number">9</span>) &#123;</div><div class="line">      logger.info(<span class="string">"random=&#123;&#125; Arithmetic Excep"</span>, random);</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ArithmeticException();</div><div class="line">    &#125;</div><div class="line">    logger.info(<span class="string">"random=&#123;&#125; ok !!!!"</span>, random);</div><div class="line">    <span class="keyword">return</span> <span class="string">"ok"</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Recover</span></div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">recover</span><span class="params">(NullPointerException ne)</span> </span>&#123;</div><div class="line">    logger.info(<span class="string">"&#123;&#125;"</span>, <span class="string">"NullPointerException"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="string">"null pointer recover"</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Recover</span></div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">recover</span><span class="params">(ArithmeticException ne)</span> </span>&#123;</div><div class="line">    logger.info(<span class="string">"&#123;&#125;"</span>, <span class="string">"ArithmeticException"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="string">"ArithmeticException recover"</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">  </div><div class="line"><span class="meta">@Configuration</span> <span class="comment">// 相当于xml bean容器</span></div><div class="line"><span class="meta">@EnableRetry</span></div><div class="line"><span class="meta">@EnableAspectJAutoProxy</span>(proxyTargetClass = <span class="keyword">true</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationRetryTest</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">AnnotationRetryTest</span><span class="params">()</span> </span>&#123;</div><div class="line">    System.out.println(<span class="string">"spring容器启动初始化。。。"</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Bean</span>  <span class="comment">// 注入AnnotationService</span></div><div class="line">  <span class="function"><span class="keyword">public</span> AnnotationService <span class="title">annotationService</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AnnotationService();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(AnnotationRetryTest.class);</div><div class="line">    AnnotationService annoService = context.getBean(AnnotationService.class);</div><div class="line">    String result = annoService.someService();</div><div class="line">    System.out.println(result);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li><code>@EnableRetry</code>：能否重试，<code>proxyTargetClass</code>属性为true时（默认false），使用CGLIB代理。默认使用标准JAVA注解。当类中有<code>@Retryable</code>注释的方法时，对该方法生成代理。</li>
<li><code>@Retryable</code>：注解需要被重试的方法 <ul>
<li><code>include</code> 指定处理的异常类。默认为空</li>
<li><code>exclude</code> 指定不需要处理的异常。默认为空 </li>
<li><code>vaue</code> 指定要重试的异常。默认为空 </li>
<li><code>maxAttempts</code> 最大重试次数。默认3次 </li>
<li><code>backoff</code> 重试等待策略。默认使用@Backoff注解</li>
</ul>
</li>
<li><code>@Backoff</code>：重试回退策略(立即重试还是等待一会再重试)<ul>
<li>不设置参数时，默认使用<code>FixedBackOffPolicy</code>，重试等待1000ms</li>
<li>只设置<code>delay</code>属性时，使用<code>FixedBackOffPolicy</code>，重试等待指定的毫秒数</li>
<li>当设置<code>delay</code>和<code>maxDealy</code>属性时，重试等待在这两个值之间均态分布</li>
<li>使用<code>delay</code>，<code>maxDealy</code>和<code>multiplier</code>属性时，使用<code>ExponentialBackOffPolicy</code></li>
<li>当设置<code>multiplier</code>属性不等于0时，同时也设置了random<code>属性时，使用</code>ExponentialRandomBackOffPolicy`</li>
<li><code>@Recover</code>: 用于<code>@Retryable</code>失败时的“兜底”处理方法。<code>@Recover</code>注释的方法参数为<code>@Retryable</code>异常类，返回值应与重试方法返回相同，否则无法识别！因此可以针对可能异常设置多个<code>@Recover</code>方法进行“兜底”处理。</li>
</ul>
</li>
</ol>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p><code>RetryTemplate</code>的<code>execute</code> 是线程安全的，实现逻辑使用<code>ThreadLocal</code>保存每个执行实例的<code>RetryContext</code>执行上下文。</p>
<p>这里以<code>SimpleRetryPolicy</code>和<code>FixedBackOffPolicy</code>策略为例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// RetrySynchronizationManager.class</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;RetryContext&gt; context = <span class="keyword">new</span> ThreadLocal&lt;RetryContext&gt;();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RetryContext <span class="title">register</span><span class="params">(RetryContext context)</span> </span>&#123;</div><div class="line">		RetryContext oldContext = getContext();</div><div class="line">		RetrySynchronizationManager.context.set(context);</div><div class="line">		<span class="keyword">return</span> oldContext;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> &lt;T, E extends Throwable&gt; <span class="function">T <span class="title">doExecute</span><span class="params">(RetryCallback&lt;T, E&gt; retryCallback,</span></span></div><div class="line">      RecoveryCallback&lt;T&gt; recoveryCallback, RetryState state) <span class="keyword">throws</span> E,</div><div class="line">      ExhaustedRetryException &#123;</div><div class="line"></div><div class="line">    ....some code ...</div><div class="line"></div><div class="line">    <span class="comment">// 注册当前的RetryContext，放在ThreadLocal中保证线程安全</span></div><div class="line">    RetrySynchronizationManager.register(context);</div><div class="line"></div><div class="line">    Throwable lastException = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line"></div><div class="line">      ...some code...</div><div class="line"></div><div class="line">      <span class="comment">// 判断当前context是否满足重试条件,这里是循环</span></div><div class="line">      <span class="keyword">while</span> (canRetry(retryPolicy, context) &amp;&amp; !context.isExhaustedOnly()) &#123;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">          <span class="comment">// Reset the last exception, so if we are successful</span></div><div class="line">          <span class="comment">// the close interceptors will not think we failed...</span></div><div class="line">          lastException = <span class="keyword">null</span>;</div><div class="line">          <span class="comment">// 执行自定义业务逻辑</span></div><div class="line">          <span class="keyword">return</span> retryCallback.doWithRetry(context);</div><div class="line">        &#125;<span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">          <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// 把异常e填充进context，同时重试技术加1</span></div><div class="line">            registerThrowable(retryPolicy, state, context, e);</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">catch</span> (Exception ex) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TerminatedRetryException(<span class="string">"Could not register throwable"</span>, ex);</div><div class="line">          &#125;</div><div class="line">          </div><div class="line">          <span class="keyword">if</span> (canRetry(retryPolicy, context) &amp;&amp; !context.isExhaustedOnly()) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">              <span class="comment">// 如果满足重试条件，如已重试次数小于预定次数，则线程等待预定的间隔时间</span></div><div class="line">              backOffPolicy.backOff(backOffContext);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">catch</span> (BackOffInterruptedException ex) &#123;</div><div class="line">              lastException = e;</div><div class="line">              <span class="comment">// back off was prevented by another thread - fail the retry</span></div><div class="line">              <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line">                logger.debug(<span class="string">"Abort retry because interrupted: count="</span> + context.getRetryCount());</div><div class="line">              &#125;</div><div class="line">              <span class="keyword">throw</span> ex;</div><div class="line">            &#125;</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          <span class="keyword">if</span> (shouldRethrow(retryPolicy, context, state)) &#123;</div><div class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line">              logger.debug(<span class="string">"Rethrow in retry for policy: count="</span> + context.getRetryCount());</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">throw</span> RetryTemplate.&lt;E&gt;wrapIfNecessary(e);</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (context.isExhaustedOnly()) &#123;</div><div class="line">        rethrow(context, <span class="string">"Retry exhausted after last attempt with no recovery path."</span>);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">// 所有重试都失败，处理“兜底”方法recover()</span></div><div class="line">      <span class="keyword">return</span> handleRetryExhausted(recoveryCallback, context, state);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">      <span class="keyword">throw</span> RetryTemplate.&lt;E&gt;wrapIfNecessary(e);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">finally</span> &#123;</div><div class="line">      close(retryPolicy, context, state, lastException == <span class="keyword">null</span>);</div><div class="line">      doCloseInterceptors(retryCallback, context, lastException);</div><div class="line">      RetrySynchronizationManager.clear();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// FixedBackOffPolicy.class</span></div><div class="line"><span class="keyword">private</span> Sleeper sleeper = <span class="keyword">new</span> ThreadWaitSleeper();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBackOff</span><span class="params">()</span> <span class="keyword">throws</span> BackOffInterruptedException </span>&#123;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// 时间间隔是由线程sleep实现</span></div><div class="line">			sleeper.sleep(backOffPeriod);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BackOffInterruptedException(<span class="string">"Thread interrupted while sleeping"</span>, e);</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadWaitSleeper</span> <span class="keyword">implements</span> <span class="title">Sleeper</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> backOffPeriod)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">		Thread.sleep(backOffPeriod);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://iyiguo.net/blog/2016/01/19/spring-retry-common-case/" target="_blank" rel="external">Spring Retry 常用示例</a></p>
<p><a href="http://kriszhang.com/spring-retry/" target="_blank" rel="external">利用Spring-Retry定制化你的RPC重试</a></p>
<p><a href="http://www.baeldung.com/spring-retry" target="_blank" rel="external">Guide to Spring Retry</a></p>
<p><a href="https://github.com/spring-projects/spring-retry" target="_blank" rel="external">github:spring-retry</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[连接池原理]]></title>
      <url>http://zsr.github.io/2017/09/15/%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<p>​    连接池的基本思想就是为连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立连接时，只需要从缓冲池中取出一个了，使用完毕后再放回去。</p>
<p><code>apache commons-pool</code>是apache基金会的一个开源对象池组件，我们常用的数据库连接池<code>dpcp</code>和<code>redis</code>的java客户端jedis都使用<code>commons-pool</code>来管理连接。</p>
<p>主要提供这个几种类型的对象池：</p>
<p><img src="https://www.throwsnew.com/img/GenericObjectPool.PNG" alt="类图"><br>这篇文章主要介绍<code>GenericObjectPool</code>的实现。</p>
<h3 id="工作原理："><a href="#工作原理：" class="headerlink" title="工作原理："></a>工作原理：</h3><p>连接池的核心思想是连接的复用，通过建立一个数据库连接池以及一套连接使用、分配和管理策略，使得该连接池中的连接可以得到高效，安全的复用，避免了数据库连接频繁建立和关闭的开销。</p>
<p>连接池的工作原理主要由三部分组成，分别为连接池的建立，连接池中连接的使用管理，连接池的关闭。</p>
<ol>
<li><p>连接池的建立。一般在系统初始化时，连接池会根据系统配置建立，并在池中建立几个连接对象，以便使用时能从连接池中获取，连接池中的连接不能随意创建和关闭，这样避免了连接随意建立和关闭造成的系统开销。</p>
</li>
<li><p>连接池的管理。连接池管理策略是连接池机制的核心，连接池内连接的分配和释放对系统的性能有很大的影响。其策略是：</p>
<p>当客户请求数据库连接时，首先查看连接池中是否有空闲连接，如果存在空闲连接，则将连接分配给客户使用；如果没有控线连接，则查看当前所开的连接数是否已经达到最大连接数，例如如果没有达到就重新创建一个请求的客户；如果达到，就按设定的最大等待时间进行等待，如果超出最大等待时间，则抛出异常给客户。</p>
</li>
<li><p>连接池的关闭。当应用程序退出时，关闭连接池中所有的链接，释放连接池相关资源，该过程正好与创建相反。</p>
</li>
</ol>
<a id="more"></a>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p><code>commons-pool</code>定义了一个接口<code>PooledObject</code>来封装池中的对象，添加了空闲时间，使用时间等信息和对象状态流转的行为。</p>
<h4 id="对象池定义"><a href="#对象池定义" class="headerlink" title="对象池定义"></a>对象池定义</h4><p>对象池(连接池)是我们保存对象的地方，对象的获取，归还和定时检查都通过对象池来实现。以GenericObjectPool为例，使用了线程安全的集合类来保存对象，LinkedBlockingDeque用于保存空闲的对象，ConcurrentHashMap保存全部对象.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;T, PooledObject&lt;T&gt;&gt; allObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;T, PooledObject&lt;T&gt;&gt;();</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> LinkedBlockingDeque&lt;PooledObject&lt;T&gt;&gt; idleObjects = <span class="keyword">new</span> LinkedBlockingDeque&lt;PooledObject&lt;T&gt;&gt;();</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// GenericObjectPool.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">GenericObjectPool</span><span class="params">(PooledObjectFactory&lt;T&gt; factory,</span></span></div><div class="line">            GenericObjectPoolConfig config) &#123;</div><div class="line"></div><div class="line">        ...other code...</div><div class="line"></div><div class="line">        setConfig(config);</div><div class="line"></div><div class="line">        <span class="comment">// **启动自动回收空闲连接**</span></div><div class="line">        startEvictor(getTimeBetweenEvictionRunsMillis());</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h4 id="获取连接-borrowObject"><a href="#获取连接-borrowObject" class="headerlink" title="获取连接:borrowObject"></a>获取连接:<code>borrowObject</code></h4><p>连接池借出对象时，经过<code>Abandoned</code>和<code>validate</code>两种检查，在连接池满时根据配置执行对应的等待策略，当没有可用对象时会抛出异常。</p>
<ol>
<li><code>Abandoned</code>检查目标是连接池所有被借出的对象，主要防止对象借出之后长时间被占用，不能退还（或者使用者忘记return）到连接池导致连接被耗尽。</li>
<li><code>validate</code>检查目标是当前即将被借出的对象，目的是保证提供的对象是可用的，检查方式由对象工厂的<code>validateObject</code>方法定义。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> T <span class="title">borrowObject</span><span class="params">(<span class="keyword">long</span> borrowMaxWaitMillis)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line"><span class="comment">// getNumIdle() 表示当前空闲对象数量，getNumActive() 表示当前非空闲的对象数量，getMaxTotal()表示连接池容量</span></div><div class="line"><span class="comment">// 那么假设最大容量10个，非空闲8个 &gt; 7 ，空闲对象只要少于2个，就需要开始Abandoned检查</span></div><div class="line">        AbandonedConfig ac = <span class="keyword">this</span>.abandonedConfig;</div><div class="line">        <span class="keyword">if</span> (ac != <span class="keyword">null</span> &amp;&amp; ac.getRemoveAbandonedOnBorrow() &amp;&amp;</div><div class="line">                (getNumIdle() &lt; <span class="number">2</span>) &amp;&amp;</div><div class="line">                (getNumActive() &gt; getMaxTotal() - <span class="number">3</span>) ) &#123;</div><div class="line">            removeAbandoned(ac);</div><div class="line">        &#125;</div><div class="line">        PooledObject&lt;T&gt; p = <span class="keyword">null</span>;</div><div class="line">        </div><div class="line">        <span class="comment">//blockWhenExhausted对象池耗尽时是否等待(默认为true)</span></div><div class="line">        <span class="keyword">boolean</span> blockWhenExhausted = getBlockWhenExhausted();</div><div class="line">        <span class="keyword">boolean</span> create;</div><div class="line">        <span class="keyword">long</span> waitTime = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (p == <span class="keyword">null</span>) &#123;</div><div class="line">            create = <span class="keyword">false</span>;</div><div class="line">            <span class="comment">// 设置了对象池耗尽(是否达到最大活跃数)时等待</span></div><div class="line">            <span class="keyword">if</span> (blockWhenExhausted) &#123;</div><div class="line">                <span class="comment">//从空闲队列取对象</span></div><div class="line">                p = idleObjects.pollFirst();</div><div class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="comment">//没有空闲对象 新建一个</span></div><div class="line">                    create = <span class="keyword">true</span>;</div><div class="line">                    p = create();</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="keyword">if</span> (borrowMaxWaitMillis &lt; <span class="number">0</span>) &#123;</div><div class="line">                        <span class="comment">//注意：没配置等待时间，会一直阻塞</span></div><div class="line">                        p = idleObjects.takeFirst();</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        <span class="comment">//按照配置的时间等待</span></div><div class="line">.....</div><div class="line">                        p = idleObjects.pollFirst(borrowMaxWaitMillis,</div><div class="line">                                TimeUnit.MILLISECONDS);</div><div class="line">.....</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                 <span class="comment">//等待之后还是没有空闲对象</span></div><div class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(</div><div class="line">                            <span class="string">"Timeout waiting for idle object"</span>);</div><div class="line">                &#125;</div><div class="line">                 <span class="comment">//等待之后获得对象 尝试分配对象</span></div><div class="line">                 <span class="comment">//这个方法由pooledobject实现</span></div><div class="line">                <span class="keyword">if</span> (!p.allocate()) &#123;</div><div class="line">                    p = <span class="keyword">null</span>;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">//没有配置blockWhenExhausted 不等待</span></div><div class="line">                p = idleObjects.pollFirst();</div><div class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</div><div class="line">                    create = <span class="keyword">true</span>;</div><div class="line">                    p = create();</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">"Pool exhausted"</span>);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (!p.allocate()) &#123;</div><div class="line">                    p = <span class="keyword">null</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//对象分配成功</span></div><div class="line">            <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                   <span class="comment">//激活对象</span></div><div class="line">                    factory.activateObject(p);</div><div class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        destroy(p);</div><div class="line">                    &#125; <span class="keyword">catch</span> (Exception e1) &#123;</div><div class="line">                    &#125;</div><div class="line">                    p = <span class="keyword">null</span>;</div><div class="line">                    .....</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//如果配置了对象检查</span></div><div class="line">                <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; (getTestOnBorrow() || create &amp;&amp; getTestOnCreate())) &#123;</div><div class="line">                    <span class="keyword">boolean</span> validate = <span class="keyword">false</span>;</div><div class="line">                    Throwable validationThrowable = <span class="keyword">null</span>;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        validate = factory.validateObject(p);</div><div class="line">                    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">                        PoolUtils.checkRethrow(t);</div><div class="line">                        validationThrowable = t;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span> (!validate) &#123;</div><div class="line">                    <span class="comment">//验证失败 销毁对象</span></div><div class="line">                        <span class="keyword">try</span> &#123;</div><div class="line">                            destroy(p);</div><div class="line">                         destroyedByBorrowValidationCount.incrementAndGet();</div><div class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                        &#125;</div><div class="line">                        p = <span class="keyword">null</span>;</div><div class="line">                        .....</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//更新借出时间等信息</span></div><div class="line">        updateStatsBorrow(p, waitTime);</div><div class="line">        <span class="keyword">return</span> p.getObject();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>1) 当客户请求数据库连接时，首先查看连接池中是否有空闲连接;</p>
<p>2) 如果存在空闲连接，则将连接分配给客户使用；如果没有空闲连接，则查看当前所开的连接数是否已经达到最大连接数;</p>
<p>3) 如果没有达到就重新创建一个连接；如果达到最大连接数，就按设定的最大等待时间进行等待，如果超出最大等待时间，则抛出异常给客户。</p>
<h4 id="释放连接-returnObject"><a href="#释放连接-returnObject" class="headerlink" title="释放连接:returnObject"></a>释放连接:<code>returnObject</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// GenericObjectPool.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnObject</span><span class="params">(T obj)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">// 从allObjects中获取要归还的连接</span></div><div class="line">        PooledObject&lt;T&gt; p = allObjects.get(obj);</div><div class="line"></div><div class="line">        ...other code...</div><div class="line"></div><div class="line">        <span class="keyword">int</span> maxIdleSave = getMaxIdle();</div><div class="line">        <span class="comment">// 如果idleObjects空闲队列中连接数已经&gt;=允许的最大空闲连接数或者连接池已经关闭就直接销毁这个连接</span></div><div class="line">        <span class="keyword">if</span> (isClosed() || maxIdleSave &gt; -<span class="number">1</span> &amp;&amp; maxIdleSave &lt;= idleObjects.size()) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">               <span class="comment">// 销毁连接</span></div><div class="line">                destroy(p);</div><div class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                swallowException(e);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123; </div><div class="line">          <span class="comment">// 将连接放入到idleObjects队列中, 一旦将连接放入到idleObjects中如果连接长时间不被使用就会被自动回收</span></div><div class="line">            <span class="keyword">if</span> (getLifo()) &#123; </div><div class="line">              <span class="comment">// 默认是使用last in first out机制(后进先出)</span></div><div class="line">                idleObjects.addFirst(p);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                idleObjects.addLast(p);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        updateStatsReturn(activeTime);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>1) 从<code>allObjects</code>中获取要归还的连接</p>
<p>2) 如果<code>idleObjects</code>空闲队列中连接数已经&gt;=允许的最大空闲连接数或者连接池已经关闭就直接销毁这个连接</p>
<p>3) 否则，将连接放入到<code>idleObjects</code>队列中, 一旦将连接放入到<code>idleObjects</code>中如果连接长时间不被使用就会被自动回收(由后台驱逐线程回收空闲连接)</p>
<h4 id="销毁连接"><a href="#销毁连接" class="headerlink" title="销毁连接"></a>销毁连接</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">(PooledObject&lt;T&gt; toDestory)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        toDestory.invalidate();</div><div class="line">        idleObjects.remove(toDestory);</div><div class="line">        allObjects.remove(toDestory.getObject());</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            factory.destroyObject(toDestory);</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            destroyedCount.incrementAndGet();</div><div class="line">            createCount.decrementAndGet();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h4 id="回收空闲连接-evict"><a href="#回收空闲连接-evict" class="headerlink" title="回收空闲连接:evict"></a>回收空闲连接:<code>evict</code></h4><h5 id="启动驱逐者线程"><a href="#启动驱逐者线程" class="headerlink" title="启动驱逐者线程"></a>启动驱逐者线程</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//GenericObjectPool.java</span></div><div class="line"><span class="comment">//构造方法中启动驱逐者线程</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">GenericObjectPool</span><span class="params">(PooledObjectFactory&lt;T&gt; factory,</span></span></div><div class="line">            GenericObjectPoolConfig config) &#123;</div><div class="line">        ...</div><div class="line">        startEvictor(getTimeBetweenEvictionRunsMillis());</div><div class="line">        ...</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//父类BaseGenericObjectPool.java</span></div><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">startEvictor</span><span class="params">(<span class="keyword">long</span> delay)</span> </span>&#123;</div><div class="line">        <span class="comment">//evictionLock对象锁</span></div><div class="line">        <span class="keyword">synchronized</span> (evictionLock) &#123;</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != evictor) &#123;</div><div class="line">                <span class="comment">//已存在evictor，取消当前驱逐者线程；重新启动另一个驱逐者线程</span></div><div class="line">                EvictionTimer.cancel(evictor);</div><div class="line">                evictor = <span class="keyword">null</span>;</div><div class="line">                evictionIterator = <span class="keyword">null</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (delay &gt; <span class="number">0</span>) &#123;</div><div class="line">                evictor = <span class="keyword">new</span> Evictor();</div><div class="line">                EvictionTimer.schedule(evictor, delay, delay);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>驱逐者<code>Evictor</code>,在<code>BaseGenericObjectPool</code>中定义，本质是由<code>java.util.TimerTask</code>定义的定时任务.</p>
<h5 id="驱逐者线程执行"><a href="#驱逐者线程执行" class="headerlink" title="驱逐者线程执行"></a>驱逐者线程执行</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//BaseGenericObjectPool内部类Evictor</span></div><div class="line"><span class="comment">//作用：驱逐空闲对象</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Evictor</span> <span class="keyword">extends</span> <span class="title">TimerTask</span> </span>&#123;</div><div class="line">    </div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            ClassLoader savedClassLoader =</div><div class="line">                    Thread.currentThread().getContextClassLoader();</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">// 切换到当前连接池的classLoader</span></div><div class="line">                Thread.currentThread().setContextClassLoader(</div><div class="line">                        factoryClassLoader);</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="comment">//执行evict()方法</span></div><div class="line">                    evict();</div><div class="line">                &#125; <span class="keyword">catch</span>(Exception e) &#123;</div><div class="line">                    swallowException(e);</div><div class="line">                &#125; <span class="keyword">catch</span>(OutOfMemoryError oome) &#123;</div><div class="line">                    oome.printStackTrace(System.err);</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// 驱逐之后还要保证空闲连接数量不能小于配置</span></div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    ensureMinIdle();</div><div class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                    swallowException(e);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                <span class="comment">// 切换回之前的classLoader</span></div><div class="line">                Thread.currentThread().setContextClassLoader(savedClassLoader);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>驱逐者线程<code>Evictor</code>被多个连接池共享,但是这些连接池可能属于不同的<code>classloader</code>,所以<code>Evictor</code>必须要保证它的所有行为在<strong>当前这个连接池的classloader</strong>下执行</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://throwsnew.com/2017/06/12/commons-pool/" target="_blank" rel="external">如何设计一个连接池：commons-pool2源码分析</a></p>
<p><a href="https://juejin.im/entry/592fec83a0bb9f0058a79876" target="_blank" rel="external">Jedis 源码阅读之连接池</a></p>
<p><a href="http://www.cnblogs.com/newpanderking/p/3875749.html" target="_blank" rel="external">数据库连接池的工作原理</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/21404377" target="_blank" rel="external">数据源连接池的原理及Tomcat中的应用</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Tomcat线程池]]></title>
      <url>http://zsr.github.io/2017/09/15/Tomcat%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      <content type="html"><![CDATA[<p>JDK只有两种典型的线程池，<code>FixedPool</code> 与 <code>CachedPool</code>：</p>
<ul>
<li><code>FixedPool</code>：固定线程数，忙不过来的全放到无限长的缓冲队列里。</li>
<li><code>CachedPool</code>：忙不过来时无限的增加临时线程，闲时回落，没有缓冲队列。</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ScheduledExecutorService定时原理]]></title>
      <url>http://zsr.github.io/2017/09/08/ScheduledExecutorService%E5%AE%9A%E6%97%B6%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<h3 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h3><p>JUC 包中的 Executor 架构带来了线程的创建与执行的分离。<code>Executor</code> 的继承者 <code>ExecutorService</code> 下面衍生出了两个重要的实现类，他们分别是</p>
<ul>
<li><code>ThreadPoolExecutor</code> 线程池</li>
<li><code>ScheduledThreadPoolExecutor</code>继承了<code>ThreadPoolExecutor</code>, 支持周期性任务的线程池</li>
</ul>
<p>通过 <code>ThreadPoolExecutor</code> 可以实现各式各样的自定义线程池，而 <code>ScheduledThreadPoolExecutor</code> 类则在自定义线程池的基础上增加了周期性执行任务的功能。</p>
<p><img src="https://segmentfault.com/img/bVHU6v?w=437&amp;h=384" alt="img"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[AbstractQueuedSynchronizer]]></title>
      <url>http://zsr.github.io/2017/07/26/AbstractQueuedSynchronizer/</url>
      <content type="html"><![CDATA[<h3 id="AbstractQueuedSynchronizer介绍"><a href="#AbstractQueuedSynchronizer介绍" class="headerlink" title="AbstractQueuedSynchronizer介绍"></a><code>AbstractQueuedSynchronizer</code>介绍</h3><p>JDK1.5中提供的<code>java.util.concurrent</code>包中的大多数的同步器(<code>Synchronizer</code>)如<code>Lock</code>, <code>Semaphore</code>, <code>Latch</code>, <code>Barrier</code>等，这些类之间大多可以互相实现，如使用Lock实现一个Semaphore或者反过来，但是它们都是基于<code>java.util.concurrent.locks.AbstractQueuedSynchronizer</code>这个类的框架实现的</p>
<p><code>AbstractQueuedSynchronizer</code>，队列同步器，简称<code>AQS</code>，它是java并发用来构建锁或者其他同步组件的基础框架。</p>
<p>一般使用<code>AQS</code>的主要方式是继承，子类通过实现它提供的抽象方法来管理同步状态，主要管理的方式是通过<code>tryAcquire</code>和<code>tryRelease</code>类似的方法来操作状态.</p>
<p>AQS本身是没有实现任何同步接口的，它仅仅只是定义了同步状态的获取和释放的方法来供自定义的同步组件的使用。在java的同步组件中，AQS的子类一般是同步组件的静态内部类。同步组件是面向使用者的，它定义了使用者与组件交互的接口，隐藏了具体的实现细节；而AQS面向的是同步组件的实现者，它简化了具体的实现方式，屏蔽了线程切换相关底层操作.</p>
<h3 id="AQS源码分析"><a href="#AQS源码分析" class="headerlink" title="AQS源码分析"></a><code>AQS</code>源码分析</h3><p>AQS的实现依赖内部的同步队列（<strong>FIFO双向队列</strong>）来完成同步状态的管理，假如当前线程获取同步状态失败，AQS会将该线程以及等待状态等信息构造成一个<code>Node</code>，并将其加入同步队列，同时阻塞当前线程。当同步状态释放时，唤醒队列的首节点。</p>
<h4 id="Node"><a href="#Node" class="headerlink" title="Node"></a><code>Node</code></h4><p><code>Node</code>主要包含以下成员变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</div><div class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</div><div class="line">        <span class="keyword">volatile</span> Node prev;</div><div class="line">        <span class="keyword">volatile</span> Node next;</div><div class="line">        <span class="keyword">volatile</span> Thread thread;</div><div class="line">        Node nextWaiter;</div><div class="line">        ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>waitStatus</code>：节点状态，主要有这几种状态：<ol>
<li><code>CANCELLED</code>：当前线程等待已经取消，是唯一一个大于0的状态；</li>
<li><code>SIGNAL</code>：当前节点的后继节点需要运行；</li>
<li><code>CONDITION</code>：当前节点在等待condition；</li>
<li><code>PROPAGATE</code>：当前场景下后续的acquireShared可以执行；</li>
</ol>
</li>
<li><code>prev</code>：前驱节点；</li>
<li><code>next</code>：后继节点；</li>
<li><code>thread</code>：进入队列的当前线程；</li>
<li><code>nextWaiter</code>：存储condition队列中的后继节点;</li>
</ul>
<p><code>Node</code>是<code>sync</code>队列和<code>condition</code>队列构建的基础，AQS拥有三个成员变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">    * Head of the wait queue, lazily initialized.  Except for</div><div class="line">    * initialization, it is modified only via method setHead.  Note:</div><div class="line">    * If head exists, its waitStatus is guaranteed not to be</div><div class="line">    * CANCELLED.</div><div class="line">    */</div><div class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line">    * Tail of the wait queue, lazily initialized.  Modified only via</div><div class="line">    * method enq to add new wait node.</div><div class="line">    */</div><div class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line">    * The synchronization state.</div><div class="line">    */</div><div class="line">   <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</div></pre></td></tr></table></figure>
<ul>
<li><code>同步队列插入节点</code></li>
</ul>
<p>当线程在获取锁的过程中被阻塞之后，这个线程会被包装成一个Node节点并被添加到线程同步队列之中，AQS提供基于CAS的设置尾节点的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetTail</span><span class="params">(Node expect, Node update)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> unsafe.compareAndSwapObject(<span class="keyword">this</span>, tailOffset, expect, update);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>假如现在有多个线程同时被阻塞，那么各个线程所获取的尾节点就有可能相同，线程就不能被正确地添加到同步队列中去了，使用<code>compareAndSetTail(Node expect,Node update)</code>来对加入同步队列的线程进行安全地插入</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5223907-4e4832f2be36aa4c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<ul>
<li><p><code>节点删除</code><br>同步队列遵循FIFO，首节点是获取同步状态成功的节点，首节点的线程在释放同步状态之后将会唤醒后继节点，后继节点将会在获取同步状态成功的时候将自己设置为首节点。</p>
<p>​</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5223907-a387fd4657047c14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p>​</p>
<p>设置首节点是由获取同步状态成功的线程来完成，因为每次只会有一个线程能够成功的获取到同步状态，所以，设置首节点并不需要CAS来保证。</p>
<p>​</p>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CyclicBarrier]]></title>
      <url>http://zsr.github.io/2017/07/26/CyclicBarrier/</url>
      <content type="html"><![CDATA[<p><code>CountDownLatch</code>和<code>CyclicBarrier</code>是jdk concurrent包下非常有用的两个并发工具类，它们提供了一种控制并发流程的手段。</p>
<h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><p><code>CyclicBarrier</code>，让一组线程到达一个同步点后再一起继续运行，其中任意一个线程未达到同步点，其他到达的线程均会被阻塞。</p>
<ul>
<li><strong>CountDownLatch</strong> : 一个或者多个线程，等待其他多个线程完成某件事情之后才能执行；</li>
<li><strong>CyclicBarrier</strong>: 多个线程互相等待，直到到达同一个同步点，再继续一起执行。</li>
</ul>
<p>对于<code>CountDownLatch</code>来说，重点是“一个线程（多个线程）等待”，而其他的N个线程在完成“某件事情”之后，可以终止，也可以等待。而对于CyclicBarrier，重点是多个线程，在任意一个线程没有完成，所有的线程都必须等待。</p>
<p>CountDownLatch是计数器，线程完成一个记录一个，只不过计数不是递增而是递减，而CyclicBarrier更像是一个阀门，需要所有线程都到达，阀门才能打开，然后继续执行。</p>
<h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>假设有只有的一个场景：每个线程代表一个跑步运动员，当运动员都准备好后，才一起出发，只要有一个人没有准备好，大家都等待.</p>
<ul>
<li><code>Runner.java</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.zsr.test.cyclicBarrier;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Runner</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> CyclicBarrier barrier;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> String name;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Runner</span><span class="params">(CyclicBarrier barrier, String name)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>();</div><div class="line">    <span class="keyword">this</span>.barrier = barrier;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      Thread.sleep(<span class="number">100</span>);</div><div class="line">      System.out.println(name + <span class="string">" 准备OK."</span>);</div><div class="line">      barrier.await();</div><div class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">      e.printStackTrace();</div><div class="line">    &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</div><div class="line">      e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">    System.out.println(name + <span class="string">" Go!!"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>CyclicBarrierTest.java</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.zsr.test.cyclicBarrier;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</div><div class="line">    CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">3</span>);</div><div class="line"></div><div class="line">    ExecutorService executor = Executors.newFixedThreadPool(<span class="number">3</span>);</div><div class="line">    executor.submit(<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runner(barrier, <span class="string">"zhangsan"</span>)));</div><div class="line">    executor.submit(<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runner(barrier, <span class="string">"lisi"</span>)));</div><div class="line">    executor.submit(<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runner(barrier, <span class="string">"wangwu"</span>)));</div><div class="line"></div><div class="line">    executor.shutdown();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="CyclicBarrier源码分析"><a href="#CyclicBarrier源码分析" class="headerlink" title="CyclicBarrier源码分析"></a><code>CyclicBarrier</code>源码分析</h4><ul>
<li>构造方法</li>
</ul>
<p><code>CyclicBarrier</code>提供两个构造方法<code>CyclicBarrier(int parties)</code>和<code>CyclicBarrier(int parties, Runnable barrierAction)</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(parties, <span class="keyword">null</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>默认构造方法，参数表示拦截的线程数量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</div><div class="line">        <span class="keyword">this</span>.parties = parties;</div><div class="line">        <span class="keyword">this</span>.count = parties;</div><div class="line">        <span class="keyword">this</span>.barrierCommand = barrierAction;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于线程之前的调度是由CPU决定的，所以默认的构造方法无法设置线程执行优先级，CyclicBarrier提供一个更高级的构造函数<code>CyclicBarrier(int parties, Runnable barrierAction)</code>，用于在线程到达同步点时，优先执行线程barrierAction，这样可以更加方便的处理一些负责的业务场景。</p>
<ul>
<li><code>await</code>方法</li>
</ul>
<p>创建<code>CyclicBarrier</code>后，每个线程调用<code>await</code>方法告诉<code>CyclicBarrier</code>自己已经到达同步点，然后当前线程被阻塞。接下来我们来看看<code>await</code>方法的具体实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">return</span> dowait(<span class="keyword">false</span>, <span class="number">0L</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(toe); <span class="comment">// cannot happen;</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></div><div class="line">        <span class="keyword">throws</span> InterruptedException,</div><div class="line">               BrokenBarrierException,</div><div class="line">               TimeoutException &#123;</div><div class="line">        <span class="keyword">return</span> dowait(<span class="keyword">true</span>, unit.toNanos(timeout));</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><code>CyclicBarrier</code>同样提供带超时时间的await和不带超时时间的<code>await</code></p>
<ul>
<li><code>dowait</code>方法</li>
</ul>
<ol>
<li>在<code>dowait</code>的前段部分，主要完成了当所有线程都到达同步点（barrier）时，唤醒所有的等待线程，一起往下继续运行，可根据参数<code>barrierAction</code>决定优先执行的线程。</li>
<li>在<code>dowait</code>的实现后半部分，主要实现了线程未到达同步点（barrier）时，线程进入<code>Condition</code>自旋等待，直到等待超时或者所有线程都到达barrier时被唤醒。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dowait</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></div><div class="line">        <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</div><div class="line">               TimeoutException &#123;</div><div class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</div><div class="line">        lock.lock();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">final</span> Generation g = generation;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (g.broken)</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123;</div><div class="line">                breakBarrier();</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">           <span class="keyword">int</span> index = --count;</div><div class="line">           <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></div><div class="line">               <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</div><div class="line">               <span class="keyword">try</span> &#123;</div><div class="line">                   <span class="keyword">final</span> Runnable command = barrierCommand;</div><div class="line">                   <span class="keyword">if</span> (command != <span class="keyword">null</span>)</div><div class="line">                       command.run();</div><div class="line">                   ranAction = <span class="keyword">true</span>;</div><div class="line">                   nextGeneration();</div><div class="line">                   <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">               &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                   <span class="keyword">if</span> (!ranAction)</div><div class="line">                       breakBarrier();</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line"></div><div class="line">            <span class="comment">// loop until tripped, broken, interrupted, or timed out</span></div><div class="line">            <span class="keyword">for</span> (;;) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="keyword">if</span> (!timed)</div><div class="line">                        trip.await();</div><div class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</div><div class="line">                        nanos = trip.awaitNanos(nanos);</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</div><div class="line">                    <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</div><div class="line">                        breakBarrier();</div><div class="line">                        <span class="keyword">throw</span> ie;</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        <span class="comment">// We're about to finish waiting even if we had not</span></div><div class="line">                        <span class="comment">// been interrupted, so this interrupt is deemed to</span></div><div class="line">                        <span class="comment">// "belong" to subsequent execution.</span></div><div class="line">                        Thread.currentThread().interrupt();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (g.broken)</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (g != generation)</div><div class="line">                    <span class="keyword">return</span> index;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</div><div class="line">                    breakBarrier();</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>在整个dowait：</p>
<ol>
<li>使用ReentrantLock保证每一次操作线程安全；</li>
<li>线程等待/唤醒使用Lock配合Condition来实现；</li>
<li>线程被唤醒的条件：等待超时或者所有线程都到达barrier。</li>
</ol>
</blockquote>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p><code>CyclicBarrier</code>就是一个栅栏，等待所有线程到达后再执行相关的操作。<code>CyclicBarrier</code>在释放等待线程后可以重用。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CountDownLatch]]></title>
      <url>http://zsr.github.io/2017/07/26/CountDownLatch/</url>
      <content type="html"><![CDATA[<p><code>CountDownLatch</code>和<code>CyclicBarrier</code>是jdk concurrent包下非常有用的两个并发工具类，它们提供了一种控制并发流程的手段。</p>
<h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p><code>CountDownLatch</code>允许一个或多个线程等待其他线程完成操作。</p>
<p><code>CountDownLatch</code>可以把它看作一个计数器，只不过这个计数器的操作是原子操作，同时只能有一个线程去操作这个计数器，也就是同时只能有一个线程去减这个计数器里面的值。</p>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>有一个任务想要往下执行，但必须要等到其他的任务执行完毕后才可以继续往下执行。假如我们这个想要继续往下执行的任务调用一个<code>CountDownLatch</code>对象的<code>await()</code>方法，其他的任务执行完自己的任务后调用同一个<code>CountDownLatch</code>对象上的<code>countDown()</code>方法则计数减1，这个调用<code>await()</code>方法的任务将一直阻塞等待，直到这个<code>CountDownLatch</code>对象的计数值减到0为止。</p>
<h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>比如：有2个工人在为老板干活，当2个工人把一天的活都干完了的时候，老板就来检查所有工人所干的活。记住这个条件：三个工人先全部干完活，老板才检查。所以在这里设计两个类，Worker代表工人，Boss代表老板。代码如下：</p>
<ul>
<li><code>Worker.java</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.zsr.test.countDownLatch;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> CountDownLatch downLatch;</div><div class="line">  <span class="keyword">private</span> String name;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(CountDownLatch downLatch, String name)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.downLatch = downLatch;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.doWork();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      TimeUnit.SECONDS.sleep(<span class="number">10</span>);</div><div class="line">    &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</div><div class="line">    &#125;</div><div class="line">    System.out.println(<span class="keyword">this</span>.name + <span class="string">"活干完了!"</span>);</div><div class="line">    <span class="keyword">this</span>.downLatch.countDown();</div><div class="line"></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</div><div class="line">    System.out.println(<span class="keyword">this</span>.name + <span class="string">"正在干活!"</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>Boss.java</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.zsr.test.countDownLatch;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Boss</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> CountDownLatch downLatch;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Boss</span><span class="params">(CountDownLatch downLatch)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.downLatch = downLatch;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    System.out.println(<span class="string">"老板正在等所有的工人干完活......"</span>);</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      <span class="keyword">this</span>.downLatch.await();</div><div class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">    &#125;</div><div class="line">    System.out.println(<span class="string">"工人活都干完了，老板开始检查了！"</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>CountDownLatchTest.java</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.zsr.test.countDownLatch;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchTest</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    ExecutorService executor = Executors.newCachedThreadPool();</div><div class="line">    CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</div><div class="line"></div><div class="line">    Worker w1 = <span class="keyword">new</span> Worker(latch, <span class="string">"张三"</span>);</div><div class="line">    Worker w2 = <span class="keyword">new</span> Worker(latch, <span class="string">"李四"</span>);</div><div class="line"></div><div class="line">    Boss boss = <span class="keyword">new</span> Boss(latch);</div><div class="line"></div><div class="line">    executor.execute(w2);</div><div class="line">    executor.execute(w1);</div><div class="line">    executor.execute(boss);</div><div class="line"></div><div class="line">    executor.shutdown();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="CountDownLatch源码分析"><a href="#CountDownLatch源码分析" class="headerlink" title="CountDownLatch源码分析"></a>CountDownLatch源码分析</h4><ul>
<li>自定义同步器<code>Sync</code>实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">/**</span></div><div class="line">     * Synchronization control For CountDownLatch.</div><div class="line">     * Uses AQS state to represent count.</div><div class="line">     */</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4982264981922014374L</span>;</div><div class="line"></div><div class="line">        Sync(<span class="keyword">int</span> count) &#123;</div><div class="line">            setState(count);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> getState();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</div><div class="line">            <span class="comment">// Decrement count; signal when transition to zero</span></div><div class="line">            <span class="keyword">for</span> (;;) &#123;</div><div class="line">                <span class="keyword">int</span> c = getState();</div><div class="line">                <span class="keyword">if</span> (c == <span class="number">0</span>)</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</div><div class="line">                <span class="keyword">if</span> (compareAndSetState(c, nextc))</div><div class="line">                    <span class="keyword">return</span> nextc == <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>构造方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count &lt; 0"</span>);</div><div class="line">       <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>从构造方法的具体实现可以看出，通过构造方法传入的int型参数count其实就是同步器的状态。</p>
<ul>
<li><code>countDown</code>方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</div><div class="line">        sync.releaseShared(<span class="number">1</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>整个<code>countDown</code>只做了一件事情，释放同步状态，同步状态在这里的实际意义也就是需要等待的完成的点的数量，只要每完成一个点，就调用countDown方法释放同步状态。</p>
<ul>
<li><code>await</code>方法</li>
</ul>
<p><code>CountDownLatch</code>提供带超时时间的<code>await</code>和不带超时时间的<code>await</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        sync.acquireSharedInterruptibly(<span class="number">1</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><code>await</code>的实质是在获取同步状态，同步状态state == 0成立，当前等待完成的点均已完成，主线程继续往下执行，否则，主线程进入等待队列自旋等待直到同步状态释放后state == 0。有些时候主线程是不能一直自旋等待，这个时候带超时时间的await就派上用场了，设置超时时间，如果在指定时间内N个点都未完成，返回false，主线程不再等待，继续往下执行。</p>
<h4 id="CountDownLatch总结"><a href="#CountDownLatch总结" class="headerlink" title="CountDownLatch总结"></a>CountDownLatch总结</h4><p><code>CountDownLatch</code>实质上就是一个<code>AQS</code>计数器，通过<code>AQS</code>来实现线程的等待与唤醒。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[redis 分布式锁]]></title>
      <url>http://zsr.github.io/2017/07/05/redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
      <content type="html"><![CDATA[<h3 id="基于redis实现分布式锁"><a href="#基于redis实现分布式锁" class="headerlink" title="基于redis实现分布式锁"></a>基于redis实现分布式锁</h3><p>分布式锁都是借助第三方来管理锁，以达到多应用直接共同享有一把锁。比较常用且轻量级的就是基于redis实现。</p>
<p>实现原理：Redis为单进程单线程模式，采用队列模式将并发访问变成串行访问，且多客户端对Redis的连接并不存在竞争关系。其次Redis提供一些命令SETNX，GETSET，可以方便实现分布式锁机制。</p>
<p>SETNX命令（SET if Not eXists） 语法： SETNX key value 功能： </p>
<ul>
<li>当且仅当 key 不存在，返回1，则该客户端获得锁，把key的键值设置为value表示该键已被锁定，该客户端最后可以通过DEL key来释放该锁(获取锁后必须要释放)；</li>
<li>若给定的 key 已经存在，返回0，表明该锁已被其他客户端取得，这时我们可以先返回或进行重试等对方完成或等待锁超时。</li>
</ul>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>如果获取锁的客户端端执行时间过长，进程被kill掉，或者因为其他异常崩溃，导致无法释放锁，就会造成死锁。所以，需要对加锁要做时效性检测。因此，我们在加锁时，把当前时间戳作为value存入此锁中，通过当前时间戳和Redis中的时间戳进行对比，如果超过一定差值，认为锁已经时效，防止锁无限期的锁下去，但是，在大并发情况，如果同时检测锁失效，并简单粗暴的删除死锁，再通过SETNX上锁，可能会导致竞争条件的产生，即多个客户端同时获取锁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">C1 获取锁，并崩溃。C2和C3调用SETNX上锁返回0后，获得foo.lock(key)的时间戳，通过比对时间戳，发现锁超时。</div><div class="line">C2 向foo.lock发送DEL命令。</div><div class="line">C2 向foo.lock发送SETNX获取锁。</div><div class="line">C3 向foo.lock发送DEL命令，此时C3发送DEL时，其实DEL掉的是C2的锁。</div><div class="line">C3 向foo.lock发送SETNX获取锁。</div></pre></td></tr></table></figure>
<p>此时C2和C3都获取了锁，产生竞争条件，如果在更高并发的情况，可能会有更多客户端获取锁。所以，DEL锁的操作，不能直接使用在锁超时的情况下，幸好有GETSET方法，假设现在有另外一个客户端C4，看看如何使用GETSET方式，避免这种情况产生。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">C4 发送SETNX lock.foo 想要获得锁，由于C1还持有锁，所以Redis返回给C4一个0</div><div class="line">C4 发送GET lock.foo 以检查锁是否超时了，如果没超时，则等待或重试。反之，如果已超时，C4通过下面的操作来尝试获得锁：</div><div class="line">	GETSET lock.foo &lt;current Unix time + lock timeout + 1&gt;</div><div class="line">通过GETSET，C4拿到的时间戳如果仍然是超时的，那就说明，C4如愿以偿拿到锁了。</div><div class="line">如果在C4之前，有个叫C5的客户端比C4快一步执行了上面的操作，那么C4拿到的时间戳是个未超时的值，这时，C4没有如期获得锁，需要再次等待或重试。注意：尽管C4没拿到锁，但它改写了C5设置的锁的超时值，不过这一点非常微小的误差带来的影响可以忽略不计。</div></pre></td></tr></table></figure>
<p><strong>注意：</strong>为了让分布式锁的算法更稳键些，持有锁的客户端在解锁之前应该再检查一次自己的锁是否已经超时，再去做DEL操作，因为可能客户端因为某个耗时的操作而挂起，操作完的时候锁因为超时已经被别人获得，这时就不必解锁了。</p>
<h4 id="分布式锁的问题"><a href="#分布式锁的问题" class="headerlink" title="分布式锁的问题"></a>分布式锁的问题</h4><ol>
<li>必要的超时机制：获取锁的客户端一旦崩溃，一定要有过期机制，否则其他客户端都降无法获取锁，造成死锁问题。</li>
<li>分布式锁，多客户端的时间戳不能保证严格意义的一致性，所以在某些特定因素下，有可能存在锁串的情况。要适度的机制，可以承受小概率的事件产生。</li>
<li>只对关键处理节点加锁，良好的习惯是，把相关的资源准备好，比如连接数据库后，调用加锁机制获取锁，直接进行操作，然后释放，尽量减少持有锁的时间。</li>
<li>在持有锁期间要不要CHECK锁，如果需要严格依赖锁的状态，最好在关键步骤中做锁的CHECK检查机制，但是根据我们的测试发现，在大并发时，每一次CHECK锁操作，都要消耗掉几个毫秒，而我们的整个持锁处理逻辑才不到10毫秒，玩客没有选择做锁的检查。</li>
<li>为了减少对Redis的压力，获取锁尝试时，循环之间一定要做sleep操作。但是sleep时间是多少是门学问。需要根据自己的Redis的QPS，加上持锁处理时间等进行合理计算。</li>
</ol>
<h3 id="实现基于redis的锁"><a href="#实现基于redis的锁" class="headerlink" title="实现基于redis的锁"></a>实现基于redis的锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.zsr.test.redislock;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.slf4j.Logger;</div><div class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</div><div class="line"><span class="keyword">import</span> org.springframework.dao.DataAccessException;</div><div class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnection;</div><div class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisCallback;</div><div class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</div><div class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 实现分布式锁</div><div class="line"> */</div><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisLock</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(RedisLock.class);</div><div class="line"></div><div class="line">  <span class="keyword">private</span> RedisTemplate redisTemplate;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_ACQUIRY_RESOLUTION_MILLIS = <span class="number">100</span>;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * Lock key path.</div><div class="line">   */</div><div class="line">  <span class="keyword">private</span> String lockKey;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 锁超时时间，防止线程在入锁以后，无限的执行等待</div><div class="line">   */</div><div class="line">  <span class="keyword">private</span> <span class="keyword">int</span> expireMsecs = <span class="number">1000</span>;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 锁等待时间，防止线程饥饿</div><div class="line">   */</div><div class="line">  <span class="keyword">private</span> <span class="keyword">int</span> timeoutMsecs = <span class="number">1000</span>;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 锁到期时间</div><div class="line">   */</div><div class="line">  <span class="keyword">private</span> String expiresStr = <span class="string">""</span>;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> locked = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * Detailed constructor with default acquire timeout 10000 msecs and lock expiration of 60000</div><div class="line">   * msecs.</div><div class="line">   *</div><div class="line">   * <span class="doctag">@param</span> lockKey lock key (ex. account:1, ...)</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RedisLock</span><span class="params">(String lockKey)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.lockKey = <span class="string">"LOCK_"</span> + lockKey;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * Detailed constructor with default lock expiration of 60000 msecs.</div><div class="line">   *</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RedisLock</span><span class="params">(String lockKey, <span class="keyword">int</span> timeoutMsecs)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(lockKey);</div><div class="line">    <span class="keyword">this</span>.timeoutMsecs = timeoutMsecs;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * Detailed constructor.</div><div class="line">   *</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RedisLock</span><span class="params">(String lockKey, <span class="keyword">int</span> timeoutMsecs, <span class="keyword">int</span> expireMsecs)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(lockKey, timeoutMsecs);</div><div class="line">    <span class="keyword">this</span>.expireMsecs = expireMsecs;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * <span class="doctag">@return</span> lock key</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getLockKey</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> lockKey;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> String <span class="title">get</span><span class="params">(<span class="keyword">final</span> String key)</span> </span>&#123;</div><div class="line">    Object obj = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      obj = redisTemplate.execute(<span class="keyword">new</span> RedisCallback&lt;Object&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">doInRedis</span><span class="params">(RedisConnection connection)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</div><div class="line">          StringRedisSerializer serializer = <span class="keyword">new</span> StringRedisSerializer();</div><div class="line">          <span class="keyword">byte</span>[] data = connection.get(serializer.serialize(key));</div><div class="line">          connection.close();</div><div class="line">          <span class="keyword">if</span> (data == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">return</span> serializer.deserialize(data);</div><div class="line">        &#125;</div><div class="line">      &#125;);</div><div class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">      logger.error(<span class="string">"get redis error, key : &#123;&#125;"</span>, key);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> obj != <span class="keyword">null</span> ? obj.toString() : <span class="keyword">null</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">setNX</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> String value)</span> </span>&#123;</div><div class="line">    Object obj = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      obj = redisTemplate.execute(<span class="keyword">new</span> RedisCallback&lt;Object&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">doInRedis</span><span class="params">(RedisConnection connection)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</div><div class="line">          StringRedisSerializer serializer = <span class="keyword">new</span> StringRedisSerializer();</div><div class="line">          Boolean success = connection.setNX(serializer.serialize(key), serializer.serialize(value));</div><div class="line">          connection.close();</div><div class="line">          <span class="keyword">return</span> success;</div><div class="line">        &#125;</div><div class="line">      &#125;);</div><div class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">      logger.error(<span class="string">"setNX redis error, key : &#123;&#125;"</span>, key);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> obj != <span class="keyword">null</span> ? (Boolean) obj : <span class="keyword">false</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> String <span class="title">getSet</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> String value)</span> </span>&#123;</div><div class="line">    Object obj = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      obj = redisTemplate.execute(<span class="keyword">new</span> RedisCallback&lt;Object&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">doInRedis</span><span class="params">(RedisConnection connection)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</div><div class="line">          StringRedisSerializer serializer = <span class="keyword">new</span> StringRedisSerializer();</div><div class="line">          <span class="keyword">byte</span>[] ret = connection.getSet(serializer.serialize(key), serializer.serialize(value));</div><div class="line">          connection.close();</div><div class="line">          <span class="keyword">return</span> serializer.deserialize(ret);</div><div class="line">        &#125;</div><div class="line">      &#125;);</div><div class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">      logger.error(<span class="string">"setNX redis error, key : &#123;&#125;"</span>, key);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> obj != <span class="keyword">null</span> ? (String) obj : <span class="keyword">null</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 主要是使用了redis 的setnx命令,缓存了锁. reids缓存的key是锁的key,所有的共享,</div><div class="line">   * value是锁的到期时间(注意:这里把过期时间放在value了,没有时间上设置其超时时间)</div><div class="line">   * &lt;p&gt;</div><div class="line">   * 执行过程:</div><div class="line">   * &lt;p&gt;</div><div class="line">   * 1.通过setnx尝试设置某个key的值,成功(当前没有这个锁)则返回,成功获得锁</div><div class="line">   * &lt;p&gt;</div><div class="line">   * 2.锁已经存在则获取锁的到期时间,和当前时间比较,超时的话,则设置新的值</div><div class="line">   *</div><div class="line">   * <span class="doctag">@return</span> true if lock is acquired, false acquire timeouted</div><div class="line">   * <span class="doctag">@throws</span> InterruptedException in case of thread interruption</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    <span class="keyword">int</span> timeout = timeoutMsecs;</div><div class="line">    <span class="keyword">while</span> (timeout &gt;= <span class="number">0</span>) &#123;</div><div class="line">      <span class="comment">// 锁到期时间</span></div><div class="line">      expiresStr = String.valueOf(System.currentTimeMillis() + expireMsecs + <span class="number">1</span>);</div><div class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.setNX(lockKey, expiresStr)) &#123;</div><div class="line">        <span class="comment">// lock acquired</span></div><div class="line">        locked = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      String currentValueStr = <span class="keyword">this</span>.get(lockKey); <span class="comment">// redis里的时间</span></div><div class="line">      <span class="keyword">if</span> (currentValueStr != <span class="keyword">null</span> &amp;&amp; Long.parseLong(currentValueStr) &lt; System.currentTimeMillis()) &#123;</div><div class="line">        <span class="comment">// 判断是否为空，不为空的情况下，如果被其他线程设置了值，则第二个条件判断是过不去的</span></div><div class="line">        <span class="comment">// lock is expired</span></div><div class="line"></div><div class="line">        String oldValueStr = <span class="keyword">this</span>.getSet(lockKey, expiresStr);</div><div class="line">        <span class="comment">// 获取上一个锁到期时间，并设置现在的锁到期时间，</span></div><div class="line">        <span class="comment">// 只有一个线程才能获取上一个线上的设置时间，因为jedis.getSet是同步的</span></div><div class="line">        <span class="keyword">if</span> (oldValueStr != <span class="keyword">null</span> &amp;&amp; oldValueStr.equals(currentValueStr)) &#123;</div><div class="line">          <span class="comment">// 防止误删（覆盖，因为key是相同的）了他人的锁——这里达不到效果，这里值会被覆盖，但是因为什么相差了很少的时间，所以可以接受</span></div><div class="line"></div><div class="line">          <span class="comment">// [分布式的情况下]:如过这个时候，多个线程恰好都到了这里，但是只有一个线程的设置值和当前值相同，他才有权利获取锁</span></div><div class="line">          <span class="comment">// lock acquired</span></div><div class="line">          locked = <span class="keyword">true</span>;</div><div class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      timeout -= DEFAULT_ACQUIRY_RESOLUTION_MILLIS;</div><div class="line"></div><div class="line">      <span class="comment">/*</span></div><div class="line">       * 延迟100 毫秒, 这里使用随机时间可能会好一点,可以防止饥饿进程的出现,即,当同时到达多个进程,</div><div class="line">       * 只会有一个进程获得锁,其他的都用同样的频率进行尝试,后面有来了一些进行,也以同样的频率申请锁,这将可能导致前面来的锁得不到满足. 使用随机的等待时间可以一定程度上保证公平性</div><div class="line">       */</div><div class="line">      Thread.sleep(DEFAULT_ACQUIRY_RESOLUTION_MILLIS);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * Acqurired lock release.</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (locked) &#123;</div><div class="line">      <span class="keyword">if</span> (expiresStr != <span class="keyword">null</span> &amp;&amp; expiresStr.equals(redisTemplate.opsForValue().get(lockKey))) &#123;</div><div class="line">        redisTemplate.delete(lockKey);</div><div class="line">        locked = <span class="keyword">false</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 测试</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> String key = <span class="string">"lockKey"</span>;</div><div class="line">    <span class="keyword">final</span> RedisLock lock = <span class="keyword">new</span> RedisLock(key, <span class="number">1000</span>, <span class="number">2000</span>);</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">      <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">          <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">if</span> (lock.lock()) &#123;</div><div class="line">              System.out.println(<span class="string">"Thread: "</span> + Thread.currentThread().getName() + <span class="string">"running"</span>);</div><div class="line">            &#125;</div><div class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">          &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            lock.unlock();</div><div class="line">          &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">      &#125;, <span class="string">""</span> + i).start();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>具体spring integration中已经实现这样的功能了。具体实现源码<a href="https://github.com/spring-projects/spring-integration/blob/master/spring-integration-redis/src/main/java/org/springframework/integration/redis/util/RedisLockRegistry.java" target="_blank" rel="external">链接</a>，具体源码分析可以查看<a href="https://wangkang007.gitbooks.io/java/redislockregistry.html" target="_blank" rel="external">gitbook链接</a></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://0opslab.com/2017/02/13/%E5%9F%BA%E4%BA%8ERedis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" target="_blank" rel="external">基于redis实现分布式锁</a></p>
<p><a href="https://github.com/spring-projects/spring-integration/blob/master/spring-integration-redis/src/main/java/org/springframework/integration/redis/util/RedisLockRegistry.java" target="_blank" rel="external">RedisLockRegistry</a></p>
<p><a href="https://wangkang007.gitbooks.io/java/redislockregistry.html" target="_blank" rel="external">RedisLockRegistry源码分析</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[redis zset内部实现]]></title>
      <url>http://zsr.github.io/2017/07/03/redis-zset%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<h3 id="Redis对象"><a href="#Redis对象" class="headerlink" title="Redis对象"></a>Redis对象</h3><p>Redis对象由<code>redisObject</code>结构体表示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> redisObject &#123;</div><div class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;            <span class="comment">// 对象的类型，包括 /* Object types */</span></div><div class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;        <span class="comment">// 底部为了节省空间，一种type的数据，可以采用不同的存储方式</span></div><div class="line">    <span class="keyword">unsigned</span> lru:REDIS_LRU_BITS; <span class="comment">/* lru time (relative to server.lruclock) */</span></div><div class="line">    <span class="keyword">int</span> refcount;         <span class="comment">// 引用计数</span></div><div class="line">    <span class="keyword">void</span> *ptr;</div><div class="line">&#125; robj;</div></pre></td></tr></table></figure>
<ul>
<li>Redis中的每个键值对的键和值都是一个redisObject。</li>
<li>共有五种类型的对象：字符串（String）、列表（List）、哈希（Hash）、集合（Set）、有序集合（SortedSet），源码<code>server.h</code>如下定义：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/* The actual Redis Object */</div><div class="line">#define OBJ_STRING 0</div><div class="line">#define OBJ_LIST 1 </div><div class="line">#define OBJ_SET 2</div><div class="line">#define OBJ_ZSET 3</div><div class="line">#define OBJ_HASH 4</div></pre></td></tr></table></figure>
<ul>
<li>每种类型的对象至少都有两种或以上的编码方式；可以在不同的使用场景上优化对象的使用场景。用<code>TYPE</code>命令可查看某个键值对的类型</li>
</ul>
<h3 id="对象编码"><a href="#对象编码" class="headerlink" title="对象编码"></a>对象编码</h3><p>Redis目前使用的编码方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/* Objects encoding. Some kind of objects like Strings and Hashes can be</div><div class="line"> * internally represented in multiple ways. The &apos;encoding&apos; field of the object</div><div class="line"> * is set to one of this fields for this object. </div><div class="line"> */</div><div class="line">#define OBJ_ENCODING_RAW     /* Raw representation */ 简单动态字符串</div><div class="line">#define OBJ_ENCODING_INT      /* Encoded as integer */ 整数</div><div class="line">#define OBJ_ENCODING_HT       /* Encoded as hash table */ 字典</div><div class="line">#define OBJ_ENCODING_ZIPLIST  /* Encoded as ziplist */ 压缩列表</div><div class="line">#define OBJ_ENCODING_INTSET   /* Encoded as intset */ 整数集合</div><div class="line">#define OBJ_ENCODING_SKIPLIST   /* Encoded as skiplist */ 跳跃表</div><div class="line">#define OBJ_ENCODING_EMBSTR  /* Embedded sds string encoding */ embstr编码的简单动态字符串</div><div class="line">#define OBJ_ENCODING_QUICKLIST  /* Encoded as linked list of ziplists */</div></pre></td></tr></table></figure>
<p>本质上，Redis就是基于这些数据结构而构造出一个对象存储系统。redisObject结构体有个ptr指针，指向对象的底层实现数据结构，encoding属性记录对象所使用的编码，即该对象使用什么数据结构作为底层实现。</p>
<h3 id="zset介绍"><a href="#zset介绍" class="headerlink" title="zset介绍"></a>zset介绍</h3><p>有序集合对象的编码可以是<code>ziplist</code>或者<code>skiplist</code>。同时满足以下条件时使用ziplist编码：</p>
<ul>
<li>元素数量小于128个</li>
<li>所有member的长度都小于64字节</li>
</ul>
<p>以上两个条件的上限值可通过zset-max-ziplist-entries和zset-max-ziplist-value来修改。</p>
<p><code>ziplist</code>编码的有序集合使用紧挨在一起的压缩列表节点来保存，第一个节点保存member，第二个保存score。ziplist内的集合元素按score从小到大排序，score较小的排在表头位置。</p>
<p><code>skiplist</code>编码的有序集合底层是一个命名为<code>zset</code>的结构体，而一个zset结构同时包含一个字典和一个跳跃表。跳跃表按score从小到大保存所有集合元素。而字典则保存着从member到score的映射，这样就可以用O(1)的复杂度来查找member对应的score值。虽然同时使用两种结构，但它们会通过指针来共享相同元素的member和score，因此不会浪费额外的内存。</p>
<h3 id="zset操作命令"><a href="#zset操作命令" class="headerlink" title="zset操作命令"></a>zset操作命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">zadd(key, score, member)：向名称为key的zset中添加元素member，score用于排序。如果该元素已经存在，则根据score更新该元素的顺序。</div><div class="line"></div><div class="line">zrem(key, member) ：删除名称为key的zset中的元素member</div><div class="line"></div><div class="line">zincrby(key, increment, member) ：如果在名称为key的zset中已经存在元素member，则该元素的score增加increment；否则向集合中添加该元素，其score的值为increment</div><div class="line"></div><div class="line">zrank(key, member) ：返回名称为key的zset（元素已按score从小到大排序）中member元素的rank（即index，从0开始），若没有member元素，返回“nil”</div><div class="line"></div><div class="line">zrevrank(key, member) ：返回名称为key的zset（元素已按score从大到小排序）中member元素的rank（即index，从0开始），若没有member元素，返回“nil”</div><div class="line"></div><div class="line">zrange(key, start, end)：返回名称为key的zset（元素已按score从小到大排序）中的index从start到end的所有元素</div><div class="line"></div><div class="line">zrevrange(key, start, end)：返回名称为key的zset（元素已按score从大到小排序）中的index从start到end的所有元素</div><div class="line"></div><div class="line">zrangebyscore(key, min, max)：返回名称为key的zset中score &gt;= min且score &lt;= max的所有元素 zcard(key)：返回名称为key的zset的基数</div><div class="line"></div><div class="line">zscore(key, element)：返回名称为key的zset中元素element的score zremrangebyrank(key, min, max)：删除名称为key的zset中rank &gt;= min且rank &lt;= max的所有元素 zremrangebyscore(key, min, max) ：删除名称为key的zset中score &gt;= min且score &lt;= max的所有元素</div></pre></td></tr></table></figure>
<h3 id="skiplist介绍"><a href="#skiplist介绍" class="headerlink" title="skiplist介绍"></a><strong>skiplist介绍</strong></h3><p>跳表(skip List)是一种随机化的数据结构，基于并联的链表，实现简单，插入、删除、查找的复杂度均为O(logN)。简单说来跳表也是链表的一种，只不过它在链表的基础上增加了跳跃功能，正是这个跳跃的功能，使得在查找元素时，跳表能够提供O(logN)的时间复杂度。</p>
<p>先来看一个有序链表，如下图（最左侧的灰色节点表示一个空的头结点）：</p>
<p><a href="http://zhangtielei.com/assets/photos_redis/skiplist/sorted_linked_list.png" target="_blank" rel="external"><img src="http://zhangtielei.com/assets/photos_redis/skiplist/sorted_linked_list.png" alt="有序链表结构图"></a></p>
<p>在这样一个链表中，如果我们要查找某个数据，那么需要从头开始逐个进行比较，直到找到包含数据的那个节点，或者找到第一个比给定数据大的节点为止（没找到）。也就是说，时间复杂度为O(n)。同样，当我们要插入新数据的时候，也要经历同样的查找过程，从而确定插入位置。</p>
<p>假如我们每相邻两个节点增加一个指针，让指针指向下下个节点，如下图：</p>
<p><a href="http://zhangtielei.com/assets/photos_redis/skiplist/skip2node_linked_list.png" target="_blank" rel="external"><img src="http://zhangtielei.com/assets/photos_redis/skiplist/skip2node_linked_list.png" alt="每两个节点增加一个跳跃指针的有序链表"></a></p>
<p>这样所有新增加的指针连成了一个新的链表，但它包含的节点个数只有原来的一半（上图中是7, 19, 26）。现在当我们想查找数据的时候，可以先沿着这个新链表进行查找。当碰到比待查数据大的节点时，再回到原来的链表中进行查找。比如，我们想查找23，查找的路径是沿着下图中标红的指针所指向的方向进行的：</p>
<p><a href="http://zhangtielei.com/assets/photos_redis/skiplist/search_path_on_skip2node_list.png" target="_blank" rel="external"><img src="http://zhangtielei.com/assets/photos_redis/skiplist/search_path_on_skip2node_list.png" alt="一个搜索路径的例子"></a></p>
<ul>
<li>23首先和7比较，再和19比较，比它们都大，继续向后比较。</li>
<li>但23和26比较的时候，比26要小，因此回到下面的链表（原链表），与22比较。</li>
<li>23比22要大，沿下面的指针继续向后和26比较。23比26小，说明待查数据23在原链表中不存在，而且它的插入位置应该在22和26之间。</li>
</ul>
<p>在这个查找过程中，由于新增加的指针，我们不再需要与链表中每个节点逐个进行比较了。需要比较的节点数大概只有原来的一半。</p>
<p>利用同样的方式，我们可以在上层新产生的链表上，继续为每相邻的两个节点增加一个指针，从而产生第三层链表。如下图：</p>
<p><a href="http://zhangtielei.com/assets/photos_redis/skiplist/skip2node_level3_linked_list.png" target="_blank" rel="external"><img src="http://zhangtielei.com/assets/photos_redis/skiplist/skip2node_level3_linked_list.png" alt="两层跳跃指针"></a></p>
<p>在这个新的三层链表结构上，如果我们还是查找23，那么沿着最上层链表首先要比较的是19，发现23比19大，接下来我们就知道只需要到19的后面去继续查找，从而一下子跳过了19前面的所有节点。可以想象，当链表足够长的时候，这种多层链表的查找方式能让我们跳过很多下层节点，大大加快查找的速度。</p>
<p><code>skiplist</code>正是受这种多层链表的想法的启发而设计出来的。实际上，按照上面生成链表的方式，上面每一层链表的节点个数，是下面一层的节点个数的一半，这样查找过程就非常类似于一个二分查找，使得查找的时间复杂度可以降低到O(log n)。但是，这种方法在插入数据的时候有很大的问题。新插入一个节点之后，就会打乱上下相邻两层链表上节点个数严格的2:1的对应关系。如果要维持这种对应关系，就必须把新插入的节点后面的所有节点（也包括新插入的节点）重新进行调整，这会让时间复杂度重新蜕化成O(n)。删除数据也有同样的问题。</p>
<p>skiplist为了避免这一问题，它不要求上下相邻两层链表之间的节点个数有严格的对应关系，而是为每个节点随机出一个层数(level)。比如，一个节点随机出的层数是3，那么就把它链入到第1层到第3层这三层链表中。为了表达清楚，下图展示了如何通过一步步的插入操作从而形成一个skiplist的过程：</p>
<p><a href="http://zhangtielei.com/assets/photos_redis/skiplist/skiplist_insertions.png" target="_blank" rel="external"><img src="http://zhangtielei.com/assets/photos_redis/skiplist/skiplist_insertions.png" alt="skiplist插入形成过程"></a></p>
<p>从上面skiplist的创建和插入过程可以看出，每一个节点的层数（level）是随机出来的，而且新插入一个节点不会影响其它节点的层数。因此，插入操作只需要修改插入节点前后的指针，而不需要对很多节点都进行调整。这就降低了插入操作的复杂度。实际上，这是skiplist的一个很重要的特性，这让它在插入性能上明显优于平衡树的方案。这在后面我们还会提到。</p>
<p>skiplist，指的就是除了最下面第1层链表之外，它会产生若干层稀疏的链表，这些链表里面的指针故意跳过了一些节点（而且越高层的链表跳过的节点越多）。这就使得我们在查找数据的时候能够先在高层的链表中进行查找，然后逐层降低，最终降到第1层链表来精确地确定数据位置。在这个过程中，我们跳过了一些节点，从而也就加快了查找速度。</p>
<p>刚刚创建的这个skiplist总共包含4层链表，现在假设我们在它里面依然查找23，下图给出了查找路径：</p>
<p><a href="http://zhangtielei.com/assets/photos_redis/skiplist/search_path_on_skiplist.png" target="_blank" rel="external"><img src="http://zhangtielei.com/assets/photos_redis/skiplist/search_path_on_skiplist.png" alt="skiplist上的查找路径展示"></a></p>
<p>需要注意的是，前面演示的各个节点的插入过程，实际上在插入之前也要先经历一个类似的查找过程，在确定插入位置后，再完成插入操作。</p>
<p>实际应用中的skiplist每个节点应该包含key和value两部分。前面的描述中我们没有具体区分key和value，但实际上列表中是按照key(score)进行排序的，查找过程也是根据key在比较。</p>
<p>执行插入操作时计算随机数的过程，是一个很关键的过程，它对skiplist的统计特性有着很重要的影响。这并不是一个普通的服从均匀分布的随机数，它的计算过程如下：</p>
<ul>
<li>首先，每个节点肯定都有第1层指针（每个节点都在第1层链表里）。</li>
<li>如果一个节点有第i层(i&gt;=1)指针（即节点已经在第1层到第i层链表中），那么它有第(i+1)层指针的概率为p。</li>
<li>节点最大的层数不允许超过一个最大值，记为MaxLevel。</li>
</ul>
<p>这个计算随机层数的伪码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">randomLevel()</div><div class="line">    level := <span class="number">1</span></div><div class="line">    <span class="comment">// random()返回一个[0...1)的随机数</span></div><div class="line">    <span class="keyword">while</span> random() &lt; p and level &lt; MaxLevel <span class="keyword">do</span></div><div class="line">        level := level + <span class="number">1</span></div><div class="line">    <span class="keyword">return</span> level</div></pre></td></tr></table></figure>
<p>randomLevel()的伪码中包含两个参数，一个是p，一个是MaxLevel。在Redis的skiplist实现中，这两个参数的取值为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">p = <span class="number">1</span>/<span class="number">4</span></div><div class="line">MaxLevel = <span class="number">32</span></div></pre></td></tr></table></figure>
<h3 id="skiplist与平衡树、哈希表的比较"><a href="#skiplist与平衡树、哈希表的比较" class="headerlink" title="skiplist与平衡树、哈希表的比较"></a>skiplist与平衡树、哈希表的比较</h3><ul>
<li>skiplist和各种平衡树（如AVL、红黑树等）的元素是有序排列的，而哈希表不是有序的。因此，在哈希表上只能做单个key的查找，不适宜做范围查找。所谓范围查找，指的是查找那些大小在指定的两个值之间的所有节点。</li>
<li>在做范围查找的时候，平衡树比skiplist操作要复杂。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在skiplist上进行范围查找就非常简单，只需要在找到小值之后，对第1层链表进行若干步的遍历就可以实现。</li>
<li>平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而skiplist的插入和删除只需要修改相邻节点的指针，操作简单又快速。</li>
<li>从内存占用上来说，skiplist比平衡树更灵活一些。一般来说，平衡树每个节点包含2个指针（分别指向左右子树），而skiplist每个节点包含的指针数目平均为1/(1-p)，具体取决于参数p的大小。如果像Redis里的实现一样，取p=1/4，那么平均每个节点包含1.33个指针，比平衡树更有优势。</li>
<li>查找单个key，skiplist和平衡树的时间复杂度都为O(log n)，大体相当；而哈希表在保持较低的哈希值冲突概率的前提下，查找时间复杂度接近O(1)，性能更高一些。所以我们平常使用的各种Map或dictionary结构，大都是基于哈希表实现的。</li>
<li>从算法实现难度上来比较，skiplist比平衡树要简单得多。</li>
</ul>
<h3 id="Redis中的skiplist实现"><a href="#Redis中的skiplist实现" class="headerlink" title="Redis中的skiplist实现"></a>Redis中的skiplist实现</h3><p>skiplist的数据结构定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ZSKIPLIST_MAXLEVEL 32</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ZSKIPLIST_P 0.25</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> zskiplistNode &#123;</div><div class="line">    robj *obj;</div><div class="line">    <span class="keyword">double</span> score;</div><div class="line">    <span class="keyword">struct</span> zskiplistNode *backward;</div><div class="line">    <span class="keyword">struct</span> zskiplistLevel &#123;</div><div class="line">        <span class="keyword">struct</span> zskiplistNode *forward;</div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> span;</div><div class="line">    &#125; level[];</div><div class="line">&#125; zskiplistNode;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> zskiplist &#123;</div><div class="line">    <span class="keyword">struct</span> zskiplistNode *header, *tail;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;</div><div class="line">    <span class="keyword">int</span> level;</div><div class="line">&#125; zskiplist;</div></pre></td></tr></table></figure>
<p>简单分析一下几个查询命令：</p>
<ul>
<li>zrevrank由数据查询它对应的排名，这在前面介绍的skiplist中并不支持。</li>
<li>zscore由数据查询它对应的分数，这也不是skiplist所支持的。</li>
<li>zrevrange根据一个排名范围，查询排名在这个范围内的数据。这在前面介绍的skiplist中也不支持。</li>
<li>zrevrangebyscore根据分数区间查询数据集合，是一个skiplist所支持的典型的范围查找（score相当于key，数据相当于value）。</li>
</ul>
<p>实际上，Redis中sorted set的实现是这样的：</p>
<ul>
<li>当数据较少时，sorted set是由一个ziplist来实现的。</li>
<li>当数据多的时候，sorted set是由一个dict + 一个skiplist来实现的。简单来讲，dict用来查询数据到分数的对应关系，而skiplist用来根据分数查询数据（可能是范围查找）。</li>
</ul>
<p>看一下sorted set与skiplist的关系，：</p>
<ul>
<li>zscore的查询，不是由skiplist来提供的，而是由那个dict来提供的。</li>
<li>为了支持排名(rank)，Redis里对skiplist做了扩展，使得根据排名能够快速查到数据，或者根据分数查到数据之后，也同时很容易获得排名。而且，根据排名的查找，时间复杂度也为O(log n)。</li>
<li>zrevrange的查询，是根据排名查数据，由扩展后的skiplist来提供。</li>
<li>zrevrank是先在dict中由数据查到分数，再拿分数到skiplist中去查找，查到后也同时获得了排名。</li>
</ul>
<p>总结起来，Redis中的skiplist跟前面介绍的经典的skiplist相比，有如下不同：</p>
<ul>
<li>分数(score)允许重复，即skiplist的key允许重复。这在最开始介绍的经典skiplist中是不允许的。</li>
<li>在比较时，不仅比较分数（相当于skiplist的key），还比较数据本身。在Redis的skiplist实现中，数据本身的内容唯一标识这份数据，而不是由key来唯一标识。另外，当多个元素分数相同的时候，还需要根据数据内容来进字典排序。</li>
<li>第1层链表不是一个单向链表，而是一个双向链表。这是为了方便以倒序方式获取一个范围内的元素。</li>
<li>在skiplist中可以很方便地计算出每个元素的排名(rank)。</li>
</ul>
<h3 id="Redis为什么用skiplist而不用平衡树？"><a href="#Redis为什么用skiplist而不用平衡树？" class="headerlink" title="Redis为什么用skiplist而不用平衡树？"></a>Redis为什么用skiplist而不用平衡树？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">There are a few reasons:</div><div class="line"></div><div class="line">1) They are not very memory intensive. It’s up to you basically. Changing parameters about the probability of a node to have a given number of levels will make then less memory intensive than btrees.</div><div class="line"></div><div class="line">2) A sorted set is often target of many ZRANGE or ZREVRANGE operations, that is, traversing the skip list as a linked list. With this operation the cache locality of skip lists is at least as good as with other kind of balanced trees.</div><div class="line"></div><div class="line">3) They are simpler to implement, debug, and so forth. For instance thanks to the skip list simplicity I received a patch (already in Redis master) with augmented skip lists implementing ZRANK in O(log(N)). It required little changes to the code.</div></pre></td></tr></table></figure>
<p>这里从内存占用、对范围查找的支持和实现难易程度这三方面总结的原因。</p>
<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p><a href="http://zhangtielei.com/posts/blog-redis-skiplist.html" target="_blank" rel="external">Redis内部数据结构详解(6)——skiplist</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JVM运行参数]]></title>
      <url>http://zsr.github.io/2017/06/26/JVM%E8%BF%90%E8%A1%8C%E5%8F%82%E6%95%B0/</url>
      <content type="html"><![CDATA[<h3 id="Java-JVM内存介绍"><a href="#Java-JVM内存介绍" class="headerlink" title="Java JVM内存介绍"></a>Java JVM内存介绍</h3><p>JVM管理两种类型的内存，堆和非堆。按照官方的说法：“Java 虚拟机具有一个堆，堆是运行时数据区域，所有类实例和数组的内存均从此处分配。堆是在 Java 虚拟机启动时创建的。”“在JVM中堆之外的内存称为非堆内存(Non-heap memory)”。简单来说堆就是Java代码可及的内存，是留给开发人员使用的；非堆就是JVM留给自己用的，所以方法区、JVM内部处理或优化所需的内存(如JIT编译后的代码缓存)、每个类结构(如运行时常数池、字段和方法数据)以及方法和构造方法的代码都在非堆内存中，它和堆不同，运行期内GC不会释放其空间。</p>
<h4 id="堆内存分配"><a href="#堆内存分配" class="headerlink" title="堆内存分配"></a>堆内存分配</h4><p>JVM初始分配的内存由-Xms指定，默认是物理内存的1/64；JVM最大分配的内存由-Xmx指定，默认是物理内存的1/4。默认空余堆内存小于 40%时，JVM就会增大堆直到-Xmx的最大限制；空余堆内存大于70%时，JVM会减少堆直到-Xms的最小限制。因此服务器一般设置-Xms、 -Xmx相等以避免在每次GC 后调整堆的大小。可以利用JVM提供的-Xmn -Xms -Xmx等选项可进行堆内存设置，一般的要将-Xms和-Xmx选项设置为相同，而-Xmn为1/4的-Xmx值，建议堆的最大值设置为可用内存的最大值的80%。</p>
<p>初始化堆的大小是JVM在启动时向系统申请的内存的大小。一般而言，这个参数不重要。但是有的应用程序在大负载的情况下会急剧地占用更多的内存，此时这个参数就是显得非常重要，如果JVM启动时设置使用的内存比较小而在这种情况下有许多对象进行初始化，JVM就必须重复地增加内存来满足使用。由于这种原因，我们一般把-Xms和-Xmx设为一样大，而堆的最大值受限于系统使用的物理内存。一般使用数据量较大的应用程序会使用持久对象，内存使用有可能迅速地增长。当应用程序需要的内存超出堆的最大值时JVM就会提示内存溢出，并且导致应用服务崩溃。所以，如果Xms超过了Xmx值，或者堆最大值和非堆最大值的总和超过了物理内存或者操作系统的最大限制都会引起服务器启动不起来。</p>
<h4 id="非堆内存分配"><a href="#非堆内存分配" class="headerlink" title="非堆内存分配"></a>非堆内存分配</h4><p>也叫永久保存的区域，用于存放Class和Meta信息,Class在被Load的时候被放入该区域。它和存放类实例(Instance)的Heap区域不同,GC(Garbage Collection)不会在主程序运行期对PermGen space进行清理。JVM使用-XX:PermSize设置非堆内存初始值，默认是物理内存的1/64；由XX:MaxPermSize设置最大非堆内存的大小，默认是物理内存的1/4。 GC不会对PermGen space进行清理，所以如果你的APP会LOAD很多CLASS的话,就很可能出现PermGen space错误。</p>
<h4 id="JVM内存限制-最大值"><a href="#JVM内存限制-最大值" class="headerlink" title="JVM内存限制(最大值)"></a>JVM内存限制(最大值)</h4><p>首先JVM内存限制于实际的最大物理内存，假设物理内存无限大的话，JVM内存的最大值跟操作系统有很大的关系。简单的说就32位处理器虽然可控内存空间有4GB,但是具体的操作系统会给一个限制，这个限制一般是2GB-3GB（一般来说Windows系统下为1.5G-2G，Linux系统 下为2G-3G），而64bit以上的处理器就不会有限制了。</p>
<h3 id="三种内存溢出异常介绍"><a href="#三种内存溢出异常介绍" class="headerlink" title="三种内存溢出异常介绍"></a>三种内存溢出异常介绍</h3><h4 id="OutOfMemoryError：Java-heap-space-堆溢出"><a href="#OutOfMemoryError：Java-heap-space-堆溢出" class="headerlink" title="OutOfMemoryError：Java heap space 堆溢出"></a>OutOfMemoryError：Java heap space 堆溢出</h4><p>内存溢出主要存在问题就是出现在这个情况中。当在JVM中如果98％的时间是用于GC且可用的 Heap size 不足2％的时候将抛出此异常信息。</p>
<h4 id="OutOfMemoryError：PermGen-space-非堆溢出（永久保存区域溢出）"><a href="#OutOfMemoryError：PermGen-space-非堆溢出（永久保存区域溢出）" class="headerlink" title="OutOfMemoryError：PermGen space 非堆溢出（永久保存区域溢出）"></a>OutOfMemoryError：PermGen space 非堆溢出（永久保存区域溢出）</h4><p>这种错误常见在web服务器对JSP进行pre compile的时候。如果你的WEB APP下都用了大量的第三方jar, 其大小超过了jvm默认的大小(4M)那么就会产生此错误信息了。如果web app用了大量的第三方jar或者应用有太多的class文件而恰好MaxPermSize设置较小，超出了也会导致这块内存的占用过多造成溢出，或者tomcat热部署时侯不会清理前面加载的环境，只会将context更改为新部署的，非堆存的内容就会越来越多。</p>
<h4 id="OutOfMemoryError：unable-to-create-new-native-thread-无法创建新的线程"><a href="#OutOfMemoryError：unable-to-create-new-native-thread-无法创建新的线程" class="headerlink" title="OutOfMemoryError：unable to create new native thread. 无法创建新的线程"></a>OutOfMemoryError：unable to create new native thread. 无法创建新的线程</h4><p>这种现象比较少见，也比较奇怪，主要是和jvm与系统内存的比例有关。这种怪事是因为JVM已经被系统分配了大量的内存（比如1.5G），并且它至少要占用可用内存的一半。</p>
<h3 id="Java-JVM内存配置"><a href="#Java-JVM内存配置" class="headerlink" title="Java JVM内存配置"></a>Java JVM内存配置</h3><p>在Linux下设置Tomcat的java虚拟机内存</p>
<ul>
<li>查看<code>catalina.sh</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">121 if [ -r &quot;$CATALINA_BASE/bin/setenv.sh&quot; ]; then</div><div class="line">122   . &quot;$CATALINA_BASE/bin/setenv.sh&quot;</div><div class="line">123 elif [ -r &quot;$CATALINA_HOME/bin/setenv.sh&quot; ]; then</div><div class="line">124   . &quot;$CATALINA_HOME/bin/setenv.sh&quot;</div><div class="line">125 fi</div></pre></td></tr></table></figure>
<ul>
<li>在tomcat的bin目录下查看是否有<code>setenv.sh</code>,如果没有则创建，然后添加如下内容</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export JAVA_OPTS=&apos;-XX:PermSize=128m -XX:MaxPermSize=256m  -Xms512m -Xmx1024m -Xmn386M -Xss228k -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=8 -XX:ParallelGCThreads=4 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC -XX:+CMSParallelRemarkEnabled -XX:+CMSClassUnloadingEnabled -XX:+CMSPermGenSweepingEnabled  -XX:CMSInitiatingOccupancyFraction=70 -XX:CMSFullGCsBeforeCompaction=5 -XX:+UseCMSCompactAtFullCollection -XX:-HeapDumpOnOutOfMemoryError -Xloggc:/srv/tomcat-forum-topic/logs/gc.log -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCApplicationStoppedTime -XX:+PrintGCApplicationConcurrentTime -Xdebug -Xrunjdwp:transport=dt_socket,address=10136,server=y,suspend=n -Djava.rmi.server.hostname=192.168.3.57 -Dcom.sun.management.jmxremote.port=10009 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false&apos;</div></pre></td></tr></table></figure>
<h4 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h4><ul>
<li><code>-XX:PermSize</code>：设定内存的永久保存区域；</li>
<li><code>-XX:MaxPermSize</code>：设定最大内存的永久保存区域；</li>
<li><code>-Xms</code>： Java Heap初始值，Server端JVM最好将-Xms和-Xmx设为相同值，开发测试机JVM可以保留默认值；</li>
<li><code>-Xmx</code>： Java Heap最大值，默认值为物理内存的1/4；</li>
<li><code>-Xmn</code>： Java Heap Young区大小，不熟悉最好保留默认值，一般设置为Xmx的3、4分之一；</li>
<li><code>-Xss</code>： 每个线程的Stack大小，不熟悉最好保留默认值；</li>
<li><code>-XX:NewSize</code>：设置JVM堆的‘新生代’的默认大小；</li>
<li><code>-XX:MaxNewSize</code>：设置JVM堆的‘新生代’的最大大小；</li>
<li><code>-XX:SurvivorRatio</code>：Eden区与Survivor区的大小比值;设置为8,则两个Survivor区与一个Eden区的比值为2:8,一个Survivor区占整个年轻代的1/10</li>
<li><code>-XX:MaxTenuringThreshold</code>：垃圾最大年龄；如果设置为0的话,则年轻代对象不经过Survivor区,直接进入年老代. 对于年老代比较多的应用,可以提高效率.如果将此值设置为一个较大值,则年轻代对象会在Survivor区进行多次复制,这样可以增加对象再年轻代的存活时间,增加在年轻代即被回收的概率。该参数只有在串行GC时才有效.</li>
<li><code>-XX:ParallelGCThreads</code>：并行收集器的线程数；此值最好配置与处理器数目相等 同样适用于CMS</li>
<li><code>-XX:+UseConcMarkSweepGC</code>：使用CMS内存收集；</li>
<li><code>-XX:+UseParNewGC</code>：设置年轻代为并行收集；可与CMS收集同时使用</li>
<li><code>-XX:+CMSParallelRemarkEnabled</code>：降低标记停顿</li>
<li><code>-XX:+CMSClassUnloadingEnabled</code>：显示在使用CMS GC时，未加载类是否可用。JVM进行GC时便会清除永久代，并且删除不再使用的类，这个选项只会在<code>UseConcMarkSweepGC</code> 可用时才起作用。</li>
<li><code>-XX:+CMSPermGenSweepingEnabled</code>：显示清除永久代是否可用。默认情况下这个参数是不可用的，所以要协调永久代问题，就必须显示设置这个参数。这个参数在Java 6里面被删除，所以如果你在使用Java 6或以上版本，你将不得不使用 -XX:+CMSClassUnloadingEnabled 选项。</li>
<li><code>-XX:CMSInitiatingOccupancyFraction＝70</code>：使用cms作为垃圾回收，使用70％后开始CMS收集</li>
<li><code>-XX:CMSFullGCsBeforeCompaction=5</code> ：多少次后进行内存压缩；由于并发收集器不对内存空间进行压缩,整理,所以运行一段时间以后会产生”碎片”,使得运行效率降低.此值设置运行多少次GC以后对内存空间进行压缩,整理.</li>
<li><code>-XX:+UseCMSCompactAtFullCollection</code>：在FULL GC的时候，对年老代的压缩；CMS是不会移动内存的，因此非常容易产生碎片，导致内存不够用，因此，内存的压缩这个时候就会被启用。</li>
<li><code>-XX:HeapDumpOnOutOfMemoryError</code>：当发生OutOfMemoryError错误时，才能触发<code>-XX:HeapDumpOnOutOfMemoryError</code> 输出到<code>-XX:HeapDumpPath</code>指定位置。</li>
<li><code>-Xloggc:/gc.log</code>：指定垃圾收集日志文件</li>
<li><code>-XX:+PrintGCDetails</code>：每次GC时打印详细信息</li>
<li><code>-XX:+PrintGCTimeStamps</code>：GC发生的时间</li>
<li><code>XX:+PrintGCApplicationStoppedTime</code>：GC消耗了多少时间</li>
<li><code>XX:+PrintGCApplicationConcurrentTime</code>：GC之间运行了多少时间</li>
<li><code>-Xdebug -Xrunjdwp:transport=dt_socket,address=10136,server=y,suspend=n</code>：方便客户端远程调试</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">-XDebug               启用调试。</div><div class="line">-Xnoagent             禁用默认sun.tools.debug调试器。</div><div class="line">-Djava.compiler=NONE  禁止 JIT 编译器的加载。</div><div class="line">-Xrunjdwp             加载JDWP的JPDA参考执行实例。</div><div class="line">transport             用于在调试程序和 VM 使用的进程之间通讯。</div><div class="line">dt_socket             套接字传输。</div><div class="line">dt_shmem              共享内存传输，仅限于 Windows。</div><div class="line">server=y/n            VM 是否需要作为调试服务器执行。</div><div class="line">address=3999          调试服务器的端口号，客户端用来连接服务器的端口号。</div><div class="line">suspend=y/n           是否在调试客户端建立连接之后启动 VM 。</div></pre></td></tr></table></figure>
<ul>
<li><code>-Djava.rmi.server.hostname=192.168.3.57</code>：指定ip</li>
<li><code>-Dcom.sun.management.jmxremote.port=10009</code>：指定端口</li>
<li><code>-Dcom.sun.management.jmxremote.ssl=false</code>：指定是否需要密码验证</li>
<li><code>-Dcom.sun.management.jmxremote.authenticate=false</code>：指定是否使用 SSL 通讯</li>
</ul>
<p><code>备注：JMX(Java Management Extensions)是一个为应用程序植入管理功能的框架,通过使用JMX，我们可以实时查询应用程序中通过JMX向外公布的相应参数或者是其他应用数据;可以使用Jconsole监控</code></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://blog.csdn.net/ye1992/article/details/9344807" target="_blank" rel="external">Tomcat中JVM内存溢出及合理配置</a></p>
<p><a href="http://www.cnblogs.com/redcreen/archive/2011/05/04/2037057.html" target="_blank" rel="external">JVM系列三:JVM参数设置、分析</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[RPC介绍]]></title>
      <url>http://zsr.github.io/2017/06/20/RPC%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<p>转载:<a href="http://blog.csdn.net/mindfloating/article/details/39474123" target="_blank" rel="external">深入浅出 RPC - 深入篇</a></p>
<h3 id="RPC-是什么？"><a href="#RPC-是什么？" class="headerlink" title="RPC 是什么？"></a>RPC 是什么？</h3><p>RPC 的全称是 Remote Procedure Call 是一种进程间通信方式。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即程序员无论是调用本地的还是远程的，本质上编写的调用代码基本相同。</p>
<h2 id="RPC-起源"><a href="#RPC-起源" class="headerlink" title="RPC 起源"></a>RPC 起源</h2><p>RPC 这个概念术语在上世纪 80 年代由 <a href="https://en.wikipedia.org/wiki/Bruce_Jay_Nelson" target="_blank" rel="external">Bruce Jay Nelson</a> 提出。在 Nelson 的论文 <a href="http://birrell.org/andrew/papers/ImplementingRPC.pdf" target="_blank" rel="external">“Implementing Remote Procedure Calls”</a> 中他提到了几点：</p>
<ul>
<li>简单：RPC 概念的语义十分清晰和简单，这样建立分布式计算就更容易。</li>
<li>高效：过程调用看起来十分简单而且高效。</li>
<li>通用：在单机计算中过程往往是不同算法部分间最重要的通信机制。 </li>
</ul>
<p>通俗一点说，就是一般程序员对于本地的过程调用很熟悉，那么我们把 RPC 作成和本地调用完全类似，那么就更容易被接受，使用起来毫无障碍。今天我们使用的 RPC 框架基本就是按这个目标来实现的。</p>
<h3 id="RPC-结构"><a href="#RPC-结构" class="headerlink" title="RPC 结构"></a>RPC 结构</h3><p>Nelson 的论文中指出实现 RPC 的程序包括 5 个部分：</p>
<blockquote>
<ol>
<li>User</li>
<li>User-stub</li>
<li>RPCRuntime</li>
<li>Server-stub</li>
<li>Server</li>
</ol>
</blockquote>
<p>这 5 个部分的关系如下图所示:</p>
<p><img src="http://img.blog.csdn.net/20150108170924203?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbWluZGZsb2F0aW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"><br>这里 user 就是 client 端，当 user 想发起一个远程调用时，它实际是通过本地调用 user-stub。user-stub 负责将调用的接口、方法和参数通过约定的协议规范进行编码并通过本地的 RPCRuntime 实例传输到远端的实例。远端 RPCRuntime 实例收到请求后交给 server-stub 进行解码后发起本地端调用，调用结果再返回给 user 端。</p>
<h3 id="RPC-功能目标"><a href="#RPC-功能目标" class="headerlink" title="RPC 功能目标"></a>RPC 功能目标</h3><p><strong>RPC 的主要功能目标是让构建分布式计算（应用）更容易，在提供强大的远程调用能力时不损失本地调用的语义简洁性。</strong>为实现该目标，RPC 框架需提供一种透明调用机制让使用者不必显式的区分本地调用和远程调用。</p>
<h3 id="RPC-调用分类"><a href="#RPC-调用分类" class="headerlink" title="RPC 调用分类"></a>RPC 调用分类</h3><p>RPC调用分以下两种：</p>
<ol>
<li><p>同步调用  </p>
<p>客户方等待调用执行完成并返回结果。  </p>
</li>
<li><p>异步调用  </p>
<p>客户方调用后不用等待执行结果返回，但依然可以通过回调通知等方式获取返回结果。  </p>
<p>若客户方不关心调用返回结果，则变成单向异步调用，单向调用不用返回结果。  </p>
</li>
</ol>
<p>异步和同步的区分在于是否等待服务端执行完成并返回结果。</p>
<h3 id="RPC-结构拆解"><a href="#RPC-结构拆解" class="headerlink" title="RPC 结构拆解"></a>RPC 结构拆解</h3><p><img src="http://img.blog.csdn.net/20150108170231000?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbWluZGZsb2F0aW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p>RPC服务方通过 <code>RpcServer</code> 去导出（export）远程接口方法，而客户方通过 <code>RpcClient</code> 去引入（import）远程接口方法。客户方像调用本地方法一样去调用远程接口方法，RPC 框架提供接口的代理实现，实际的调用将委托给代理<code>RpcProxy</code> 。代理封装调用信息并将调用转交给<code>RpcInvoker</code> 去实际执行。在客户端的<code>RpcInvoker</code> 通过连接器<code>RpcConnector</code> 去维持与服务端的通道<code>RpcChannel</code>，并使用<code>RpcProtocol</code> 执行协议编码（encode）并将编码后的请求消息通过通道发送给服务方。</p>
<p>RPC 服务端接收器 <code>RpcAcceptor</code> 接收客户端的调用请求，同样使用<code>RpcProtocol</code> 执行协议解码（decode）。解码后的调用信息传递给<code>RpcProcessor</code> 去控制处理调用过程，最后再委托调用给<code>RpcInvoker</code> 去实际执行并返回调用结果。</p>
<h3 id="RPC-组件职责"><a href="#RPC-组件职责" class="headerlink" title="RPC 组件职责"></a>RPC 组件职责</h3><p>下面详细说明下每个组件的职责划分。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">1. RpcServer  </div><div class="line">   负责导出（export）远程接口  </div><div class="line">2. RpcClient  </div><div class="line">   负责导入（import）远程接口的代理实现  </div><div class="line">3. RpcProxy  </div><div class="line">   远程接口的代理实现  </div><div class="line">4. RpcInvoker  </div><div class="line">   客户方实现：负责编码调用信息和发送调用请求到服务方并等待调用结果返回  </div><div class="line">   服务方实现：负责调用服务端接口的具体实现并返回调用结果  </div><div class="line">5. RpcProtocol  </div><div class="line">   负责协议编/解码  </div><div class="line">6. RpcConnector  </div><div class="line">   负责维持客户方和服务方的连接通道和发送数据到服务方  </div><div class="line">7. RpcAcceptor  </div><div class="line">   负责接收客户方请求并返回请求结果  </div><div class="line">8. RpcProcessor  </div><div class="line">   负责在服务方控制调用过程，包括管理调用线程池、超时时间等  </div><div class="line">9. RpcChannel  </div><div class="line">   数据传输通道</div></pre></td></tr></table></figure>
<h3 id="RPC-实现分析"><a href="#RPC-实现分析" class="headerlink" title="RPC 实现分析"></a>RPC 实现分析</h3><h4 id="导出远程接口"><a href="#导出远程接口" class="headerlink" title="导出远程接口"></a>导出远程接口</h4><p>导出远程接口的意思是指只有导出的接口可以供远程调用，而未导出的接口则不能。在 java 中导出接口的代码片段可能如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">DemoService demo   = <span class="keyword">new</span> DemoService();  </div><div class="line">RpcServer  server = <span class="keyword">new</span> RpcServer();  </div><div class="line">server.export(DemoService.class, demo, options);</div></pre></td></tr></table></figure>
<p>我们可以导出整个接口，也可以更细粒度一点只导出接口中的某些方法，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 只导出 DemoService 中签名为 hi(String s) 的方法  </span></div><div class="line">server.export(DemoService.class, demo, <span class="string">"hi"</span>, <span class="keyword">new</span> Class&lt;?&gt;[] &#123; String.class &#125;, options);</div></pre></td></tr></table></figure>
<p>java 中还有一种比较特殊的调用就是多态，也就是一个接口可能有多个实现，那么远程调用时到底调用哪个？这个本地调用的语义是通过 jvm 提供的引用多态性隐式实现的，那么对于 RPC 来说跨进程的调用就没法隐式实现了。如果前面<code>DemoService</code> 接口有 2 个实现，那么在导出接口时就需要特殊标记不同的实现，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">DemoService demo   = <span class="keyword">new</span> DemoService();  </div><div class="line">DemoService demo2  = <span class="keyword">new</span> DemoService();  </div><div class="line">RpcServer   server = <span class="keyword">new</span> RpcServer();  </div><div class="line">server.export(DemoService.class, demo, options);  </div><div class="line">server.export(<span class="string">"demo2"</span>, DemoService.class, demo2, options);</div></pre></td></tr></table></figure>
<p>上面 demo2 是另一个实现，我们标记为 “demo2” 来导出，那么远程调用时也需要传递该标记才能调用到正确的实现类，这样就解决了多态调用的语义。</p>
<h4 id="导入远程接口与客户端代理"><a href="#导入远程接口与客户端代理" class="headerlink" title="导入远程接口与客户端代理"></a>导入远程接口与客户端代理</h4><p>导入相对于导出远程接口，客户端代码为了能够发起调用必须要获得远程接口的方法或过程定义。目前，大部分跨语言平台 RPC 框架采用根据 IDL 定义通过 code generator 去生成 stub 代码，这种方式下实际导入的过程就是通过代码生成器在编译期完成的。</p>
<p>代码生成的方式对跨语言平台 RPC 框架而言是必然的选择，而对于同一语言平台的 RPC 则可以通过共享接口定义来实现。在 java 中导入接口的代码片段可能如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">RpcClient client = <span class="keyword">new</span> RpcClient();  </div><div class="line">DemoService demo = client.refer(DemoService.class);  </div><div class="line">demo.hi(<span class="string">"how are you?"</span>);</div></pre></td></tr></table></figure>
<p>在 java 中 ‘import’ 是关键字，所以代码片段中我们用 refer 来表达导入接口的意思。这里的导入方式本质也是一种代码生成技术，只不过是在运行时生成，比静态编译期的代码生成看起来更简洁些。</p>
<h4 id="协议编解码"><a href="#协议编解码" class="headerlink" title="协议编解码"></a>协议编解码</h4><p>客户端代理在发起调用前需要对调用信息进行编码，这就要考虑需要编码些什么信息并以什么格式传输到服务端才能让服务端完成调用。出于效率考虑，编码的信息越少越好（传输数据少），编码的规则越简单越好（执行效率高）。我们先看下需要编码些什么信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">-- 调用编码 --  </div><div class="line">1. 接口方法  </div><div class="line">   包括接口名、方法名  </div><div class="line">2. 方法参数  </div><div class="line">   包括参数类型、参数值  </div><div class="line">3. 调用属性  </div><div class="line">   包括调用属性信息，例如调用附件隐式参数、调用超时时间等  </div><div class="line">  </div><div class="line">-- 返回编码 --  </div><div class="line">1. 返回结果  </div><div class="line">   接口方法中定义的返回值  </div><div class="line">2. 返回码  </div><div class="line">   异常返回码  </div><div class="line">3. 返回异常信息  </div><div class="line">   调用异常信息</div></pre></td></tr></table></figure>
<p>除了以上这些必须的调用信息，我们可能还需要一些元信息以方便程序编解码以及未来可能的扩展。这样我们的编码消息里面就分成了两部分，一部分是元信息、另一部分是调用的必要信息。如果设计一种 RPC 协议消息的话，元信息我们把它放在协议消息头中，而必要信息放在协议消息体中。下面给出一种概念上的 RPC 协议消息设计格式：</p>
<p><img src="http://img.blog.csdn.net/20150108170315663?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbWluZGZsb2F0aW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">-- 消息头 --  </div><div class="line">magic      : 协议魔数，为解码设计  </div><div class="line">header size: 协议头长度，为扩展设计  </div><div class="line">version    : 协议版本，为兼容设计  </div><div class="line">st         : 消息体序列化类型  </div><div class="line">hb         : 心跳消息标记，为长连接传输层心跳设计  </div><div class="line">ow         : 单向消息标记，  </div><div class="line">rp         : 响应消息标记，不置位默认是请求消息  </div><div class="line">status code: 响应消息状态码  </div><div class="line">reserved   : 为字节对齐保留  </div><div class="line">message id : 消息 id  </div><div class="line">body size  : 消息体长度  </div><div class="line">  </div><div class="line">-- 消息体 --  </div><div class="line">采用序列化编码，常见有以下格式  </div><div class="line">xml   : 如 webservie soap  </div><div class="line">json  : 如 JSON-RPC  </div><div class="line">binary: 如 thrift; hession; kryo 等</div></pre></td></tr></table></figure>
<p>格式确定后编解码就简单了，由于头长度一定所以我们比较关心的就是消息体的序列化方式。序列化我们关心三个方面：</p>
<ol>
<li>序列化和反序列化的效率，越快越好。 </li>
<li>序列化后的字节长度，越小越好。 </li>
<li>序列化和反序列化的兼容性，接口参数对象若增加了字段，是否兼容。</li>
</ol>
<h4 id="传输服务"><a href="#传输服务" class="headerlink" title="传输服务"></a>传输服务</h4><p>协议编码之后，自然就是需要将编码后的 RPC 请求消息传输到服务方，服务方执行后返回结果消息或确认消息给客户方。RPC 的应用场景实质是一种可靠的请求应答消息流，和 HTTP 类似。因此选择长连接方式的 TCP 协议会更高效，与 HTTP 不同的是在协议层面我们定义了每个消息的唯一 id，因此可以更容易的复用连接。</p>
<p>既然使用长连接，那么第一个问题是到底 client 和 server 之间需要多少根连接？实际上单连接和多连接在使用上没有区别，对于数据传输量较小的应用类型，单连接基本足够。单连接和多连接最大的区别在于，每根连接都有自己私有的发送和接收缓冲区，因此大数据量传输时分散在不同的连接缓冲区会得到更好的吞吐效率。所以，如果你的数据传输量不足以让单连接的缓冲区一直处于饱和状态的话，那么使用多连接并不会产生任何明显的提升，反而会增加连接管理的开销。</p>
<p>连接是由 client 端发起建立并维持。如果 client 和 server 之间是直连的，那么连接一般不会中断（当然物理链路故障除外）。如果 client 和 server 连接经过一些负载中转设备，有可能连接一段时间不活跃时会被这些中间设备中断。为了保持连接有必要定时为每个连接发送心跳数据以维持连接不中断。心跳消息是 RPC 框架库使用的内部消息，在前文协议头结构中也有一个专门的心跳位，就是用来标记心跳消息的，它对业务应用透明。</p>
<h4 id="执行调用"><a href="#执行调用" class="headerlink" title="执行调用"></a>执行调用</h4><p>client stub 所做的事情仅仅是编码消息并传输给服务方，而真正调用过程发生在服务方。server stub 从前文的结构拆解中我们细分了 <code>RpcProcessor</code> 和 <code>RpcInvoker</code> 两个组件，一个负责控制调用过程，一个负责真正调用。这里我们还是以 java 中实现这两个组件为例来分析下它们到底需要做什么？</p>
<p>java 中实现代码的动态接口调用目前一般通过反射调用。除了原生的 jdk 自带的反射，一些第三方库也提供了性能更优的反射调用，因此 <code>RpcInvoker</code> 就是封装了反射调用的实现细节。</p>
<p>调用过程的控制需要考虑哪些因素，<code>RpcProcessor</code> 需要提供什么样地调用控制服务呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1. 效率提升  </div><div class="line">   每个请求应该尽快被执行，因此我们不能每请求来再创建线程去执行，需要提供线程池服务。  </div><div class="line">2. 资源隔离  </div><div class="line">   当我们导出多个远程接口时，如何避免单一接口调用占据所有线程资源，而引发其他接口执行阻塞。  </div><div class="line">3. 超时控制  </div><div class="line">   当某个接口执行缓慢，而 client 端已经超时放弃等待后，server 端的线程继续执行此时显得毫无意义。</div></pre></td></tr></table></figure>
<h4 id="RPC-异常处理"><a href="#RPC-异常处理" class="headerlink" title="RPC 异常处理"></a>RPC 异常处理</h4><p>无论 RPC 怎样努力把远程调用伪装的像本地调用，但它们依然有很大的不同点，而且有一些异常情况是在本地调用时绝对不会碰到的。在说异常处理之前，我们先比较下本地调用和 RPC 调用的一些差异：</p>
<ol>
<li>本地调用一定会执行，而远程调用则不一定，调用消息可能因为网络原因并未发送到服务方。</li>
<li>本地调用只会抛出接口声明的异常，而远程调用还会跑出 RPC 框架运行时的其他异常。</li>
<li>本地调用和远程调用的性能可能差距很大，这取决于 RPC 固有消耗所占的比重。</li>
</ol>
<p>正是这些区别决定了使用 RPC 时需要更多考量。当调用远程接口抛出异常时，异常可能是一个业务异常，也可能是 RPC 框架抛出的运行时异常（如：网络中断等）。业务异常表明服务方已经执行了调用，可能因为某些原因导致未能正常执行，而 RPC 运行时异常则有可能服务方根本没有执行，对调用方而言的异常处理策略自然需要区分。</p>
<p>由于 RPC 固有的消耗相对本地调用高出几个数量级，本地调用的固有消耗是纳秒级，而 RPC 的固有消耗是在毫秒级。那么对于过于轻量的计算任务就并不合适导出远程接口由独立的进程提供服务，只有花在计算任务上时间远远高于 RPC 的固有消耗才值得导出为远程接口提供服务。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Thrift详解]]></title>
      <url>http://zsr.github.io/2017/06/20/Thrift%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h3 id="RPC调用流程"><a href="#RPC调用流程" class="headerlink" title="RPC调用流程"></a>RPC调用流程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">1）客户端（client）调用以本地调用方式调用服务；</div><div class="line">2）client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；</div><div class="line">3）client stub找到服务地址，并将消息发送到服务端；</div><div class="line"></div><div class="line">4）server stub收到消息后进行解码；</div><div class="line">5）server stub根据解码结果调用本地的服务；</div><div class="line">6）服务端执行并将结果返回给server stub；</div><div class="line">7）server stub将返回结果打包成消息并发送至消费方；</div><div class="line"></div><div class="line">8）client stub接收到消息，并进行解码；</div><div class="line">9）客户端得到最终结果。</div></pre></td></tr></table></figure>
<p><img src="http://images2015.cnblogs.com/blog/522490/201510/522490-20151003120412386-363334260.png" alt="img"></p>
<h3 id="Thrift主要特点"><a href="#Thrift主要特点" class="headerlink" title="Thrift主要特点"></a>Thrift主要特点</h3><ol>
<li>基于二进制的高性能的编解码框架</li>
<li>基于NIO的底层通信</li>
<li>相对简单的服务调用模型</li>
<li>使用IDL支持跨平台调用</li>
</ol>
<h3 id="Thrift核心组件"><a href="#Thrift核心组件" class="headerlink" title="Thrift核心组件"></a>Thrift核心组件</h3><ol>
<li><code>TProtocol</code> 协议和编解码组件</li>
<li><code>TTransport</code> 传输组件</li>
<li><code>TProcessor</code> 服务调用组件</li>
<li><code>TServer</code>，<code>Client</code> 服务器和客户端组件</li>
<li>IDL 服务描述组件，负责生产跨平台客户端</li>
</ol>
<a id="more"></a>
<h3 id="Thrift基础架构"><a href="#Thrift基础架构" class="headerlink" title="Thrift基础架构"></a>Thrift基础架构</h3><p> <img src="http://www.blogjava.net/images/blogjava_net/ldwblog/thrift%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="img"></p>
<p>thrift是一个客户端和服务器端的架构体系（c/s），在最上层是用户自行实现的业务逻辑代码。第二层是由thrift编译器自动生成的代码，主要用于结构化数据的解析，发送和接收。TServer主要任务是高效的接受客户端请求，并将请求转发给Processor处理。Processor负责对客户端的请求做出响应，包括RPC请求转发，调用参数解析和用户逻辑调用，返回值写回等处理。从TProtocol以下部分是thirft的传输协议和底层I/O通信。TProtocol是用于数据类型解析的，将结构化数据转化为字节流给TTransport进行传输。TTransport是与底层数据传输密切相关的传输层，负责以字节流方式接收和发送消息体，不关注是什么数据类型。底层IO负责实际的数据传输，包括socket、文件和压缩数据流等。</p>
<h4 id="传输层TTransport"><a href="#传输层TTransport" class="headerlink" title="传输层TTransport"></a>传输层TTransport</h4><ul>
<li><code>TIOStreamTransport</code>: 这个类封装了<code>InputStream</code>和<code>OutputStream</code>这两个流，用来处理数据传输中的输入输出流。采用的是阻塞同步IO。<ul>
<li><code>TSocket</code>: 是<code>TIOStreamTransport</code>类的子类，并且封装了<code>Socket</code>接口。</li>
</ul>
</li>
<li><code>TNonblockingTransport</code>: 这个类是非阻塞IO的抽象类。<ul>
<li><code>TNonblockingSocket</code>: 是<code>TNonblockingTransport</code>类的子类，使用了<code>SocketChannel</code>进行了非阻塞IO。</li>
</ul>
</li>
<li><code>TFramedTransport</code>: 使用非阻塞方式，帧传输类就是按照一帧的固定大小来传输数据，所有的写操作首先都是在内存中完成的直到调用了flush操作，然后传输节点在flush操作之后将所有数据根据数据的有效载荷写入数据的长度的二进制块发送出去，允许在接收的另一端按照固定的长度来读取。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// TTransport.class</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TTransport</span> </span>&#123;</div><div class="line">  <span class="comment">// 读取指定长度的数据</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] buf, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> TTransportException</span>;</div><div class="line"></div><div class="line">  <span class="comment">// 写数据</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] buf, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> TTransportException</span>;</div><div class="line">  </div><div class="line">  <span class="comment">// 把缓冲区的数据全部都push出去</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> <span class="keyword">throws</span> TTransportException</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="阻塞TSocket"><a href="#阻塞TSocket" class="headerlink" title="阻塞TSocket"></a>阻塞TSocket</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// TSocket.class</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TSocket</span> <span class="keyword">extends</span> <span class="title">TIOStreamTransport</span> </span>&#123;</div><div class="line">  <span class="comment">// 构造socket</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TSocket</span><span class="params">(String host, <span class="keyword">int</span> port, <span class="keyword">int</span> socketTimeout, <span class="keyword">int</span> connectTimeout)</span> </span>&#123;</div><div class="line">    host_ = host;</div><div class="line">    port_ = port;</div><div class="line">    socketTimeout_ = socketTimeout;</div><div class="line">    connectTimeout_ = connectTimeout;</div><div class="line">    initSocket();</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="comment">// 创建新的Socket</span></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initSocket</span><span class="params">()</span> </span>&#123;</div><div class="line">    socket_ = <span class="keyword">new</span> Socket();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      socket_.setSoLinger(<span class="keyword">false</span>, <span class="number">0</span>);</div><div class="line">      socket_.setTcpNoDelay(<span class="keyword">true</span>);</div><div class="line">      socket_.setKeepAlive(<span class="keyword">true</span>);</div><div class="line">      socket_.setSoTimeout(socketTimeout_);</div><div class="line">    &#125; <span class="keyword">catch</span> (SocketException sx) &#123;</div><div class="line">      LOGGER.error(<span class="string">"Could not configure socket."</span>, sx);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="comment">// 打开链接</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> <span class="keyword">throws</span> TTransportException </span>&#123;</div><div class="line">     socket_.connect(<span class="keyword">new</span> InetSocketAddress(host_, port_), timeout_);</div><div class="line">     inputStream_ = <span class="keyword">new</span> BufferedInputStream(socket_.getInputStream(), <span class="number">1024</span>);</div><div class="line">     outputStream_ = <span class="keyword">new</span> BufferedOutputStream(socket_.getOutputStream(), <span class="number">1024</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="非阻塞TFramedTransport"><a href="#非阻塞TFramedTransport" class="headerlink" title="非阻塞TFramedTransport"></a>非阻塞TFramedTransport</h5><ul>
<li>流程图</li>
</ul>
<p><img src="http://img.voidcn.com/vcimg/000/005/545/078_fcf_750.jpg" alt="这里写图片描述"></p>
<ul>
<li>源码分析</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TFramedTransport</span> <span class="keyword">extends</span> <span class="title">TTransport</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> TTransport transport_ = <span class="keyword">null</span>;</div><div class="line">  </div><div class="line">  <span class="comment">// 输出缓冲区</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> TByteArrayOutputStream writeBuffer_ =</div><div class="line">    <span class="keyword">new</span> TByteArrayOutputStream(<span class="number">1024</span>);</div><div class="line">  </div><div class="line">  <span class="comment">// 输入缓冲区</span></div><div class="line">  <span class="keyword">private</span> TMemoryInputTransport readBuffer_ = <span class="keyword">new</span> TMemoryInputTransport(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>]);</div><div class="line">  </div><div class="line">  <span class="comment">// 一帧4byte</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] i32buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>];</div><div class="line">  </div><div class="line">  <span class="comment">// 读取数据</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] buf, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> TTransportException </span>&#123;</div><div class="line">    <span class="keyword">if</span> (readBuffer_ != <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">int</span> got = readBuffer_.read(buf, off, len);</div><div class="line">      <span class="keyword">if</span> (got &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> got;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Read another frame of data</span></div><div class="line">    readFrame();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> readBuffer_.read(buf, off, len);</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="comment">// 读取一帧数据，放到输入缓冲区</span></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readFrame</span><span class="params">()</span> <span class="keyword">throws</span> TTransportException </span>&#123;</div><div class="line">    transport_.readAll(i32buf, <span class="number">0</span>, <span class="number">4</span>);</div><div class="line">    <span class="keyword">int</span> size = decodeFrameSize(i32buf);</div><div class="line"></div><div class="line">    <span class="keyword">byte</span>[] buff = <span class="keyword">new</span> <span class="keyword">byte</span>[size];</div><div class="line">    transport_.readAll(buff, <span class="number">0</span>, size);</div><div class="line">    readBuffer_.reset(buff);</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>TFramedTransport</code>封装了<code>TMemoryInputTransport</code>做输入流，封装了<code>TByteArryOutPutStream</code>做输出流，作为内存读写缓冲区的一个封装。<code>TFramedTransport</code>的<code>flush</code>方法时，会先写4个字节的输出流的长度作为消息头，然后写消息体；和<code>FrameBuffer</code>的读消息对应起来，<code>FrameBuffer</code> 读消息时，先读4个字节的长度，再读消息体。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Test </span></div><div class="line">TTransport transport = <span class="keyword">new</span> TFramedTransport(<span class="keyword">new</span> TSocket(SERVER_IP, SERVER_PORT, TIMEOUT));</div></pre></td></tr></table></figure>
<h4 id="协议层TProtocol"><a href="#协议层TProtocol" class="headerlink" title="协议层TProtocol"></a>协议层TProtocol</h4><ul>
<li><code>TBinaryProtocol</code>：二进制编码格式进行数据传输。 </li>
<li><code>TCompactProtocol</code>：高效的编码方式，对数据进行压缩。 </li>
<li><code>TJSONProtocol</code>：使用JSON的数据编码协议进行数据传输。 </li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://www.cnblogs.com/LBSer/p/4853234.html" target="_blank" rel="external">你应该知道的RPC原理</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[一致性hash]]></title>
      <url>http://zsr.github.io/2017/06/07/%E4%B8%80%E8%87%B4%E6%80%A7hash/</url>
      <content type="html"><![CDATA[<h3 id="分布式缓存问题"><a href="#分布式缓存问题" class="headerlink" title="分布式缓存问题"></a>分布式缓存问题</h3><p>​     分布式系统中，当服务增长到一定规模时，惯常的做法是集群化，引入负载均衡，这样做的好处是：1. 高可用。2. 解耦。从外部看，透明化了集群的内部细节（外部都通过负载均衡服务器通信，然后由负载均衡服务器分发请求）。</p>
<p>假设一个简单的场景：有4个cache服务器组成的集群，当一个对象传入集群时，这个对象应该存储在哪一个cache里呢？一种简单的方法是使用映射公式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Hash(object) % <span class="number">4</span></div></pre></td></tr></table></figure>
<p>这个算法的问题在于容错性和扩展性不好。所谓容错性是指当系统中某一个或几个服务器变得不可用时，整个系统是否可以正确高效运行；而扩展性是指当加入新的服务器后，整个系统是否可以正确高效运行。</p>
<p>假设一下情况：</p>
<ul>
<li>由于流量增大，需要增加一台cache，共5个cache。这时，映射公式就变成<code>Hash(object) % 5</code>。</li>
<li>有一个cache服务器down掉，变成3个cache。这时，映射公式就变成<code>Hash(object) % 3</code>。</li>
</ul>
<p>因此系统中一旦有服务器变更，大量的key会被重定位到不同的服务器从而造成大量的缓存不命中，这意味着一时间所有的缓存全部失效。而这种情况在分布式系统中是非常糟糕的。</p>
<p>一个设计良好的分布式哈希方案应该具有良好的单调性，即服务节点的增减不会造成大量哈希重定位。一致性哈希算法就是这样一种哈希方案。</p>
<h3 id="一致性哈希算法"><a href="#一致性哈希算法" class="headerlink" title="一致性哈希算法"></a>一致性哈希算法</h3><ol>
<li>简单来说，一致性哈希将整个哈希值空间组织成一个虚拟的圆环，如假设某哈希函数H的值空间为${2}^{32}$-1（即哈希值是一个32位无符号整形），整个哈希空间环如下：</li>
</ol>
<p><img src="http://blog.codinglabs.org/uploads/pictures/consistent-hashing/2.png" alt="img"></p>
<p>整个空间按顺时针方向组织。0和${2}^{32}$-1在零点中方向重合。</p>
<ol>
<li>下一步将各个服务器使用hash函数进行一次哈希，具体可以选择服务器的ip或主机名作为关键字进行哈希，这样每台机器就能确定其在哈希环上的位置，这里假设将三台服务器使用ip地址哈希后在环空间的位置如下：</li>
</ol>
<p><img src="http://blog.codinglabs.org/uploads/pictures/consistent-hashing/3.png" alt="img"></p>
<ol>
<li>接下来使用如下算法定位数据访问到相应服务器：将数据key使用相同的hash函数计算出哈希值h，通根据h确定此数据在环上的位置，从此位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器。</li>
</ol>
<p>例如我们有A、B、C、D四个数据对象，经过哈希计算后，在环空间上的位置如下：</p>
<p><img src="http://blog.codinglabs.org/uploads/pictures/consistent-hashing/4.png" alt="img"></p>
<p>根据一致性哈希算法，数据A会被定为到Server 1上，D被定为到Server 3上，而B、C分别被定为到Server 2上。</p>
<h3 id="容错性与可扩展性分析"><a href="#容错性与可扩展性分析" class="headerlink" title="容错性与可扩展性分析"></a>容错性与可扩展性分析</h3><p>新的一致性hash算法成功解决了cache服务器增减时key的失效问题。现在，无论增减cache，<strong>只有部分key失效</strong>。</p>
<p>现假设Server 3宕机了：</p>
<p><img src="http://blog.codinglabs.org/uploads/pictures/consistent-hashing/5.png" alt="img"></p>
<p>可以看到此时A、C、B不会受到影响，只有D节点被重定位到Server 2。一般的，在一致性哈希算法中，如果一台服务器不可用，则受影响的数据仅仅是此服务器到其环空间中前一台服务器（即顺着逆时针方向行走遇到的第一台服务器）之间数据，其它不会受到影响。</p>
<p>下面考虑另外一种情况，如果我们在系统中增加一台服务器Memcached Server 4：</p>
<p><img src="http://blog.codinglabs.org/uploads/pictures/consistent-hashing/6.png" alt="img"></p>
<p>此时A、D、C不受影响，只有B需要重定位到新的Server 4。一般的，在一致性哈希算法中，如果增加一台服务器，则受影响的数据仅仅是新服务器到其环空间中前一台服务器（即顺着逆时针方向行走遇到的第一台服务器）之间数据，其它不会受到影响。</p>
<p>综上所述，一致性哈希算法对于节点的增减都只需重定位环空间中的一小部分数据，具有较好的容错性和可扩展性。</p>
<h2 id="虚拟节点"><a href="#虚拟节点" class="headerlink" title="虚拟节点"></a>虚拟节点</h2><p>对于一个object来说，它落在环上的任何位置的概率都是一样的，<strong>那么落在一个cache的概率就和圆弧的长度成正比</strong>。于是，我们希望每个cache所占的圆弧长度更接近。</p>
<p>理论上，<strong>只要cache足够多，每个cache在圆环上就会足够分散</strong>。但是在真实场景里，cache服务器只会有很少，所以，引入了“虚拟节点”的概念。</p>
<p>一致性哈希算法在服务节点太少时，容易因为节点分部不均匀而造成数据倾斜问题。例如我们的系统中有两台服务器，其环分布如下：</p>
<p><img src="http://blog.codinglabs.org/uploads/pictures/consistent-hashing/7.png" alt="img"></p>
<p>此时必然造成大量数据集中到Server 1上，而只有极少量会定位到Server 2上。为了解决这种数据倾斜问题，一致性哈希算法引入了虚拟节点机制，<strong>将一个物理节点拆分为多个虚拟节点，并且同一个物理节点的虚拟节点尽量均匀分布在Hash环上</strong>。具体做法可以在服务器ip或主机名的后面增加编号来实现。</p>
<h3 id="实现一致性哈希-java"><a href="#实现一致性哈希-java" class="headerlink" title="实现一致性哈希(java)"></a>实现一致性哈希(java)</h3><ul>
<li><strong>一致性Hash算法实现版本1：不带虚拟节点</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.zsr.test.ConsistentHash;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.Map.Entry;</div><div class="line"><span class="keyword">import</span> java.util.TreeMap;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 一致性Hash算法实现版本1：不带虚拟节点</div><div class="line"> * </div><div class="line"> * <span class="doctag">@author</span> David</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsistentHashingWithoutVirtualNode</span> </span>&#123;</div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 待添加入Hash环的服务器列表</div><div class="line">   */</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> String[] servers = &#123; <span class="string">"192.168.0.0:111"</span>, <span class="string">"192.168.0.1:111"</span>, <span class="string">"192.168.0.2:111"</span>, <span class="string">"192.168.0.3:111"</span>,</div><div class="line">      <span class="string">"192.168.0.4:111"</span> &#125;;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * key表示服务器的hash值，value表示服务器的名称</div><div class="line">   */</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> TreeMap&lt;Integer, String&gt; treeMap = <span class="keyword">new</span> TreeMap&lt;Integer, String&gt;();</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 程序初始化，将所有的服务器放入sortedMap中</div><div class="line">   */</div><div class="line">  <span class="keyword">static</span> &#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; servers.length; i++) &#123;</div><div class="line">      <span class="keyword">int</span> hash = getHash(servers[i]);</div><div class="line">      System.out.println(<span class="string">"["</span> + servers[i] + <span class="string">"]加入集合中, 其Hash值为"</span> + hash);</div><div class="line">      treeMap.put(hash, servers[i]);</div><div class="line">    &#125;</div><div class="line">    System.out.println();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 简单起见，复用String的hashCode算法;实际hash算法可以采用MurmurHash</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getHash</span><span class="params">(String str)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> hash = str.hashCode();</div><div class="line">    <span class="comment">// String的hashCode()方法却会产生负数，取绝对值</span></div><div class="line">    <span class="keyword">return</span> Math.abs(hash);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 得到应当路由到的结点</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getServer</span><span class="params">(String node)</span> </span>&#123;</div><div class="line">    <span class="comment">// 得到带路由的结点的Hash值</span></div><div class="line">    <span class="keyword">int</span> hash = getHash(node);</div><div class="line">    <span class="comment">// 获取大于或等于指定key的最小map键相关联的map键值对</span></div><div class="line">    Entry&lt;Integer, String&gt; entry = treeMap.ceilingEntry(hash);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">return</span> treeMap.firstEntry().getValue();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> entry.getValue();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    String[] nodes = &#123; <span class="string">"127.0.0.1:1111"</span>, <span class="string">"221.226.0.1:2222"</span>, <span class="string">"10.211.0.1:3333"</span> &#125;;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodes.length; i++)</div><div class="line">      System.out.println(<span class="string">"["</span> + nodes[i] + <span class="string">"]的hash值为"</span> + getHash(nodes[i]) + <span class="string">", 被路由到结点["</span> + getServer(nodes[i]) + <span class="string">"]"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[192.168.0.0:111]加入集合中, 其Hash值为771739798</div><div class="line">[192.168.0.1:111]加入集合中, 其Hash值为770816277</div><div class="line">[192.168.0.2:111]加入集合中, 其Hash值为769892756</div><div class="line">[192.168.0.3:111]加入集合中, 其Hash值为768969235</div><div class="line">[192.168.0.4:111]加入集合中, 其Hash值为768045714</div><div class="line"></div><div class="line">[127.0.0.1:1111]的hash值为35944419, 被路由到结点[192.168.0.4:111]</div><div class="line">[221.226.0.1:2222]的hash值为973393028, 被路由到结点[192.168.0.4:111]</div><div class="line">[10.211.0.1:3333]的hash值为561068530, 被路由到结点[192.168.0.4:111]</div></pre></td></tr></table></figure>
<p>从运行结果来看，也没有问题，三个点路由到的都是顺时针离他们Hash值最近的那台服务器上。</p>
<ul>
<li><strong>一致性Hash算法实现版本2：带虚拟节点</strong></li>
</ul>
<p>编程方面需要考虑的问题是：</p>
<ol>
<li>一个真实结点如何对应成为多个虚拟节点？</li>
<li>虚拟节点找到后如何还原为真实结点？</li>
</ol>
<p>这两个问题其实有很多解决办法，这里使用了一种简单的办法，给每个真实结点后面根据虚拟节点加上后缀再取Hash值，比如”192.168.0.0:111”就把它变成”192.168.0.0:111&amp;&amp;VN0”到”192.168.0.0:111&amp;&amp;VN4”，VN就是Virtual Node的缩写，还原的时候只需要从头截取字符串到”&amp;&amp;”的位置就可以了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.zsr.test.ConsistentHash;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.LinkedList;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"><span class="keyword">import</span> java.util.Map.Entry;</div><div class="line"><span class="keyword">import</span> java.util.TreeMap;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 带虚拟节点的一致性Hash算法</div><div class="line"> * </div><div class="line"> * <span class="doctag">@author</span> David</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsistentHashingWithVirtualNode</span> </span>&#123;</div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 待添加入Hash环的服务器列表</div><div class="line">   */</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> String[] servers = &#123; <span class="string">"192.168.0.0:111"</span>, <span class="string">"192.168.0.1:111"</span>, <span class="string">"192.168.0.2:111"</span>, <span class="string">"192.168.0.3:111"</span>,</div><div class="line">      <span class="string">"192.168.0.4:111"</span> &#125;;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 真实结点列表,考虑到服务器上线、下线的场景，即添加、删除的场景会比较频繁，这里使用LinkedList会更好</div><div class="line">   */</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; realNodes = <span class="keyword">new</span> LinkedList&lt;String&gt;();</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 虚拟节点，key表示虚拟节点的hash值，value表示虚拟节点的名称</div><div class="line">   */</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> TreeMap&lt;Integer, String&gt; virtualNodes = <span class="keyword">new</span> TreeMap&lt;Integer, String&gt;();</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 虚拟节点的数目，这里写死，为了演示需要，一个真实结点对应5个虚拟节点</div><div class="line">   */</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VIRTUAL_NODES = <span class="number">5</span>;</div><div class="line"></div><div class="line">  <span class="keyword">static</span> &#123;</div><div class="line">    <span class="comment">// 先把原始的服务器添加到真实结点列表中</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; servers.length; i++)</div><div class="line">      realNodes.add(servers[i]);</div><div class="line"></div><div class="line">    <span class="comment">// 再添加虚拟节点，遍历LinkedList使用foreach循环效率会比较高</span></div><div class="line">    <span class="keyword">for</span> (String str : realNodes) &#123;</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; VIRTUAL_NODES; i++) &#123;</div><div class="line">        String virtualNodeName = str + <span class="string">"&amp;&amp;VN"</span> + String.valueOf(i);</div><div class="line">        <span class="keyword">int</span> hash = getHash(virtualNodeName);</div><div class="line">        System.out.println(<span class="string">"虚拟节点["</span> + virtualNodeName + <span class="string">"]被添加, hash值为"</span> + hash);</div><div class="line">        virtualNodes.put(hash, virtualNodeName);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    System.out.println();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 简单起见，复用String的hashCode算法;实际hash算法可以采用MurmurHash</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getHash</span><span class="params">(String str)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> hash = str.hashCode();</div><div class="line">    <span class="comment">// String的hashCode()方法却会产生负数，取绝对值</span></div><div class="line">    <span class="keyword">return</span> Math.abs(hash);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 得到应当路由到的结点</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getServer</span><span class="params">(String node)</span> </span>&#123;</div><div class="line">    <span class="comment">// 得到带路由的结点的Hash值</span></div><div class="line">    <span class="keyword">int</span> hash = getHash(node);</div><div class="line">    <span class="comment">// 获取大于或等于指定key的最小map键相关联的map键值对</span></div><div class="line">    Entry&lt;Integer, String&gt; entry = virtualNodes.ceilingEntry(hash);</div><div class="line"></div><div class="line">    String virtualNode = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</div><div class="line">      virtualNode = virtualNodes.firstEntry().getValue();</div><div class="line">    &#125;</div><div class="line">    virtualNode = entry.getValue();</div><div class="line">    <span class="keyword">return</span> virtualNode.substring(<span class="number">0</span>, virtualNode.indexOf(<span class="string">"&amp;&amp;"</span>));</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    String[] nodes = &#123; <span class="string">"127.0.0.1:1111"</span>, <span class="string">"221.226.0.1:2222"</span>, <span class="string">"10.211.0.1:3333"</span> &#125;;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodes.length; i++)</div><div class="line">      System.out.println(<span class="string">"["</span> + nodes[i] + <span class="string">"]的hash值为"</span> + getHash(nodes[i]) + <span class="string">", 被路由到结点["</span> + getServer(nodes[i]) + <span class="string">"]"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">虚拟节点[192.168.0.0:111&amp;&amp;VN0]被添加, hash值为1490088590</div><div class="line">虚拟节点[192.168.0.0:111&amp;&amp;VN1]被添加, hash值为1490088591</div><div class="line">虚拟节点[192.168.0.0:111&amp;&amp;VN2]被添加, hash值为1490088592</div><div class="line">虚拟节点[192.168.0.0:111&amp;&amp;VN3]被添加, hash值为1490088593</div><div class="line">虚拟节点[192.168.0.0:111&amp;&amp;VN4]被添加, hash值为1490088594</div><div class="line">虚拟节点[192.168.0.1:111&amp;&amp;VN0]被添加, hash值为1293575085</div><div class="line">虚拟节点[192.168.0.1:111&amp;&amp;VN1]被添加, hash值为1293575086</div><div class="line">虚拟节点[192.168.0.1:111&amp;&amp;VN2]被添加, hash值为1293575087</div><div class="line">虚拟节点[192.168.0.1:111&amp;&amp;VN3]被添加, hash值为1293575088</div><div class="line">虚拟节点[192.168.0.1:111&amp;&amp;VN4]被添加, hash值为1293575089</div><div class="line">虚拟节点[192.168.0.2:111&amp;&amp;VN0]被添加, hash值为1097061580</div><div class="line">虚拟节点[192.168.0.2:111&amp;&amp;VN1]被添加, hash值为1097061581</div><div class="line">虚拟节点[192.168.0.2:111&amp;&amp;VN2]被添加, hash值为1097061582</div><div class="line">虚拟节点[192.168.0.2:111&amp;&amp;VN3]被添加, hash值为1097061583</div><div class="line">虚拟节点[192.168.0.2:111&amp;&amp;VN4]被添加, hash值为1097061584</div><div class="line">虚拟节点[192.168.0.3:111&amp;&amp;VN0]被添加, hash值为900548075</div><div class="line">虚拟节点[192.168.0.3:111&amp;&amp;VN1]被添加, hash值为900548076</div><div class="line">虚拟节点[192.168.0.3:111&amp;&amp;VN2]被添加, hash值为900548077</div><div class="line">虚拟节点[192.168.0.3:111&amp;&amp;VN3]被添加, hash值为900548078</div><div class="line">虚拟节点[192.168.0.3:111&amp;&amp;VN4]被添加, hash值为900548079</div><div class="line">虚拟节点[192.168.0.4:111&amp;&amp;VN0]被添加, hash值为704034570</div><div class="line">虚拟节点[192.168.0.4:111&amp;&amp;VN1]被添加, hash值为704034571</div><div class="line">虚拟节点[192.168.0.4:111&amp;&amp;VN2]被添加, hash值为704034572</div><div class="line">虚拟节点[192.168.0.4:111&amp;&amp;VN3]被添加, hash值为704034573</div><div class="line">虚拟节点[192.168.0.4:111&amp;&amp;VN4]被添加, hash值为704034574</div><div class="line"></div><div class="line">[127.0.0.1:1111]的hash值为35944419, 被路由到结点[192.168.0.4:111]</div><div class="line">[221.226.0.1:2222]的hash值为973393028, 被路由到结点[192.168.0.2:111]</div><div class="line">[10.211.0.1:3333]的hash值为561068530, 被路由到结点[192.168.0.4:111]</div></pre></td></tr></table></figure>
<p>从运行结果看，每个点路由到的服务器都是Hash值顺时针离它最近的那个服务器节点，没有任何问题。</p>
<p>通过采取虚拟节点的方法，一个真实结点不再固定在Hash换上的某个点，而是大量地分布在整个Hash环上，这样即使上线、下线服务器，也不会造成整体的负载不均衡。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://blog.codinglabs.org/articles/consistent-hashing.html" target="_blank" rel="external">一致性哈希算法及其在分布式系统中的应用</a></p>
<p><a href="http://www.cnblogs.com/xrq730/p/5186728.html" target="_blank" rel="external">对一致性Hash算法，Java代码实现的深入研究</a></p>
<p><a href="http://afghl.github.io/2016/11/19/implement-consistent-hashing.html" target="_blank" rel="external">实现一致性哈希java版本</a></p>
<p><a href="http://calvin1978.blogcn.com/articles/murmur.html" target="_blank" rel="external">陌生但默默一统江湖的MurmurHash</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Semaphore信号量]]></title>
      <url>http://zsr.github.io/2017/06/01/Semaphore%E4%BF%A1%E5%8F%B7%E9%87%8F/</url>
      <content type="html"><![CDATA[<h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><p>​    <code>Semaphore</code>当前在多线程环境下被扩放使用，操作系统的信号量是个很重要的概念，在进程控制方面都有应用。Java 并发库的<code>Semaphore</code>可以很轻松完成信号量控制，<code>Semaphore</code>可以控制某个资源可被同时访问的个数，通过 <code>acquire()</code>获取一个许可，如果没有就等待，而<code>release()</code>释放一个许可。用来控制资源同时访问个数</p>
<p>​      以一个停车场运作为例。假设停车场只有三个车位，一开始三个车位都是空的。这时如果同时来了五辆车，看门人允许其中三辆不受阻碍的进入，然后放下车拦，剩下的车则必须在入口等待，此后来的车也都不得不在入口处等待。这时，有一辆车离开停车场，看门人得知后，打开车拦，放入一辆，如果又离开两辆，则又可以放入两辆，如此往复。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p><code>Semaphore</code>提供了一个带有<code>boolean</code>参数的构造方法，<code>true</code>代表公平锁，<code>false</code>代表非公平锁，默认实现是非公平锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span></span>; <span class="comment">// 创建具有给定许可数的非公平Semaphore</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span></span>; <span class="comment">//创建具有给定许可数的公平(true)或非公平(false) Semaphore</span></div></pre></td></tr></table></figure>
<h3 id="普通方法"><a href="#普通方法" class="headerlink" title="普通方法"></a>普通方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="comment">//从此信号量获取一个许可，在提供一个许可前一直将线程阻塞，否则线程被中断</span></span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> permits)</span> <span class="comment">//从此信号量获取给定数目的许可，在提供这些许可前一直将线程阻塞，或者线程已被中断</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> <span class="comment">//释放一个许可，将可用的许可数增加1</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> permits)</span> <span class="comment">//释放给定数目的许可，将其返回到信号量</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFair</span><span class="params">()</span> <span class="comment">//如果此信号量的公平设置为true，则返回 true</span></div></pre></td></tr></table></figure>
<h3 id="停车案例"><a href="#停车案例" class="headerlink" title="停车案例"></a>停车案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.zsr.test.Semaphore;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Semaphore parkingspace;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">int</span> carNo;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * <span class="doctag">@param</span> parkingspace</div><div class="line">   * <span class="doctag">@param</span> carNo</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(Semaphore parkingspace, <span class="keyword">int</span> carNo)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.parkingspace = parkingspace;</div><div class="line">    <span class="keyword">this</span>.carNo = carNo;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      parkingspace.acquire();</div><div class="line">      parking();</div><div class="line">      Thread.sleep(<span class="number">300</span>);</div><div class="line">      parkingspace.release();</div><div class="line">      leaving();</div><div class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">      e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parking</span><span class="params">()</span> </span>&#123;</div><div class="line">    System.out.println(String.format(<span class="string">"%d号车泊车"</span>, carNo));</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">leaving</span><span class="params">()</span> </span>&#123;</div><div class="line">    System.out.println(String.format(<span class="string">"%d号车离开车位"</span>, carNo));</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParkingCars</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUMBER_OF_CARS = <span class="number">5</span>;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUMBER_OF_PARKING_SPACE = <span class="number">3</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    </div><div class="line">    Semaphore parkingSpace = <span class="keyword">new</span> Semaphore(NUMBER_OF_PARKING_SPACE, <span class="keyword">true</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> carNo = <span class="number">1</span>; carNo &lt;= NUMBER_OF_CARS; carNo++) &#123;</div><div class="line">      <span class="keyword">new</span> Thread(<span class="keyword">new</span> Car(parkingSpace, carNo)).start();</div><div class="line">    &#125;</div><div class="line">    Thread.sleep(<span class="number">3000</span>);</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line">     * 输出还有几个可以用的资源数</div><div class="line">     */</div><div class="line">    System.out.println(parkingSpace.availablePermits() + <span class="string">" 个停车位可以用!"</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="number">2</span>号车泊车</div><div class="line"><span class="number">1</span>号车泊车</div><div class="line"><span class="number">3</span>号车泊车</div><div class="line"><span class="number">2</span>号车离开车位</div><div class="line"><span class="number">4</span>号车泊车</div><div class="line"><span class="number">3</span>号车离开车位</div><div class="line"><span class="number">1</span>号车离开车位</div><div class="line"><span class="number">5</span>号车泊车</div><div class="line"><span class="number">4</span>号车离开车位</div><div class="line"><span class="number">5</span>号车离开车位</div><div class="line"><span class="number">3</span> 个停车位可以用!</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[设计模式-单例模式]]></title>
      <url>http://zsr.github.io/2017/05/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[设计模式-建造者模式]]></title>
      <url>http://zsr.github.io/2017/05/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>​       在软件开发中，存在大量类似汽车一样的复杂对象，它们拥有一系列成员属性，这些成员属性中有些是引用类型的成员对象。而且在这些复杂对象中，还可能存在一些限制条件，如某些属性没有赋值则复杂对象不能作为一个完整的产品使用；有些属性的赋值必须按照某个顺序，一个属性没有赋值之前，另一个属性可能无法赋值等。</p>
<p>复杂对象相当于一辆有待建造的汽车，而对象的属性相当于汽车的部件，建造产品的过程就相当于组合部件的过程。由于组合部件的过程很复杂，因此，这些部件的组合过程往往被“外部化”到一个称作建造者的对象里，建造者返还给客户端的是一个已经建造完毕的完整产品对象，而用户无须关心该对象所包含的属性以及它们的组装方式，这就是建造者模式的模式动机。</p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>​      建造者模式是较为复杂的创建型模式，它将客户端与包含多个组成部分（或部件）的复杂对象的创建过程分离，客户端无须知道复杂对象的内部组成部分与装配方式，只需要知道所需建造者的类型即可。它关注如何一步一步创建一个的复杂对象，不同的具体建造者定义了不同的创建过程，且具体建造者相互独立，增加新的建造者非常方便，无须修改已有代码，系统具有较好的扩展性。</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">建造者模式(Builder Pattern)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式是一种对象创建型模式。</div></pre></td></tr></table></figure>
<p>建造者模式一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。</p>
<h3 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h3><p><img src="http://design-patterns.readthedocs.io/zh_CN/latest/_images/Builder.jpg" alt="img"></p>
<h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><p>在建造者模式结构图中包含如下几个角色：</p>
<ul>
<li><strong>Builder（抽象建造者）：</strong>它为创建一个产品Product对象的各个部件指定抽象接口，在该接口中一般声明两类方法，一类方法是buildPartX()，它们用于创建复杂对象的各个部件；另一类方法是getResult()，它们用于返回复杂对象。Builder既可以是抽象类，也可以是接口。</li>
<li><strong>ConcreteBuilder（具体建造者）：</strong>它实现了Builder接口，实现各个部件的具体构造和装配方法，定义并明确它所创建的复杂对象，也可以提供一个方法返回创建好的复杂产品对象。</li>
<li><strong>Product（产品角色）：</strong>它是被构建的复杂对象，包含多个组成部件，具体建造者创建该产品的内部表示并定义它的装配过程。</li>
<li><strong>Director（指挥者）：</strong>指挥者又称为导演类，它负责安排复杂对象的建造次序，指挥者与抽象建造者之间存在关联关系，可以在其construct()建造方法中调用建造者对象的部件构造与装配方法，完成复杂对象的建造。客户端一般只需要与指挥者进行交互，在客户端确定具体建造者的类型，并实例化具体建造者对象（也可以通过配置文件和反射机制），然后通过指挥者类的构造函数或者Setter方法将该对象传入指挥者类中。</li>
</ul>
<a id="more"></a>
<h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><p><img src="http://design-patterns.readthedocs.io/zh_CN/latest/_images/seq_Builder.jpg" alt="img"></p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>复杂对象类代码示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Class Product  &#123;</div><div class="line">       <span class="keyword">private</span>  String partA; <span class="comment">//定义部件，部件可以是任意类型，包括值类型和引用类型</span></div><div class="line">       <span class="keyword">private</span>  String partB;</div><div class="line">       <span class="keyword">private</span>  String partC;</div><div class="line">       <span class="comment">//partA的Getter方法和Setter方法省略</span></div><div class="line">       <span class="comment">//partB的Getter方法和Setter方法省略</span></div><div class="line">       <span class="comment">//partC的Getter方法和Setter方法省略</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在抽象建造者类中定义了产品的创建方法和返回方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</div><div class="line">       <span class="comment">//创建产品对象</span></div><div class="line">       <span class="keyword">protected</span> Product product=<span class="keyword">new</span> Product();</div><div class="line">      </div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildPartA</span><span class="params">()</span></span>;</div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildPartB</span><span class="params">()</span></span>;</div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildPartC</span><span class="params">()</span></span>;</div><div class="line">      </div><div class="line">       <span class="comment">//返回产品对象</span></div><div class="line">       <span class="function"><span class="keyword">public</span> Product <span class="title">getResult</span><span class="params">()</span> </span>&#123;</div><div class="line">              <span class="keyword">return</span> product;</div><div class="line">       &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在抽象类<code>Builder</code>中声明了一系列抽象的<code>buildPartX()</code>方法用于创建复杂产品的各个部件，具体建造过程在<code>ConcreteBuilder</code>中实现，此外还提供了工厂方法<code>getResult()</code>，用于返回一个建造好的完整产品。</p>
<p>​      在<code>ConcreteBuilder</code>中实现了<code>buildPartX()</code>方法，通过调用<code>Product</code>的<code>setPartX()</code>方法可以给产品对象的成员属性设值。不同的具体建造者在实现<code>buildPartX()</code>方法时将有所区别，如<code>setPartX()</code>方法的参数可能不一样，在有些具体建造者类中某些<code>setPartX()</code>方法无须实现（提供一个空实现）。而这些对于客户端来说都无须关心，客户端只需知道具体建造者类型即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPartA</span><span class="params">()</span> </span>&#123;</div><div class="line">      product.setPartA(<span class="string">"A"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPartB</span><span class="params">()</span> </span>&#123;</div><div class="line">      product.setPartB(<span class="string">"B"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPartC</span><span class="params">()</span> </span>&#123;</div><div class="line">      product.setPartC(<span class="string">"C"</span>);</div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​      在建造者模式的结构中还引入了一个指挥者类<code>Director</code>，该类主要有两个作用：一方面它隔离了客户与创建过程；另一方面它控制产品的创建过程，包括某个<code>buildPartX()</code>方法是否被调用以及多个<code>buildPartX()</code>方法调用的先后次序等。指挥者针对抽象建造者编程，客户端只需要知道具体建造者的类型，即可通过指挥者类调用建造者的相关方法，返回一个完整的产品对象。在实际生活中也存在类似指挥者一样的角色，如一个客户去购买电脑，电脑销售人员相当于指挥者，只要客户确定电脑的类型，电脑销售人员可以通知电脑组装人员给客户组装一台电脑。指挥者类的代码示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</div><div class="line">       <span class="keyword">private</span>  Builder builder;</div><div class="line">      </div><div class="line">       <span class="function"><span class="keyword">public</span>  <span class="title">Director</span><span class="params">(Builder builder)</span> </span>&#123;</div><div class="line">              <span class="keyword">this</span>.builder=builder;</div><div class="line">       &#125;</div><div class="line">      </div><div class="line">       <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">setBuilder</span><span class="params">(Builder builder)</span> </span>&#123;</div><div class="line">              <span class="keyword">this</span>.builder=builer;</div><div class="line">       &#125;</div><div class="line">      </div><div class="line">      <span class="comment">//产品构建与组装方法</span></div><div class="line">       <span class="function"><span class="keyword">public</span> Product <span class="title">construct</span><span class="params">()</span> </span>&#123;</div><div class="line">              builder.buildPartA();</div><div class="line">              builder.buildPartB();</div><div class="line">              builder.buildPartC();</div><div class="line">              <span class="keyword">return</span> builder.getResult();</div><div class="line">       &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在指挥者类中可以注入一个抽象建造者类型的对象，其核心在于提供了一个建造方法construct()，在该方法中调用了builder对象的构造部件的方法，最后返回一个产品对象。</p>
<p>对于客户端而言，只需关心具体的建造者即可，一般情况下，客户端类代码片段如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Builder  builder = <span class="keyword">new</span> ConcreteBuilder(); <span class="comment">//可通过配置文件实现</span></div><div class="line">Director director = <span class="keyword">new</span> Director(builder);</div><div class="line">Product product = director.construct();</div></pre></td></tr></table></figure>
<p>可以通过配置文件来存储具体建造者类ConcreteBuilder的类名，使得更换新的建造者时无须修改源代码，系统扩展更为方便。在客户端代码中，无须关心产品对象的具体组装过程，只需指定具体建造者的类型即可。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>在建造者模式中， <strong>客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。</strong></li>
<li>每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者， <strong>用户使用不同的具体建造者即可得到不同的产品对象</strong> 。</li>
<li><strong>可以更加精细地控制产品的创建过程</strong> 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。</li>
<li><strong>增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合“开闭原则”。</strong></li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。</li>
<li>如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。</li>
</ul>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h3><p>​      在以下情况下可以考虑使用建造者模式：</p>
<ol>
<li>需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性。</li>
<li>需要生成的产品对象的属性相互依赖，需要指定其生成顺序。</li>
<li>对象的创建过程独立于创建该对象的类。在建造者模式中通过引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类和客户类中。</li>
<li>隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。</li>
</ol>
<h3 id="模式应用"><a href="#模式应用" class="headerlink" title="模式应用"></a>模式应用</h3><p>在很多游戏软件中，地图包括天空、地面、背景等组成部分，人物角色包括人体、服装、装备等组成部分，可以使用建造者模式对其进行设计，通过不同的具体建造者创建不同类型的地图或人物。</p>
<h3 id="模式扩展"><a href="#模式扩展" class="headerlink" title="模式扩展"></a>模式扩展</h3><p>建造者模式的简化:</p>
<ul>
<li><strong>省略抽象建造者角色：</strong>如果系统中只需要一个具体建造者的话，可以省略掉抽象建造者。</li>
<li><strong>省略指挥者角色：</strong>在具体建造者只有一个的情况下，如果抽象建造者角色已经被省略掉，那么还可以省略指挥者角色，让<code>Builder</code>角色扮演指挥者与建造者双重角色。</li>
</ul>
<p>建造者模式与抽象工厂模式的比较:</p>
<ul>
<li>与抽象工厂模式相比， <strong>建造者模式返回一个组装好的完整产品</strong> ，而 <strong>抽象工厂模式返回一系列相关的产品，这些产品位于不同的产品等级结构，构成了一个产品族。</strong></li>
<li>在抽象工厂模式中，客户端实例化工厂类，然后调用工厂方法获取所需产品对象，而在建造者模式中，客户端可以不直接调用建造者的相关方法，而是通过指挥者类来指导如何生成对象，包括对象的组装过程和建造步骤，它侧重于一步步构造一个复杂对象，返回一个完整的对象。</li>
<li>如果将抽象工厂模式看成 <strong>汽车配件生产工厂</strong> ，生产一个产品族的产品，那么建造者模式就是一个 <strong>汽车组装工厂</strong> ，通过对部件的组装可以返回一辆完整的汽车。</li>
</ul>
<h3 id="建造者简化"><a href="#建造者简化" class="headerlink" title="建造者简化"></a>建造者简化</h3><ul>
<li>首先创建一个静态内部类，把外部类的所有属性拷贝到静态内部类里面，同时为了遵循命名的规范，我们以类名Builder来命名内部类。</li>
<li>静态内部类包含一个public的构造函数，所有必需传递的参数作为构造函数的参数。</li>
<li>静态内部类应该提供设置可选参数的入口，即可选参数对应的set方法同时当连续调用多个属性的set方法之后，应该保证返回的是同一个builder对象。</li>
<li>最后一步要在静态内部类中实现一个builder方法，这个方法会返回外部类的对象。通过在外部类中实现一个private的私有构造函数，静态内部类作为参数来实现。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//required parameters</span></div><div class="line">    <span class="keyword">private</span> String HDD;</div><div class="line">    <span class="keyword">private</span> String RAM;</div><div class="line"></div><div class="line">    <span class="comment">//optional parameters</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isGraphicsCardEnabled;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isBluetoothEnabled;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getHDD</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> HDD;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRAM</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> RAM;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isGraphicsCardEnabled</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> isGraphicsCardEnabled;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBluetoothEnabled</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> isBluetoothEnabled;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Computer</span><span class="params">(ComputerBuilder builder)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.HDD = builder.HDD;</div><div class="line">        <span class="keyword">this</span>.RAM = builder.RAM;</div><div class="line">        <span class="keyword">this</span>.isGraphicsCardEnabled = builder.isGraphicsCardEnabled;</div><div class="line">        <span class="keyword">this</span>.isBluetoothEnabled = builder.isBluetoothEnabled;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Computer [HDD="</span> + HDD + <span class="string">", RAM="</span> + RAM + <span class="string">", isGraphicsCardEnabled="</span></div><div class="line">               + isGraphicsCardEnabled + <span class="string">", isBluetoothEnabled="</span> + isBluetoothEnabled + <span class="string">"]"</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//Builder Class</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputerBuilder</span> </span>&#123;</div><div class="line">        <span class="comment">// required parameters</span></div><div class="line">        <span class="keyword">private</span> String  HDD;</div><div class="line">        <span class="keyword">private</span> String  RAM;</div><div class="line">        <span class="comment">// optional parameters</span></div><div class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> isGraphicsCardEnabled;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> isBluetoothEnabled;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ComputerBuilder</span><span class="params">(String hdd, String ram)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.HDD = hdd;</div><div class="line">            <span class="keyword">this</span>.RAM = ram;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> ComputerBuilder <span class="title">setGraphicsCardEnabled</span><span class="params">(<span class="keyword">boolean</span> isGraphicsCardEnabled)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.isGraphicsCardEnabled = isGraphicsCardEnabled;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> ComputerBuilder <span class="title">setBluetoothEnabled</span><span class="params">(<span class="keyword">boolean</span> isBluetoothEnabled)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.isBluetoothEnabled = isBluetoothEnabled;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> Computer <span class="title">build</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Computer(<span class="keyword">this</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一般开发中都需要自己手动建造产品，成员属性的值是可变的。</p>
<p>jdk中建造者模式：<code>java.lang.StringBuilder#append()</code></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/builder.html#id16" target="_blank" rel="external">建造者模式</a></p>
<p><a href="http://blog.csdn.net/lovelion/article/details/7426015" target="_blank" rel="external">建造者模式</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[设计模式-抽象工厂模式]]></title>
      <url>http://zsr.github.io/2017/05/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>​       工厂方法模式通过引入工厂等级结构，解决了简单工厂模式中工厂类职责太重的问题，但由于工厂方法模式中的每个工厂只生产一类产品，可能会导致系统中存在大量的工厂类，势必会增加系统的开销。此时，可以考虑<strong>将一些相关的产品组成一个“产品族”，由同一个工厂来统一生产</strong>，这就是我们本文将要学习的抽象工厂模式的基本思想。</p>
<h3 id="产品等级结构与产品族"><a href="#产品等级结构与产品族" class="headerlink" title="产品等级结构与产品族"></a>产品等级结构与产品族</h3><ul>
<li>在工厂方法模式中具体工厂负责生产具体的产品，每一个具体工厂对应一种具体产品，工厂方法具有唯一性，一般情况下，一个具体工厂中只有一个或者一组重载的工厂方法。但是有时候我们希望一个工厂可以提供多个产品对象，而不是单一的产品对象，如一个电器工厂，它可以生产电视机、电冰箱、空调等多种电器，而不是只生产某一种电器。为了更好地理解抽象工厂模式，先引入两个概念：<ol>
<li><strong>产品等级结构</strong>：<strong>产品等级结构即产品的继承结构</strong>，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。**</li>
<li><strong>产品族</strong>：在抽象工厂模式中，<strong>产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品</strong>，如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中，海尔电视机、海尔电冰箱构成了一个产品族。</li>
</ol>
</li>
<li>当系统所提供的工厂所需生产的具体产品并不是一个简单的对象，而是多个位于不同产品等级结构中属于不同类型的具体产品时需要使用抽象工厂模式。</li>
<li>抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形态。</li>
<li>抽象工厂模式与工厂方法模式最大的区别在于，<strong>工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构</strong>，一个工厂等级结构可以负责多个不同产品等级结构中的产品对象的创建 。当一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象时，抽象工厂模式比工厂方法模式更为简单、有效率。</li>
</ul>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>抽象工厂模式为创建一组对象提供了一种解决方案。与工厂方法模式相比，抽象工厂模式中的具体工厂不只是创建一种产品，它负责创建一族产品。</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，它是一种对象创建型模式。</div></pre></td></tr></table></figure>
<h3 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h3><p><img src="http://design-patterns.readthedocs.io/zh_CN/latest/_images/AbatractFactory.jpg" alt="img"></p>
<h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><p>在抽象工厂模式结构图中包含如下几个角色：</p>
<ul>
<li><strong>AbstractFactory（抽象工厂）：</strong>它声明了一组用于创建一族产品的方法，每一个方法对应一种产品。</li>
<li><strong>ConcreteFactory（具体工厂）：</strong>它实现了在抽象工厂中声明的创建产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中。</li>
<li><strong>AbstractProduct（抽象产品）：</strong>它为每种产品声明接口，在抽象产品中声明了产品所具有的业务方法。</li>
<li><strong>ConcreteProduct（具体产品）：</strong>它定义具体工厂生产的具体产品对象，实现抽象产品接口中声明的业务方法。</li>
</ul>
<a id="more"></a>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p> 在抽象工厂中声明了多个工厂方法，用于创建不同类型的产品，抽象工厂可以是接口，也可以是抽象类或者具体类，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span> </span>&#123;  </div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> AbstractProductA <span class="title">createProductA</span><span class="params">()</span></span>; <span class="comment">//工厂方法一  </span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> AbstractProductB <span class="title">createProductB</span><span class="params">()</span></span>; <span class="comment">//工厂方法二   </span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>具体工厂实现了抽象工厂，每一个具体的工厂方法可以返回一个特定的产品对象，而同一个具体工厂所创建的产品对象构成了一个产品族。对于每一个具体工厂类，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory1</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span> </span>&#123;  </div><div class="line">    <span class="comment">//工厂方法一  </span></div><div class="line">    <span class="function"><span class="keyword">public</span> AbstractProductA <span class="title">createProductA</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProductA1();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">//工厂方法二  </span></div><div class="line">    <span class="function"><span class="keyword">public</span> AbstractProductB <span class="title">createProductB</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProductB1();  </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 与工厂方法模式一样，抽象工厂模式也可为每一种产品提供一组重载的工厂方法，以不同的方式对产品对象进行创建。</p>
<p>在客户端代码中，只需关心工厂类即可，不同的具体工厂可以创建不同的产品，客户端类代码片段如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;  </div><div class="line">		AbstractFactory factory = <span class="keyword">new</span> ConcreteFactory1(); <span class="comment">//可通过配置文件实现  </span></div><div class="line">		ConcreteProductA1 productA1 = factory.createProductA();  </div><div class="line">        ConcreteProductB1 productB1 = factory.createProductA();  </div><div class="line"> 	&#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易。所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。另外，应用抽象工厂模式可以实现高内聚低耦合的设计目的，因此抽象工厂模式得到了广泛的应用。</li>
<li>当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。这对一些需要根据当前环境来决定其行为的软件系统来说，是一种非常实用的设计模式。</li>
<li>增加新的具体工厂和产品族很方便，无须修改已有系统，符合“开闭原则”。</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>在添加新的产品对象时，难以扩展抽象工厂来生产新种类的产品，这是因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其所有子类的修改，显然会带来较大的不便，违背了“开闭原则”。</li>
<li>开闭原则的倾斜性（增加新的工厂和产品族容易，增加新的产品等级结构麻烦）。</li>
</ul>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>​       在以下情况下可以考虑使用抽象工厂模式：</p>
<ol>
<li>一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是很重要的，用户无须关心对象的创建过程，将对象的创建和使用解耦。</li>
<li>系统中有多于一个的产品族，而每次只使用其中某一产品族。可以通过配置文件等方式来使得用户可以动态改变产品族，也可以很方便地增加新的产品族。</li>
<li>属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。同一个产品族中的产品可以是没有任何关系的对象，但是它们都具有一些共同的约束，如同一操作系统下的按钮和文本框，按钮与文本框之间没有直接关系，但它们都是属于某一操作系统的，此时具有一个共同的约束条件：操作系统的类型。</li>
<li>产品等级结构稳定，设计完成之后，不会向系统中增加新的产品等级结构或者删除已有的产品等级结构。</li>
</ol>
<h3 id="模式应用"><a href="#模式应用" class="headerlink" title="模式应用"></a>模式应用</h3><p>在很多软件系统中需要更换界面主题，要求界面中的按钮、文本框、背景色等一起发生改变时，可以使用抽象工厂模式进行设计。</p>
<h3 id="模式扩展"><a href="#模式扩展" class="headerlink" title="模式扩展"></a>模式扩展</h3><p>“开闭原则”的倾斜性</p>
<ul>
<li>“开闭原则”要求系统对扩展开放，对修改封闭，通过扩展达到增强其功能的目的。对于涉及到多个产品族与多个产品等级结构的系统，其功能增强包括两方面：<ul>
<li>增加产品族：对于增加新的产品族，抽象工厂模式很好的支持了“开闭原则”，对于新增加的产品族，只需要对应增加一个新的具体工厂即可，对已有代码无须做任何修改。增加新的产品等级结构：对于增加新的产品等级结构，需要修改所有的工厂角色，包括抽象工厂类，在所有的工厂类中都需要增加生产新产品的方法，不能很好地支持“开闭原则”。</li>
<li>抽象工厂模式的这种性质称为“开闭原则”的倾斜性，抽象工厂模式以一种倾斜的方式支持增加新的产品，它为新产品族的增加提供方便，但不能为新的产品等级结构的增加提供这样的方便。</li>
</ul>
</li>
</ul>
<p>工厂模式的退化</p>
<ul>
<li>当抽象工厂模式中每一个具体工厂类只创建一个产品对象，也就是只存在一个产品等级结构时，抽象工厂模式退化成工厂方法模式；当工厂方法模式中抽象工厂与具体工厂合并，提供一个统一的工厂来创建产品对象，并将创建对象的工厂方法设计为静态方法时，工厂方法模式退化成简单工厂模式。</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/abstract_factory.html#id17" target="_blank" rel="external">抽象工厂模式(Abstract Factory)</a></p>
<p><a href="http://blog.csdn.net/lovelion/article/details/9319423" target="_blank" rel="external">工厂三兄弟之抽象工厂模式</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[设计模式-工厂方法模式]]></title>
      <url>http://zsr.github.io/2017/05/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>​       简单工厂模式虽然简单，但存在一个很严重的问题。<strong>当系统中需要引入新产品时，由于静态工厂方法通过所传入参数的不同来创建不同的产品，这必定要修改工厂类的源代码，将违背“开闭原则”，如何实现增加新产品而不影响已有代码？</strong>工厂方法模式应运而生，本文将介绍第二种工厂模式—工厂方法模式。</p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>​       在简单工厂模式中只提供一个工厂类，该工厂类处于对产品类进行实例化的中心位置，它需要知道每一个产品对象的创建细节，并决定何时实例化哪一个产品类。简单工厂模式最大的缺点是当有新产品要加入到系统中时，必须修改工厂类，需要在其中加入必要的业务逻辑，这违背了“开闭原则”。此外，在简单工厂模式中，所有的产品都由同一个工厂创建，工厂类职责较重，业务逻辑较为复杂，具体产品与工厂类之间的耦合度高，严重影响了系统的灵活性和扩展性，而工厂方法模式则可以很好地解决这一问题。</p>
<p>在工厂方法模式中，我们<strong>不再提供一个统一的工厂类来创建所有的产品对象，而是针对不同的产品提供不同的工厂，系统提供一个与产品等级结构对应的工厂等级结构</strong>。</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">工厂方法模式(Factory Method Pattern)：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。工厂方法模式又简称为工厂模式(Factory Pattern)，又可称作虚拟构造器模式(Virtual Constructor Pattern)或多态工厂模式(Polymorphic Factory Pattern)。工厂方法模式是一种类创建型模式。</div></pre></td></tr></table></figure>
<h3 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h3><p><img src="http://design-patterns.readthedocs.io/zh_CN/latest/_images/FactoryMethod.jpg" alt="img"></p>
<h3 id="角色："><a href="#角色：" class="headerlink" title="角色："></a>角色：</h3><ul>
<li><strong>Product（抽象产品）：</strong>它是定义产品的接口，是工厂方法模式所创建对象的超类型，也就是产品对象的公共父类。</li>
<li><strong>ConcreteProduct（具体产品）：</strong>它实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，具体工厂和具体产品之间一一对应。</li>
<li><strong>Factory（抽象工厂）：</strong>在抽象工厂类中，声明了工厂方法(Factory Method)，用于返回一个产品。抽象工厂是工厂方法模式的核心，所有创建对象的工厂类都必须实现该接口。</li>
<li><strong>ConcreteFactory（具体工厂）：</strong>它是抽象工厂类的子类，实现了抽象工厂中定义的工厂方法，并可由客户端调用，返回一个具体产品类的实例。</li>
</ul>
<a id="more"></a>
<h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><p><img src="http://design-patterns.readthedocs.io/zh_CN/latest/_images/seq_FactoryMethod.jpg" alt="img"></p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p><strong>与简单工厂模式相比，工厂方法模式最重要的区别是引入了抽象工厂角色，</strong>抽象工厂可以是接口，也可以是抽象类或者具体类，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">factoryMethod</span><span class="params">()</span></span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在抽象工厂中声明了工厂方法但并未实现工厂方法，具体产品对象的创建由其子类负责，客户端针对抽象工厂编程，可在运行时再指定具体工厂类，具体工厂类实现了工厂方法，不同的具体工厂可以创建不同的具体产品，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">factoryMethod</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在实际使用时，具体工厂类在实现工厂方法时除了创建具体产品对象之外，还可以负责产品对象的初始化工作以及一些资源和环境配置工作，例如连接数据库、创建文件等。</p>
<p>在客户端代码中，只需关心工厂类即可，不同的具体工厂可以创建不同的产品，客户端类代码片段如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;  </div><div class="line">		Factory factory = <span class="keyword">new</span> ConcreteFactory(); <span class="comment">//可通过配置文件实现  </span></div><div class="line">		Product product = factory.factoryMethod();  </div><div class="line"> 	&#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 可以通过配置文件来存储具体工厂类ConcreteFactory的类名，更换新的具体工厂时无须修改源代码，系统扩展更为方便。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。</li>
<li>基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，是因为所有的具体工厂类都具有同一抽象父类。</li>
<li>使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而<strong>只要添加一个具体工厂和具体产品就可以了</strong>。这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。</li>
<li>由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。</li>
</ul>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>​       在以下情况下可以考虑使用工厂方法模式：</p>
<ol>
<li>客户端不知道它所需要的对象的类。在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建，可将具体工厂类的类名存储在配置文件或数据库中。</li>
<li>抽象工厂类通过其子类来指定创建哪个对象。在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。</li>
<li>将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。</li>
</ol>
<h3 id="模式应用"><a href="#模式应用" class="headerlink" title="模式应用"></a>模式应用</h3><p>JDBC中的工厂方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Connection 抽象工厂接口，先通过getConnection获取具体的工厂类</span></div><div class="line">Connection conn=DriverManager.getConnection(<span class="string">"jdbc:microsoft:sqlserver://localhost:1433; DatabaseName=DB;user=sa;password="</span>);</div><div class="line"><span class="comment">// conn为具体的工厂类，statement为具体产品</span></div><div class="line">Statement statement=conn.createStatement();</div><div class="line">ResultSet rs=statement.executeQuery(<span class="string">"select * from UserInfo"</span>);</div></pre></td></tr></table></figure>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://blog.csdn.net/lovelion/article/details/9306745" target="_blank" rel="external">工厂方法模式</a></p>
<p><a href="http://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/factory_method.html#id15" target="_blank" rel="external">工厂方法模式(Factory Method Pattern)</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[设计模式-简单工厂模式]]></title>
      <url>http://zsr.github.io/2017/05/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>​       <strong>简单工厂模式</strong>并不属于GoF 23个经典设计模式，但通常将它作为学习其他工厂模式的基础，它的设计思想很简单，其基本流程如下：</p>
<p>​       首先将需要创建的各种不同对象的相关代码封装到不同的类中，这些类称为<strong>具体产品类</strong>，而将它们公共的代码进行抽象和提取后封装在一个<strong>抽象产品类</strong>中，每一个具体产品类都是抽象产品类的子类；然后提供一个<strong>工厂类</strong>用于创建各种产品，在工厂类中提供一个创建产品的工厂方法，该方法可以根据所传入的参数不同创建不同的具体产品对象；客户端只需调用工厂类的工厂方法并传入相应的参数即可得到一个产品对象。</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">简单工厂模式(Simple Factory Pattern)：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。因为在简单工厂模式中用于创建实例的方法是静态(static)方法，因此简单工厂模式又被称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。</div></pre></td></tr></table></figure>
<h3 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h3><p>简单工厂模式的要点在于：<strong>当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。</strong>简单工厂模式结构比较简单，其核心是工厂类的设计，其结构如图所示：</p>
<p><img src="http://design-patterns.readthedocs.io/zh_CN/latest/_images/SimpleFactory.jpg" alt="img"></p>
<h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><p>  在简单工厂模式结构图中包含如下几个角色：</p>
<ul>
<li><strong>Factory（工厂角色）：</strong>工厂角色即工厂类，它是简单工厂模式的核心，负责实现创建所有产品实例的内部逻辑；工厂类可以被外界直接调用，创建所需的产品对象；在工厂类中提供了静态的工厂方法factoryMethod()，它的返回类型为抽象产品类型Product。</li>
<li><strong>Product（抽象产品角色）：</strong>它是工厂类所创建的所有对象的父类，封装了各种产品对象的公有方法，它的引入将提高系统的灵活性，使得在工厂类中只需定义一个通用的工厂方法，因为所有创建的具体产品对象都是其子类对象。</li>
<li><strong>ConcreteProduct（具体产品角色）：</strong>它是简单工厂模式的创建目标，所有被创建的对象都充当这个角色的某个具体类的实例。每一个具体产品角色都继承了抽象产品角色，需要实现在抽象产品中声明的抽象方法。</li>
</ul>
<p>在简单工厂模式中，客户端通过工厂类来创建一个产品类的实例，而无须直接使用new关键字来创建对象，它是工厂模式家族中最简单的一员。</p>
<a id="more"></a>
<h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><p><img src="http://design-patterns.readthedocs.io/zh_CN/latest/_images/seq_SimpleFactory.jpg" alt="img"></p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>抽象产品类代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;  </div><div class="line">    <span class="comment">//所有产品类的公共业务方法  </span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodSame</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="comment">//公共方法的实现  </span></div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">//声明抽象业务方法  </span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">methodDiff</span><span class="params">()</span></span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在具体产品类中实现了抽象产品类中声明的抽象业务方法，不同的具体产品类可以提供不同的实现，具体产品类代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct</span> <span class="keyword">extends</span> <span class="title">Product</span> </span>&#123;  </div><div class="line">    <span class="comment">//实现自己的业务方法  </span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodDiff</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="comment">//业务方法的实现  </span></div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>简单工厂模式的核心是工厂类，在没有工厂类之前，客户端一般会使用new关键字来直接创建产品对象，而在引入工厂类之后，客户端可以通过工厂类来创建产品，在简单工厂模式中，工厂类提供了一个静态工厂方法供客户端使用，根据所传入的参数不同可以创建不同的产品对象，工厂类代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;  </div><div class="line">    <span class="comment">//静态工厂方法  </span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Product <span class="title">createProduct</span><span class="params">(String arg)</span> </span>&#123;  </div><div class="line">        Product product = <span class="keyword">null</span>;  </div><div class="line">        <span class="keyword">if</span> (arg.equalsIgnoreCase(<span class="string">"A"</span>)) &#123;  </div><div class="line">            product = <span class="keyword">new</span> ConcreteProductA();  </div><div class="line">            <span class="comment">//初始化设置product  </span></div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arg.equalsIgnoreCase(<span class="string">"B"</span>)) &#123;  </div><div class="line">            product = <span class="keyword">new</span> ConcreteProductB();  </div><div class="line">            <span class="comment">//初始化设置product  </span></div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">return</span> product;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 在客户端代码中，我们通过调用工厂类的工厂方法即可得到产品对象，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;  </div><div class="line">        Product product = Factory.getProduct(<span class="string">"A"</span>); <span class="comment">//通过工厂类创建产品对象  </span></div><div class="line">        product.methodSame();  </div><div class="line">        product.methodDiff();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的责任，而仅仅“消费”产品；简单工厂模式通过这种做法实现了对责任的分割，它提供了专门的工厂类用于创建对象。</li>
<li>客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以减少使用者的记忆量。</li>
<li>通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>由于工厂类集中了所有产品创建逻辑，一旦不能正常工作，整个系统都要受到影响。</li>
<li>使用简单工厂模式将会增加系统中类的个数，在一定程序上增加了系统的复杂度和理解难度。</li>
<li>系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。</li>
<li>简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。</li>
</ul>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>​       在以下情况下可以考虑使用简单工厂模式：</p>
<ol>
<li>工厂类负责创建的对象比较少，由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。</li>
<li>客户端只知道传入工厂类的参数，对于如何创建对象并不关心。</li>
</ol>
<h3 id="模式应用"><a href="#模式应用" class="headerlink" title="模式应用"></a>模式应用</h3><ol>
<li>JDK类库中广泛使用了简单工厂模式，如工具类java.text.DateFormat，它用于格式化一个本地日期或者时间。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> DateFormat <span class="title">getDateInstance</span><span class="params">(<span class="keyword">int</span> style)</span></span>;</div></pre></td></tr></table></figure>
<ol>
<li>Java加密技术</li>
</ol>
<p>获取不同加密算法的密钥生成器:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">KeyGenerator keyGen=KeyGenerator.getInstance(<span class="string">"DESede"</span>);</div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Spring MVC 请求参数绑定]]></title>
      <url>http://zsr.github.io/2017/05/15/Spring-MVC-%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A/</url>
      <content type="html"><![CDATA[<p>在做<code>Spring MVC</code>时，我们只需用<code>@Controllor</code>来标记<code>Controllor</code>的bean，再用<code>@RequestMapping</code>来标记需要接受请求的方法，就可以根据网页请求中的参数名，自动绑定到POJO对象的属性名，这是相当方便的。其中的原理是什么呢？</p>
<h3 id="前瞻"><a href="#前瞻" class="headerlink" title="前瞻"></a>前瞻</h3><p>通过Spring MVC请求调用链，实际是由<code>ServletInvocableHandlerMethod.invokeAndHandle(webRequest, mavContainer)</code>方法执行处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">  <span class="comment">/**</span></div><div class="line"> * Invokes the method and handles the return value through a registered</div><div class="line"> * &#123;<span class="doctag">@link</span> HandlerMethodReturnValueHandler&#125;.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> webRequest the current request</div><div class="line"> * <span class="doctag">@param</span> mavContainer the ModelAndViewContainer for this request</div><div class="line"> * <span class="doctag">@param</span> providedArgs "given" arguments matched by type, not resolved</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">invokeAndHandle</span><span class="params">(ServletWebRequest webRequest,</span></span></div><div class="line">		ModelAndViewContainer mavContainer, Object... providedArgs) <span class="keyword">throws</span> Exception &#123;</div><div class="line"></div><div class="line">       <span class="comment">// 执行请求方法，返回结果。。。</span></div><div class="line">	Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);</div><div class="line"></div><div class="line">	setResponseStatus(webRequest);</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (returnValue == <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="keyword">if</span> (isRequestNotModified(webRequest) || hasResponseStatus() || mavContainer.isRequestHandled()) &#123;</div><div class="line">			mavContainer.setRequestHandled(<span class="keyword">true</span>);</div><div class="line">			<span class="keyword">return</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.hasText(<span class="keyword">this</span>.responseReason)) &#123;</div><div class="line">		mavContainer.setRequestHandled(<span class="keyword">true</span>);</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	mavContainer.setRequestHandled(<span class="keyword">false</span>);</div><div class="line"></div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">		<span class="keyword">this</span>.returnValueHandlers.handleReturnValue(returnValue, getReturnValueType(returnValue), mavContainer, webRequest);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">catch</span> (Exception ex) &#123;</div><div class="line">		<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</div><div class="line">			logger.trace(getReturnValueHandlingErrorMessage(<span class="string">"Error handling return value"</span>, returnValue), ex);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">throw</span> ex;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p><code>webRequest</code>为<code>httpRequest</code>包装后的类，添加了uri成员，标记请求uri以便方便分配。<code>mavContainer</code>为<code>ModelAndViewContainer</code>类对象，用于绑定模块（POJO）和视图（view即网页）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">  <span class="comment">/**</span></div><div class="line"> * Invoke the method after resolving its argument values in the context of the given request. &lt;p&gt;Argument</div><div class="line"> * values are commonly resolved through &#123;<span class="doctag">@link</span> HandlerMethodArgumentResolver&#125;s. The &#123;<span class="doctag">@code</span> provideArgs&#125;</div><div class="line"> * parameter however may supply argument values to be used directly, i.e. without argument resolution.</div><div class="line"> * Examples of provided argument values include a &#123;<span class="doctag">@link</span> WebDataBinder&#125;, a &#123;<span class="doctag">@link</span> SessionStatus&#125;, or</div><div class="line"> * a thrown exception instance. Provided argument values are checked before argument resolvers.</div><div class="line"> * <span class="doctag">@param</span> request the current request</div><div class="line"> * <span class="doctag">@param</span> mavContainer the ModelAndViewContainer for this request</div><div class="line"> * <span class="doctag">@param</span> providedArgs "given" arguments matched by type, not resolved</div><div class="line"> * <span class="doctag">@return</span> the raw value returned by the invoked method</div><div class="line"> * <span class="doctag">@exception</span> Exception raised if no suitable argument resolver can be found, or the method raised an exception</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">invokeForRequest</span><span class="params">(NativeWebRequest request, ModelAndViewContainer mavContainer,</span></span></div><div class="line">		Object... providedArgs) <span class="keyword">throws</span> Exception &#123;</div><div class="line">       </div><div class="line">       <span class="comment">// 绑定参数，重点。。。。。</span></div><div class="line">	Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);</div><div class="line">	<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</div><div class="line">		StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"Invoking ["</span>);</div><div class="line">		sb.append(getBeanType().getSimpleName()).append(<span class="string">"."</span>);</div><div class="line">		sb.append(getMethod().getName()).append(<span class="string">"] method with arguments "</span>);</div><div class="line">		sb.append(Arrays.asList(args));</div><div class="line">		logger.trace(sb.toString());</div><div class="line">	&#125;</div><div class="line">	Object returnValue = invoke(args);</div><div class="line">	<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</div><div class="line">		logger.trace(<span class="string">"Method ["</span> + getMethod().getName() + <span class="string">"] returned ["</span> + returnValue + <span class="string">"]"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> returnValue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>invokeForRequest</code>方法中，<code>Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs)</code>;该方法获取每个请求参数与对应的值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">   <span class="comment">/**</span></div><div class="line">	 * Get the method argument values for the current request.</div><div class="line">	 */</div><div class="line"><span class="keyword">private</span> Object[] getMethodArgumentValues(NativeWebRequest request, ModelAndViewContainer mavContainer,</div><div class="line">            Object... providedArgs) <span class="keyword">throws</span> Exception &#123;</div><div class="line">        <span class="comment">// 获取所有参数所属的类</span></div><div class="line">        MethodParameter[] parameters = getMethodParameters();</div><div class="line">        Object[] args = <span class="keyword">new</span> Object[parameters.length];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameters.length; i++) &#123;</div><div class="line">            MethodParameter parameter = parameters[i];</div><div class="line">            parameter.initParameterNameDiscovery(<span class="keyword">this</span>.parameterNameDiscoverer);</div><div class="line">            GenericTypeResolver.resolveParameterType(parameter, getBean().getClass());</div><div class="line">            args[i] = resolveProvidedArgument(parameter, providedArgs);</div><div class="line">            <span class="keyword">if</span> (args[i] != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.argumentResolvers.supportsParameter(parameter)) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    args[i] = <span class="keyword">this</span>.argumentResolvers.resolveArgument(</div><div class="line">                            parameter, mavContainer, request, <span class="keyword">this</span>.dataBinderFactory);</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">catch</span> (Exception ex) &#123;</div><div class="line">                    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</div><div class="line">                        logger.trace(getArgumentResolutionErrorMessage(<span class="string">"Error resolving argument"</span>, i), ex);</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">throw</span> ex;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (args[i] == <span class="keyword">null</span>) &#123;</div><div class="line">                String msg = getArgumentResolutionErrorMessage(<span class="string">"No suitable resolver for argument"</span>, i);</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> args;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getArgumentResolutionErrorMessage</span><span class="params">(String message, <span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">        MethodParameter param = getMethodParameters()[index];</div><div class="line">        message += <span class="string">" ["</span> + index + <span class="string">"] [type="</span> + param.getParameterType().getName() + <span class="string">"]"</span>;</div><div class="line">        <span class="keyword">return</span> getDetailedErrorMessage(message);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这个方法也还是比较简单的，循环遍历请求参数，然后委托给<code>HandlerMethodArgumentResolver</code>接口的方法 <code>resolveArgument</code>去进行参数值解析。</p>
<h3 id="绑定参数名"><a href="#绑定参数名" class="headerlink" title="绑定参数名"></a>绑定参数名</h3><p>这里面对<code>ParameterNameDiscovery</code>初始化，用来查找参数名：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> ParameterNameDiscoverer parameterNameDiscoverer = <span class="keyword">new</span> LocalVariableTableParameterNameDiscoverer();</div><div class="line"><span class="comment">// 。。。。。。省略</span></div><div class="line">methodParam.initParameterNameDiscovery(<span class="keyword">this</span>.parameterNameDiscoverer);</div></pre></td></tr></table></figure>
<p>低于java1.8使用<code>new LocalVariableTableParameterNameDiscoverer()</code>来解析参数名。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> String[] getParameterNames(Method method) &#123;</div><div class="line">		Method originalMethod = BridgeMethodResolver.findBridgedMethod(method);</div><div class="line">		Class&lt;?&gt; declaringClass = originalMethod.getDeclaringClass();</div><div class="line">		Map&lt;Member, String[]&gt; map = <span class="keyword">this</span>.parameterNamesCache.get(declaringClass);</div><div class="line">		<span class="keyword">if</span> (map == <span class="keyword">null</span>) &#123;</div><div class="line">			map = inspectClass(declaringClass);</div><div class="line">			<span class="keyword">this</span>.parameterNamesCache.put(declaringClass, map);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (map != NO_DEBUG_INFO_MAP) &#123;</div><div class="line">			<span class="keyword">return</span> map.get(originalMethod);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>通过<code>map = inspectClass(declaringClass);</code>获取名称map。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">	 * Inspects the target class. Exceptions will be logged and a maker map returned</div><div class="line">	 * to indicate the lack of debug information.</div><div class="line">	 */</div><div class="line">	<span class="keyword">private</span> Map&lt;Member, String[]&gt; inspectClass(Class&lt;?&gt; clazz) &#123;</div><div class="line">		InputStream is = clazz.getResourceAsStream(ClassUtils.getClassFileName(clazz));</div><div class="line">		<span class="keyword">if</span> (is == <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="comment">// We couldn't load the class file, which is not fatal as it</span></div><div class="line">			<span class="comment">// simply means this method of discovering parameter names won't work.</span></div><div class="line">			<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line">				logger.debug(<span class="string">"Cannot find '.class' file for class ["</span> + clazz +</div><div class="line">						<span class="string">"] - unable to determine constructor/method parameter names"</span>);</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">return</span> NO_DEBUG_INFO_MAP;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			ClassReader classReader = <span class="keyword">new</span> ClassReader(is);</div><div class="line">			Map&lt;Member, String[]&gt; map = <span class="keyword">new</span> ConcurrentHashMap&lt;Member, String[]&gt;(<span class="number">32</span>);</div><div class="line">			classReader.accept(<span class="keyword">new</span> ParameterNameDiscoveringVisitor(clazz, map), <span class="number">0</span>);</div><div class="line">			<span class="keyword">return</span> map;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">catch</span> (IOException ex) &#123;</div><div class="line">			<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line">				logger.debug(<span class="string">"Exception thrown while reading '.class' file for class ["</span> + clazz +</div><div class="line">						<span class="string">"] - unable to determine constructor/method parameter names"</span>, ex);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</div><div class="line">			<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line">				logger.debug(<span class="string">"ASM ClassReader failed to parse class file ["</span> + clazz +</div><div class="line">						<span class="string">"], probably due to a new Java class file version that isn't supported yet "</span> +</div><div class="line">						<span class="string">"- unable to determine constructor/method parameter names"</span>, ex);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">finally</span> &#123;</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				is.close();</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">catch</span> (IOException ex) &#123;</div><div class="line">				<span class="comment">// ignore</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> NO_DEBUG_INFO_MAP;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p><code>ClassReader</code>位于<code>org.springframework.asm</code>包中，是Spring用于反编译的包，读取class信息，class信息中是包含参数名的（可以用文本编辑器打开一个class文件查看，虽然有乱码，但是方法的参数名还在）。</p>
<p>通过accept填充map对象，map的键为成员名(方法名或者参数名)，值为参数列表(字符串数组)。</p>
<p>由此可见，Spring是直接读取class文件来读取参数名的.</p>
<p>注意：<code>this.parameterNamesCache.put(declaringClass, map);</code>使用了<code>ConcurrentHashMap</code>设置方法名缓存。避免每一次调用都要反编译class文件。</p>
<h3 id="解析参数值"><a href="#解析参数值" class="headerlink" title="解析参数值"></a>解析参数值</h3><p>要给参数注入参数的值，最终是通过<code>HandlerMethodArgumentResolver</code>接口的实现类<code>HandlerMethodArgumentResolverComposite</code>实现的。<code>HandlerMethodArgumentResolverComposite</code>类实现是采用的组合模式的设计策略，可以在类<code>RequestMappingHandlerAdapter</code>中的方法<code>afterPropertiesSet</code>方法中看到<code>HandlerMethodArgumentResolverComposite</code>中的resovler的初始化代码。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.argumentResolvers == <span class="keyword">null</span>) &#123;</div><div class="line">			List&lt;HandlerMethodArgumentResolver&gt; resolvers = getDefaultArgumentResolvers();</div><div class="line">			<span class="keyword">this</span>.argumentResolvers = <span class="keyword">new</span> HandlerMethodArgumentResolverComposite().addResolvers(resolvers);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.initBinderArgumentResolvers == <span class="keyword">null</span>) &#123;</div><div class="line">			List&lt;HandlerMethodArgumentResolver&gt; resolvers = getDefaultInitBinderArgumentResolvers();</div><div class="line">			<span class="keyword">this</span>.initBinderArgumentResolvers = <span class="keyword">new</span> HandlerMethodArgumentResolverComposite().addResolvers(resolvers);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.returnValueHandlers == <span class="keyword">null</span>) &#123;</div><div class="line">			List&lt;HandlerMethodReturnValueHandler&gt; handlers = getDefaultReturnValueHandlers();</div><div class="line">			<span class="keyword">this</span>.returnValueHandlers = <span class="keyword">new</span> HandlerMethodReturnValueHandlerComposite().addHandlers(handlers);</div><div class="line">		&#125;</div><div class="line">		initControllerAdviceCache();</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>通过这个<code>afterPropertiesSet</code>方法增加默认的参数解析器，默认的参数解析器如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">	 * Return the list of argument resolvers to use including built-in resolvers</div><div class="line">	 * and custom resolvers provided via &#123;<span class="doctag">@link</span> #setCustomArgumentResolvers&#125;.</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">private</span> List&lt;HandlerMethodArgumentResolver&gt; <span class="title">getDefaultArgumentResolvers</span><span class="params">()</span> </span>&#123;</div><div class="line">		List&lt;HandlerMethodArgumentResolver&gt; resolvers = <span class="keyword">new</span> ArrayList&lt;HandlerMethodArgumentResolver&gt;();</div><div class="line"></div><div class="line">		<span class="comment">// Annotation-based argument resolution</span></div><div class="line">        <span class="comment">// 支持带有@RequestParam注解的参数</span></div><div class="line">		resolvers.add(<span class="keyword">new</span> RequestParamMethodArgumentResolver(getBeanFactory(), <span class="keyword">false</span>));</div><div class="line">		resolvers.add(<span class="keyword">new</span> RequestParamMapMethodArgumentResolver());</div><div class="line">		resolvers.add(<span class="keyword">new</span> PathVariableMethodArgumentResolver());</div><div class="line">		resolvers.add(<span class="keyword">new</span> PathVariableMapMethodArgumentResolver());</div><div class="line">		resolvers.add(<span class="keyword">new</span> MatrixVariableMethodArgumentResolver());</div><div class="line">		resolvers.add(<span class="keyword">new</span> MatrixVariableMapMethodArgumentResolver());</div><div class="line">		resolvers.add(<span class="keyword">new</span> ServletModelAttributeMethodProcessor(<span class="keyword">false</span>));</div><div class="line">        <span class="comment">// @RequestBody注解的参数解析器</span></div><div class="line">		resolvers.add(<span class="keyword">new</span> RequestResponseBodyMethodProcessor(getMessageConverters()));</div><div class="line">		resolvers.add(<span class="keyword">new</span> RequestPartMethodArgumentResolver(getMessageConverters()));</div><div class="line">		resolvers.add(<span class="keyword">new</span> RequestHeaderMethodArgumentResolver(getBeanFactory()));</div><div class="line">		resolvers.add(<span class="keyword">new</span> RequestHeaderMapMethodArgumentResolver());</div><div class="line">		resolvers.add(<span class="keyword">new</span> ServletCookieValueMethodArgumentResolver(getBeanFactory()));</div><div class="line">		resolvers.add(<span class="keyword">new</span> ExpressionValueMethodArgumentResolver(getBeanFactory()));</div><div class="line"></div><div class="line">		<span class="comment">// Type-based argument resolution</span></div><div class="line">        <span class="comment">// 参数类型是实现或继承或是WebRequest、ServletRequest这些类。</span></div><div class="line">		resolvers.add(<span class="keyword">new</span> ServletRequestMethodArgumentResolver());</div><div class="line">		resolvers.add(<span class="keyword">new</span> ServletResponseMethodArgumentResolver());</div><div class="line">		resolvers.add(<span class="keyword">new</span> HttpEntityMethodProcessor(getMessageConverters()));</div><div class="line">		resolvers.add(<span class="keyword">new</span> RedirectAttributesMethodArgumentResolver());</div><div class="line">		resolvers.add(<span class="keyword">new</span> ModelMethodProcessor());</div><div class="line">		resolvers.add(<span class="keyword">new</span> MapMethodProcessor());</div><div class="line">		resolvers.add(<span class="keyword">new</span> ErrorsMethodArgumentResolver());</div><div class="line">		resolvers.add(<span class="keyword">new</span> SessionStatusMethodArgumentResolver());</div><div class="line">		resolvers.add(<span class="keyword">new</span> UriComponentsBuilderMethodArgumentResolver());</div><div class="line"></div><div class="line">		<span class="comment">// Custom arguments</span></div><div class="line">		<span class="keyword">if</span> (getCustomArgumentResolvers() != <span class="keyword">null</span>) &#123;</div><div class="line">			resolvers.addAll(getCustomArgumentResolvers());</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">// Catch-all</span></div><div class="line">		resolvers.add(<span class="keyword">new</span> RequestParamMethodArgumentResolver(getBeanFactory(), <span class="keyword">true</span>));</div><div class="line">		resolvers.add(<span class="keyword">new</span> ServletModelAttributeMethodProcessor(<span class="keyword">true</span>));</div><div class="line"></div><div class="line">		<span class="keyword">return</span> resolvers;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>常用的参数解析器由<code>RequestParamMethodArgumentResolver</code>， <code>RequestResponseBodyMethodProcessor</code>(这个类也实现了<code>HandlerMethodReturnValueHandler</code>接口)等。</p>
<p>参数解析源码说明如下：</p>
<ul>
<li>如果有提供的参数值，直接返回提供的参数值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">args[i] = resolveProvidedArgument(parameter, providedArgs);</div><div class="line"><span class="keyword">if</span> (args[i] != <span class="keyword">null</span>) &#123;</div><div class="line">	 <span class="keyword">continue</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>检察参数类型是否支持</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.argumentResolvers.supportsParameter(parameter)</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// HandlerMethodArgumentResolverComposite类</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsParameter</span><span class="params">(MethodParameter parameter)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> getArgumentResolver(parameter) != <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">	 * Find a registered &#123;<span class="doctag">@link</span> HandlerMethodArgumentResolver&#125; that supports the given method parameter.</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">private</span> HandlerMethodArgumentResolver <span class="title">getArgumentResolver</span><span class="params">(MethodParameter parameter)</span> </span>&#123;</div><div class="line">		HandlerMethodArgumentResolver result = <span class="keyword">this</span>.argumentResolverCache.get(parameter);</div><div class="line">		<span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">for</span> (HandlerMethodArgumentResolver methodArgumentResolver : <span class="keyword">this</span>.argumentResolvers) &#123;</div><div class="line">				<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</div><div class="line">					logger.trace(<span class="string">"Testing if argument resolver ["</span> + methodArgumentResolver + <span class="string">"] supports ["</span> +</div><div class="line">							parameter.getGenericParameterType() + <span class="string">"]"</span>);</div><div class="line">				&#125;</div><div class="line">                <span class="comment">// 检察参数类型是否支持(每一个HandlerMethodArgumentResolver都有一个supportsParameter方法判断是否支持参数类型)</span></div><div class="line">				<span class="keyword">if</span> (methodArgumentResolver.supportsParameter(parameter)) &#123;</div><div class="line">					result = methodArgumentResolver;</div><div class="line">					<span class="keyword">this</span>.argumentResolverCache.put(parameter, result);</div><div class="line">					<span class="keyword">break</span>;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> result;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<ul>
<li>查询参数解析器，找到后委托给参数解析器解析</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">args[i] = <span class="keyword">this</span>.argumentResolvers.resolveArgument(</div><div class="line">							parameter, mavContainer, request, <span class="keyword">this</span>.dataBinderFactory);</div><div class="line">					<span class="keyword">continue</span>;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// HandlerMethodArgumentResolver实现类(这里是RequestResponseBodyMethodProcessor)</span></div><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">resolveArgument</span><span class="params">(MethodParameter parameter, ModelAndViewContainer mavContainer,</span></span></div><div class="line">			NativeWebRequest webRequest, WebDataBinderFactory binderFactory) <span class="keyword">throws</span> Exception &#123;</div><div class="line">		Object arg = readWithMessageConverters(webRequest, parameter, parameter.getGenericParameterType());</div><div class="line">		String name = Conventions.getVariableNameForParameter(parameter);</div><div class="line">		WebDataBinder binder = binderFactory.createBinder(webRequest, arg, name);</div><div class="line">		<span class="keyword">if</span> (arg != <span class="keyword">null</span>) &#123;</div><div class="line">			validate(binder, parameter);</div><div class="line">		&#125;</div><div class="line">		mavContainer.addAttribute(BindingResult.MODEL_KEY_PREFIX + name, binder.getBindingResult());</div><div class="line">		<span class="keyword">return</span> arg;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">	<span class="keyword">protected</span> &lt;T&gt; <span class="function">Object <span class="title">readWithMessageConverters</span><span class="params">(NativeWebRequest webRequest, MethodParameter methodParam,</span></span></div><div class="line">			Type paramType) <span class="keyword">throws</span> IOException, HttpMediaTypeNotSupportedException &#123;</div><div class="line"></div><div class="line">		HttpServletRequest servletRequest = webRequest.getNativeRequest(HttpServletRequest.class);</div><div class="line">		HttpInputMessage inputMessage = <span class="keyword">new</span> ServletServerHttpRequest(servletRequest);</div><div class="line"></div><div class="line">        <span class="comment">// 查看参数是否有@RequestBody注解</span></div><div class="line">		RequestBody ann = methodParam.getParameterAnnotation(RequestBody.class);</div><div class="line">		<span class="keyword">if</span> (!ann.required()) &#123;</div><div class="line">			InputStream inputStream = inputMessage.getBody();</div><div class="line">			<span class="keyword">if</span> (inputStream == <span class="keyword">null</span>) &#123;</div><div class="line">				<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (inputStream.markSupported()) &#123;</div><div class="line">				inputStream.mark(<span class="number">1</span>);</div><div class="line">				<span class="keyword">if</span> (inputStream.read() == -<span class="number">1</span>) &#123;</div><div class="line">					<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">				&#125;</div><div class="line">				inputStream.reset();</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">else</span> &#123;</div><div class="line">				<span class="keyword">final</span> PushbackInputStream pushbackInputStream = <span class="keyword">new</span> PushbackInputStream(inputStream);</div><div class="line">				<span class="keyword">int</span> b = pushbackInputStream.read();</div><div class="line">				<span class="keyword">if</span> (b == -<span class="number">1</span>) &#123;</div><div class="line">					<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">else</span> &#123;</div><div class="line">					pushbackInputStream.unread(b);</div><div class="line">				&#125;</div><div class="line">				inputMessage = <span class="keyword">new</span> ServletServerHttpRequest(servletRequest) &#123;</div><div class="line">					<span class="meta">@Override</span></div><div class="line">					<span class="function"><span class="keyword">public</span> InputStream <span class="title">getBody</span><span class="params">()</span> </span>&#123;</div><div class="line">						<span class="comment">// Form POST should not get here</span></div><div class="line">						<span class="keyword">return</span> pushbackInputStream;</div><div class="line">					&#125;</div><div class="line">				&#125;;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.readWithMessageConverters(inputMessage, methodParam, paramType);</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>然后会执行父类(AbstractMessageConverterMethodArgumentResolver)的readWithMessageConverters方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">	 * Create the method argument value of the expected parameter type by reading</div><div class="line">	 * from the given HttpInputMessage.</div><div class="line">	 * <span class="doctag">@param</span> &lt;T&gt; the expected type of the argument value to be created</div><div class="line">	 * <span class="doctag">@param</span> inputMessage the HTTP input message representing the current request</div><div class="line">	 * <span class="doctag">@param</span> methodParam the method argument</div><div class="line">	 * <span class="doctag">@param</span> targetType the type of object to create, not necessarily the same as</div><div class="line">	 * the method parameter type (e.g. for &#123;<span class="doctag">@code</span> HttpEntity&lt;String&gt;&#125; method</div><div class="line">	 * parameter the target type is String)</div><div class="line">	 * <span class="doctag">@return</span> the created method argument value</div><div class="line">	 * <span class="doctag">@throws</span> IOException if the reading from the request fails</div><div class="line">	 * <span class="doctag">@throws</span> HttpMediaTypeNotSupportedException if no suitable message converter is found</div><div class="line">	 */</div><div class="line">	<span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">	<span class="keyword">protected</span> &lt;T&gt; <span class="function">Object <span class="title">readWithMessageConverters</span><span class="params">(HttpInputMessage inputMessage,</span></span></div><div class="line">			MethodParameter methodParam, Type targetType) <span class="keyword">throws</span> IOException, HttpMediaTypeNotSupportedException &#123;</div><div class="line"></div><div class="line">		MediaType contentType;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			contentType = inputMessage.getHeaders().getContentType();</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">catch</span> (InvalidMediaTypeException ex) &#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> HttpMediaTypeNotSupportedException(ex.getMessage());</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (contentType == <span class="keyword">null</span>) &#123;</div><div class="line">			contentType = MediaType.APPLICATION_OCTET_STREAM;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		Class&lt;?&gt; contextClass = methodParam.getDeclaringClass();</div><div class="line">		Map&lt;TypeVariable, Type&gt; map = GenericTypeResolver.getTypeVariableMap(contextClass);</div><div class="line">		Class&lt;T&gt; targetClass = (Class&lt;T&gt;) GenericTypeResolver.resolveType(targetType, map);</div><div class="line"></div><div class="line">		<span class="keyword">for</span> (HttpMessageConverter&lt;?&gt; converter : <span class="keyword">this</span>.messageConverters) &#123;</div><div class="line">			<span class="keyword">if</span> (converter <span class="keyword">instanceof</span> GenericHttpMessageConverter) &#123;</div><div class="line">				GenericHttpMessageConverter genericConverter = (GenericHttpMessageConverter) converter;</div><div class="line">				<span class="keyword">if</span> (genericConverter.canRead(targetType, contextClass, contentType)) &#123;</div><div class="line">					<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line">						logger.debug(<span class="string">"Reading ["</span> + targetType + <span class="string">"] as \""</span> +</div><div class="line">								contentType + <span class="string">"\" using ["</span> + converter + <span class="string">"]"</span>);</div><div class="line">					&#125;</div><div class="line">					<span class="keyword">return</span> genericConverter.read(targetType, contextClass, inputMessage);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> (targetClass != <span class="keyword">null</span>) &#123;</div><div class="line">				<span class="keyword">if</span> (converter.canRead(targetClass, contentType)) &#123;</div><div class="line">					<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line">						logger.debug(<span class="string">"Reading ["</span> + targetClass.getName() + <span class="string">"] as \""</span> +</div><div class="line">								contentType + <span class="string">"\" using ["</span> + converter + <span class="string">"]"</span>);</div><div class="line">					&#125;</div><div class="line">					<span class="keyword">return</span> ((HttpMessageConverter&lt;T&gt;) converter).read(targetClass, inputMessage);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> HttpMediaTypeNotSupportedException(contentType, <span class="keyword">this</span>.allSupportedMediaTypes);</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>这里是用了消息转换器<code>HttpMessageConverter</code></p>
<ul>
<li>如果未找到抛出异常</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (args[i] == <span class="keyword">null</span>) &#123;</div><div class="line">				String msg = getArgumentResolutionErrorMessage(<span class="string">"No suitable resolver for argument"</span>, i);</div><div class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://www.cnblogs.com/guangshan/p/4660564.html" target="_blank" rel="external">反射获取一个方法中的参数名(不是类型)</a></p>
<p><a href="http://www.cnblogs.com/guangshan/p/4431800.html" target="_blank" rel="external">Spring源码研究：数据绑定</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Servlet 3 中的异步处理]]></title>
      <url>http://zsr.github.io/2017/05/09/Servlet-3-%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86/</url>
      <content type="html"><![CDATA[<p><strong><a href="http://www.cnblogs.com/davenkin/p/async-servlet.html" target="_blank" rel="external">转载</a></strong></p>
<p>在<code>Servlet 3.0</code>之前，<code>Servlet</code>采用<code>Thread-Per-Request</code>的方式处理请求，即每一次<code>Http</code>请求都由某一个线程从头到尾负责处理。如果一个请求需要进行IO操作，比如访问数据库、调用第三方服务接口等，那么其所对应的线程将同步地等待IO操作完成， 而IO操作是非常慢的，所以此时的线程并不能及时地释放回线程池以供后续使用，在并发量越来越大的情况下，这将带来严重的性能问题。即便是像<code>Spring</code>、<code>Struts</code>这样的高层框架也脱离不了这样的桎梏，因为他们都是建立在<code>Servlet</code>之上的。为了解决这样的问题，<code>Servlet 3.0</code>引入了异步处理，然后在<code>Servlet 3.1</code>中又引入了非阻塞IO来进一步增强异步处理的性能。</p>
<p>在<code>Servlet 3.0</code>中，我们可以从<code>HttpServletRequest</code>对象中获得一个<code>AsyncContext</code>对象，该对象构成了异步处理的上下文，<code>Request</code>和<code>Response</code>对象都可从中获取。<code>AsyncContext</code>可以从当前线程传给另外的线程，并在新的线程中完成对请求的处理并返回结果给客户端，初始线程便可以还回给容器线程池以处理更多的请求。如此，通过将请求从一个线程传给另一个线程处理的过程便构成了<code>Servlet 3.0</code>中的异步处理。</p>
<h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> davenkin.servlet;</div><div class="line"></div><div class="line"><span class="keyword">import</span> javax.servlet.ServletException;</div><div class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</div><div class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</div><div class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</div><div class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"></div><div class="line"><span class="meta">@WebServlet</span>(<span class="string">"/syncHello"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncHelloServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request,</span></span></div><div class="line">                         HttpServletResponse response) <span class="keyword">throws</span> ServletException, IOException &#123;</div><div class="line">        <span class="keyword">new</span> LongRunningProcess().run();</div><div class="line">        response.getWriter().write(<span class="string">"Hello World!"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为了模拟长时处理过程，创建了一个<code>LongRunningProcess</code>类，其<code>run()</code>方法将随机地等待2秒之内的一个时间：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> davenkin.servlet;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.concurrent.ThreadLocalRandom;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by yteng on 3/14/17.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongRunningProcess</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line"></div><div class="line">            <span class="keyword">int</span> millis = ThreadLocalRandom.current().nextInt(<span class="number">2000</span>);</div><div class="line">            String currentThread = Thread.currentThread().getName();</div><div class="line">            System.out.println(currentThread + <span class="string">" sleep for "</span> + millis + <span class="string">" milliseconds."</span>);</div><div class="line">            Thread.sleep(millis);</div><div class="line"></div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此时的<code>SyncHelloServlet</code>将顺序地先执行<code>LongRunningProcess</code>的<code>run()</code>方法，然后将将<code>HelloWorld</code>返回给客户端，这是一个典型的同步过程。</p>
<a id="more"></a>
<p>在<code>Servlet 3.0</code>中，我们可以这么写来达到异步处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> davenkin.servlet;</div><div class="line"></div><div class="line"><span class="keyword">import</span> javax.servlet.AsyncContext;</div><div class="line"><span class="keyword">import</span> javax.servlet.ServletException;</div><div class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</div><div class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</div><div class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</div><div class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"></div><div class="line"><span class="meta">@WebServlet</span>(value = <span class="string">"/simpleAsync"</span>, asyncSupported = <span class="keyword">true</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleAsyncHelloServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</div><div class="line">        AsyncContext asyncContext = request.startAsync();</div><div class="line"></div><div class="line">        asyncContext.start(() -&gt; &#123;</div><div class="line">            <span class="keyword">new</span> LongRunningProcess().run();</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                asyncContext.getResponse().getWriter().write(<span class="string">"Hello World!"</span>);</div><div class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">            asyncContext.complete();</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此时，我们先通过<code>request.startAsync()</code>获取到该请求对应的<code>AsyncContext</code>，然后调用<code>AsyncContext</code>的<code>start()</code>方法进行异步处理，处理完毕后需要调用<code>complete()</code>方法告知<code>Servlet</code>容器。<code>start()</code>方法会向<code>Servlet</code>容器另外申请一个新的线程（可以是从<code>Servlet</code>容器中已有的主线程池获取，也可以另外维护一个线程池，不同容器实现可能不一样），然后在这个新的线程中继续处理请求，而原先的线程将被回收到主线程池中。<strong>事实上，这种方式对性能的改进不大，因为如果新的线程和初始线程共享同一个线程池的话，相当于闲置下了一个线程，但同时又占用了另一个线程。</strong></p>
<p>当然，除了调用<code>AsyncContext</code>的<code>start()</code>方法，我们还可以通过手动创建线程的方式来实现异步处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> davenkin.servlet;</div><div class="line"></div><div class="line"><span class="keyword">import</span> javax.servlet.AsyncContext;</div><div class="line"><span class="keyword">import</span> javax.servlet.ServletException;</div><div class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</div><div class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</div><div class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</div><div class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"></div><div class="line"><span class="meta">@WebServlet</span>(value = <span class="string">"/newThreadAsync"</span>, asyncSupported = <span class="keyword">true</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewThreadAsyncHelloServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</div><div class="line"></div><div class="line">        AsyncContext asyncContext = request.startAsync();</div><div class="line"></div><div class="line">        Runnable runnable = () -&gt; &#123;</div><div class="line">            <span class="keyword">new</span> LongRunningProcess().run();</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                asyncContext.getResponse().getWriter().write(<span class="string">"Hello World!"</span>);</div><div class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">            asyncContext.complete();</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        <span class="keyword">new</span> Thread(runnable).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>自己手动创建新线程一般是不被鼓励的，并且此时线程不能重用。因此，一种更好的办法是我们自己维护一个线程池。这个线程池不同于<code>Servlet</code>容器的主线程池</strong>，如下图： </p>
<p><img src="http://images2015.cnblogs.com/blog/341412/201703/341412-20170314155524776-1999546106.png" alt="img"> </p>
<p> 在上图中，用户发起的请求首先交由<code>Servlet</code>容器主线程池中的线程处理，在该线程中，我们获取到<code>AsyncContext</code>，然后将其交给异步处理线程池。可以通过<code>Java</code>提供的<code>Executor</code>框架来创建线程池：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> davenkin.servlet;</div><div class="line"></div><div class="line"><span class="keyword">import</span> javax.servlet.AsyncContext;</div><div class="line"><span class="keyword">import</span> javax.servlet.ServletException;</div><div class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</div><div class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</div><div class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</div><div class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</div><div class="line"></div><div class="line"><span class="meta">@WebServlet</span>(value = <span class="string">"/threadPoolAsync"</span>, asyncSupported = <span class="keyword">true</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolAsyncHelloServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">100</span>, <span class="number">200</span>, <span class="number">50000L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">100</span>));</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</div><div class="line"></div><div class="line">        AsyncContext asyncContext = request.startAsync();</div><div class="line"></div><div class="line">        executor.execute(() -&gt; &#123;</div><div class="line"></div><div class="line">            <span class="keyword">new</span> LongRunningProcess().run();</div><div class="line"></div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                asyncContext.getResponse().getWriter().write(<span class="string">"Hello World!"</span>);</div><div class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            asyncContext.complete();</div><div class="line"></div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Servlet 3.0</code>对请求的处理虽然是异步的，但是对<code>InputStream</code>和<code>OutputStream</code>的IO操作却依然是阻塞的，对于数据量大的请求体或者返回体，阻塞IO也将导致不必要的等待。因此在<code>Servlet 3.1</code>中引入了非阻塞IO，通过在<code>HttpServletRequest</code>和<code>HttpServletResponse</code>中分别添加<code>ReadListener</code>和<code>WriterListener</code>方式，只有在IO数据满足一定条件时（比如数据准备好时），才进行后续的操作。</p>
<p><img src="http://images2015.cnblogs.com/blog/341412/201703/341412-20170314164534432-1636480194.png" alt="img"></p>
<p>对应的代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> davenkin.servlet;</div><div class="line"></div><div class="line"><span class="keyword">import</span> javax.servlet.AsyncContext;</div><div class="line"><span class="keyword">import</span> javax.servlet.ReadListener;</div><div class="line"><span class="keyword">import</span> javax.servlet.ServletException;</div><div class="line"><span class="keyword">import</span> javax.servlet.ServletInputStream;</div><div class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</div><div class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</div><div class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</div><div class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</div><div class="line"></div><div class="line"><span class="meta">@WebServlet</span>(value = <span class="string">"/nonBlockingThreadPoolAsync"</span>, asyncSupported = <span class="keyword">true</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NonBlockingAsyncHelloServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">100</span>, <span class="number">200</span>, <span class="number">50000L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">100</span>));</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</div><div class="line"></div><div class="line">        AsyncContext asyncContext = request.startAsync();</div><div class="line"></div><div class="line">        ServletInputStream inputStream = request.getInputStream();</div><div class="line"></div><div class="line">        inputStream.setReadListener(<span class="keyword">new</span> ReadListener() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDataAvailable</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAllDataRead</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">                executor.execute(() -&gt; &#123;</div><div class="line">                    <span class="keyword">new</span> LongRunningProcess().run();</div><div class="line"></div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        asyncContext.getResponse().getWriter().write(<span class="string">"Hello World!"</span>);</div><div class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    asyncContext.complete();</div><div class="line"></div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span> </span>&#123;</div><div class="line">                asyncContext.complete();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上例中，为<code>ServletInputStream</code>添加了一个<code>ReadListener</code>，并在<code>ReadListener</code>的<code>onAllDataRead()</code>方法中完成了长时处理过程。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Spring MVC 处理响应返回值]]></title>
      <url>http://zsr.github.io/2017/05/08/Spring-MVC-%E5%93%8D%E5%BA%94%E8%BF%94%E5%9B%9E%E5%80%BC%E5%A4%84%E7%90%86/</url>
      <content type="html"><![CDATA[<p><code>HandlerMethodReturnValueHandler</code>是<code>RequestMappingHandlerAdapter</code>用来处理当含有<code>@RequestMapping</code>的方法调度完成后，后面要进行的事情。<br>首先是<code>HandlerMethodReturnValueHandler</code>的自定义注册： </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span>  </div><div class="line">        <span class="tag">&lt;<span class="name">mvc:return-value-handlers</span>&gt;</span>  </div><div class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.method.annotation.ModelAndViewMethodReturnValueHandler"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </div><div class="line">        <span class="tag">&lt;/<span class="name">mvc:return-value-handlers</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></div></pre></td></tr></table></figure>
<p>在启动<code>AnnotationDrivenBeanDefinitionParser</code>来解析<code>mvc:annotation-driven</code>标签的过程中，会注册我们所配置的<code>HandlerMethodReturnValueHandler</code>，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ManagedList&lt;?&gt; returnValueHandlers = getReturnValueHandlers(element, parserContext);</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> ManagedList&lt;?&gt; getReturnValueHandlers(Element element, ParserContext parserContext) &#123;  </div><div class="line">        Element handlersElement = DomUtils.getChildElementByTagName(element, <span class="string">"return-value-handlers"</span>);  </div><div class="line">        <span class="keyword">if</span> (handlersElement != <span class="keyword">null</span>) &#123;  </div><div class="line">            <span class="keyword">return</span> extractBeanSubElements(handlersElement, parserContext);  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;  </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><strong>然后将会这些自定义的<code>HandlerMethodReturnValueHandler</code>设置到<code>RequestMappingHandlerAdapter</code>的<code>customReturnValueHandlers</code>属性中</strong></p>
<p><code>RequestMappingHandlerAdapter</code>的两个重要属性： </p>
<ul>
<li><code>customReturnValueHandlers</code>：存放我们自定义的<code>HandlerMethodReturnValueHandler</code></li>
<li><code>returnValueHandlers</code>：存放最终所有的<code>HandlerMethodReturnValueHandler</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestMappingHandlerAdapter</span> <span class="keyword">extends</span> <span class="title">AbstractHandlerMethodAdapter</span>  </span></div><div class="line">        <span class="keyword">implements</span> <span class="title">BeanFactoryAware</span>, <span class="title">InitializingBean</span> &#123;  </div><div class="line">  </div><div class="line">    <span class="keyword">private</span> List&lt;HandlerMethodArgumentResolver&gt; customArgumentResolvers;  </div><div class="line">  </div><div class="line">    <span class="keyword">private</span> HandlerMethodArgumentResolverComposite argumentResolvers;  </div><div class="line">  </div><div class="line">    <span class="keyword">private</span> HandlerMethodArgumentResolverComposite initBinderArgumentResolvers;  </div><div class="line">    <span class="comment">//...</span></div><div class="line">    <span class="keyword">private</span> List&lt;HandlerMethodReturnValueHandler&gt; customReturnValueHandlers;  </div><div class="line">    <span class="comment">//...</span></div><div class="line">    <span class="keyword">private</span> HandlerMethodReturnValueHandlerComposite returnValueHandlers;</div></pre></td></tr></table></figure>
<p><code>returnValueHandlers</code>的属性类型为<code>HandlerMethodReturnValueHandlerComposite</code>，里面也有一个list集合，来存放所有的<code>HandlerMethodReturnValueHandler</code>。 </p>
<a id="more"></a>
<p>默认的<code>returnValueHandlers</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> List&lt;HandlerMethodReturnValueHandler&gt; <span class="title">getDefaultReturnValueHandlers</span><span class="params">()</span> </span>&#123;</div><div class="line">		List&lt;HandlerMethodReturnValueHandler&gt; handlers = <span class="keyword">new</span> ArrayList&lt;HandlerMethodReturnValueHandler&gt;();</div><div class="line"></div><div class="line">		<span class="comment">// Single-purpose return value types</span></div><div class="line">        <span class="comment">// 返回值类型是ModelAndView或其子类</span></div><div class="line">		handlers.add(<span class="keyword">new</span> ModelAndViewMethodReturnValueHandler());</div><div class="line">        <span class="comment">// 返回值类型是Model或其子类</span></div><div class="line">		handlers.add(<span class="keyword">new</span> ModelMethodProcessor());</div><div class="line">        <span class="comment">// 返回值类型是View或其子类 </span></div><div class="line">		handlers.add(<span class="keyword">new</span> ViewMethodReturnValueHandler());</div><div class="line">        <span class="comment">// 用来处理返回值类型是HttpEntity的方法</span></div><div class="line">		handlers.add(<span class="keyword">new</span> HttpEntityMethodProcessor(getMessageConverters(), <span class="keyword">this</span>.contentNegotiationManager));</div><div class="line">		handlers.add(<span class="keyword">new</span> CallableMethodReturnValueHandler());</div><div class="line">		handlers.add(<span class="keyword">new</span> DeferredResultMethodReturnValueHandler());</div><div class="line">		handlers.add(<span class="keyword">new</span> AsyncTaskMethodReturnValueHandler(<span class="keyword">this</span>.beanFactory));</div><div class="line"></div><div class="line">		<span class="comment">// Annotation-based return value types</span></div><div class="line">        <span class="comment">// 返回值有@ModelAttribute注解</span></div><div class="line">		handlers.add(<span class="keyword">new</span> ModelAttributeMethodProcessor(<span class="keyword">false</span>));</div><div class="line">		handlers.add(<span class="keyword">new</span> RequestResponseBodyMethodProcessor(getMessageConverters(), <span class="keyword">this</span>.contentNegotiationManager));</div><div class="line"></div><div class="line">		<span class="comment">// Multi-purpose return value types</span></div><div class="line">        <span class="comment">// 返回值是void或String, 将返回的字符串作为view视图的名字</span></div><div class="line">		handlers.add(<span class="keyword">new</span> ViewNameMethodReturnValueHandler());</div><div class="line">		handlers.add(<span class="keyword">new</span> MapMethodProcessor());</div><div class="line"></div><div class="line">		<span class="comment">// Custom return value types</span></div><div class="line">        <span class="comment">//这里这里会从customReturnValueHandlers属性中获取我们自定的HandlerMethodReturnValueHandler  </span></div><div class="line">		<span class="keyword">if</span> (getCustomReturnValueHandlers() != <span class="keyword">null</span>) &#123;</div><div class="line">			handlers.addAll(getCustomReturnValueHandlers());</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">// Catch-all</span></div><div class="line">		<span class="keyword">if</span> (!CollectionUtils.isEmpty(getModelAndViewResolvers())) &#123;</div><div class="line">			handlers.add(<span class="keyword">new</span> ModelAndViewResolverMethodReturnValueHandler(getModelAndViewResolvers()));</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> &#123;</div><div class="line">			handlers.add(<span class="keyword">new</span> ModelAttributeMethodProcessor(<span class="keyword">true</span>));</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">return</span> handlers;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p><strong>使用<code>@ResponseBody</code>注解的话最终返回值会被<code>RequestResponseBodyMethodProcessor</code>这个<code>HandlerMethodReturnValueHandler</code>实现类处理。</strong></p>
<p>至此，所有的<code>HandlerMethodReturnValueHandler</code>的注册已经完成。</p>
<h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><ul>
<li>第一步：获取合适的HandlerAdapter，当方法含有@RequestMapping注释的时候，便选择RequestMappingHandlerAdapter来进行方法的调度处理 </li>
<li>第二步：方法的调度处理过程为：首先执行方法体，然后根据返回值来选择一个合适的HandlerMethodReturnValueHandler，如下代码： </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">  <span class="comment">// RequestMappingHandlerAdapter类</span></div><div class="line">  <span class="comment">/**</span></div><div class="line"> * Invoke the &#123;<span class="doctag">@link</span> RequestMapping&#125; handler method preparing a &#123;<span class="doctag">@link</span> ModelAndView&#125;</div><div class="line"> * if view resolution is required.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> ModelAndView <span class="title">invokeHandleMethod</span><span class="params">(HttpServletRequest request,</span></span></div><div class="line">		HttpServletResponse response, HandlerMethod handlerMethod) <span class="keyword">throws</span> Exception &#123;</div><div class="line"></div><div class="line">	ServletWebRequest webRequest = <span class="keyword">new</span> ServletWebRequest(request, response);</div><div class="line"></div><div class="line">	WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod);</div><div class="line">	ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory);</div><div class="line">    <span class="comment">// 创建 ServletInvocableHandlerMethod （HandlerMethod 的子类），并绑定相关属性	</span></div><div class="line">       ServletInvocableHandlerMethod requestMappingMethod = createRequestMappingMethod(handlerMethod, binderFactory);</div><div class="line"></div><div class="line">	ModelAndViewContainer mavContainer = <span class="keyword">new</span> ModelAndViewContainer();</div><div class="line">	mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));</div><div class="line">	modelFactory.initModel(webRequest, mavContainer, requestMappingMethod);</div><div class="line">	mavContainer.setIgnoreDefaultModelOnRedirect(<span class="keyword">this</span>.ignoreDefaultModelOnRedirect);</div><div class="line"></div><div class="line">	AsyncWebRequest asyncWebRequest = WebAsyncUtils.createAsyncWebRequest(request, response);</div><div class="line">	asyncWebRequest.setTimeout(<span class="keyword">this</span>.asyncRequestTimeout);</div><div class="line"></div><div class="line">	<span class="keyword">final</span> WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</div><div class="line">	asyncManager.setTaskExecutor(<span class="keyword">this</span>.taskExecutor);</div><div class="line">	asyncManager.setAsyncWebRequest(asyncWebRequest);</div><div class="line">	asyncManager.registerCallableInterceptors(<span class="keyword">this</span>.callableInterceptors);</div><div class="line">	asyncManager.registerDeferredResultInterceptors(<span class="keyword">this</span>.deferredResultInterceptors);</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (asyncManager.hasConcurrentResult()) &#123;</div><div class="line">		Object result = asyncManager.getConcurrentResult();</div><div class="line">		mavContainer = (ModelAndViewContainer) asyncManager.getConcurrentResultContext()[<span class="number">0</span>];</div><div class="line">		asyncManager.clearConcurrentResult();</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line">			logger.debug(<span class="string">"Found concurrent result value ["</span> + result + <span class="string">"]"</span>);</div><div class="line">		&#125;</div><div class="line">		requestMappingMethod = requestMappingMethod.wrapConcurrentResult(result);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">       <span class="comment">// 执行处理器的方法, 重点。。。。。。(看下面)</span></div><div class="line">	requestMappingMethod.invokeAndHandle(webRequest, mavContainer);</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">       <span class="comment">// 返回 ModelAndView, 重点。。。。。。</span></div><div class="line">	<span class="keyword">return</span> getModelAndView(mavContainer, modelFactory, webRequest);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ServletInvocableHandlerMethod类(HandlerMethod 的子类)</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">invokeAndHandle</span><span class="params">(ServletWebRequest webRequest,  </span></span></div><div class="line">            ModelAndViewContainer mavContainer, Object... providedArgs) <span class="keyword">throws</span> Exception &#123;  </div><div class="line">        <span class="comment">// 执行该请求处理方法(包含了获取该请求处理方法参数值)，取得返回值</span></div><div class="line">        Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);  </div><div class="line">  </div><div class="line">        setResponseStatus(webRequest);  </div><div class="line">  </div><div class="line">        <span class="keyword">if</span> (returnValue == <span class="keyword">null</span>) &#123;  </div><div class="line">            <span class="keyword">if</span> (isRequestNotModified(webRequest) || hasResponseStatus() || mavContainer.isRequestHandled()) &#123;  </div><div class="line">                mavContainer.setRequestHandled(<span class="keyword">true</span>);  </div><div class="line">                <span class="keyword">return</span>;  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.hasText(<span class="keyword">this</span>.responseReason)) &#123;  </div><div class="line">            mavContainer.setRequestHandled(<span class="keyword">true</span>);  </div><div class="line">            <span class="keyword">return</span>;  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        mavContainer.setRequestHandled(<span class="keyword">false</span>);  </div><div class="line">        </div><div class="line">        <span class="keyword">try</span> &#123;  </div><div class="line">            <span class="comment">// 重点。。。。。。</span></div><div class="line">            <span class="keyword">this</span>.returnValueHandlers.handleReturnValue(returnValue, getReturnValueType(returnValue), mavContainer, webRequest);  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">catch</span> (Exception ex) &#123;  </div><div class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;  </div><div class="line">                logger.trace(getReturnValueHandlingErrorMessage(<span class="string">"Error handling return value"</span>, returnValue), ex);  </div><div class="line">            &#125;  </div><div class="line">            <span class="keyword">throw</span> ex;  </div><div class="line">        &#125;  </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><code>this.returnValueHandlers.handleReturnValue(returnValue, getReturnValueType(returnValue), mavContainer, webRequest)</code>会遍历所有的已注册的<code>HandlerMethodReturnValueHandler</code>判断他们支不支持<code>returnValue</code>的返回类型。如下： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// HandlerMethodReturnValueHandlerComposite类(包含了所有的HandlerMethodReturnValueHandler)</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleReturnValue</span><span class="params">(  </span></span></div><div class="line">            Object returnValue, MethodParameter returnType,  </div><div class="line">            ModelAndViewContainer mavContainer, NativeWebRequest webRequest)  </div><div class="line">            <span class="keyword">throws</span> Exception &#123;  </div><div class="line">  </div><div class="line">        HandlerMethodReturnValueHandler handler = getReturnValueHandler(returnType);  </div><div class="line">        Assert.notNull(handler, <span class="string">"Unknown return value type ["</span> + returnType.getParameterType().getName() + <span class="string">"]"</span>);  </div><div class="line">        handler.handleReturnValue(returnValue, returnType, mavContainer, webRequest);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * Find a registered &#123;<span class="doctag">@link</span> HandlerMethodReturnValueHandler&#125; that supports the given return type. </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">private</span> HandlerMethodReturnValueHandler <span class="title">getReturnValueHandler</span><span class="params">(MethodParameter returnType)</span> </span>&#123;  </div><div class="line">        <span class="keyword">for</span> (HandlerMethodReturnValueHandler returnValueHandler : returnValueHandlers) &#123;  </div><div class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;  </div><div class="line">                logger.trace(<span class="string">"Testing if return value handler ["</span> + returnValueHandler + <span class="string">"] supports ["</span> +  </div><div class="line">                        returnType.getGenericParameterType() + <span class="string">"]"</span>);  </div><div class="line">            &#125;  </div><div class="line">            <span class="keyword">if</span> (returnValueHandler.supportsReturnType(returnType)) &#123;  </div><div class="line">                <span class="keyword">return</span> returnValueHandler;  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;  </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>找到支持的<code>HandlerMethodReturnValueHandler</code>后，就要执行它的<code>handleReturnValue</code>方法。假设使用了｀<code>@ResponseBody</code>注解，则由<code>RequestResponseBodyMethodProcessor</code>类处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleReturnValue</span><span class="params">(Object returnValue, MethodParameter returnType,</span></span></div><div class="line">			ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</div><div class="line">			<span class="keyword">throws</span> IOException, HttpMediaTypeNotAcceptableException &#123;</div><div class="line"></div><div class="line">		mavContainer.setRequestHandled(<span class="keyword">true</span>);</div><div class="line">		<span class="keyword">if</span> (returnValue != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">// 由这里处理返回，涉及到HttpMessageConverter处理</span></div><div class="line">			writeWithMessageConverters(returnValue, returnType, webRequest);</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>注意这里设置<code>mavContainer.setRequestHandled(true)</code>，表示请求已被处理，不需要返回<code>ModelAndView</code>。看代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"># RequestMappingHandlerAdapter</div><div class="line">private ModelAndView getModelAndView(ModelAndViewContainer mavContainer,</div><div class="line">			ModelFactory modelFactory, NativeWebRequest webRequest) throws Exception &#123;</div><div class="line"></div><div class="line">		modelFactory.updateModel(webRequest, mavContainer);</div><div class="line">        // 如果isRequestHandled()为true，不需要再做处理</div><div class="line">		if (mavContainer.isRequestHandled()) &#123;</div><div class="line">			return null;</div><div class="line">		&#125;</div><div class="line">		ModelMap model = mavContainer.getModel();</div><div class="line">		ModelAndView mav = new ModelAndView(mavContainer.getViewName(), model);</div><div class="line">		if (!mavContainer.isViewReference()) &#123;</div><div class="line">			mav.setView((View) mavContainer.getView());</div><div class="line">		&#125;</div><div class="line">		if (model instanceof RedirectAttributes) &#123;</div><div class="line">			Map&lt;String, ?&gt; flashAttributes = ((RedirectAttributes) model).getFlashAttributes();</div><div class="line">			HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class);</div><div class="line">			RequestContextUtils.getOutputFlashMap(request).putAll(flashAttributes);</div><div class="line">		&#125;</div><div class="line">		return mav;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Spring MVC 应用上下文]]></title>
      <url>http://zsr.github.io/2017/05/08/Spring-MVC-%E5%BA%94%E7%94%A8%E4%B8%8A%E4%B8%8B%E6%96%87/</url>
      <content type="html"><![CDATA[<p>先看上文：<a href="https://zsr.github.io/2016/08/16/ApplicationContext/">Spring MVC ApplicationContext</a></p>
<h3 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h3><p><code>javaee</code>标准规定了，<code>servlet</code>容器需要在应用项目启动时，给应用项目初始化一个<code>ServletContext</code>作为公共环境容器存放公共信息。<code>ServletContext</code>中的信息都是由容器提供的。</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>通过自定义<code>contextListener</code>获取<code>web.xml</code>中配置的参数</p>
<ol>
<li>容器启动时，找到配置文件中的<code>context-param</code>作为键值对放到<code>ServletContext</code>中</li>
<li>然后找到<code>listener</code>，容器调用它的<code>contextInitialized(ServletContextEvent event)</code>方法，执行其中的操作</li>
</ol>
<p>例如：在web.xml中配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>key<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span> </div><div class="line">   <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>com.zsr.contextlistener.listener.ContextListenerTest<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></div></pre></td></tr></table></figure>
<p>配置好之后，在该类中获取对应的参数信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.zsr.contextlistener.listener;</div><div class="line"></div><div class="line"><span class="keyword">import</span> javax.servlet.ServletContext;</div><div class="line"><span class="keyword">import</span> javax.servlet.ServletContextEvent;</div><div class="line"><span class="keyword">import</span> javax.servlet.ServletContextListener;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextListenerTest</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent event)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"*************destroy ContextListener*************"</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent event)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"*************init ContextListener*************"</span>);</div><div class="line">        ServletContext servletContext = event.getServletContext();</div><div class="line">        System.out.println(<span class="string">"key:"</span>+servletContext.getInitParameter(<span class="string">"key"</span>));</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h4><p>　　<strong><code>web.xml</code>在<code>&lt;context-param&gt;&lt;/context-param&gt;</code>标签中声明<code>应用范围内</code>的初始化参数</strong></p>
<ol>
<li>启动一个WEB项目的时候,容器(如:<code>Tomcat</code>)会去读它的配置文件<code>web.xml</code>.读两个节点: <code>&lt;listener&gt;&lt;/listener&gt;</code>和 <code>&lt;context-param&gt;&lt;/context-param&gt;</code></li>
<li>紧接着,容器创建一个<code>ServletContext</code>(上下文)。在该应用内全局共享。</li>
<li>容器将<code>&lt;context-param&gt;&lt;/context-param&gt;</code>转化为键值对,并交给<code>ServletContext</code>.</li>
<li>容器创建<code>&lt;listener&gt;&lt;/listener&gt;</code>中的类实例,即创建监听.该监听器必须实现自<strong><code>ServletContextListener</code></strong>接口</li>
<li>在监听中会有<code>contextInitialized(ServletContextEvent event)</code>初始化方法</li>
<li>得到这个<code>context-param</code>的值之后,你就可以做一些操作了.注意,这个时候你的WEB项目还没有完全启动完成.这个动作会比所有的Servlet都要早.换句话说,这个时候,<strong>对<code>&lt;context-param&gt;</code>中的键值做的操作,将在你的WEB项目完全启动之前被执行</strong>.</li>
</ol>
<p><code>web.xml</code>中可以定义两种参数：</p>
<ul>
<li>全局参数(<code>ServletContext</code>)，通过<code>&lt;context-param&gt;</code>声明</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>key<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></div></pre></td></tr></table></figure>
<p> 参数在<code>servlet</code>里面可以通过<code>getServletContext().getInitParameter(&quot;key&quot;)</code>得到</p>
<ul>
<li><p><code>servlet</code>参数，通过在<code>servlet</code>中声明    　　 </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>param1<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">param-value</span>&gt;</span>avalible in servlet init()<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span>   </div><div class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>参数只能在<code>servlet</code>的<code>init()</code>方法中通过<code>this.getInitParameter(&quot;param1&quot;)</code>取得</p>
<h3 id="Spring上下文容器配置"><a href="#Spring上下文容器配置" class="headerlink" title="Spring上下文容器配置"></a>Spring上下文容器配置</h3><p>　Spring提供了实现<code>ServletContextListener</code>接口的上下文初始化监听器：<code>org.springframework.web.context.ContextLoaderListener</code></p>
<p>   Spring为我们提供的IOC容器，需要我们指定容器的配置文件，然后由该监听器初始化并创建该容器。要求你指定配置文件的地址及文件名称，一定要使用：<code>contextConfigLocation</code>作为参数名称。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:web-context.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></div></pre></td></tr></table></figure>
<p>该监听器，默认读取<code>/WEB-INF/</code>下的<code>web-context.xml</code>文件。但是通过<code>context-param</code>指定配置文件路径后，便会去你指定的路径下读取对应的配置文件，并进行初始化。</p>
<h4 id="执行流程-1"><a href="#执行流程-1" class="headerlink" title="执行流程"></a>执行流程</h4><p><code>ServletContext</code>是由<code>Servlet</code>容器初始化的，那Spring的<code>ContextLoaderListener</code>又做了什么初始化呢？</p>
<ol>
<li><code>servlet</code>容器启动，为应用创建一个“全局上下文环境”：<code>ServletContext</code></li>
<li>容器调用<code>web.xml</code>中配置的<code>contextLoaderListener</code>，初始化<code>WebApplicationContext</code>上下文环境（即IOC容器），加载<code>context-param</code>指定的配置文件信息到IOC容器中。<code>WebApplicationContext</code>在<code>ServletContext</code>中以键值对的形式保存</li>
<li>容器初始化<code>web.xml</code>中配置的<code>servlet</code>，为其初始化自己的上下文信息<code>servletContext</code>，并加载其设置的配置信息到该上下文中。<strong>将WebApplicationContext设置为它的父容器。</strong></li>
<li><p>此后的所有<code>servlet</code>的初始化都按照3步中方式创建，初始化自己的上下文环境，将<code>WebApplicationContext</code>设置为自己的父上下文环境。</p>
<p><img src="http://images.cnitblog.com/blog/698747/201502/011528042224276.png" alt="img"></p>
</li>
</ol>
<p>​       <strong>对于作用范围而言，在<code>DispatcherServlet</code>中可以引用由<code>ContextLoaderListener</code>所创建的<code>ApplicationContext</code>中的内容，而反过来不行。</strong></p>
<p>​       当Spring在执行<code>ApplicationContext</code>的<code>getBean(BeanName)</code>时，如果在自己<code>context</code>中找不到对应的bean，则会在父<code>ApplicationContext</code>中去找。这也解释了为什么我们可以在<code>DispatcherServlet</code>中获取到由<code>ContextLoaderListener</code>对应的<code>ApplicationContext中的bean</code>。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://www.cnblogs.com/brolanda/p/4265597.html" target="_blank" rel="external">Spring-MVC理解之一：应用上下文webApplicationContext</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[init-method、@PostConstruct、afterPropertiesSet孰先孰后]]></title>
      <url>http://zsr.github.io/2017/05/08/Spring-bean-%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F/</url>
      <content type="html"><![CDATA[<p>Spring 允许在 Bean 在初始化完成后以及 Bean 销毁前执行特定的操作，常用的设定方式有以下三种：</p>
<ul>
<li>通过实现 <code>InitializingBean/DisposableBean</code> 接口来定制初始化之后/销毁之前的操作方法；</li>
<li>通过<code>&lt;bean&gt;</code> 元素的<code>init-method/destroy-method</code>属性指定初始化之后 /销毁之前调用的操作方法；</li>
<li>在指定方法上加上<code>@PostConstruct/@PreDestroy</code>注解来制定该方法是在初始化之后还是销毁之前调用。 </li>
</ul>
<p>这三种方式是完全等同的吗，孰先孰后？</p>
<h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><p>编写一个简单的测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitSequenceBean</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;  </div><div class="line">   </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InitSequenceBean</span><span class="params">()</span> </span>&#123;  </div><div class="line">       System.out.println(<span class="string">"InitSequenceBean: constructor"</span>);  </div><div class="line">    &#125;  </div><div class="line">     </div><div class="line">    <span class="meta">@PostConstruct</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postConstruct</span><span class="params">()</span> </span>&#123;  </div><div class="line">       System.out.println(<span class="string">"InitSequenceBean: postConstruct"</span>);  </div><div class="line">    &#125;  </div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initMethod</span><span class="params">()</span> </span>&#123;  </div><div class="line">       System.out.println(<span class="string">"InitSequenceBean: init-method"</span>);  </div><div class="line">    &#125;  </div><div class="line">     </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;  </div><div class="line">       System.out.println(<span class="string">"InitSequenceBean: afterPropertiesSet"</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>并且在配置文件中添加如下Bean定义：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"InitSequenceBean"</span> <span class="attr">init-method</span>=<span class="string">"initMethod"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<p>启动Spring容器，观察输出结果，就可知道三者的先后顺序了：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">InitSequenceBean: constructor</div><div class="line">InitSequenceBean: postConstruct</div><div class="line">InitSequenceBean: afterPropertiesSet</div><div class="line">InitSequenceBean: init-method</div></pre></td></tr></table></figure>
<p>通过上述输出结果，三者的先后顺序也就一目了然了：</p>
<p><strong><code>Constructor</code> &gt; <code>@PostConstruct</code> &gt; <code>InitializingBean</code> &gt; <code>init-method</code></strong></p>
<p><code>PostConstruct</code>为何率先于<code>InitializingBean</code>执行呢？</p>
<h3 id="CommonAnnotationBeanPostProcessor"><a href="#CommonAnnotationBeanPostProcessor" class="headerlink" title="CommonAnnotationBeanPostProcessor"></a>CommonAnnotationBeanPostProcessor</h3><p>通过Debug并查看调用栈，发现了这个类<code>org.springframework.context.annotation.CommonAnnotationBeanPostProcessor</code>，从命名上，我们就可以得到某些信息—这是一个<code>BeanPostProcessor</code>。<code>BeanPostProcessor</code>的<code>postProcessBeforeInitialization</code>是在Bean生命周期中<code>afterPropertiesSet</code>和<code>init-method</code>之前执被调用的。 </p>
<p><code>CommonAnnotationBeanPostProcessor</code>这个类，继承自<code>InitDestroyAnnotationBeanPostProcessor</code>。<code>InitDestroyAnnotationBeanPostProcessor</code>顾名思义，就是在Bean初始化和销毁的时候所作的一个前置/后置处理器。</p>
<p>查看<code>InitDestroyAnnotationBeanPostProcessor</code>类下的<code>postProcessBeforeInitialization</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;  </div><div class="line">       LifecycleMetadata metadata = findLifecycleMetadata(bean.getClass());  </div><div class="line">       <span class="keyword">try</span> &#123;  </div><div class="line">           metadata.invokeInitMethods(bean, beanName);  </div><div class="line">       &#125;  </div><div class="line">       <span class="keyword">catch</span> (InvocationTargetException ex) &#123;  </div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">"Invocation of init method failed"</span>, ex.getTargetException());  </div><div class="line">       &#125;  </div><div class="line">       <span class="keyword">catch</span> (Throwable ex) &#123;  </div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">"Couldn't invoke init method"</span>, ex);  </div><div class="line">       &#125;  </div><div class="line">        <span class="keyword">return</span> bean;  </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>查看<code>findLifecycleMetadata</code>方法，继而我们跟踪到<code>buildLifecycleMetadata</code>这个方法体中，看下<code>buildLifecycleMetadata</code>这个方法体的内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> LifecycleMetadata <span class="title">buildLifecycleMetadata</span><span class="params">(<span class="keyword">final</span> Class clazz)</span> </span>&#123;  </div><div class="line">       <span class="keyword">final</span> LifecycleMetadata newMetadata = <span class="keyword">new</span> LifecycleMetadata();  </div><div class="line">       <span class="keyword">final</span> <span class="keyword">boolean</span> debug = logger.isDebugEnabled();  </div><div class="line">       ReflectionUtils.doWithMethods(clazz, <span class="keyword">new</span> ReflectionUtils.MethodCallback() &#123;  </div><div class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWith</span><span class="params">(Method method)</span> </span>&#123;  </div><div class="line">              <span class="keyword">if</span> (initAnnotationType != <span class="keyword">null</span>) &#123;  </div><div class="line">                  <span class="keyword">if</span> (method.getAnnotation(initAnnotationType) != <span class="keyword">null</span>) &#123;  </div><div class="line">                     newMetadata.addInitMethod(method);  </div><div class="line">                     <span class="keyword">if</span> (debug) &#123;  </div><div class="line">                         logger.debug(<span class="string">"Found init method on class ["</span> + clazz.getName() + <span class="string">"]: "</span> + method);  </div><div class="line">                     &#125;  </div><div class="line">                  &#125;  </div><div class="line">              &#125;  </div><div class="line">              <span class="keyword">if</span> (destroyAnnotationType != <span class="keyword">null</span>) &#123;  </div><div class="line">                  <span class="keyword">if</span> (method.getAnnotation(destroyAnnotationType) != <span class="keyword">null</span>) &#123;  </div><div class="line">                     newMetadata.addDestroyMethod(method);  </div><div class="line">                     <span class="keyword">if</span> (debug) &#123;  </div><div class="line">                         logger.debug(<span class="string">"Found destroy method on class ["</span> + clazz.getName() + <span class="string">"]: "</span> + method);  </div><div class="line">                     &#125;  </div><div class="line">                  &#125;  </div><div class="line">              &#125;  </div><div class="line">           &#125;  </div><div class="line">       &#125;);  </div><div class="line">       <span class="keyword">return</span> newMetadata;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里会去判断某方法有没有被<code>initAnnotationType/destroyAnnotationType</code>注释，如果有，则添加到init/destroy队列中，后续一一执行。</p>
<p><code>initAnnotationType/destroyAnnotationType</code>注释是什么?我们在<code>CommonAnnotationBeanPostProcessor</code>的构造函数中看到下面这段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">CommonAnnotationBeanPostProcessor</span><span class="params">()</span> </span>&#123;  </div><div class="line">       setOrder(Ordered.LOWEST_PRECEDENCE - <span class="number">3</span>);  </div><div class="line">       setInitAnnotationType(PostConstruct.class);  </div><div class="line">       setDestroyAnnotationType(PreDestroy.class);  </div><div class="line">       ignoreResourceType(<span class="string">"javax.xml.ws.WebServiceContext"</span>);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一言以蔽之，<code>@PostConstruct</code>注解后的方法在<code>BeanPostProcessor</code>前置处理器中就被执行了，所以当然要先于<code>InitializingBean</code>和<code>init-method</code>执行了。</p>
<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p><a href="http://sexycoding.iteye.com/blog/1046993" target="_blank" rel="external">源码解析：init-method、@PostConstruct、afterPropertiesSet孰先孰后</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Spring Bean 生命周期]]></title>
      <url>http://zsr.github.io/2017/05/05/Spring-Bean-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      <content type="html"><![CDATA[<h1 id="Spring-Bean-生命周期"><a href="#Spring-Bean-生命周期" class="headerlink" title="Spring Bean 生命周期"></a>Spring Bean 生命周期</h1><hr>
<p><code>BeanFactory</code>和<code>ApplicationContext</code>是<code>Spring</code>两种很重要的容器,前者提供了最基本的依赖注入的支持，而后者在继承前者的基础进行了功能的拓展，例如增加了事件传播，资源访问和国际化的消息访问等功能。</p>
<p>概括来说主要有四个阶段：实例化，初始化，使用，销毁。</p>
<h3 id="Bean-作用范围"><a href="#Bean-作用范围" class="headerlink" title="Bean 作用范围"></a>Bean 作用范围</h3><p>常用的<code>Bean</code>作用范围：<code>singleton</code>和<code>prototype</code></p>
<ul>
<li><code>singleton</code></li>
</ul>
<p>在默认情况下,<code>Spring</code>的<code>ApplicationContext</code>容器在启动时,自动实例化所有<code>singleton</code>的<code>Bean</code>并缓存于容器中.虽然启动时会花费一些时间,但带来两个好处:首先对<code>Bean</code>提前的实例化操作会及早发现一些潜在的配置问题.其次<code>Bean</code>以缓存的方式保存,当运行时使用到该<code>Bean</code>时就无须再实例化了,加快了运行效率.如果用户不希望在容器启动时提前实例化<code>singleton</code>的<code>Bean</code>,可以通过<code>lazy-init</code>属性进行控制.</p>
<ul>
<li><code>prototype</code></li>
</ul>
<p>在默认情况下,<code>Spring</code>容器在启动时不实例化<code>prototype</code>的<code>Bean</code>.此外,<code>Spring</code>容器将<code>prototype</code>的<code>Bean</code>交给调用者后,就不再管理它的生命周期.</p>
<h3 id="ApplicationContext-Bean生命周期："><a href="#ApplicationContext-Bean生命周期：" class="headerlink" title="ApplicationContext Bean生命周期："></a>ApplicationContext Bean生命周期：</h3><p><code>Spring Bean</code>的完整生命周期从创建<code>Spring</code>容器开始，直到最终<code>Spring</code>容器销毁<code>Bean</code>，这其中包含了一系列关键点。</p>
<h4 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h4><p><img src="http://xfhnever.com/images/post/spring5-2.jpg" alt="img"></p>
<p>若容器注册了以上各种接口，程序那么将会按照以上的流程进行。下面将仔细讲解各接口作用。</p>
<a id="more"></a>
<h4 id="各种接口方法分类"><a href="#各种接口方法分类" class="headerlink" title="各种接口方法分类"></a>各种接口方法分类</h4><p><code>Bean</code>的完整生命周期经历了各种方法调用，这些方法可以划分为以下几类：</p>
<p>1、<code>Bean</code>自身的方法：这个包括了<code>Bean</code>本身调用的方法和通过配置文件中<code>&lt;bean&gt;</code>的<code>init-method</code>和<code>destroy-method</code>指定的方法</p>
<p>2、<code>Bean</code>级生命周期接口方法：这个包括了<code>BeanNameAware</code>、<code>BeanFactoryAware</code>、<code>InitializingBean</code>和<code>DiposableBean</code>这些接口的方法</p>
<p>3、<code>容器级</code>生命周期接口方法：这个包括了<code>InstantiationAwareBeanPostProcessor</code>和 <code>BeanPostProcessor</code>这两个接口实现，一般称它们的实现类为“后处理器”。容器中每个<code>bean</code>初始化都要经过这一步。</p>
<p>4、工厂后处理器接口<code>BeanFactoryPostProcessor</code>方法：这个包括了<code>AspectJWeavingEnabler</code>, <code>ConfigurationClassPostProcessor</code>, <code>CustomAutowireConfigurer</code>等等非常有用的工厂后处理器接口的方法。工厂后处理器也是容器级的，在应用上下文装配配置文件之后立即调用。</p>
<h4 id="流程说明"><a href="#流程说明" class="headerlink" title="流程说明"></a>流程说明</h4><ol>
<li>首先容器启动后，会对<code>scope</code>为<code>singleton</code>且非懒加载(<code>lazy-init=false</code>)的<code>bean</code>进行实例化，</li>
<li>按照<code>Bean</code>定义信息配置信息，注入所有的属性</li>
<li>如果<code>Bean</code>实现了<code>BeanNameAware</code>接口，会回调该接口的<code>setBeanName()</code>方法，传入该<code>Bean</code>的id，此时该<code>Bean</code>就获得了自己在配置文件中的id</li>
<li>如果<code>Bean</code>实现了<code>BeanFactoryAware</code>接口,会回调该接口的<code>setBeanFactory()</code>方法，传入该<code>Bean</code>的<code>BeanFactory</code>，这样该<code>Bean</code>就获得了自己所在的<code>BeanFactory</code></li>
<li><strong>如果<code>Bean</code>实现了<code>ApplicationContextAware</code>接口,会回调该接口的<code>setApplicationContext()</code>方法，传入该<code>Bean</code>的<code>ApplicationContext</code>，这样该<code>Bean</code>就获得了自己所在的<code>ApplicationContext</code></strong></li>
<li>如果有<code>Bean</code>实现了<code>BeanPostProcessor</code>接口，则会回调该接口的<code>postProcessBeforeInitialzation()</code>方法</li>
<li>如果<code>Bean</code>实现了<code>InitializingBean</code>接口，则会回调该接口的<code>afterPropertiesSet()</code>方法</li>
<li>如果<code>Bean</code>配置了<code>init-method</code>方法，则会执行<code>init-method</code>配置的方法</li>
<li>如果有<code>Bean</code>实现了<code>BeanPostProcessor</code>接口，则会回调该接口的<code>postProcessAfterInitialization()</code>方法</li>
<li>经过流程9之后，就可以正式使用该<code>Bean</code>了,对于<code>scope</code>为<code>singleton</code>的<code>Bean</code>,Spring的ioc容器中会缓存一份该<code>bean</code>的实例，而对于<code>scope</code>为<code>prototype</code>的<code>Bean</code>,每次被调用都会new一个新的对象，生命周期就交给调用方管理了，不再是Spring容器进行管理了</li>
<li>容器关闭后，如果<code>Bean</code>实现了<code>DisposableBean</code>接口，则会回调该接口的<code>destroy()</code>方法</li>
<li>如果<code>Bean</code>配置了<code>destroy-method</code>方法，则会执行<code>destroy-method</code>配置的方法，至此，整个<code>Bean</code>的生命周期结束</li>
</ol>
<h3 id="BeanFactory-Bean生命周期"><a href="#BeanFactory-Bean生命周期" class="headerlink" title="BeanFactory Bean生命周期"></a>BeanFactory Bean生命周期</h3><p><code>BeanFactoty</code>容器中, <code>Bean</code>的生命周期如下图所示，与<code>ApplicationContext</code>相比，有如下几点不同:</p>
<p>1.<code>BeanFactory</code>容器中，不会调用<code>ApplicationContextAware</code>接口的<code>setApplicationContext()</code>方法</p>
<p>2.<code>BeanPostProcessor</code>接口的<code>postProcessBeforeInitialzation()</code>方法和<code>postProcessAfterInitialization()</code>方法不会自动调用，必须自己通过代码手动注册</p>
<p>3.<code>BeanFactory</code>容器启动的时候，不会去实例化所有<code>Bean</code>,包括所有<code>scope</code>为<code>singleton</code>且非懒加载的<code>Bean</code>也是一样，而是在调用的时候去实例化。</p>
<h4 id="流程图-1"><a href="#流程图-1" class="headerlink" title="流程图"></a>流程图</h4><p><img src="http://xfhnever.com/images/post/spring5-1.jpg" alt="img"></p>
<h4 id="流程说明-1"><a href="#流程说明-1" class="headerlink" title="流程说明"></a>流程说明</h4><ol>
<li>当调用者通过 <code>getBean(name)</code>向 容器寻找<code>Bean</code>时，如果容器注册了<code>org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor</code>接口，在实例<code>bean</code>之前，将调用该接口的 <code>postProcessBeforeInstantiation()</code>方法</li>
<li>容器寻找<code>Bean</code>的定义信息，并将其实例化</li>
<li>使用依赖注入，<code>Spring</code>按照<code>Bean</code>定义信息配置<code>Bean</code>的所有属性</li>
<li>如果<code>Bean</code>实现了<code>BeanNameAware</code>接口，工厂调用<code>Bean</code>的<code>setBeanName()</code>方法传递<code>Bean</code>的id</li>
<li>如果实现了<code>BeanFactoryAware</code>接口，工厂调用<code>setBeanFactory()</code>方法传入工厂自身</li>
<li>如果<code>BeanPostProcessor</code>和<code>Bean</code>关联，那么它们的<code>postProcessBeforeInitialization()</code>方法将被调用（需要手动进行注册！）</li>
<li>如果<code>Bean</code>实现了<code>InitializingBean</code>接口，则会回调该接口的<code>afterPropertiesSet()</code>方法</li>
<li>如果<code>Bean</code>指定了<code>init-method</code>方法，就会调用<code>init-method</code>方法</li>
<li>如果<code>BeanPostProcessor</code>和<code>Bean</code>关联，那么它的<code>postProcessAfterInitialization()</code>方法将被调用（需要手动注册！）</li>
<li>现在<code>Bean</code>已经可以使用了<ol>
<li><code>scope</code>为<code>singleton</code>的<code>Bean</code>缓存在Spring IOC容器中</li>
<li><code>scope</code>为<code>prototype</code>的<code>Bean</code>生命周期交给客户端</li>
</ol>
</li>
<li>销毁<ol>
<li>如果<code>Bean</code>实现了<code>DisposableBean</code>接口，<code>destory()</code>方法将会被调用</li>
<li>如果配置了<code>destory-method</code>方法，就调用这个方法</li>
</ol>
</li>
</ol>
<h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><p>用一个简单的<code>Spring Bean</code>来演示一下<code>Spring Bean</code>的生命周期。</p>
<p>1、首先是一个简单的<code>Spring Bean</code>，调用Bean自身的方法和Bean级生命周期接口方法，为了方便演示，它实现了<code>BeanNameAware</code>、<code>BeanFactoryAware</code>、<code>InitializingBean</code>和<code>DiposableBean</code>这4个接口，同时有2个方法，对应配置文件中<code>&lt;bean&gt;</code>的<code>init-method</code>和<code>destroy-method</code>。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.zsr.test.spring.bean;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</div><div class="line"><span class="keyword">import</span> org.springframework.beans.factory.BeanFactory;</div><div class="line"><span class="keyword">import</span> org.springframework.beans.factory.BeanFactoryAware;</div><div class="line"><span class="keyword">import</span> org.springframework.beans.factory.BeanNameAware;</div><div class="line"><span class="keyword">import</span> org.springframework.beans.factory.DisposableBean;</div><div class="line"><span class="keyword">import</span> org.springframework.beans.factory.InitializingBean;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">BeanFactoryAware</span>, <span class="title">BeanNameAware</span>, <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> String name;</div><div class="line">  <span class="keyword">private</span> String address;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">int</span> phone;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> BeanFactory beanFactory;</div><div class="line">  <span class="keyword">private</span> String beanName;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</div><div class="line">    System.out.println(<span class="string">"【构造器】调用Person的构造器实例化"</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> name;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">    System.out.println(<span class="string">"【注入属性】注入属性name"</span>);</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> address;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddress</span><span class="params">(String address)</span> </span>&#123;</div><div class="line">    System.out.println(<span class="string">"【注入属性】注入属性address"</span>);</div><div class="line">    <span class="keyword">this</span>.address = address;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPhone</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> phone;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPhone</span><span class="params">(<span class="keyword">int</span> phone)</span> </span>&#123;</div><div class="line">    System.out.println(<span class="string">"【注入属性】注入属性phone"</span>);</div><div class="line">    <span class="keyword">this</span>.phone = phone;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"Person [address="</span> + address + <span class="string">", name="</span> + name + <span class="string">", phone="</span> + phone + <span class="string">"]"</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 这是BeanFactoryAware接口方法</span></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">    System.out.println(<span class="string">"【BeanFactoryAware接口】调用BeanFactoryAware.setBeanFactory()"</span>);</div><div class="line">    <span class="keyword">this</span>.beanFactory = beanFactory;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 这是BeanNameAware接口方法</span></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">    System.out.println(<span class="string">"【BeanNameAware接口】调用BeanNameAware.setBeanName()"</span>);</div><div class="line">    <span class="keyword">this</span>.beanName = name;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 这是InitializingBean接口方法</span></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    System.out.println(<span class="string">"【InitializingBean接口】调用InitializingBean.afterPropertiesSet()"</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 这是DiposibleBean接口方法</span></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    System.out.println(<span class="string">"【DiposibleBean接口】调用DiposibleBean.destory()"</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 通过&lt;bean&gt;的init-method属性指定的初始化方法</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myInit</span><span class="params">()</span> </span>&#123;</div><div class="line">    System.out.println(<span class="string">"【init-method】调用&lt;bean&gt;的init-method属性指定的初始化方法"</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 通过&lt;bean&gt;的destroy-method属性指定的初始化方法</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myDestory</span><span class="params">()</span> </span>&#123;</div><div class="line">    System.out.println(<span class="string">"【destroy-method】调用&lt;bean&gt;的destroy-method属性指定的初始化方法"</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>2、接下来是演示BeanPostProcessor接口的方法，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.zsr.test.spring.bean;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</div><div class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.BeanPostProcessor;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyBeanPostProcessor</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>();</div><div class="line">    System.out.println(<span class="string">"这是BeanPostProcessor实现类构造器！！"</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">    System.out.println(<span class="string">"BeanPostProcessor接口方法postProcessBeforeInitialization对属性进行更改！"</span>);</div><div class="line">    <span class="keyword">return</span> bean;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">    System.out.println(<span class="string">"BeanPostProcessor接口方法postProcessAfterInitialization对属性进行更改！"</span>);</div><div class="line">    <span class="keyword">return</span> bean;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如上，<code>BeanPostProcessor</code>接口包括2个方法<code>postProcessAfterInitialization</code>和<code>postProcessBeforeInitialization</code>，这两个方法的第一个参数都是要处理的Bean对象，第二个参数都是Bean的name。返回值也都是要处理的Bean对象。</p>
<p>3、<strong><code>InstantiationAwareBeanPostProcessor</code> 接口本质是<code>BeanPostProcessor</code>的子接口</strong>，一般我们继承Spring为其提供的适配器类<code>InstantiationAwareBeanPostProcessorAdapter</code>来使用它，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.zsr.test.spring.bean;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.beans.PropertyDescriptor;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</div><div class="line"><span class="keyword">import</span> org.springframework.beans.PropertyValues;</div><div class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessorAdapter;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInstantiationAwareBeanPostProcessor</span> <span class="keyword">extends</span> <span class="title">InstantiationAwareBeanPostProcessorAdapter</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyInstantiationAwareBeanPostProcessor</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>();</div><div class="line">    System.out.println(<span class="string">"这是InstantiationAwareBeanPostProcessorAdapter实现类构造器！！"</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 接口方法、实例化Bean之前调用</span></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInstantiation</span><span class="params">(Class beanClass, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">    System.out.println(<span class="string">"InstantiationAwareBeanPostProcessor调用postProcessBeforeInstantiation方法"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 接口方法、实例化Bean之后调用</span></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">    System.out.println(<span class="string">"InstantiationAwareBeanPostProcessor调用postProcessAfterInitialization方法"</span>);</div><div class="line">    <span class="keyword">return</span> bean;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 接口方法、设置某个属性时调用</span></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> PropertyValues <span class="title">postProcessPropertyValues</span><span class="params">(PropertyValues pvs, PropertyDescriptor[] pds, Object bean,</span></span></div><div class="line">      String beanName) <span class="keyword">throws</span> BeansException &#123;</div><div class="line">    System.out.println(<span class="string">"InstantiationAwareBeanPostProcessor调用postProcessPropertyValues方法"</span>);</div><div class="line">    <span class="keyword">return</span> pvs;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个有3个方法，其中第二个方法<code>postProcessAfterInitialization</code>就是重写了<code>BeanPostProcessor</code>的方法。第三个方法<code>postProcessPropertyValues</code>用来操作属性，返回值也应该是<code>PropertyValues</code>对象。</p>
<p>4、工厂后处理器接口方法，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.zsr.test.spring.bean;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</div><div class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.BeanDefinition;</div><div class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.BeanFactoryPostProcessor;</div><div class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.ConfigurableListableBeanFactory;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyBeanFactoryPostProcessor</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>();</div><div class="line">    System.out.println(<span class="string">"这是BeanFactoryPostProcessor实现类构造器！！"</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">    System.out.println(<span class="string">"BeanFactoryPostProcessor调用postProcessBeanFactory方法"</span>);</div><div class="line">    BeanDefinition bd = arg0.getBeanDefinition(<span class="string">"person"</span>);</div><div class="line">    bd.getPropertyValues().addPropertyValue(<span class="string">"phone"</span>, <span class="string">"110"</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><code>BeanFactoryPostProcessor</code> 可以修改 <code>bean</code> 的配置信息而 <code>BeanPostProcessor</code> 不能</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span></span></div><div class="line">                <span class="keyword">throws</span> BeansException &#123;</div><div class="line">            <span class="comment">//BeanFactoryPostProcessor可以修改BEAN的配置信息而BeanPostProcessor不能</span></div><div class="line">            <span class="comment">//我们在这里修改postProcessorBean的username注入属性</span></div><div class="line">            BeanDefinition bd = beanFactory.getBeanDefinition(<span class="string">"postProcessorBean"</span>);</div><div class="line">            MutablePropertyValues pv =  bd.getPropertyValues();</div><div class="line">            <span class="keyword">if</span>(pv.contains(<span class="string">"username"</span>))</div><div class="line">            &#123;</div><div class="line">                pv.addPropertyValue(<span class="string">"username"</span>, <span class="string">"xiaojun"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>5、配置文件如下<code>beans.xml</code>，使用<code>ApplicationContext</code>,处理器不用手动注册：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></div><div class="line">    <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span> <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></div><div class="line">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></div><div class="line">            http://www.springframework.org/schema/beans </div><div class="line">            http://www.springframework.org/schema/beans/spring-beans-3.2.xsd"&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"beanPostProcessor"</span> <span class="attr">class</span>=<span class="string">"springBeanTest.MyBeanPostProcessor"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"instantiationAwareBeanPostProcessor"</span> <span class="attr">class</span>=<span class="string">"springBeanTest.MyInstantiationAwareBeanPostProcessor"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"beanFactoryPostProcessor"</span> <span class="attr">class</span>=<span class="string">"springBeanTest.MyBeanFactoryPostProcessor"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">    </div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person"</span> <span class="attr">class</span>=<span class="string">"springBeanTest.Person"</span> <span class="attr">init-method</span>=<span class="string">"myInit"</span></span></div><div class="line">        <span class="attr">destroy-method</span>=<span class="string">"myDestory"</span> <span class="attr">scope</span>=<span class="string">"singleton"</span> <span class="attr">p:name</span>=<span class="string">"张三"</span> <span class="attr">p:address</span>=<span class="string">"广州"</span></div><div class="line">        <span class="attr">p:phone</span>=<span class="string">"15900000000"</span> /&gt;</div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
<p>6、测试一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.zsr.test.spring.bean;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</div><div class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanLifeCycleTest</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">    System.out.println(<span class="string">"现在开始初始化容器"</span>);</div><div class="line"></div><div class="line">    ApplicationContext factory = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</div><div class="line">    System.out.println(<span class="string">"容器初始化成功"</span>);</div><div class="line">    <span class="comment">// 得到Preson，并使用</span></div><div class="line">    Person person = factory.getBean(<span class="string">"person"</span>, Person.class);</div><div class="line">    System.out.println(person);</div><div class="line"></div><div class="line">    System.out.println(<span class="string">"现在开始关闭容器！"</span>);</div><div class="line">    ((ClassPathXmlApplicationContext) factory).registerShutdownHook();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>关闭容器使用的是实际是<code>AbstractApplicationContext</code>的钩子方法。</p>
<p>7、结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">现在开始初始化容器</div><div class="line">[location]15:15:33 100  INFO (org.springframework.context.support.ClassPathXmlApplicationContext:510) - Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@75a70476: startup date [Mon May 08 15:15:33 CST 2017]; root of context hierarchy</div><div class="line">[location]15:15:33 194  INFO (org.springframework.beans.factory.xml.XmlBeanDefinitionReader:315) - Loading XML bean definitions from class path resource [beans.xml]</div><div class="line">这是BeanFactoryPostProcessor实现类构造器！！</div><div class="line">BeanFactoryPostProcessor调用postProcessBeanFactory方法</div><div class="line">这是BeanPostProcessor实现类构造器！！</div><div class="line">这是InstantiationAwareBeanPostProcessorAdapter实现类构造器！！</div><div class="line">[location]15:15:33 695  INFO (org.springframework.beans.factory.support.DefaultListableBeanFactory:596) - Pre-instantiating singletons in org.springframework.beans.factory.support.DefaultListableBeanFactory@461d434f: defining beans [beanPostProcessor,instantiationAwareBeanPostProcessor,beanFactoryPostProcessor,person]; root of factory hierarchy</div><div class="line">InstantiationAwareBeanPostProcessor调用postProcessBeforeInstantiation方法</div><div class="line">【构造器】调用Person的构造器实例化</div><div class="line">InstantiationAwareBeanPostProcessor调用postProcessPropertyValues方法</div><div class="line">【注入属性】注入属性address</div><div class="line">【注入属性】注入属性name</div><div class="line">【注入属性】注入属性phone</div><div class="line">【BeanNameAware接口】调用BeanNameAware.setBeanName()</div><div class="line">【BeanFactoryAware接口】调用BeanFactoryAware.setBeanFactory()</div><div class="line">BeanPostProcessor接口方法postProcessBeforeInitialization对属性进行更改！</div><div class="line">【InitializingBean接口】调用InitializingBean.afterPropertiesSet()</div><div class="line">【init-method】调用&lt;bean&gt;的init-method属性指定的初始化方法</div><div class="line">BeanPostProcessor接口方法postProcessAfterInitialization对属性进行更改！</div><div class="line">InstantiationAwareBeanPostProcessor调用postProcessAfterInitialization方法</div><div class="line">容器初始化成功</div><div class="line">Person [address=广州, name=张三, phone=110]</div><div class="line">现在开始关闭容器！</div><div class="line">[location]15:15:33 752  INFO (org.springframework.context.support.ClassPathXmlApplicationContext:1042) - Closing org.springframework.context.support.ClassPathXmlApplicationContext@75a70476: startup date [Mon May 08 15:15:33 CST 2017]; root of context hierarchy</div><div class="line">[location]15:15:33 752  INFO (org.springframework.beans.factory.support.DefaultListableBeanFactory:444) - Destroying singletons in org.springframework.beans.factory.support.DefaultListableBeanFactory@461d434f: defining beans [beanPostProcessor,instantiationAwareBeanPostProcessor,beanFactoryPostProcessor,person]; root of factory hierarchy</div><div class="line">【DiposibleBean接口】调用DiposibleBean.destory()</div><div class="line">【destroy-method】调用&lt;bean&gt;的destroy-method属性指定的初始化方法</div></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Bean的完整生命周期从 spring 容器开始实例化 bean 开始，到销毁。可以从三点来理解</p>
<p>1、<code>bean</code>自身的方法：包括构造方法、 set 方法、 init-method 指定的方法、 destroy-method 指定的方法</p>
<p>2、<code>bean</code>级生命周期接口方法：如<code>BeanNameAware</code> 、 <code>BeanFactoryAware</code> 等这些接口方法由 bean类实现</p>
<p>3、容器级生命周期接口方法：有<code>InstantiationAwareBeanPostProcessor</code> 、 <code>BeanPostProcessor</code>等。一般称为后处理器。他们一般不由bean 本身实现，独立存在，注册到 spring 容器中。 Spring 通过接口反射预先知道，当 spring 容器创建任何 bean 时，这些后处理器都会发生作用。所以他们是全局的，用户可以通过编码对只感兴趣的 bean 进行处理</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://www.cnblogs.com/zrtqsk/p/3735273.html" target="_blank" rel="external">Spring Bean的生命周期</a></p>
<p><a href="http://www.jianshu.com/p/3944792a5fff" target="_blank" rel="external">Spring Bean生命周期</a></p>
<p><a href="https://my.oschina.net/u/1246663/blog/207450" target="_blank" rel="external">Spring bean生命周期详解</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ThreadPoolExecutor]]></title>
      <url>http://zsr.github.io/2017/05/03/ThreadPoolExecutor/</url>
      <content type="html"><![CDATA[<h1 id="ThreadPoolExecutor线程池-实现原理"><a href="#ThreadPoolExecutor线程池-实现原理" class="headerlink" title="ThreadPoolExecutor线程池 实现原理"></a>ThreadPoolExecutor线程池 实现原理</h1><hr>
<h3 id="类结构"><a href="#类结构" class="headerlink" title="类结构"></a>类结构</h3><p>首先要先了解一下类结构，如下图：</p>
<p><img src="http://kael-aiur.com/static/img/blog/java-thread-pool/images/class_struts.png" alt="enter description here"></p>
<ul>
<li><code>Executor</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>只有一个接口，传入一个<code>Runnable</code>对象，线程池就会帮你执行这个指令。</p>
<ul>
<li><code>ExecutorService</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</div><div class="line">    <span class="function">List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</div><div class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</div><div class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</div><div class="line"> </div><div class="line">    .......省略........</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个接口是执行器服务接口，声明了关于执行器的许多管理方法。</p>
<ul>
<li><code>AbstractExecutorService</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractExecutorService</span> <span class="keyword">implements</span> <span class="title">ExecutorService</span> </span>&#123;</div><div class="line">  </div><div class="line">  .......省略........</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</div><div class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">        RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</div><div class="line">        execute(ftask);</div><div class="line">        <span class="keyword">return</span> ftask;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">        RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);</div><div class="line">        execute(ftask);</div><div class="line">        <span class="keyword">return</span> ftask;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">        RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</div><div class="line">        execute(ftask);</div><div class="line">        <span class="keyword">return</span> ftask;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line"> .......省略........</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个抽象类实现了<code>ExecutorService</code>接口中的大部分方法，不过大部分的实现都依赖于<code>Executor</code>接口声明的<code>execute</code>方法，而这里并没有实现这个关键的方法，而是把这个方法的实现交给了子类，也就是<code>java.util.concurrent.ThreadPoolExecutor</code>来实现了。</p>
<a id="more"></a>
<ul>
<li><code>Worker</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ThreadPoolExecutor内部类</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></div><div class="line">&#123;</div><div class="line">   Worker(Runnable firstTask) &#123;</div><div class="line">            setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></div><div class="line">            <span class="keyword">this</span>.firstTask = firstTask;</div><div class="line">            <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">  <span class="comment">/** Delegates main run loop to outer runWorker  */</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            runWorker(<span class="keyword">this</span>);</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Worker</code>，每一个<code>Worker</code>对象代表了一个线程，同时也是真正负责执行任务的对象。</p>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></div><div class="line">                              <span class="keyword">int</span> maximumPoolSize,</div><div class="line">                              <span class="keyword">long</span> keepAliveTime,</div><div class="line">                              TimeUnit unit,</div><div class="line">                              BlockingQueue&lt;Runnable&gt; workQueue) &#123;</div><div class="line">        <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</div><div class="line">             Executors.defaultThreadFactory(), defaultHandler);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">.......省略........</div><div class="line">   </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></div><div class="line">                              <span class="keyword">int</span> maximumPoolSize,</div><div class="line">                              <span class="keyword">long</span> keepAliveTime,</div><div class="line">                              TimeUnit unit,</div><div class="line">                              BlockingQueue&lt;Runnable&gt; workQueue,</div><div class="line">                              ThreadFactory threadFactory,</div><div class="line">                              RejectedExecutionHandler handler) &#123;</div><div class="line">        <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</div><div class="line">            maximumPoolSize &lt;= <span class="number">0</span> ||</div><div class="line">            maximumPoolSize &lt; corePoolSize ||</div><div class="line">            keepAliveTime &lt; <span class="number">0</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</div><div class="line">        <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">        <span class="keyword">this</span>.corePoolSize = corePoolSize;</div><div class="line">        <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</div><div class="line">        <span class="keyword">this</span>.workQueue = workQueue;</div><div class="line">        <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</div><div class="line">        <span class="keyword">this</span>.threadFactory = threadFactory;</div><div class="line">        <span class="keyword">this</span>.handler = handler;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>corePoolSize</code>：核心池的大小，在创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，当线程池中的线程数目达到<code>corePoolSize</code>后，就会把到达的任务放到缓存队列当中。只有当工作队列满了的情况下才会创建超出这个数量的线程。如果某个线程的空闲时间超过了活动时间，那么将标记为可回收，并且只有当线程池的当前大小超过<code>corePoolSize</code>时该线程才会被终止。用户可调用<code>prestartAllCoreThreads()</code>或者<code>prestartCoreThread()</code>方法预先创建线程，即在没有任务到来之前就创建<code>corePoolSize</code>个线程或者一个线程。</li>
<li><code>maximumPoolSize</code>：线程池最大线程数，这个参数也是一个非常重要的参数，它表示在线程池中最多能创建多少个线程；当大于了这个值就会将<code>Thread</code>由一个丢弃处理机制来处理。</li>
<li><code>keepAliveTime</code>：表示线程没有任务执行时最多保持多久时间会终止。默认情况下，只有当线程池中的线程数大于<code>corePoolSize</code>时，<code>keepAliveTime</code>才会起作用，直到线程池中的线程数不大于<code>corePoolSize</code>，即当线程池中的线程数大于<code>corePoolSize</code>时，如果一个线程空闲的时间达到<code>keepAliveTime</code>，则会终止，直到线程池中的线程数不超过<code>corePoolSize</code>。但是如果调用了<code>allowCoreThreadTimeOut(boolean)</code>方法，在线程池中的线程数不大于<code>corePoolSize</code>时，<code>keepAliveTime</code>参数也会起作用，直到线程池中的线程数为0；</li>
<li><code>Unit</code>：参数<code>keepAliveTime</code>的时间单位，有7种取值，在<code>TimeUnit</code>类中有7种静态属性。</li>
<li><code>workQueue</code>：一个阻塞队列，用来存储等待执行的任务，当线程池中的线程数目达到<code>corePoolSize</code>后，就会把到达的任务放到缓存队列当中。</li>
<li><code>threadFactory</code>：线程工厂，主要用来创建线程；</li>
<li><code>handler</code>：表示当拒绝处理任务时的策略，也就是参数<code>maximumPoolSize</code>达到后丢弃处理的方法。有以下四种取值：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。 </div><div class="line">ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 </div><div class="line">ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</div><div class="line">ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务</div></pre></td></tr></table></figure>
<p>用户也可以实现接口<code>RejectedExecutionHandler</code>定制自己的策略。</p>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>按照下面的几个方面来阅读jdk的源码：</p>
<ol>
<li>线程池的状态</li>
<li>线程任务执行</li>
<li>线程池关闭</li>
<li>线程容量动态调整</li>
</ol>
<h4 id="线程池的状态"><a href="#线程池的状态" class="headerlink" title="线程池的状态"></a>线程池的状态</h4><p>跟线程池状态有关的几个属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">AtomicInteger ctl; <span class="comment">// 状态计数器</span></div><div class="line"><span class="keyword">int</span> RUNNING; <span class="comment">// 运行状态</span></div><div class="line"><span class="keyword">int</span> SHUTDOWN ;<span class="comment">// 关闭状态</span></div><div class="line"><span class="keyword">int</span> STOP; <span class="comment">// 停止状态</span></div><div class="line"><span class="keyword">int</span> TIDYING; <span class="comment">// 整理状态</span></div><div class="line"><span class="keyword">int</span> TERMINATED; <span class="comment">//结束状态</span></div></pre></td></tr></table></figure>
<ul>
<li><code>ctl</code>：标识线程池当前状态和线程数的，这里要特别注意，这个属性把两个变量打包成一个变量了，通过这个属性可以计算得出目前的线程数和线程池当前的状态。</li>
<li><p><code>RUNNING</code>：正在处理任务和接受队列中的任务。</p>
</li>
<li><p><code>SHUTDOWN</code>：不再接受新的任务，但是会继续处理完队列中的任务。</p>
</li>
</ul>
<ul>
<li><code>STOP</code>：不再接受新任务，也不继续处理队列中的任务，并且会中止正在处理的任务。</li>
</ul>
<ul>
<li><code>TIDYING</code>：所有任务都已经处理结束，目前<code>worker</code>数为0，当线程池进入这个状态的时候，会调用<code>terminated()</code>方法。</li>
</ul>
<ul>
<li><code>TERMINATED</code>：线程池已经全部结束，并且<code>terminated()</code>方法执行完成。</li>
</ul>
<h4 id="线程任务执行"><a href="#线程任务执行" class="headerlink" title="线程任务执行"></a>线程任务执行</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (command == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">        <span class="comment">/*</span></div><div class="line">         * Proceed in 3 steps:</div><div class="line">         *</div><div class="line">         * 1. If fewer than corePoolSize threads are running, try to</div><div class="line">         * start a new thread with the given command as its first</div><div class="line">         * task.  The call to addWorker atomically checks runState and</div><div class="line">         * workerCount, and so prevents false alarms that would add</div><div class="line">         * threads when it shouldn't, by returning false.</div><div class="line">         *</div><div class="line">         * 2. If a task can be successfully queued, then we still need</div><div class="line">         * to double-check whether we should have added a thread</div><div class="line">         * (because existing ones died since last checking) or that</div><div class="line">         * the pool shut down since entry into this method. So we</div><div class="line">         * recheck state and if necessary roll back the enqueuing if</div><div class="line">         * stopped, or start a new thread if there are none.</div><div class="line">         *</div><div class="line">         * 3. If we cannot queue task, then we try to add a new</div><div class="line">         * thread.  If it fails, we know we are shut down or saturated</div><div class="line">         * and so reject the task.</div><div class="line">         */</div><div class="line">        <span class="keyword">int</span> c = ctl.get();</div><div class="line">        <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</div><div class="line">            <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            c = ctl.get();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</div><div class="line">            <span class="keyword">int</span> recheck = ctl.get();</div><div class="line">            <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</div><div class="line">                reject(command);</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</div><div class="line">                addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</div><div class="line">            reject(command);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先判断了传入的指令对象是否为空，为空就不用执行了，直接抛出异常。如果指令对象不为空，那么就真正进入线程任务的逻辑，一共分为3步来处理：</p>
<ul>
<li>检查当前线程总数，如果低于核心线程数，则创建新的线程来执行这个任务</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> c = ctl.get();</div><div class="line"><span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</div><div class="line">    <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</div><div class="line">    	<span class="keyword">return</span>;</div><div class="line">    c = ctl.get();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里<code>workerCountOf(c)</code>可以从计数器(clt)的结果中计算出当前线程数。</p>
<p><code>addWorker(command, true)</code>会检查线程池状态和总线程数，并确定是否创建新线程，如果创建了新线程执行这个任务，则返回true，如果没有创建新线程，则返回false。</p>
<ul>
<li>尝试把任务放入任务队列，并且重新检查线程池状态，如果线程池已经不接收新的任务，则移除这个任务，并转入拒绝策略。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</div><div class="line">	<span class="keyword">int</span> recheck = ctl.get();</div><div class="line">	<span class="keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command))</div><div class="line">		reject(command);</div><div class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</div><div class="line">	addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第二步先检查了线程池当前是否运行状态，如果是运行状态的话，则执行<code>workQueue.offer(command)</code>把任务放入任务队列。</p>
<p>任务放入队列之后，会复查线程池状态是否RUNNING，这里需要做复查的主要原因是在前面的检查中没有加锁，因此可能在添加任务队列的过程，其他线程修改了线程池的状态。</p>
<p>如果这个时候线程池状态被修改了，那么就会把这次添加的任务移除<code>remove(command)</code>，同时启动拒绝策略<code>reject(command)</code>。</p>
<p>如果线程池状态没有被改变，则重新检查当前核心线程数，如果为0则调用<code>addWorker(null, false)</code>去队列中取任务并执行，如果不为0，则不做任何操作，等待线程执行完当前任务后自动去任务队列中获取新的任务并执行。</p>
<ul>
<li>如果任务队列已满，则尝试添加临时线程，并把当然任务交给临时线程处理，如果临时线程也满了，则启动拒绝策略</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</div><div class="line">            reject(command);</div></pre></td></tr></table></figure>
<p>这里先通过<code>addWorker(command, false)</code>尝试添加临时线程，如果临时线程创建成功则由临时线程执行这个任务，如果临时线程创建失败，则会返回false，并转入拒绝策略<code>reject(command)</code>。</p>
<h5 id="addWorker"><a href="#addWorker" class="headerlink" title="addWorker"></a><code>addWorker</code></h5><p>这里有一个重要的方法<code>addWorker(Runnable firstTask, boolean core)</code>，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</div><div class="line">        retry:</div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="keyword">int</span> c = ctl.get();</div><div class="line">            <span class="keyword">int</span> rs = runStateOf(c);</div><div class="line"></div><div class="line">            <span class="comment">/** 这里返回false有以下可能：</span></div><div class="line">              * 1 线程池状态大于SHUTDOWN</div><div class="line">              * 2 线程池状态为SHUTDOWN，但firstTask不为空，也就是说线程池已经SHUTDOWN，拒绝添加新任务</div><div class="line">              * 3 线程池状态为SHUTDOWN且firstTask为空，但workQueue为空，即无任务需要执行</div><div class="line">              */</div><div class="line">            <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</div><div class="line">                ! (rs == SHUTDOWN &amp;&amp;</div><div class="line">                   firstTask == <span class="keyword">null</span> &amp;&amp;</div><div class="line">                   ! workQueue.isEmpty()))</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">            <span class="keyword">for</span> (;;) &#123;</div><div class="line">                <span class="keyword">int</span> wc = workerCountOf(c);</div><div class="line">                <span class="comment">/** 返回false有以下可能：</span></div><div class="line">                  * 1 工作线程数量超过最大容量</div><div class="line">                  * 2 core为true，工作线程数量超过边界corePoolSize</div><div class="line">                  * 3 core为false,工作线程数量超过边界maximumPoolSize</div><div class="line">                  */</div><div class="line">                <span class="keyword">if</span> (wc &gt;= CAPACITY ||</div><div class="line">                    wc &gt;= (core ? corePoolSize : maximumPoolSize))</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</div><div class="line">                    <span class="keyword">break</span> retry;<span class="comment">//直接跳出最外层循环</span></div><div class="line">                c = ctl.get();  <span class="comment">// Re-read ctl</span></div><div class="line">                <span class="keyword">if</span> (runStateOf(c) != rs)<span class="comment">//线程池状态发生改变则从最外层循环重新开始</span></div><div class="line">                    <span class="keyword">continue</span> retry;</div><div class="line">                <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Worker w = <span class="keyword">new</span> Worker(firstTask);</div><div class="line">        Thread t = w.thread;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</div><div class="line">        mainLock.lock();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// 持有锁之后需要重新检查线程池状态，防止ThreadFactory返回失败或线程池在加锁之前被关闭</span></div><div class="line">            <span class="keyword">int</span> c = ctl.get();</div><div class="line">            <span class="keyword">int</span> rs = runStateOf(c);</div><div class="line">             <span class="comment">/** 返回false有以下可能：</span></div><div class="line">               * 1 t为null,说明ThreadFactory创建线程失败，可能发生OutOfMemoryError</div><div class="line">               * 2 线程池状态大于SHUTDOWN</div><div class="line">               * 3 线程池状态为SHUTDOWN，但firstTask不为空</div><div class="line">               */</div><div class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span> ||</div><div class="line">                (rs &gt;= SHUTDOWN &amp;&amp;</div><div class="line">                 ! (rs == SHUTDOWN &amp;&amp;</div><div class="line">                    firstTask == <span class="keyword">null</span>))) &#123;</div><div class="line">                decrementWorkerCount();</div><div class="line">                tryTerminate();</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            workers.add(w);</div><div class="line"></div><div class="line">            <span class="keyword">int</span> s = workers.size();</div><div class="line">            <span class="keyword">if</span> (s &gt; largestPoolSize)</div><div class="line">                largestPoolSize = s;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            mainLock.unlock();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        t.start();</div><div class="line">        <span class="comment">// 在线程池变为stop期间，线程可能已经被添加到workers，但还未被启动（该现象不太可能发生，这可能</span></div><div class="line">        <span class="comment">// 导致罕见的丢失中断，因为Thread.interrupt不能保证对非启动状态的线程有效</span></div><div class="line">        <span class="keyword">if</span> (runStateOf(ctl.get()) == STOP &amp;&amp; ! t.isInterrupted())</div><div class="line">            t.interrupt();</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>addWorker首先会检查当前线程池的状态和给定的边界是否可以创建一个新的worker，在此期间会对workers的数量进行适当调整；如果满足条件，将创建一个新的worker并启动，以参数中的firstTask作为worker的第一个任务。</p>
<ul>
<li><code>addWorker</code>方法参数：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Runnable firstTask; // 表示新建的线程的第一个任务</div><div class="line">boolean core; // 是否以核心线程数为边界，如果传入true，表示以核心线程数为边界，当前线程超过核心线程数则不创建新线程，如果不使用核心线程数为边界，则会以最大线程数为边界</div></pre></td></tr></table></figure>
<ul>
<li>第一步就是检查线程池当前的状态:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> c = ctl.get();</div><div class="line"><span class="keyword">int</span> rs = runStateOf(c);</div><div class="line"></div><div class="line"><span class="comment">// Check if queue empty only if necessary.</span></div><div class="line"><span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</div><div class="line">	! (rs == SHUTDOWN &amp;&amp;</div><div class="line">		firstTask == <span class="keyword">null</span> &amp;&amp;</div><div class="line">		! workQueue.isEmpty()))</div><div class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</div></pre></td></tr></table></figure>
<p>如果已经不允许接受新任务了，这里就直接返回了，如果允许接受新任务的话，会继续执行</p>
<ul>
<li>检查是否要求使用核心线程数为边界，如果不满足条件，则直接返回false</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (;;) &#123;</div><div class="line">	<span class="keyword">int</span> wc = workerCountOf(c);</div><div class="line">	<span class="keyword">if</span> (wc &gt;= CAPACITY ||</div><div class="line">		wc &gt;= (core ? corePoolSize : maximumPoolSize))</div><div class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">	<span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</div><div class="line">		<span class="keyword">break</span> retry;</div><div class="line">	c = ctl.get();  <span class="comment">// Re-read ctl</span></div><div class="line">	<span class="keyword">if</span> (runStateOf(c) != rs)</div><div class="line">		<span class="keyword">continue</span> retry;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果满足条件，则会执行<code>compareAndIncrementWorkerCount(c)</code>给计数器加1，同时跳出循环，执行下一步，如果计数器添加失败，会再次计算线程池当前状态是否RUNNING，如果线程池还在RUNNING状态，则继续重试。</p>
<ul>
<li>前面已经添加了线程数了，那么下一步就开始创建新线程了：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">w = <span class="keyword">new</span> Worker(firstTask);</div><div class="line"><span class="keyword">final</span> Thread t = w.thread;</div></pre></td></tr></table></figure>
<p>一个<code>Worker</code>对象表示的是一个线程，每创建一个<code>Worker</code>对象，就会创建一个新的线程，并以自己作为线程的运行对象(<code>Worker</code>自己也是<code>Runnable</code>的实现类)。</p>
<ul>
<li>创建了<code>Worker</code>对象之后，需要对线程池做一系列的检查，并将这个对象加入到线程池中</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</div><div class="line">mainLock.lock();</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">	<span class="keyword">int</span> rs = runStateOf(ctl.get());</div><div class="line">	<span class="keyword">if</span> (rs &lt; SHUTDOWN ||</div><div class="line">	(rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</div><div class="line">		<span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</div><div class="line">		workers.add(w);</div><div class="line">		<span class="keyword">int</span> s = workers.size();</div><div class="line">		<span class="keyword">if</span> (s &gt; largestPoolSize)</div><div class="line">			largestPoolSize = s;</div><div class="line">		workerAdded = <span class="keyword">true</span>;</div><div class="line">	&#125;</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">	mainLock.unlock();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里首先获取线程池的主锁，保证在添加线程的过程不受其他线程干扰。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mainLock.lock();</div></pre></td></tr></table></figure>
<p>然后检查线程池状态和线程状态，如果线程池各个状态都是正常的，可以把线程加入到线程池中，则会把线程池加入线程池，并将线程添加状态设置为true:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">workers.add(w);</div><div class="line"><span class="comment">// ... 省略若干代码</span></div><div class="line">workerAdded = <span class="keyword">true</span>;</div></pre></td></tr></table></figure>
<p>最后释放锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">finally</span> &#123;</div><div class="line">	mainLock.unlock();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里要特别注意，锁一定要在<code>finally</code>代码块中释放，不然很容易造成死锁。</p>
<ul>
<li>最后，判断线程是否已经加入线程池中，如果已经加入线程池中，则启动线程：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (workerAdded) &#123;</div><div class="line">	t.start();</div><div class="line">	workerStarted = <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>在最后判断线程是否启动，如果线程没有启动，则会做回滚：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">finally</span> &#123;</div><div class="line">	<span class="keyword">if</span> (!workerStarted)</div><div class="line">		addWorkerFailed(w);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="reject"><a href="#reject" class="headerlink" title="reject"></a><code>reject</code></h5><p>这个方法是调用线程池的拒绝处理策略：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">final void reject(Runnable command) &#123;</div><div class="line">        handler.rejectedExecution(command, this);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然这个策略可以通过我们自己传入的对象来处理，默认使用<code>AbortPolicy</code>处理，抛出异常。</p>
<h5 id="worker线程运行"><a href="#worker线程运行" class="headerlink" title="worker线程运行"></a><code>worker</code>线程运行</h5><p>这里就涉及到<code>Worker</code>的<code>run</code>方法实现了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">	runWorker(<span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里实际上是调用了<code>java.util.concurrent.ThreadPoolExecutor</code>的<code>runWorker(Worker w)</code>方法，我们来看下这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</div><div class="line">        Thread wt = Thread.currentThread();</div><div class="line">        Runnable task = w.firstTask;</div><div class="line">        w.firstTask = <span class="keyword">null</span>;</div><div class="line">        w.unlock(); <span class="comment">// allow interrupts</span></div><div class="line">        <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</div><div class="line">                w.lock();</div><div class="line">                <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</div><div class="line">                     (Thread.interrupted() &amp;&amp;</div><div class="line">                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</div><div class="line">                    !wt.isInterrupted())</div><div class="line">                    wt.interrupt();</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    beforeExecute(wt, task);</div><div class="line">                    Throwable thrown = <span class="keyword">null</span>;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        task.run();</div><div class="line">                    &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</div><div class="line">                        thrown = x; <span class="keyword">throw</span> x;</div><div class="line">                    &#125; <span class="keyword">catch</span> (Error x) &#123;</div><div class="line">                        thrown = x; <span class="keyword">throw</span> x;</div><div class="line">                    &#125; <span class="keyword">catch</span> (Throwable x) &#123;</div><div class="line">                        thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</div><div class="line">                    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                        afterExecute(task, thrown);</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                    task = <span class="keyword">null</span>;</div><div class="line">                    w.completedTasks++;</div><div class="line">                    w.unlock();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            completedAbruptly = <span class="keyword">false</span>;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            processWorkerExit(w, completedAbruptly);</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里首先调用Worker的unlock()方法，允许这个线程被中断，然后进入一个循环，这个循环内部做了几件事情：</p>
<ul>
<li>获取要执行的任务</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>)</div></pre></td></tr></table></figure>
<p>这里判断是否有第一个任务，如果有第一个任务则使用第一个任务，如果没有第一个任务，则使用<code>getTask()</code>获得新任务，<strong><code>getTask()</code>是一个重要的方法，如果获取不到任务的话，这个方法会阻塞并等待任务</strong>，后边详细看这个方法。</p>
<ul>
<li>获取当前线程的锁，检查当前线程是否允许运行</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">w.lock();</div><div class="line"><span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</div><div class="line">                     (Thread.interrupted() &amp;&amp;</div><div class="line">                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</div><div class="line">                    !wt.isInterrupted())</div><div class="line">                    wt.interrupt();</div></pre></td></tr></table></figure>
<ul>
<li>所有检查通过之后，确认当前任务可以执行了，就开始执行任务</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">	beforeExecute(wt, task);</div><div class="line">	Throwable thrown = <span class="keyword">null</span>;</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">		task.run();</div><div class="line">	&#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</div><div class="line">		thrown = x; <span class="keyword">throw</span> x;</div><div class="line">	&#125; <span class="keyword">catch</span> (Error x) &#123;</div><div class="line">		thrown = x; <span class="keyword">throw</span> x;</div><div class="line">	&#125; <span class="keyword">catch</span> (Throwable x) &#123;</div><div class="line">		thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</div><div class="line">	&#125; <span class="keyword">finally</span> &#123;</div><div class="line">		afterExecute(task, thrown);</div><div class="line">	&#125;</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">	task = <span class="keyword">null</span>;	</div><div class="line">	w.completedTasks++;</div><div class="line">	w.unlock();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行任务的过程，先调用了<code>beforeExecute(wt, task)</code>做执行前处理，任务执行完成后，调用<code>afterExecute(task, thrown)</code>做执行完成后处理，这里主要是留给开发者扩展用的，默认不做任何处理，如果我们需要做一些处理，比如计算任务执行时间一类的，可以通过继承<code>java.util.concurrent.ThreadPoolExecutor</code>并重写这两个方法来实现。</p>
<p>任务执行完成后，在finally中释放了锁并给完成任务计数器加1。</p>
<h6 id="getTask"><a href="#getTask" class="headerlink" title="getTask()"></a>getTask()</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></div><div class="line"></div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="keyword">int</span> c = ctl.get();</div><div class="line">            <span class="keyword">int</span> rs = runStateOf(c);</div><div class="line"></div><div class="line">            <span class="comment">// Check if queue empty only if necessary.</span></div><div class="line">            <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</div><div class="line">                decrementWorkerCount();</div><div class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</div><div class="line"></div><div class="line">            <span class="comment">// Are workers subject to culling?</span></div><div class="line">            <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</div><div class="line">                &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</div><div class="line">                <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                Runnable r = timed ?</div><div class="line">                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</div><div class="line">                    workQueue.take();</div><div class="line">                <span class="keyword">if</span> (r != <span class="keyword">null</span>)</div><div class="line">                    <span class="keyword">return</span> r;</div><div class="line">                timedOut = <span class="keyword">true</span>;</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</div><div class="line">                timedOut = <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>简单而言就是检查线程池状态，只要线程池还没有终止，这里就就会无限循环知道抛出异常或者线程池终止，线程的阻塞是用<code>workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS)</code>或<code>workQueue.take()</code>实现的。</p>
<h4 id="线程池关闭"><a href="#线程池关闭" class="headerlink" title="线程池关闭"></a>线程池关闭</h4><p>在<code>java.util.concurrent.ExecutorService</code>接口中提供了如下两个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>; <span class="comment">// 不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务</span></div><div class="line"><span class="function">List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span></span>; <span class="comment">// 立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务</span></div></pre></td></tr></table></figure>
<h4 id="线程池容量的动态调整"><a href="#线程池容量的动态调整" class="headerlink" title="线程池容量的动态调整"></a>线程池容量的动态调整</h4><p>动态调整线程池容量，在执行过程我们已经知道了，只要改变核心线程数和最大线程数即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setCorePoolSize</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span></span>;<span class="comment">// 调整核心线程数</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setMaximumPoolSize</span><span class="params">(<span class="keyword">int</span> maximumPoolSize)</span> </span>; <span class="comment">// 调整动态线程数</span></div></pre></td></tr></table></figure>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://kael-aiur.com/java/jdk%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0-ThreadPoolExecutor.html" target="_blank" rel="external">jdk的线程池实现-ThreadPoolExecutor</a></p>
<p><a href="https://my.oschina.net/7001/blog/889931" target="_blank" rel="external">Java线程池核心实现原理和源码解析</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LinkedHashMap]]></title>
      <url>http://zsr.github.io/2017/04/27/LinkedHashMap/</url>
      <content type="html"><![CDATA[<h1 id="LinkedHashMap-源码阅读"><a href="#LinkedHashMap-源码阅读" class="headerlink" title="LinkedHashMap 源码阅读"></a>LinkedHashMap 源码阅读</h1><hr>
<h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><ul>
<li>类继承关系</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public class LinkedHashMap&lt;K,V&gt;</div><div class="line">       extends HashMap&lt;K,V&gt;</div><div class="line">       implements Map&lt;K,V&gt;</div></pre></td></tr></table></figure>
<p><code>LinkedHashMap</code>继承自<code>HashMap</code></p>
<ul>
<li>核心成员变量</li>
</ul>
<p>jdk 7:(下文都是该环境)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * The head of the doubly linked list.</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; header;   <span class="comment">//链表头结点</span></div><div class="line"></div><div class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;   <span class="comment">//按元素插入顺序(默认)或元素最近访问顺序(LRU)排列</span></div></pre></td></tr></table></figure>
<p>jdk 8:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;   <span class="comment">//链表头结点</span></div><div class="line"></div><div class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;  <span class="comment">//链表尾节点</span></div><div class="line"></div><div class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</div></pre></td></tr></table></figure>
<p>jdk 8中新增了一个<code>链表尾节点</code></p>
<ul>
<li>特点</li>
</ul>
<p>一般来说，如果需要使用的Map中的key无序，选择<code>HashMap</code>；如果要求key有序，则选择<code>TreeMap</code>。<br>但是选择<code>TreeMap</code>就会有性能问题，因为<code>TreeMap</code>的get操作的时间复杂度是<code>O(log(n))</code>的，相比于<code>HashMap</code>的<code>O(1)</code>还是差不少的，<code>LinkedHashMap</code>的出现就是为了平衡这些因素，使得</p>
<blockquote>
<p>能够以<code>O(1)</code>时间复杂度增加查找元素，又能够保证key的有序性</p>
</blockquote>
<p>此外，<code>LinkedHashMap</code>提供了两种key的顺序：</p>
<blockquote>
<p>访问顺序（access order）：非常实用，可以使用这种顺序实现LRU（Least Recently Used）缓存</p>
<p>插入顺序（insertion orde）：同一key的多次插入，并不会影响其顺序</p>
</blockquote>
<a id="more"></a>
<h3 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h3><ul>
<li><code>环型双向链表</code></li>
</ul>
<p><img src="https://img.alicdn.com/imgextra/i1/581166664/TB27MP7fXXXXXb6XXXXXXXXXXXX_!!581166664.png" alt="环型双向链表"></p>
<p><code>LinkedHashMap</code>中采用就是这种<code>环型双向链表</code></p>
<ul>
<li><code>LinkedHashMap</code> 结构图</li>
</ul>
<p><img src="http://images2015.cnblogs.com/blog/939998/201605/939998-20160528192537725-909052596.png" alt="LinkedHashMap_base.png"></p>
<p>采用双向链表（doubly-linked list）的形式将所有entry连接起来，这样是为保证元素的迭代顺序跟插入顺序相同;<code>header</code>指向双向链表的头部（是一个哑元），该双向链表的迭代顺序就是entry的插入顺序。</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><ul>
<li>构造函数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//accessOrder为true表示该LinkedHashMap的key为访问顺序</span></div><div class="line"><span class="comment">//accessOrder为false表示该LinkedHashMap的key为插入顺序</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>(initialCapacity, loadFactor);</div><div class="line">    <span class="comment">//默认为false，也就是插入顺序</span></div><div class="line">    accessOrder = <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>(initialCapacity);</div><div class="line">    accessOrder = <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>();</div><div class="line">    accessOrder = <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>(m);</div><div class="line">    accessOrder = <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></div><div class="line">                     <span class="keyword">float</span> loadFactor,</div><div class="line">                     <span class="keyword">boolean</span> accessOrder) &#123;</div><div class="line">    <span class="keyword">super</span>(initialCapacity, loadFactor);</div><div class="line">    <span class="keyword">this</span>.accessOrder = accessOrder;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * Called by superclass constructors and pseudoconstructors (clone,</div><div class="line"> * readObject) before any entries are inserted into the map.  Initializes</div><div class="line"> * the chain.</div><div class="line"> */</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">    header = <span class="keyword">new</span> Entry&lt;&gt;(-<span class="number">1</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">    <span class="comment">//通过这里可以看出，LinkedHashMap采用的是环型的双向链表</span></div><div class="line">    header.before = header.after = header;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>内部节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="comment">// These fields comprise the doubly linked list used for iteration.</span></div><div class="line">    <span class="comment">//每个节点包含两个指针，指向前继节点与后继节点</span></div><div class="line">    Entry&lt;K,V&gt; before, after;</div><div class="line">    Entry(<span class="keyword">int</span> hash, K key, V value, HashMap.Entry&lt;K,V&gt; next) &#123;</div><div class="line">        <span class="keyword">super</span>(hash, key, value, next);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Removes this entry from the linked list.</div><div class="line">     */</div><div class="line">    <span class="comment">//删除一个节点时，需要把</span></div><div class="line">    <span class="comment">//1. 前继节点的后继指针 指向 要删除节点的后继节点</span></div><div class="line">    <span class="comment">//2. 后继节点的前继指针 指向 要删除节点的前继节点</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</div><div class="line">        before.after = after;</div><div class="line">        after.before = before;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Inserts this entry before the specified existing entry in the list.</div><div class="line">     */</div><div class="line">    <span class="comment">//在某节点前插入节点</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addBefore</span><span class="params">(Entry&lt;K,V&gt; existingEntry)</span> </span>&#123;</div><div class="line">        after  = existingEntry;</div><div class="line">        before = existingEntry.before;</div><div class="line">        before.after = <span class="keyword">this</span>;</div><div class="line">        after.before = <span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * This method is invoked by the superclass whenever the value</div><div class="line">     * of a pre-existing entry is read by Map.get or modified by Map.set.</div><div class="line">     * If the enclosing Map is access-ordered, it moves the entry</div><div class="line">     * to the end of the list; otherwise, it does nothing.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recordAccess</span><span class="params">(HashMap&lt;K,V&gt; m)</span> </span>&#123;</div><div class="line">        LinkedHashMap&lt;K,V&gt; lm = (LinkedHashMap&lt;K,V&gt;)m;</div><div class="line">        <span class="comment">// 如果需要key的访问顺序，需要把</span></div><div class="line">        <span class="comment">// 当前访问的节点删除，并把它插入到双向链表的尾部</span></div><div class="line">        <span class="keyword">if</span> (lm.accessOrder) &#123;</div><div class="line">            lm.modCount++;</div><div class="line">            remove();</div><div class="line">            addBefore(lm.header);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recordRemoval</span><span class="params">(HashMap&lt;K,V&gt; m)</span> </span>&#123;</div><div class="line">        remove();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Entry</code>继承自<code>HashMap.Entry</code>，同时增加了指向前一个和后一个节点的引用。</p>
<ul>
<li><code>put</code>方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.addEntry(hash, key, value, bucketIndex);</div><div class="line">    <span class="comment">// Remove eldest entry if instructed</span></div><div class="line">    Entry&lt;K,V&gt; eldest = header.after;</div><div class="line">    <span class="comment">//如果有必要移除最老的节点，那么就移除。LinkedHashMap默认removeEldestEntry总是返回false</span></div><div class="line">    <span class="comment">//也就是这里if里面的语句永远不会执行</span></div><div class="line">    <span class="comment">//这里removeEldestEntry主要是给LinkedHashMap的子类留下的一个钩子</span></div><div class="line">    <span class="comment">//子类完全可以根据自己的需要重写removeEldestEntry。可以看下文LRU cache实现例子</span></div><div class="line">    <span class="keyword">if</span> (removeEldestEntry(eldest)) &#123;</div><div class="line">        <span class="comment">//从这里看，最久未访问的节点是头部节点</span></div><div class="line">        removeEntryForKey(eldest.key);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</div><div class="line">    HashMap.Entry&lt;K,V&gt; old = table[bucketIndex];</div><div class="line">    Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, old);</div><div class="line">    table[bucketIndex] = e;</div><div class="line">    <span class="comment">//这里把新增的Entry加到了双向链表的header的前面，成为新的header</span></div><div class="line">    e.addBefore(header);</div><div class="line">    size++;</div><div class="line">&#125;   </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面是<code>LinkedHashMap</code>中重写了<code>HashMap</code>的两个方法，当调用<code>put</code>时添加<code>Entry</code>（新增Entry之前不存在）整个方法调用链是这样的：</p>
<blockquote>
<p><code>HashMap.put</code> -&gt; <code>LinkedHashMap.addEntry</code> -&gt;<br><code>HashMap.addEntry</code> -&gt; <code>LinkedHashMap.createEntry</code></p>
</blockquote>
<p>注意，通过<code>addEntry()</code>方法插入新的<code>entry</code>，这里的<strong>插入有两重含义</strong>：</p>
<ol>
<li>从<code>table</code>的角度看，新的<code>entry</code>需要插入到对应的<code>bucket</code>里，当有哈希冲突时，采用头插法将新的<code>entry</code>插入到冲突链表的头部。</li>
<li>从<code>header</code>的角度看，新的<code>entry</code>需要插入到双向链表的尾部。</li>
</ol>
<p>上述代码中用到了<code>addBefore()</code>方法将新<code>entry e</code>插入到双向链表头引用<code>header</code>的前面，这样<code>e</code>就成为双向链表中的最后一个元素。<strong>头结点代表最久未访问的节点</strong>。</p>
<p><img src="http://images2015.cnblogs.com/blog/939998/201605/939998-20160528192545084-2117175891.png" alt="LinkedHashMap_addEntry.png"></p>
<ul>
<li><code>get</code>方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">        Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)getEntry(key);</div><div class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        <span class="comment">// 如果是key的访问顺序，需要把</span></div><div class="line">        <span class="comment">// 当前访问的节点删除，并把它插入到双向链表的尾部</span></div><div class="line">        e.recordAccess(<span class="keyword">this</span>);</div><div class="line">        <span class="keyword">return</span> e.value;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="LRU-Cache"><a href="#LRU-Cache" class="headerlink" title="LRU Cache"></a>LRU Cache</h3><p>利用<code>LinkedHashMap</code>简单视线LRU cache.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</div><div class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; cache;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.capacity = capacity;</div><div class="line">        <span class="comment">// access_order为true，按访问顺序排序</span></div><div class="line">        <span class="keyword">this</span>.cache = <span class="keyword">new</span> java.util.LinkedHashMap&lt;Integer, Integer&gt; (capacity, <span class="number">0.75f</span>, <span class="keyword">true</span>) &#123;</div><div class="line">            <span class="comment">// 定义put后的移除规则，大于容量就删除eldest</span></div><div class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;Integer, Integer&gt; eldest)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> size() &gt; capacity;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (cache.containsKey(key)) &#123;</div><div class="line">            <span class="keyword">return</span> cache.get(key);</div><div class="line">        &#125; <span class="keyword">else</span></div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</div><div class="line">        cache.put(key, value);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[spring-rabbit配置多connect-factory]]></title>
      <url>http://zsr.github.io/2017/04/12/spring-rabbit%E9%85%8D%E7%BD%AE%E5%A4%9Aconnect-factory/</url>
      <content type="html"><![CDATA[<p><strong>多connect-factory时配置exchange， queue需使用declared-by</strong></p>
<h3 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h3><p>项目中需要监听多个<code>rabbitmq</code>服务器或者发消息到多个<code>rabbitmq</code>服务器，项目启动报错。结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Caused by: com.rabbitmq.client.ShutdownSignalException: channel error; protocol method: #method&lt;channel.close&gt;(reply-code=406, reply-text=PRECONDITION_FAILED - cannot redeclare exchange &apos;lamia.live.start&apos; in vhost &apos;/&apos; with different type, durable, internal or autodelete value, class-id=40, method-id=10)</div><div class="line">at com.rabbitmq.client.impl.ChannelN.asyncShutdown(ChannelN.java:478)</div><div class="line">at com.rabbitmq.client.impl.ChannelN.processAsync(ChannelN.java:315)</div><div class="line">at com.rabbitmq.client.impl.AMQChannel.handleCompleteInboundCommand(AMQChannel.java:144)</div><div class="line">at com.rabbitmq.client.impl.AMQChannel.handleFrame(AMQChannel.java:91)</div><div class="line">at com.rabbitmq.client.impl.AMQConnection$MainLoop.run(AMQConnection.java:550)</div><div class="line">... 1 more</div></pre></td></tr></table></figure>
<p>问题原因：从错误来看，大概意思是重复声明了“exchange”。研究了下spring-rabbit中“exchange”的配置。</p>
<h3 id="基本信息："><a href="#基本信息：" class="headerlink" title="基本信息："></a>基本信息：</h3><p><code>Broker</code>：简单来说就是消息队列服务器实体，可以把一个rabbitmq server当作一个broker。</p>
<p><code>vhost</code>虚拟主机：一个broker里可以开设多个vhost，用作不同用户的权限分离，也可以把他看作明名空间。vhost之间相互完全隔离，不同Vhost之间无法共享Exchange和Queue。(如果不指定vhost,默认是”/“)</p>
<p><code>Exchange</code>：Exchange是属于Vhost的。同一个vhost不能有重复的Exchange名称(这个就是错误原因)。</p>
<p><code>Channel</code>：消息通道，在客户端的每个连接里，可建立多个channel，每个channel代表一个会话任务。</p>
<a id="more"></a>
<h3 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a>项目配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 声明消息转换器为SimpleMessageConverter --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"messageConverter"</span></span></div><div class="line">        <span class="attr">class</span>=<span class="string">"org.springframework.amqp.support.converter.SimpleMessageConverter"</span>&gt;</div><div class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </div><div class="line"></div><div class="line">  <span class="comment">&lt;!-- 2) 推送APN --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">rabbit:connection-factory</span> <span class="attr">id</span>=<span class="string">"notificationConnectionFactory"</span></span></div><div class="line">                           <span class="attr">host</span>=<span class="string">"$&#123;push.apn.rabbit.connect.host&#125;"</span> </div><div class="line">                           <span class="attr">port</span>=<span class="string">"$&#123;push.apn.rabbit.connect.port&#125;"</span></div><div class="line">                           <span class="attr">username</span>=<span class="string">"$&#123;push.apn.rabbit.connect.username&#125;"</span> </div><div class="line">                           <span class="attr">password</span>=<span class="string">"$&#123;push.apn.rabbit.connect.password&#125;"</span></div><div class="line">                           <span class="attr">channel-cache-size</span>=<span class="string">"$&#123;push.apn.rabbitmq.connect.channelCacheSize&#125;"</span> /&gt;</div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">rabbit:admin</span> <span class="attr">id</span>=<span class="string">"notificationRabbitAdmin"</span> </span></div><div class="line">                <span class="attr">connection-factory</span>=<span class="string">"notificationConnectionFactory"</span> /&gt;</div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">rabbit:template</span> <span class="attr">id</span>=<span class="string">"notificationRabbitTemplate"</span></span></div><div class="line">                   <span class="attr">connection-factory</span>=<span class="string">"notificationConnectionFactory"</span> </div><div class="line">                   <span class="attr">exchange</span>=<span class="string">"$&#123;pns-push.notification.topic&#125;"</span> /&gt;</div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">rabbit:template</span> <span class="attr">id</span>=<span class="string">"clockedNotificationRabbitTemplate"</span></span></div><div class="line">                   <span class="attr">connection-factory</span>=<span class="string">"notificationConnectionFactory"</span> </div><div class="line">                   <span class="attr">routing-key</span>=<span class="string">"$&#123;pns-push.clockedMsg.queue&#125;"</span> /&gt;</div><div class="line"></div><div class="line">  <span class="comment">&lt;!-- 3) 推送微信服务号 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">rabbit:connection-factory</span> <span class="attr">id</span>=<span class="string">"wechatConnectionFactory"</span></span></div><div class="line">                           <span class="attr">host</span>=<span class="string">"$&#123;push.wx.rabbit.connect.host&#125;"</span> </div><div class="line">                           <span class="attr">port</span>=<span class="string">"$&#123;push.wx.rabbit.connect.port&#125;"</span></div><div class="line">                           <span class="attr">username</span>=<span class="string">"$&#123;push.wx.rabbit.connect.username&#125;"</span> </div><div class="line">                           <span class="attr">password</span>=<span class="string">"$&#123;push.wx.rabbit.connect.password&#125;"</span> /&gt;</div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">rabbit:template</span> <span class="attr">id</span>=<span class="string">"wechatRabbitTemplate"</span></span></div><div class="line">                   <span class="attr">connection-factory</span>=<span class="string">"wechatConnectionFactory"</span> /&gt;</div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">rabbit:admin</span> <span class="attr">id</span>=<span class="string">"wechatRabbitAdmin"</span> <span class="attr">connection-factory</span>=<span class="string">"wechatConnectionFactory"</span> /&gt;</span></div><div class="line"></div><div class="line">  <span class="comment">&lt;!-- 微信 推送预约提醒topic --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">rabbit:topic-exchange</span> <span class="attr">name</span>=<span class="string">"lamia.live.start"</span> <span class="attr">durable</span>=<span class="string">"true"</span> /&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li><code>rabbit:connection-factory</code></li>
</ul>
<p>在<code>spring-rabbit</code>中，管理消息协商器(broker)连接的核心组件是<code>ConnectionFactory</code>这个接口。 <code>ConnectionFactory</code>提供了 <code>org.springframework.amqp.rabbit.connection.Connection</code>(<code>com.rabbitmq.client.Connection</code>的包装类)实例的连接与管理。</p>
<p><code>CachingConnectionFactory</code>：是<code>ConnectionFactory</code>的在Spring AMQP中唯一实现，它创建一个连接代理，使程序可以共享连接。</p>
<p><code>Connection</code> 提供一个<code>createChannel</code>的方法。<code>CachingConnectionFactory</code> 的实现能支持<code>channels</code>的缓存,并且能根据区分是事务性或非事务性各自独立。同时，<code>CachingConnectionFactory</code>也提供<code>hostname</code>的构造函数，并且可以设置<code>username</code>、<code>password</code>、<code>setChannelCacheSize</code>等方法。<code>CachingConnectionFactory</code>  默认<code>channel cache</code> 大小为1，如果想改变可以用<code>setChannelCacheSize</code>设置 <code>channel-cache-size</code>的大小。</p>
<ul>
<li><code>rabbit:template</code></li>
</ul>
<p>Spring AMQP提供了一个发送和接收消息的操作模板类<code>AmqpTemplate</code>。 AmqpTemplate它定义包含了发送和接收消息等的一些基本的操作功能。<code>RabbitTemplate</code>是AmqpTemplate的一个实现。</p>
<p><code>RabbitTemplate</code>支持消息的确认与返回，为了返回消息，<code>RabbitTemplate</code> 需要设置<code>mandatory</code> 属性为true,并且<code>CachingConnectionFactory</code> 的<code>publisherReturns</code>属性也需要设置为true。返回的消息会根据它注册的<code>RabbitTemplate.ReturnCallback setReturnCallback</code> 回调发送到给客户端，一个<code>RabbitTemplate</code>仅能支持一个<code>ReturnCallback</code>。</p>
<p>为了确认Confirms消息, <code>CachingConnectionFactory</code> 的<code>publisherConfirms</code> 属性也需要设置为true，确认的消息会根据它注册的<code>RabbitTemplate.ConfirmCallback setConfirmCallback</code>回调发送到给客户端。一个<code>RabbitTemplate</code>也仅能支持一个<code>ConfirmCallback</code>.</p>
<ul>
<li><code>messageConverter</code></li>
</ul>
<p>AmqpTemplate 定义提供了各种发送和接收委拖给<code>MessageConverter</code>转化对象消息的方法。<code>MessageConverter</code> 本身比较简单，它提供了消息对象的转化,可将object转化成Message 对象，或者将Message 对象转化成Object对象。它提供了默认的<code>SimpleMessageConverter</code>实现，以及第三方的<code>MessageConverter</code>，如<code>Jackson2JsonMessageConverter</code>，<code>MarshallingMessageConverter</code>等，来处理消息与对象之间的转换。</p>
<ul>
<li><code>rabbit:admin</code></li>
</ul>
<p>当<code>CachingConnectionFactory</code> 缓存模式是<code>CHANNEL</code> 时(默认的),  <code>RabbitAdmin</code> 实现会在同一个<code>ApplicationContext</code>中自动延迟声明 <code>Queues</code>,<code>Exchanges</code> 和 <code>Bindings</code>.</p>
<p>默认情况下，所有<code>queues</code>, <code>exchanges</code>,和<code>bindings</code> 都可通过应用程序上下文中所有<code>RabbitAdmin</code> 实例来声明(设置了<code>auto-startup=&quot;true&quot;</code>).</p>
<p>从１.２版本开始，可以有条件地声明元素.当程序连接了多个<code>brokers</code>，并需要在哪些<code>brokers</code>上声明特定元素时，特别有用．</p>
<p>默认情况下，如果没有提供<code>declared-by</code>(或是空的)， <code>auto-declare</code> 属性则为true，那么所有<code>RabbitAdmin</code>将声明对象(只要admin的<code>auto-startup</code> 属性为true，默认值)</p>
<p>错误原因：在这个例子中<code>RabbitAdmin有2个，并且</code>exchange<code>‘lamia.live.start&#39; 没有提供</code>declared-by<code>声明。故此，该</code>exchange<code>被这2个</code>RabbitAdmin<code>都声明了一次。而且刚好这2个RabbitAdmin使用的是同一个服务器上面的同一个</code>vhost<code>. 同一个</code>vhost<code>不能有重复的</code>Exchange`名称。所以，项目启动报错。</p>
<h3 id="正确姿势"><a href="#正确姿势" class="headerlink" title="正确姿势"></a>正确姿势</h3><p>在<code>exchange</code>和<code>queue</code>上面加上<code>declared-by</code>.</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 2) 推送APN --&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">rabbit:connection-factory</span> <span class="attr">id</span>=<span class="string">"notificationConnectionFactory"</span></span></div><div class="line">		                       <span class="attr">host</span>=<span class="string">"$&#123;push.apn.rabbit.connect.host&#125;"</span> </div><div class="line">		                       <span class="attr">port</span>=<span class="string">"$&#123;push.apn.rabbit.connect.port&#125;"</span></div><div class="line">		                       <span class="attr">username</span>=<span class="string">"$&#123;push.apn.rabbit.connect.username&#125;"</span> </div><div class="line">		                       <span class="attr">password</span>=<span class="string">"$&#123;push.apn.rabbit.connect.password&#125;"</span></div><div class="line">		                       <span class="attr">channel-cache-size</span>=<span class="string">"$&#123;push.apn.rabbitmq.connect.channelCacheSize&#125;"</span> /&gt;</div><div class="line"></div><div class="line">	<span class="tag">&lt;<span class="name">rabbit:admin</span> <span class="attr">id</span>=<span class="string">"notificationRabbitAdmin"</span></span></div><div class="line">		<span class="attr">connection-factory</span>=<span class="string">"notificationConnectionFactory"</span> /&gt;</div><div class="line"></div><div class="line">	<span class="tag">&lt;<span class="name">rabbit:template</span> <span class="attr">id</span>=<span class="string">"notificationRabbitTemplate"</span></span></div><div class="line">		<span class="attr">connection-factory</span>=<span class="string">"notificationConnectionFactory"</span> <span class="attr">exchange</span>=<span class="string">"$&#123;pns-push.notification.topic&#125;"</span> /&gt;</div><div class="line"></div><div class="line">	<span class="tag">&lt;<span class="name">rabbit:template</span> <span class="attr">id</span>=<span class="string">"clockedNotificationRabbitTemplate"</span></span></div><div class="line">		<span class="attr">connection-factory</span>=<span class="string">"notificationConnectionFactory"</span> <span class="attr">routing-key</span>=<span class="string">"$&#123;pns-push.clockedMsg.queue&#125;"</span> /&gt;</div><div class="line">	</div><div class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"produceService"</span> <span class="attr">class</span>=<span class="string">"com.ximalaya.pns.device.service.impl.ProduceService"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line">	<span class="comment">&lt;!-- 3) 推送微信服务号 --&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">rabbit:connection-factory</span> <span class="attr">id</span>=<span class="string">"wechatConnectionFactory"</span></span></div><div class="line">		                       <span class="attr">host</span>=<span class="string">"$&#123;push.wx.rabbit.connect.host&#125;"</span> </div><div class="line">		                       <span class="attr">port</span>=<span class="string">"$&#123;push.wx.rabbit.connect.port&#125;"</span></div><div class="line">		                       <span class="attr">username</span>=<span class="string">"$&#123;push.wx.rabbit.connect.username&#125;"</span> </div><div class="line">		                       <span class="attr">password</span>=<span class="string">"$&#123;push.wx.rabbit.connect.password&#125;"</span> /&gt;</div><div class="line"></div><div class="line">	<span class="tag">&lt;<span class="name">rabbit:template</span> <span class="attr">id</span>=<span class="string">"wechatRabbitTemplate"</span></span></div><div class="line">		<span class="attr">connection-factory</span>=<span class="string">"wechatConnectionFactory"</span> /&gt;</div><div class="line"></div><div class="line">	<span class="tag">&lt;<span class="name">rabbit:admin</span> <span class="attr">id</span>=<span class="string">"wechatRabbitAdmin"</span> <span class="attr">connection-factory</span>=<span class="string">"wechatConnectionFactory"</span> /&gt;</span></div><div class="line"></div><div class="line">	<span class="comment">&lt;!-- 微信 推送预约提醒topic --&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">rabbit:topic-exchange</span> <span class="attr">name</span>=<span class="string">"$&#123;push.wx.live.start.topic&#125;"</span> <span class="attr">durable</span>=<span class="string">"true"</span> <span class="attr">declared-by</span>=<span class="string">"wechatRabbitAdmin"</span> /&gt;</span></div></pre></td></tr></table></figure>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://o-u-u.com/?p=1535" target="_blank" rel="external">spring-rabbit配置多vhost，多connect-factory</a></p>
<p>[<a href="http://www.cnblogs.com/wade-luffy/p/6004219.html" target="_blank" rel="external">Spring AMQP</a>]</p>
<p><a href="http://www.blogjava.net/qbna350816/archive/2016/08/13/431561.html" target="_blank" rel="external">Spring AMQP 1.6完整参考指南-第二部分</a></p>
<p><a href="http://www.blogjava.net/qbna350816/archive/2016/08/13/431567.html" target="_blank" rel="external">Spring AMQP 1.6完整参考指南-第六部分</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Binlog]]></title>
      <url>http://zsr.github.io/2017/03/28/Binlog/</url>
      <content type="html"><![CDATA[<h3 id="什么是-Binlog"><a href="#什么是-Binlog" class="headerlink" title="什么是 Binlog"></a>什么是 Binlog</h3><p><code>MySQL Server</code>有四种类型的日志——<code>Error Log</code>、<code>General Query Log</code>、<code>Binary Log</code> 和 <code>Slow Query Log</code>。</p>
<p>　　第一个是错误日志，记录 <code>mysqld</code> (<code>mysql daemon</code>)的一些错误。第二个是一般查询日志，记录 <code>mysqld</code> 正在做的事情，比如客户端的连接和断开、来自客户端每条 <code>Sql Statement</code> 记录信息；如果你想知道客户端到底传了什么给服务端，这个日志就非常管用了，不过它非常影响性能。第四个是慢查询日志，记录一些查询比较慢的 <code>SQL</code> 语句——这种日志非常常用，主要是给开发者调优用的。</p>
<p>　　第三种就是 <code>Binlog</code> 了，<code>binlog</code>是mysql的二进制日志，包含了一些事件，这些事件描述了数据库的改动，如建表、数据改动等，也包括一些潜在改动，比如 <code>DELETE FROM ran WHERE bing = luan</code>，然而一条数据都没被删掉的这种情况。除非使用 <code>Row-based logging</code>，否则会包含所有改动数据的 <code>SQL Statement</code>。</p>
<p>注意：<code>binlog</code>主要有<code>statement-based</code>、<code>row-based logging</code>和<code>mixed logging</code> 三种格式，<code>row-based</code>的记录中不包括潜在更新记录。</p>
<p>　　 <code>Binlog</code> 有两个重要的用途——复制和恢复。比如主从表的复制，和备份恢复。</p>
<p>注：<code>mysqld</code>是<code>MySQL</code>服务器的守护进程。</p>
<h3 id="binlog格式"><a href="#binlog格式" class="headerlink" title="binlog格式"></a>binlog格式</h3><p>可以指定三种binary log的格式(启动时指定)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">--binlog-format=STATEMENT</div><div class="line">--binlog-format=ROW</div><div class="line">--binlog-format=MIXED</div></pre></td></tr></table></figure>
<ul>
<li><code>statement-based logging</code>： 基于SQL语句，Mysql5.6默认，某些语句和函数如UUID, LOAD DATA INFILE等在复制过程可能导致数据不一致甚至出错。</li>
<li><code>row-based logging</code>：基于行，记录影响table中每一行的事务，很安全。所以一条语句可能会对应0-N个事件，记录很详细，数据同步的支持比<code>STATEMENT</code>方式要好。但是<code>binlog</code>会比其他两种模式大很多，在一些大表中清除大量数据时在<code>binlog</code>中会生成很多条语句，可能导致从库延迟变大。</li>
<li><code>mixed logging</code>：使用<code>statement-based logging</code>作为默认，但是日志模式可能会在某些情况下自动切换到<code>row-based logging</code>。</li>
</ul>
<a id="more"></a>
<h3 id="启用-Binlog"><a href="#启用-Binlog" class="headerlink" title="启用 Binlog"></a>启用 Binlog</h3><p>通常情况 <code>MySQL</code> 是默认关闭 <code>Binlog</code> 的，需要在<code>my.cnf</code>中手动配置启用它。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># log-bin 是指以后生成各 Binlog 文件的前缀，比如上述使用 master-bin，那么文件就将会是 </div><div class="line"># master-bin.000001、master-bin.000002 等</div><div class="line">log-bin=master-bin</div><div class="line"></div><div class="line"># log-bin-index 则指 binlog index 文件的名称，这里我们设置为 master-bin.index。</div><div class="line">log-bin-index=master-bin.index</div></pre></td></tr></table></figure>
<p>启动<code>MySQL</code>服务</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># mysqld_safe是一个启动脚本，该脚本会调用mysqld启动，如果启动出错，会将错误信息记录到错误日志中</span></div><div class="line">$ ./mysqld_safe &amp;</div><div class="line"><span class="comment"># 符号“&amp;”表示在后台启动</span></div></pre></td></tr></table></figure>
<p>启动<code>MySQL</code>客户端</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mysql -u <span class="variable">$USERNAME</span> -p <span class="variable">$PASSWORD</span></div></pre></td></tr></table></figure>
<p>在客户端终端里面输入下面一句 <code>SQL</code>语句：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ SHOW VARIABLES LIKE <span class="string">'%log_bin%'</span>;</div></pre></td></tr></table></figure>
<p>显示结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">+---------------------------------+---------------------------------------+</div><div class="line">| Variable_name                   | Value                                 |</div><div class="line">+---------------------------------+---------------------------------------+</div><div class="line">| <span class="built_in">log</span>_bin                         | ON                                    |</div><div class="line">| <span class="built_in">log</span>_bin_basename                | /usr/<span class="built_in">local</span>/var/mysql/master-bin       |</div><div class="line">| <span class="built_in">log</span>_bin_index                   | /usr/<span class="built_in">local</span>/var/mysql/master-bin.index |</div><div class="line">| <span class="built_in">log</span>_bin_trust_<span class="keyword">function</span>_creators | OFF                                   |</div><div class="line">| <span class="built_in">log</span>_bin_use_v1_row_events       | OFF                                   |</div><div class="line">| sql_<span class="built_in">log</span>_bin                     | ON                                    |</div><div class="line">+---------------------------------+---------------------------------------+</div><div class="line">6 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</div></pre></td></tr></table></figure>
<h3 id="结构解析"><a href="#结构解析" class="headerlink" title="结构解析"></a>结构解析</h3><h4 id="索引文件"><a href="#索引文件" class="headerlink" title="索引文件"></a>索引文件</h4><p>　　索引文件就是 <code>master-bin.index</code> 文件，是一个普通的文本文件，以换行为间隔，一行一个文件名。比如它可能是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">master-bin.000001</div><div class="line">master-bin.000002</div><div class="line">master-bin.000003</div></pre></td></tr></table></figure>
<p>　　然后对应的每行文件就是一个 <code>Binlog</code>实体文件了。</p>
<h4 id="Binlog-文件"><a href="#Binlog-文件" class="headerlink" title="Binlog 文件"></a>Binlog 文件</h4><p>　　<code>Binlog</code> 的文件结构大致由如下几个方面组成。</p>
<h4 id="文件头"><a href="#文件头" class="headerlink" title="文件头"></a>文件头</h4><p>　　文件头由一个四字节 <code>Magic Number</code>，其值为 <code>1852400382</code>，在内存中就是 <code>&quot;\xfe\x62\x69\x6e&quot;</code>.</p>
<p>　　与平常二进制一样，通常都有一个 <code>Magic Number</code> 进行文件识别，如果 <code>Magic Number</code>不吻合上述的值那么这个文件就不是一个正常的 <code>Binlog</code>。</p>
<h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p>　　在文件头之后，跟随的是一个个事件依次排列。每个事件都由一个事件头和事件体组成。</p>
<p>　　事件头里面的内容包含了这个事件的类型（如新增、删除等）、事件执行时间以及是哪个服务器执行的事件等信息。</p>
<p>　　第一个事件是一个事件描述符，描述了这个 <code>Binlog</code> 文件格式的版本。接下去的一堆事件将会按照第一个事件描述符所描述的结构版本进行解读。最后一个事件是一个衔接事件，指定了下一个 <code>Binlog</code> 文件名——有点类似于链表里面的 <code>next</code> 指针。</p>
<h5 id="事件头"><a href="#事件头" class="headerlink" title="事件头"></a>事件头</h5><p>　　一个事件头有 19 字节，依次排列为四字节的时间戳、一字节的当前事件类型、四字节的服务端 ID、四字节的当前事件长度描述、四字节的下个事件位置（方便跳转）以及两字节的标识。</p>
<p><code>Header</code>的格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">|---------|---------|--------|-----------|----------------------|-----|</div><div class="line">|  4byte  |  1byte  | 4byte  |   4byte   |         4byte        |2byte|</div><div class="line">|timestamp|EventType|serverId|data-length|nextEventStartPosition|flag |</div></pre></td></tr></table></figure>
<h5 id="事件体"><a href="#事件体" class="headerlink" title="事件体"></a>事件体</h5><p>　　事实上在 <code>Binlog</code> 事件中应该是有三个部分组成，<code>header</code>、<code>post-header</code> 和 <code>payload</code>，不过通常情况下我们把 <code>post-header</code> 和 <code>payload</code> 都归结为事件体，实际上这个 <code>post-header</code> 里面放的是一些定长的数据.</p>
<p>实际上一个真正的事件体由两部分组成:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">+=====================================+</div><div class="line">| event  | fixed part (post-header)   |</div><div class="line">| data   +----------------------------+</div><div class="line">|        | variable part (payload)    |</div><div class="line">+=====================================+</div></pre></td></tr></table></figure>
<p>而这个 <code>post-header</code> 对于不同类型的事件来说长度是不一样的，同种类型来说是一样的，而这个长度的预先规定将会在一个“格式描述事件”中定好。</p>
<ul>
<li><a href="https://github.com/shyiko/mysql-binlog-connector-java/blob/master/src/main/java/com/github/shyiko/mysql/binlog/event/deserialization/QueryEventDataDeserializer.java" target="_blank" rel="external">QUERY</a></li>
</ul>
<p>标识更新操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">|------------------post-header------------------|--------payload------ --|</div><div class="line">|--------|-------------|-------------|----------|-------|---------------|--------|</div><div class="line">|  4byte |    4byte    |    1byte    |   2byte  | 2byte |     nbyte     |  nbyte |</div><div class="line">|ThreadId|ExecutionTime|DbNameLength |error code| status|    database   |   Sql  |</div></pre></td></tr></table></figure>
<ul>
<li><a href="https://github.com/shyiko/mysql-binlog-connector-java/blob/master/src/main/java/com/github/shyiko/mysql/binlog/event/deserialization/WriteRowsEventDataDeserializer.java" target="_blank" rel="external">WRITE_ROWS_EVENT</a></li>
</ul>
<p>标识写入操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">|---post-header--|---------payload------------|</div><div class="line">|-------|--------|---- --|--- ---|------------|</div><div class="line">| 6byte | 2byte  | byte  | nbyte |   nbyte    |</div><div class="line">|tableId|Reserved|col_num|map_col|insert_value|</div></pre></td></tr></table></figure>
<p><code>col_num</code>:  代表字段的个数占用字节数是可变的，一般一字节就够了，1字节/2的八次方 一般也很难有表有几百个字段</p>
<p><code>map_col</code>: 这个代表字段是否为空,每一位映射一个列，描述是否被使用， N列的对应的size=int((N+7)/8)bytes</p>
<p><code>insert_value</code>：这个就是具体的记录内容。</p>
<ul>
<li><a href="https://github.com/shyiko/mysql-binlog-connector-java/blob/master/src/main/java/com/github/shyiko/mysql/binlog/event/deserialization/RotateEventDataDeserializer.java" target="_blank" rel="external">ROTATE</a></li>
</ul>
<p>标识binlog文件结束，以及新的binlog文件的名称和位置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">|---post-header--|-----payload-----|</div><div class="line">|----------------|-----------------|</div><div class="line">|      8byte     |      nbyte      |</div><div class="line">| BinlogPosition | BinlogFilename  |</div></pre></td></tr></table></figure>
<h5 id="格式描述事件"><a href="#格式描述事件" class="headerlink" title="格式描述事件"></a>格式描述事件</h5><p>​       在 <code>Magic Number</code> 之后跟着的是一个格式描述事件，其实这只是在 v4 版本中的称呼，在以前的版本里面叫起始事件。</p>
<ul>
<li>v1，用于 MySQL 3.2.3</li>
<li>v3，用于 MySQL 4.0.2 以及 4.1.0</li>
<li>v4，用于 MySQL 5.0 以及更高版本</li>
</ul>
<p>在 v4 版本中这个事件的结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">+=====================================+</div><div class="line">| event  | timestamp         0 : 4    |</div><div class="line">| header +----------------------------+</div><div class="line">|        | type_code         4 : 1    | = FORMAT_DESCRIPTION_EVENT = 15</div><div class="line">|        +----------------------------+</div><div class="line">|        | server_id         5 : 4    |</div><div class="line">|        +----------------------------+</div><div class="line">|        | event_length      9 : 4    | &gt;= 91</div><div class="line">|        +----------------------------+</div><div class="line">|        | next_position    13 : 4    |</div><div class="line">|        +----------------------------+</div><div class="line">|        | flags            17 : 2    |</div><div class="line">+=====================================+</div><div class="line">| event  | binlog_version   19 : 2    | = 4</div><div class="line">| data   +----------------------------+</div><div class="line">|        | server_version   21 : 50   |</div><div class="line">|        +----------------------------+</div><div class="line">|        | create_timestamp 71 : 4    |</div><div class="line">|        +----------------------------+</div><div class="line">|        | header_length    75 : 1    |</div><div class="line">|        +----------------------------+</div><div class="line">|        | post-header      76 : n    | = array of n bytes, one byte per event</div><div class="line">|        | lengths for all            |   type that the server knows about</div><div class="line">|        | event types                |</div><div class="line">+=====================================+</div></pre></td></tr></table></figure>
<p>　这个事件的 <code>type_code</code> 是 15，然后 <code>event_length</code> 是大于等于 91 的值的，这个主要取决于所有事件类型数。</p>
<p>　　因为从第 76 字节开始后面的二进制就代表一个字节类型的数组了，一个字节代表一个事件类型的 <code>post-header</code> 长度，即每个事件类型固定数据的长度。</p>
<h5 id="校验和"><a href="#校验和" class="headerlink" title="校验和"></a>校验和</h5><p>​       从5.6开始，如果服务器设置产生检验和的前提，事件末尾就多一个检验和字段，是一个32位整型数，用来检查时间写入后是否有损坏</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://blog.csdn.net/jolly10/article/details/13998761" target="_blank" rel="external">mysql的binlog初探</a></p>
<p><a href="https://github.com/jaywcjlove/mysql-tutorial/blob/master/chapter2/2.3.md" target="_blank" rel="external">启动服务并登录MySQL数据库</a></p>
<p><a href="http://blog.csdn.net/kang_nian/article/details/12954547" target="_blank" rel="external">Linux系统下MySQL的启动方式</a></p>
<p><a href="https://dev.mysql.com/doc/internals/en/event-data-for-specific-event-types.html" target="_blank" rel="external">binlog 事件体</a></p>
<p><a href="http://blog.chinaunix.net/attachment/attach/25/95/31/492595314929396a8f65b2a242d02be206411d0d92.txt" target="_blank" rel="external">binlog 结构详解</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CopyOnWriteArrayList设计原理]]></title>
      <url>http://zsr.github.io/2017/03/15/CopyOnWriteArrayList%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<p>转载：<a href="http://xiajunhust.github.io/2016/08/06/CopyOnWriteArrayList%E4%B8%8EJMM/" target="_blank" rel="external">CopyOnWriteArrayList与JMM</a></p>
<h3 id="1-什么是CopyOnWriteArrayList"><a href="#1-什么是CopyOnWriteArrayList" class="headerlink" title="1 什么是CopyOnWriteArrayList"></a>1 什么是CopyOnWriteArrayList</h3><p><code>CopyOnWriteArrayList</code>相当于线程安全的<code>ArrayList</code>，是一个可变数组。它具有如下特性：</p>
<ul>
<li>是线程安全的</li>
<li>写操作会复制整个基础数组，因此写操作开销很大</li>
<li>适用于如下情况：数组大小较小，并且读操作比写操作多很多的情形</li>
</ul>
<h3 id="2-CopyOnWriteArrayList的设计原理与JMM"><a href="#2-CopyOnWriteArrayList的设计原理与JMM" class="headerlink" title="2 CopyOnWriteArrayList的设计原理与JMM"></a>2 CopyOnWriteArrayList的设计原理与JMM</h3><p>下面分析CopyOnWriteArrayList的设计原理，结合JMM的基础知识，分析CopyOnWriteArrayList是如何保证线程安全的。</p>
<p>首先看用来实际保存数据的数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** The array, accessed only via getArray/setArray. */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</div></pre></td></tr></table></figure>
<p>可以看到array数组前面使用了volatile变量来修饰。volatile主要用来解决内存可见性问题。关于volatile的详细实现原理可以参考《<a href="http://o8sltkx20.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.pdf" target="_blank" rel="external">深入理解java内存模型.pdf</a>》以及<a href="http://www.cnblogs.com/dolphin0520/p/3920373.html" target="_blank" rel="external">Java并发编程：volatile关键字解析-博客园-海子</a>。</p>
<h4 id="2-1-CopyOnWriteArrayList的读方法"><a href="#2-1-CopyOnWriteArrayList的读方法" class="headerlink" title="2.1 CopyOnWriteArrayList的读方法"></a>2.1 CopyOnWriteArrayList的读方法</h4><p>读方法比较简单，直接从array中获取对应索引的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* &#123;<span class="doctag">@inheritDoc</span>&#125;</div><div class="line">*</div><div class="line">* <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</div><div class="line"></div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> get(getArray(), index);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line"><span class="function"><span class="keyword">private</span> E <span class="title">get</span><span class="params">(Object[] a, <span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> (E) a[index];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* Gets the array. Non-private so as to also be accessible</div><div class="line">* from CopyOnWriteArraySet class.</div><div class="line">*/</div><div class="line"><span class="keyword">final</span> Object[] getArray() &#123;</div><div class="line"><span class="keyword">return</span> array;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-2-CopyOnWriteArrayList的写方法"><a href="#2-2-CopyOnWriteArrayList的写方法" class="headerlink" title="2.2 CopyOnWriteArrayList的写方法"></a>2.2 CopyOnWriteArrayList的写方法</h4><ul>
<li><strong>set方法</strong><br>​</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Replaces the element at the specified position in this list with the</div><div class="line"> * specified element.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</div><div class="line">    lock.lock();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        Object[] elements = getArray();</div><div class="line">        E oldValue = get(elements, index);</div><div class="line">        <span class="keyword">if</span> (oldValue != element) &#123;</div><div class="line">            <span class="keyword">int</span> len = elements.length;</div><div class="line">            Object[] newElements = Arrays.copyOf(elements, len);</div><div class="line">            newElements[index] = element;</div><div class="line">            setArray(newElements);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// Not quite a no-op; ensures volatile write semantics</span></div><div class="line">            setArray(elements);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> oldValue;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        lock.unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * Sets the array.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(Object[] a)</span> </span>&#123;</div><div class="line">    array = a;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>set方法的功能是将对应索引的元素置为一个新值。执行流程：<br>（1）加锁<br>（2）获取对应索引已有的值<br>（3）比较已有的值和新值，如果不相等，转4，否则转5<br>（4）创建新的数组，复制原数组的元素，并将对应索引置为新值。然后将新数组赋给array（setArray）<br>（5）setArray:将array赋给array</p>
<p>这里有一个比较奇怪的点，为什么已有的值和新值相等的时候，还要执行setArray呢？本质上setArray也没有做什么事情。</p>
<p><strong>这段代码混合使用了锁以及volatile。锁的用法比较容易理解，它在使用同一个锁的不同线程之间保证内存顺序性，代码结尾的释放锁的操作提供了本线程和其他欲获取相同的锁的线程之间的happens-before语义。但是CopyOnWriteArrayList类中其他代码，不一定会使用到这把锁，因此，前面所述的锁带来的内存模型含义对这部分代码执行是不适用的。其他没用到这把锁的代码，读写是volatile读和volatile写（因为array前面使用volatile关键字修饰）。由volatile来保证happens-before语义。</strong></p>
<hr>
<p><strong>volatile的特性及原理</strong></p>
<p>volatile 变量自身具有下列特性:<br>（1）可见性。对一个volatile 变量的读,总是能看到(任意线程)对这个volatile变量最后的写入。<br>（2）原子性:对任意单个volatile 变量的读/写具有原子性,但类似于volatile++这种复合操作不具有原子性。</p>
<p>volatile 写和锁的释放有相同的内存语义。</p>
<p>为了实现 volatile 的内存语义,编译器在生成字节码时,会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。</p>
<hr>
<p>这里调用setArray的原因是，确保set方法对array执行的永远是volatile写。这就和其他对array执行volatile读的线程之间建立了happens-before语义。非常重要的一点：<strong>volatile读/写语义针对的是读写操作，而不是使用volatile修饰的变量本身。</strong>这样说更直白一点：在一个volatile写操作之前的对其他非volatile变量的写，happens-before于同一个volatile变量读操作之后的对其他变量的读。这句话比较绕，看下面一个例子就比较易懂了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// initial conditions</span></div><div class="line"><span class="keyword">int</span> nonVolatileField = <span class="number">0</span>;</div><div class="line">CopyOnWriteArrayList&lt;String&gt; list = <span class="comment">/* a single String */</span></div><div class="line"><span class="comment">// Thread 1</span></div><div class="line">nonVolatileField = <span class="number">1</span>;                 <span class="comment">// (1)</span></div><div class="line">list.set(<span class="number">0</span>, <span class="string">"x"</span>);                     <span class="comment">// (2)</span></div><div class="line"><span class="comment">// Thread 2</span></div><div class="line">String s = list.get(<span class="number">0</span>);               <span class="comment">// (3)</span></div><div class="line"><span class="keyword">if</span> (s == <span class="string">"x"</span>) &#123;</div><div class="line">    <span class="keyword">int</span> localVar = nonVolatileField;  <span class="comment">// (4)</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在假设原始数组中无元素“x”，这样(2)成功设置了元素”x”，(3)处可以成功获取到元素”x”。这种情况下，(4)一定会读取到(1)处设置的值1.因为(2)处的volatile写以及在此之前的任何写操作都happens-before(3)处的读以及之后的所有读。</p>
<p>但是，假设一开始数组中就有了元素”x”，如果else不调用setArray，那么(2)处的写就不是volatile写，(4)处的读就不一定能读到(1)处设置的值！</p>
<p>很显然我们不想让内存可见性依赖于list中已有的值，为了确保任何情况下的内存可见性，set方法必须永远都是一个volatile写，这就是为何要在else代码块中调用setArray的原因。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[mysql优化]]></title>
      <url>http://zsr.github.io/2017/03/07/mysql%E4%BC%98%E5%8C%96/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[Thread中start()和run()的区别]]></title>
      <url>http://zsr.github.io/2017/03/03/Thread%E4%B8%ADstart-%E5%92%8Crun-%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<h3 id="start-和-run-的区别示例"><a href="#start-和-run-的区别示例" class="headerlink" title="start() 和 run()的区别示例"></a>start() 和 run()的区别示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 最常见的两种方法启动新的线程</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startThread</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 1) 覆盖 run 方法</span></div><div class="line">    <span class="keyword">new</span> Thread() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="comment">// 耗时操作</span></div><div class="line">        &#125;</div><div class="line">    &#125;.start();</div><div class="line"></div><div class="line">    <span class="comment">// 2) 传入 Runnable 对象</span></div><div class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="comment">// 耗时操作</span></div><div class="line">        &#125;</div><div class="line">    &#125;).start();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="start-和-run-相关源码"><a href="#start-和-run-相关源码" class="headerlink" title="start() 和 run()相关源码"></a>start() 和 run()相关源码</h3><p>Thread.java中start()方法的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 如果线程不是"就绪状态"，则抛出异常！</span></div><div class="line">    <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</div><div class="line"></div><div class="line">    <span class="comment">// 将线程添加到ThreadGroup中</span></div><div class="line">    group.add(<span class="keyword">this</span>);</div><div class="line"></div><div class="line">    <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// 通过start0()启动线程</span></div><div class="line">        start0();</div><div class="line">        <span class="comment">// 设置started标记</span></div><div class="line">        started = <span class="keyword">true</span>;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">if</span> (!started) &#123;</div><div class="line">                group.threadStartFailed(<span class="keyword">this</span>);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>说明：start()实际上是通过本地方法start0()启动线程的。而start0()会新运行一个线程，新线程会调用run()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">start0</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure>
<p>Thread.java中run()的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</div><div class="line">        target.run();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>说明：target是一个Runnable对象。run()就是直接调用Thread线程的Runnable成员的run()方法，并不会新建一个线程。</p>
<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p><a href="https://github.com/xcc3641/hexo_blog/blob/master/source/_posts/Review-Java-Thread-1.md" target="_blank" rel="external">https://github.com/xcc3641/hexo_blog/blob/master/source/_posts/Review-Java-Thread-1.md</a></p>
<p><a href="http://www.jianshu.com/p/81a56497e073" target="_blank" rel="external">http://www.jianshu.com/p/81a56497e073</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java8环境下的Maven javadoc插件的配置]]></title>
      <url>http://zsr.github.io/2017/03/02/Java8%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84Maven-javadoc%E6%8F%92%E4%BB%B6%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a><strong>问题</strong></h3><p>用maven在mvn clean package时，出现新的问题：生成javadoc出现异常，导致打包失败。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ERROR] Failed to execute goal org.apache.maven.plugins:maven-javadoc-plugin:2.10.1:jar (default) on project ticket-business: MavenReportException: Error while creating archive:</div><div class="line">[ERROR] Exit code: 1 - /Users/nali/Documents/workspace/ticket/ticket-business/src/main/java/com/ximalaya/ticket/business/dao/ticket/TicketProductMapper.java:13: 错误: 未知标记: mbg.generated</div><div class="line">[ERROR] * @mbg.generated Wed Mar 01 20:02:30 CST 2017</div><div class="line">[ERROR] ^</div><div class="line">[ERROR] /Users/nali/Documents/workspace/ticket/ticket-business/src/main/java/com/ximalaya/ticket/business/dao/ticket/TicketProductMapper.java:15: 警告: example没有 @param</div><div class="line">[ERROR] long countByExample(TicketProductExample example);</div></pre></td></tr></table></figure>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a><strong>配置</strong></h3><p>javadoc的插件pom.xml配置如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-javadoc-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.10.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">executions</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">goals</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>javadoc<span class="tag">&lt;/<span class="name">goal</span>&gt;</span>        </div><div class="line">      <span class="tag">&lt;/<span class="name">goals</span>&gt;</span>       </div><div class="line">      <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">executions</span>&gt;</span>                  </div><div class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="排查"><a href="#排查" class="headerlink" title="排查"></a><strong>排查</strong></h3><p>回退java版本到java7, 结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[WARNING] /Users/nali/Documents/workspace/ticket/ticket-business/src/main/java/com/ximalaya/ticket/business/model/TicketUser.java:172: 警告 - @mbg.generated是未知标记。</div></pre></td></tr></table></figure>
<p>可以发现在java7中是可以通过的，而在java8中则会报错。</p>
<p>应该是java8加了对javadoc的新的特性，查看<a href="http://openjdk.java.net/projects/jdk8/features" target="_blank" rel="external">Java8的特性列表</a>吧。果然，Java8添加了一个Javadoc注释内容检查的特性<a href="http://openjdk.java.net/jeps/172" target="_blank" rel="external">DocLint</a>。</p>
<p><code>DocLint</code>提供了一种方法来检测Javadoc的注释中的错误，希望能够在开发周期的早期和容易链接回源代码的方式。</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>1) 忽略注释错误</p>
<p>如果想忽略<code>DocLint</code>的使用，可以在<code>maven-javadoc-plugin</code>的配置中加上对<code>DocLint</code>的忽略。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-javadoc-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.10.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">executions</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">goals</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>javadoc<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">additionalparam</span>&gt;</span>-Xdoclint:none<span class="tag">&lt;/<span class="name">additionalparam</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></div></pre></td></tr></table></figure>
<p>或者在控制台输出:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mvn clean install -Dadditionalparam=-Xdoclint:none</div></pre></td></tr></table></figure>
<p>2) 跳过javadoc生成</p>
<p>控制台输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mvn clean install -Dmaven.javadoc.skip=true</div></pre></td></tr></table></figure>
<p>参考:</p>
<p><a href="https://tonydeng.github.io/2015/10/21/maven-Javadoc-plugin-in-java8-exception-resolution/" target="_blank" rel="external">https://tonydeng.github.io/2015/10/21/maven-Javadoc-plugin-in-java8-exception-resolution/</a></p>
<p><a href="http://openjdk.java.net/jeps/172" target="_blank" rel="external">http://openjdk.java.net/jeps/172</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Quartz 原理]]></title>
      <url>http://zsr.github.io/2017/02/28/Quartz-%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<h2 id="一、Quartz-基本介绍"><a href="#一、Quartz-基本介绍" class="headerlink" title="一、Quartz 基本介绍"></a>一、Quartz 基本介绍</h2><h3 id="1-1-Quartz特点"><a href="#1-1-Quartz特点" class="headerlink" title="1.1 Quartz特点"></a>1.1 Quartz特点</h3><p>​       <code>Quartz</code> 具有以下特点：</p>
<ol>
<li>强大的调度功能，例如支持丰富多样的调度方法，可以满足各种常规及特殊需求；</li>
<li>灵活的应用方式，例如支持任务和调度的多种组合方式，支持调度数据的多种存储方式；</li>
<li>分布式和集群能力，Terracotta 收购后在原来功能基础上作了进一步提升。</li>
</ol>
<p>​      另外，作为 Spring 默认的调度框架，Quartz 很容易与 Spring 集成实现灵活可配置的调度功能。</p>
<p><strong>quartz调度核心元素</strong>：</p>
<ol>
<li><strong>Scheduler</strong>: 任务调度器，是实际执行任务调度的控制器。在spring中通过<code>SchedulerFactoryBean</code>封装起来。</li>
<li><strong>Trigger</strong>：触发器，用于定义任务调度的时间规则，有<code>SimpleTrigger</code>,<code>CronTrigger</code>，其中CronTrigger用的比较多。CronTrigger在spring中封装在CronTriggerFactoryBean中。</li>
<li><strong>JobDetail</strong>: 用来描述Job实现类及其它相关的静态信息，如Job名字、关联监听器等信息。在spring中有<code>JobDetailFactoryBean</code>和 <code>MethodInvokingJobDetailFactoryBean</code>两种实现，如果任务调度只需要执行某个类的某个方法，就可以通过<code>MethodInvokingJobDetailFactoryBean</code>来调用。</li>
<li><strong>Job</strong>: 是一个接口，只有一个方法<code>void execute(JobExecutionContext context)</code>,开发者实现该接口定义运行任务，<code>JobExecutionContext</code>类提供了调度上下文的各种信息。Job运行时的信息保存在<code>JobDataMap</code>实例中。实现Job接口的任务，默认是无状态的，若要将Job设置成有状态的，在quartz中是给实现的Job添加<code>@DisallowConcurrentExecution</code>注解（以前是实现StatefulJob接口，现在已被Deprecated）,在与spring结合中可以在spring配置文件的job detail中配置concurrent参数。</li>
<li><strong>QuartzSchedulerResources</strong>:相当于调度的资源存放器，包含了JobStore, ThreadPool等资源，调度都是通过                QuartzSchedulerResources获取相关属性的。</li>
</ol>
<p>实现一个最简单的 Quartz 定时任务（不支持多机），有几个步骤：</p>
<ol>
<li>创建 Job。</li>
<li>创建 JobBuilder。顾名思义，可以用于生成 JobDetail 。</li>
<li>创建 TriggerBuilder。作用：配置定时时间,可以用于生成 Trigger 。</li>
<li>创建 Scheduler。作用：启动定时任务。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloJob</span> <span class="keyword">implements</span> <span class="title">Job</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(JobExecutionContext context)</span> <span class="keyword">throws</span> JobExecutionException </span>&#123;</div><div class="line">    System.out.println(<span class="string">"Hello World"</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    JobDetail job = JobBuilder.newJob(HelloJob.class).withIdentity(<span class="string">"dummyJobName"</span>, <span class="string">"group1"</span>).build();</div><div class="line"></div><div class="line">    Trigger trigger = TriggerBuilder.newTrigger().withIdentity(<span class="string">"dummyTriggerName"</span>, <span class="string">"group1"</span>)</div><div class="line">        .withSchedule(CronScheduleBuilder.cronSchedule(<span class="string">"0/5 * * * * ?"</span>)).build();</div><div class="line"></div><div class="line">    Scheduler scheduler = <span class="keyword">new</span> StdSchedulerFactory().getScheduler();</div><div class="line">    scheduler.start();</div><div class="line">    scheduler.scheduleJob(job, trigger);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="1-2-Quartz-集群配置"><a href="#1-2-Quartz-集群配置" class="headerlink" title="1.2 Quartz 集群配置"></a>1.2 Quartz 集群配置</h3><p><code>quartz</code>集群是通过数据库表来感知其他的应用的，各个节点之间并没有直接的通信。只有使用持久的JobStore才能完成Quartz集群。<br>数据库表：以前有12张表，现在只有11张表，现在没有存储listener相关的表，多了<code>QRTZ_SIMPROP_TRIGGERS</code>表：</p>
<table>
<thead>
<tr>
<th>Table name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>QRTZ_CALENDARS</td>
<td>存储Quartz的Calendar信息</td>
</tr>
<tr>
<td>QRTZ_CRON_TRIGGERS</td>
<td>存储CronTrigger，包括Cron表达式和时区信息</td>
</tr>
<tr>
<td>QRTZ_FIRED_TRIGGERS</td>
<td>存储与已触发的Trigger相关的状态信息，以及相联Job的执行信息</td>
</tr>
<tr>
<td>QRTZ_PAUSED_TRIGGER_GRPS</td>
<td>存储已暂停的Trigger组的信息</td>
</tr>
<tr>
<td>QRTZ_SCHEDULER_STATE</td>
<td>存储少量的有关Scheduler的状态信息，和别的Scheduler实例</td>
</tr>
<tr>
<td><strong>QRTZ_LOCKS</strong></td>
<td>存储程序的悲观锁的信息</td>
</tr>
<tr>
<td>QRTZ_JOB_DETAILS</td>
<td>存储每一个已配置的Job的详细信息</td>
</tr>
<tr>
<td>QRTZ_SIMPLE_TRIGGERS</td>
<td>存储简单的Trigger，包括重复次数、间隔、以及已触的次数</td>
</tr>
<tr>
<td>QRTZ_BLOG_TRIGGERS</td>
<td>Trigger作为Blob类型存储</td>
</tr>
<tr>
<td>QRTZ_TRIGGERS</td>
<td>存储已配置的Trigger的信息</td>
</tr>
<tr>
<td>QRTZ_SIMPROP_TRIGGERS</td>
</tr>
</tbody>
</table>
<p><code>QRTZ_LOCKS</code>就是Quartz集群实现同步机制的行锁表,包括以下几个锁：<code>CALENDAR_ACCESS</code> 、<code>JOB_ACCESS</code>、<code>MISFIRE_ACCESS</code> 、<code>STATE_ACCESS</code> 、<code>TRIGGER_ACCESS</code>。</p>
<a id="more"></a>
<h2 id="二、Quartz-原理及流程"><a href="#二、Quartz-原理及流程" class="headerlink" title="二、Quartz 原理及流程"></a>二、Quartz 原理及流程</h2><h3 id="2-1-quartz基本原理"><a href="#2-1-quartz基本原理" class="headerlink" title="2.1 quartz基本原理"></a>2.1 quartz基本原理</h3><p>Quartz是通过对用户暴露出Scheduler来进行任务的操作，它可以把任务JobDetail和触发器Trigger加入任务池中，可以把任务删除，也可以把任务停止，scheduler把这些任务和触发器放到一个JobStore中，这里jobStore有内存形式的也有持久化形式的.</p>
<p>它内部会通过一个调度线程<code>QuartzSchedulerThread</code>不断到<code>JobStore</code>中找出下次需要执行的任务，并把这些任务封装放到一个线程池<code>ThreadPool</code>中运行.</p>
<p>在 Quartz 中， scheduler 由 scheduler 工厂创建：<code>DirectSchedulerFactory</code> 或者 <code>StdSchedulerFactory</code>。 第二种工厂 StdSchedulerFactory 使用较多，因为 DirectSchedulerFactory 使用起来不够方便，需要作许多详细的手工编码设置。 Scheduler 主要有三种：<code>RemoteMBeanScheduler</code>， <code>RemoteScheduler</code> 和 <code>StdScheduler</code>。以最常用的 <code>StdScheduler</code> 为例讲解。</p>
<p>Quartz 核心元素之间的关系如下图所示：</p>
<p>图 1. Quartz 核心元素关系图</p>
<p><img src="/images/quartz 图2-1.gif"></p>
<p><strong>线程视图</strong></p>
<p>在 Quartz 中，有两类线程，<code>Scheduler</code> 调度线程和任务执行线程，其中任务执行线程通常使用一个线程池维护一组线程。</p>
<p>图 2. Quartz 线程视图</p>
<p><img src="/images/quartz 图2-2.gif"></p>
<p>Scheduler 调度线程主要有两个： 执行常规调度的线程，和执行 misfired trigger 的线程。常规调度线程轮询存储的所有 trigger，如果有需要触发的 trigger，即到达了下一次触发的时间，则从任务执行线程池获取一个空闲线程，执行与该 trigger 关联的任务。Misfire 线程是扫描所有的 trigger，查看是否有 misfired trigger，如果有的话根据 misfire 的策略分别处理。下图描述了这两个线程的基本流程：</p>
<p>图 3. Quartz 调度线程流程图</p>
<p><img src="/images/quartz 图2-3.png"></p>
<p>图 4. Quartz 调度执行时序图</p>
<p><img src="http://p.blog.csdn.net/images/p_blog_csdn_net/cutesource/EntryImages/20091208/quartz1.jpg" alt="img"></p>
<h3 id="2-2-quartz源码分析"><a href="#2-2-quartz源码分析" class="headerlink" title="2.2 quartz源码分析"></a>2.2 quartz源码分析</h3><ul>
<li><code>StdSchedulerFactory.getScheduler()</code>源码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Scheduler <span class="title">getScheduler</span><span class="params">()</span> <span class="keyword">throws</span> SchedulerException </span>&#123;</div><div class="line">        <span class="comment">// 读取quartz配置文件，未指定则顺序遍历各个path下的quartz.properties文件</span></div><div class="line">        <span class="comment">// 解析出quartz配置内容和环境变量，存入PropertiesParser对象</span></div><div class="line">        <span class="comment">// PropertiesParser组合了Properties（继承Hashtable），定义了一系列对Properties的操作方法，比如getPropertyGroup()批量获取相同前缀的配置。配置内容和环境变量存放在Properties成员变量中</span></div><div class="line">        <span class="keyword">if</span> (cfg == <span class="keyword">null</span>) &#123;</div><div class="line">            initialize();</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 获取调度器池，采用了单例模式</span></div><div class="line">        <span class="comment">// 其实，调度器池的核心变量就是一个hashmap，每个元素key是scheduler名，value是scheduler实例</span></div><div class="line">        <span class="comment">// getInstance()用synchronized防止并发创建</span></div><div class="line">        SchedulerRepository schedRep = SchedulerRepository.getInstance();</div><div class="line"></div><div class="line">        <span class="comment">// 从调度器池中取出当前配置所用的调度器</span></div><div class="line">        Scheduler sched = schedRep.lookup(getSchedulerName());</div><div class="line"></div><div class="line">        ......</div><div class="line"></div><div class="line">        <span class="comment">// 如果调度器池中没有当前配置的调度器，则实例化一个调度器，主要动作包括：</span></div><div class="line">        <span class="comment">// 1）初始化threadPool(线程池)：开发者可以通过org.quartz.threadPool.class配置指定使用哪个线程池类，比如SimpleThreadPool。先class load线程池类，接着动态生成线程池实例bean，然后通过反射，使用setXXX()方法将以org.quartz.threadPool开头的配置内容赋值给bean成员变量；</span></div><div class="line">        <span class="comment">// 2）初始化jobStore(任务存储方式)：开发者可以通过org.quartz.jobStore.class配置指定使用哪个任务存储类，比如RAMJobStore。先class load任务存储类，接着动态生成实例bean，然后通过反射，使用setXXX()方法将以org.quartz.jobStore开头的配置内容赋值给bean成员变量；</span></div><div class="line">        <span class="comment">// 3）初始化dataSource(数据源)：开发者可以通过org.quartz.dataSource配置指定数据源详情，比如哪个数据库、账号、密码等。jobStore要指定为JDBCJobStore，dataSource才会有效；</span></div><div class="line">        <span class="comment">// 4）初始化其他配置：包括SchedulerPlugins、JobListeners、TriggerListeners等；</span></div><div class="line">        <span class="comment">// 5）初始化threadExecutor(线程执行器)：默认为DefaultThreadExecutor；</span></div><div class="line">        <span class="comment">// 6）创建工作线程：根据配置创建N个工作thread，执行start()启动thread，并将N个thread顺序add进threadPool实例的空闲线程列表availWorkers中；</span></div><div class="line">        <span class="comment">// 7）创建调度器线程：创建QuartzSchedulerThread实例，并通过threadExecutor.execute(实例)启动调度器线程；</span></div><div class="line">        <span class="comment">// 8）创建调度器：创建StdScheduler实例，将上面所有配置和引用组合进实例中，并将实例存入调度器池中</span></div><div class="line">        sched = instantiate();</div><div class="line"></div><div class="line">        <span class="keyword">return</span> sched;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面有个过程是初始化jobStore，表示使用哪种方式存储scheduler相关数据。quartz有两大jobStore：<code>RAMJobStore</code>和<code>JDBCJobStore</code>。<code>RAMJobStore</code>把数据存入内存，性能最高，配置也简单，但缺点是系统挂了难以恢复数据。<code>JDBCJobStore</code>保存数据到数据库，保证数据的可恢复性，但性能较差且配置复杂。</p>
<ul>
<li><code>QuartzScheduler.scheduleJob(JobDetail, Trigger)</code>源码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">scheduleJob</span><span class="params">(JobDetail jobDetail,</span></span></div><div class="line">            Trigger trigger) <span class="keyword">throws</span> SchedulerException &#123;</div><div class="line">        <span class="comment">// 检查调度器是否开启，如果关闭则throw异常到上层</span></div><div class="line">        validateState();</div><div class="line">        ......</div><div class="line">        <span class="comment">// 获取trigger首次触发job的时间，以此时间为起点，每隔一段指定的时间触发job</span></div><div class="line">        Date ft = trig.computeFirstFireTime(cal);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (ft == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SchedulerException(</div><div class="line">                    <span class="string">"Based on configured schedule, the given trigger '"</span> + trigger.getKey() + <span class="string">"' will never fire."</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 把job和trigger注册进调度器的jobStore</span></div><div class="line">        resources.getJobStore().storeJobAndTrigger(jobDetail, trig);</div><div class="line">        <span class="comment">// 通知job监听者</span></div><div class="line">        notifySchedulerListenersJobAdded(jobDetail);                </div><div class="line">        <span class="comment">// 通知调度器线程</span></div><div class="line">        notifySchedulerThread(trigger.getNextFireTime().getTime());</div><div class="line">        <span class="comment">// 通知trigger监听者</span></div><div class="line">        notifySchedulerListenersSchduled(trigger);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> ft;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>QuartzScheduler.start()</code>源码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> SchedulerException </span>&#123;</div><div class="line">        ......</div><div class="line">        <span class="comment">// 这句最关键，作用是使调度器线程跳出一个无限循环，开始轮询所有trigger触发job</span></div><div class="line">        <span class="comment">// 原理详见“如何采用多线程进行任务调度”</span></div><div class="line">        schedThread.togglePause(<span class="keyword">false</span>);</div><div class="line">        ......</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="如何采用多线程进行任务调度"><a href="#如何采用多线程进行任务调度" class="headerlink" title="如何采用多线程进行任务调度"></a>如何采用多线程进行任务调度</h3><ul>
<li><code>QuartzSchedulerThread.java</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 调度器线程一旦启动，将一直运行此方法</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">  ......</div><div class="line">  <span class="comment">// while()无限循环，每次循环取出时间将到的trigger，触发对应的job，直到调度器线程被关闭</span></div><div class="line">  <span class="comment">// halted是一个AtomicBoolean类变量，有个volatile int变量value，其get()方法仅仅简单的一句return value != 0，get()返回结果表示调度器线程是否开关</span></div><div class="line">  <span class="comment">// volatile修饰的变量，存取必须走内存，不能通过cpu缓存，这样一来get总能获得set的最新真实值，因此volatile变量适合用来存放简单的状态信息</span></div><div class="line">  <span class="comment">// 顾名思义，AtomicBoolean要解决原子性问题，但volatile并不能保证原子性，详见http://blog.csdn.net/wxwzy738/article/details/43238089</span></div><div class="line">  <span class="keyword">while</span> (!halted.get()) &#123;</div><div class="line">     <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// check if we're supposed to pause...</span></div><div class="line">        <span class="comment">// sigLock是个Object对象，被用于加锁同步</span></div><div class="line">        <span class="comment">// 需要用到wait()，必须加到synchronized块内</span></div><div class="line">        <span class="keyword">synchronized</span> (sigLock) &#123;</div><div class="line">            <span class="keyword">while</span> (paused &amp;&amp; !halted.get()) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="comment">// wait until togglePause(false) is called...</span></div><div class="line">                    <span class="comment">// 这里会不断循环等待，直到QuartzScheduler.start()调用了togglePause(false)</span></div><div class="line">                    <span class="comment">// 调用wait()，调度器线程进入休眠状态，同时sigLock锁被释放</span></div><div class="line">                    <span class="comment">// togglePause(false)获得sigLock锁，将paused置为false，使调度器线程能够退出此循环，同时执行sigLock.notifyAll()唤醒调度器线程</span></div><div class="line">                    sigLock.wait(<span class="number">1000L</span>);</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ignore) &#123;&#125;</div><div class="line">            &#125;</div><div class="line">            ......</div><div class="line">        &#125;</div><div class="line">        ......</div><div class="line">        <span class="comment">// 如果线程池中的工作线程个数 &gt; 0</span></div><div class="line">        <span class="keyword">if</span>(availThreadCount &gt; <span class="number">0</span>) &#123;</div><div class="line">            ......</div><div class="line">            <span class="comment">// 获取马上到时间的trigger</span></div><div class="line">            <span class="comment">// 允许取出的trigger个数不能超过一个阀值，这个阀值是线程池个数与org.quartz.scheduler.batchTriggerAcquisitionMaxCount配置值间的最小者</span></div><div class="line">            triggers = qsRsrcs.getJobStore().acquireNextTriggers(</div><div class="line">                now + idleWaitTime, Math.min(availThreadCount, qsRsrcs.getMaxBatchSize()), qsRsrcs.getBatchTimeWindow());</div><div class="line">            ......</div><div class="line">            <span class="comment">// 执行与trigger绑定的job</span></div><div class="line">            <span class="comment">// shell是JobRunShell对象，实现了Runnable接口</span></div><div class="line">            <span class="comment">// SimpleThreadPool.runInThread(Runnable)从线程池空闲列表中取出一个工作线程</span></div><div class="line">            <span class="comment">// 工作线程执行WorkerThread.run(Runnable)，详见下方WorkerThread的讲解</span></div><div class="line">            <span class="keyword">if</span> (qsRsrcs.getThreadPool().runInThread(shell) == <span class="keyword">false</span>) &#123; ...... &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;......&#125;</div><div class="line">        ......</div><div class="line">    &#125; <span class="keyword">catch</span>(RuntimeException re) &#123;......&#125;</div><div class="line">  &#125; <span class="comment">// while (!halted)</span></div><div class="line">  ......</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>WorkerThread.java</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(Runnable newRunnable)</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span>(lock) &#123;</div><div class="line">            <span class="keyword">if</span>(runnable != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already running a Runnable!"</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            runnable = newRunnable;</div><div class="line">            lock.notifyAll();</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 工作线程一旦启动，将一直运行此方法</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">boolean</span> ran = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        <span class="comment">// 工作线程一直循环等待job，直到线程被关闭，原理同QuartzSchedulerThread.run()中的halted.get()</span></div><div class="line">        <span class="keyword">while</span> (run.get()) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">               <span class="comment">// 原理同QuartzSchedulerThread.run()中的synchronized (sigLock)</span></div><div class="line">               <span class="comment">// 锁住lock，不断循环等待job，当job要被执行时，WorkerThread.run(Runnable)被调用，job运行环境被赋值给runnable</span></div><div class="line">                <span class="keyword">synchronized</span>(lock) &#123;</div><div class="line">                    <span class="keyword">while</span> (runnable == <span class="keyword">null</span> &amp;&amp; run.get()) &#123;</div><div class="line">                        lock.wait(<span class="number">500</span>);</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">// 开始执行job</span></div><div class="line">                    <span class="keyword">if</span> (runnable != <span class="keyword">null</span>) &#123;</div><div class="line">                        ran = <span class="keyword">true</span>;</div><div class="line">                        <span class="comment">// runnable.run()将触发运行job实现类（比如JobImpl.execute()）</span></div><div class="line">                        runnable.run();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException unblock) &#123;</div><div class="line">             ......</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        ......</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>核心代码就是在while循环中调用<code>Object.wait()</code>，等待可以跳出while循环的条件成立，当条件成立时，立马调度<code>Object.notifyAll()</code>使线程跳出while。通过这样的代码，可以实现调度器线程等待启动、工作线程等待job等功能。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://www.jianshu.com/p/bab8e4e329520" target="_blank" rel="external">quartz原理揭秘和源码解读</a></p>
<p><a href="https://my.oschina.net/songhongxu/blog/802574" target="_blank" rel="external">quartz (从原理到应用)详解篇</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Mockito 源码解析]]></title>
      <url>http://zsr.github.io/2017/02/24/Mockito-%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<p><a href="http://site.mockito.org/" target="_blank" rel="external">Mockito</a>是Java平台上超火的Mock框架，因为其便捷的API，深受广大开发者喜爱。本文将从源码的角度，来分析Mockito的运行流程。</p>
<h3 id="Mockito-简介"><a href="#Mockito-简介" class="headerlink" title="Mockito 简介"></a>Mockito 简介</h3><p>Mockito类相当于整个框架的门面，负责对外提供调用接口。常用的有如下几个：</p>
<ul>
<li><p><strong>mock</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List list = Mockito.mock(List.class);   此时， list就是被Mockito所mock后生成的实例，Mockito会记住它所mock对象的所有调用，为后面的验证做准备。</div></pre></td></tr></table></figure>
<ul>
<li>默认情况下，调用mock对象的带返回值的方法会返回默认的值，比如返回null、0值或者false等。</li>
<li>允许多次代理mock对象的同一个方法，但具体的行为取决于该方法最近的一次代理行为。</li>
<li>mock对象的代理方法，允许多次调用，只有不覆盖它的代理行为，那么每次调用的执行相同的行为或者返回相同的值</li>
<li>相同的方法和参数唯一确认一个代理。比如你可以分别代理get(int)方法在参数分别为0和1时的不同行为。</li>
</ul>
</li>
<li><p><strong>when</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Mockito.when(list.size()).thenReturn(1);</div></pre></td></tr></table></figure>
<p>上述代码表示，当对list对象调用size()方法时，会返回1.这样我们就可以自定义mock对象的行为了。</p>
<p>java 中的程序调用是以栈的形式实现的，对于 when 方法，list.size() 方法的调用对它是不可见的。when 能接收到的，只有 list.size() 的返回值。</p>
</li>
<li><p><strong>verify</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Mockito.verify(list).add(Matchers.anyObject());</div></pre></td></tr></table></figure>
<p>verify是负责验证的函数，接受的参数是一个被mock的对象，表示验证其是否执行了后面的方法。</p>
</li>
</ul>
<h3 id="Mockito-实现"><a href="#Mockito-实现" class="headerlink" title="Mockito 实现"></a>Mockito 实现</h3><p>Mock 使用了代理模式。我们操作的list，实际上是继承了<code>List</code>的代理类的实例，我们把它称为 proxy 对象。因此对于list 的所有操作，都会先经过 proxy 对象。</p>
<p>Mocktio 就是通过这种方式，拦截到了list 的所有操作。只要在调用list 的方法时，将该方法存放起来，然后在调用 thenReturn 为其设置返回值就可以了。</p>
<h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p><img src="http://7rf34y.com2.z0.glb.qiniucdn.com/c/ca500a410275d01ec697437e54a09f2e" alt="img"></p>
<p>几个主要的类已用红颜色标出，它们将会是Mockito的核心，也是下文主要介绍的对象。接下来，就深入Mockito的源码来一探究竟。</p>
<a id="more"></a>
<h4 id="Mock"><a href="#Mock" class="headerlink" title="Mock"></a>Mock</h4><p>Mockito类中有几个mock函数的重载，最终都会调到mock(Class<t> classToMock, MockSettings mockSettings)，接受一个<code>Class</code>类型与一个<code>MockSettings</code>，class就是我们需要mock对象的类型，而mockSettings则记录着此次mock的一些信息。mock的行为实则转交个<code>MockitoCore</code>：</t></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">MOCKITO_CORE.mock(classToMock, mockSettings)</div></pre></td></tr></table></figure>
<p>在<code>MockitoCore</code>中一是做了一下初始化工作，二是继续转交给<code>MockUtil</code>处理:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">MockSettingsImpl impl = MockSettingsImpl.class.cast(settings);</div><div class="line">MockCreationSettings&lt;T&gt; creationSettings = impl.confirm(typeToMock);</div><div class="line">T mock = mockUtil.createMock(creationSettings);</div><div class="line">mockingProgress.mockingStarted(mock, typeToMock);</div></pre></td></tr></table></figure>
<p>在<code>MockUtil</code>中则作了两件非常关键的事情:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">MockHandler mockHandler =  createMockHandler(settings);</div><div class="line">T mock = mockMaker.createMock(settings, mockHandler);</div></pre></td></tr></table></figure>
<p>一是创建了MockHandler对象，MockHandler是一个接口，通过createMockHandler函数我们可以清楚，MockHandler对象的实例是InvocationNotifierHandler类型，但它只是负责对外的包装，内部实际起作用的是MockHandlerImpl这个家伙，也是上文类图右下角的那位，这个类可谓承载了Mockito的主要逻辑，我们后面会详细的来说明。</p>
<p>接着会调用mockMaker来创建最终的实例，这个<code>MockMaker</code>也是一个接口，其实现为<code>ByteBuddyMockMaker</code>，我们追进去看一下createMock函数（省略异常处理代码）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">createMock</span><span class="params">(MockCreationSettings&lt;T&gt; settings, MockHandler handler)</span></span>&#123;</div><div class="line">    Class&lt;T&gt; mockedProxyType = createProxyClass(mockWithFeaturesFrom(settings));</div><div class="line">    Instantiator instantiator = Plugins.getInstantiatorProvider().getInstantiator(settings);</div><div class="line">    T mockInstance = <span class="keyword">null</span>;</div><div class="line">    mockInstance = instantiator.newInstance(mockedProxyType);</div><div class="line">    MockAccess mockAccess = (MockAccess) mockInstance;</div><div class="line">    mockAccess.setMockitoInterceptor(<span class="keyword">new</span> MockMethodInterceptor(asInternalMockHandler(handler), settings));</div><div class="line">    <span class="keyword">return</span> ensureMockIsAssignableToMockedType(settings, mockInstance);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先函数内的第一行代码就比较引人注目：createProxyClass，要创建一个代理类, 但没有创建出目标类的实例。所以往下看，这个重担就交在了这三行代码上:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Instantiator instantiator = Plugins.getInstantiatorProvider().getInstantiator(settings);</div><div class="line">T mockInstance = <span class="keyword">null</span>;</div><div class="line">mockInstance = instantiator.newInstance(mockedProxyType);</div></pre></td></tr></table></figure>
<p>这个<code>Instantiator</code>也是一个接口，它有两个实现，一是<code>ObjenesisInstantiator</code>,另外一个是<code>ConstructorInstantiator</code>， 默认情况下，都是在使用<code>ObjenesisInstantiator</code>， 所以我们这里只查看<code>ObjenesisInstantiator</code>，并且<code>ObjenesisInstantiator</code>也是上述UML图中的一个标红的类，因为它承载生成对象的工作。看其newInstance方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">newInstance</span><span class="params">(Class&lt;T&gt; cls)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> objenesis.newInstance(cls);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里调用了objenesis.newInstance，可以根据不同的平台选择不同的方法来new对象。总之一句话，只要输入一个class进去，它就会输出其一个实例对象.可以查看其Github:<a href="https://github.com/easymock/objenesis" target="_blank" rel="external">https://github.com/easymock/objenesis</a>。</p>
<p>如此，走到这里，我们的mock对象就已经被生成出来.</p>
<h4 id="When"><a href="#When" class="headerlink" title="When"></a>When</h4><p>接下来看一下Mockito里的when方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">OngoingStubbing&lt;T&gt; <span class="title">when</span><span class="params">(T methodCall)</span> </span>&#123;</div><div class="line">     <span class="keyword">return</span> MOCKITO_CORE.when(methodCall);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同样是转交到了<code>MOCKITO_CORE</code>这里:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">OngoingStubbing&lt;T&gt; <span class="title">when</span><span class="params">(T methodCall)</span> </span>&#123;</div><div class="line">    mockingProgress.stubbingStarted();</div><div class="line">    OngoingStubbing&lt;T&gt; stubbing = mockingProgress.pullOngoingStubbing();</div><div class="line">    <span class="keyword">if</span> (stubbing == <span class="keyword">null</span>) &#123;</div><div class="line">        mockingProgress.reset();</div><div class="line">        <span class="keyword">throw</span> missingMethodInvocation();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> stubbing;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上文说过，mock对象所有的方法最终都会交由<code>MockHandlerImpl</code>的handle方法处理.</p>
<p>在handle中和when有关的几句代码是:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">handle</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">     ...</div><div class="line">     <span class="comment">// prepare invocation for stubbing</span></div><div class="line">     OngoingStubbingImpl&lt;T&gt; ongoingStubbing = <span class="keyword">new</span> OngoingStubbingImpl&lt;invocationContainerImpl);</div><div class="line">     mockingProgress.reportOngoingStubbing(ongoingStubbing)</div><div class="line">       </div><div class="line">     <span class="comment">// look for existing answer for this invocation</span></div><div class="line">     StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);</div><div class="line">     <span class="keyword">if</span> (stubbedInvocation != <span class="keyword">null</span>) &#123;</div><div class="line">         stubbedInvocation.captureArgumentsFrom(invocation);</div><div class="line">         <span class="keyword">return</span> stubbedInvocation.answer(invocation);</div><div class="line">     &#125; <span class="keyword">else</span> &#123;</div><div class="line">     ...</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>when调用的基本形式是when(mock.doSome()), 此时，当mock.doSome()时即会触发上面的语句，<code>OngoingStubbingImpl</code>表示正在对一个方法打桩的包装，<code>invocationContainerImpl</code> 相当于一个mock对象的管家，记录着mock对象方法的调用。后面我们还会再见到它。<code>mockingProgress</code>则可以理解为一个和线程相关的记录器，用于存放每个线程正要准备做的一些事情，它的内部包含了几个<strong>report</strong> 和 <strong>pull</strong> 这样的函数，如上所看到，mockingProgress记录着ongoingStubbing对象。</p>
<p>再回过头来看<code>MOCKITO_CORE</code>里的when方法就会清晰许多，它会取出刚刚存放在mockingProgress中的ongoingStubbing对象。<code>OngoingStubbing&lt;T&gt; stubbing = mockingProgress.pullOngoingStubbing();</code></p>
<p>而我们熟知的<code>thenReturn</code>、<code>thenThrow</code>则是<code>OngoingStubbing</code>里的方法，这些方法最终都会调到如下方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> OngoingStubbing&lt;T&gt; <span class="title">thenAnswer</span><span class="params">(Answer&lt;?&gt; answer)</span> </span>&#123;</div><div class="line">      <span class="keyword">if</span>(!invocationContainerImpl.hasInvocationForPotentialStubbing()) &#123;</div><div class="line">          <span class="keyword">throw</span> incorrectUseOfApi();</div><div class="line">      &#125;</div><div class="line">      invocationContainerImpl.addAnswer(answer);</div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ConsecutiveStubbing&lt;T&gt;(invocationContainerImpl);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>answer</code>即是对<code>thenReturn</code>、<code>thenThrow</code>之类的包装，当然我们也可以自己定义answer。我们又看到了<code>invocationContainerImpl</code>，它会帮我们保管这个<code>answer</code>，待以后调用该方法时返回正确的值，与之对应的代码是handle方法中如下这句代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">StubbedInvocationMatcher stubbedInvocation =     invocationContainerImpl.findAnswerFor(invocation);</div></pre></td></tr></table></figure>
<p>当stubbedInvocation不为空时，就会调用anwser方法来回去之前设定的值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">stubbedInvocation.answer(invocation)</div></pre></td></tr></table></figure>
<p>如此，对于when(mock.doSome()).thenReturn(obj)这样的用法的主要逻辑了。</p>
<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p><a href="https://toutiao.io/posts/b0h8dz/preview" target="_blank" rel="external">Mockito 源码解析</a></p>
<p><a href="https://blog.coding.net/blog/how-to-write-mockito" target="_blank" rel="external">动手编写 Mockito</a></p>
<p><a href="http://www.devtf.cn/?p=1315" target="_blank" rel="external">Mockito 中文文档</a></p>
<p><a href="http://blog.csdn.net/zhoudaxia/article/details/30591941" target="_blank" rel="external">Java动态代理与Cglib库</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[基于Spring MVC做单元测试]]></title>
      <url>http://zsr.github.io/2017/02/23/SpringMVC-Mock/</url>
      <content type="html"><![CDATA[<p>在Spring 3.2之前，测试时一般都是直接new控制器，注入依赖，然后判断返回值。但是我们无法连同Spring MVC的基础设施（如DispatcherServlet调度、类型转换、数据绑定、拦截器等）一起测试，另外也没有现成的方法测试如最终渲染的视图（@ResponseBody生成的JSON/XML、JSP、Velocity等）内容是否正确。从Spring 3.2开始这些事情都可以完成了。而且可以测试完整的Spring MVC流程，即从URL请求到控制器处理，再到视图渲染都可以测试。</p>
<h3 id="添加Maven依赖"><a href="#添加Maven依赖" class="headerlink" title="添加Maven依赖 "></a><strong>添加Maven依赖 </strong></h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </div><div class="line">  </div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<p><strong>版本信息</strong>：<spring.version>3.2.6.RELEASE</spring.version></p>
<p>测试相关的依赖（<code>junit</code>、<code>hamcrest</code>、<code>mockito</code>、<code>spring-test</code>）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;junit.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hamcrest<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hamcrest-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;hamcrest.core.version&#125;/version&gt;  </div><div class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mockito<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mockito-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mockito.core.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.jayway.jsonpath<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>json-path<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<p><strong>版本信息：</strong><junit.version>4.12</junit.version>、<hamcrest.core.version>1.3</hamcrest.core.version>、<mockito.core.version>2.2.22</mockito.core.version></p>
<h3 id="Spring-MVC测试说明"><a href="#Spring-MVC测试说明" class="headerlink" title="Spring MVC测试说明"></a><strong>Spring MVC测试说明</strong></h3><p><strong>首先是Spring的几个Annotate</strong></p>
<ul>
<li>RunWith(SpringJUnit4ClassRunner.class): 表示使用Spring Test组件进行单元测试;</li>
<li>WebAppConfiguration: 测试环境使用，用来表示测试环境使用的ApplicationContext将是WebApplicationContext类型的；value指定web应用的根;</li>
<li>ContextConfiguration: 指定Bean的配置文件信息，可以有多种方式，这个例子使用的是文件路径形式，如果有多个配置文件，可以将括号中的信息配置为一个字符串数组来表示;</li>
</ul>
<p><strong>然后是Mockito的Annotate</strong></p>
<ul>
<li>Mock: 如果该对象需要mock，则加上此Annotate;</li>
<li>InjectMocks: 使mock对象的使用类可以注入mock对象，在上面这个例子中，mock对象是UserService，使用了UserService的是UserController，所以在Controller加上该Annotate;</li>
</ul>
<p><strong>Setup方法</strong></p>
<ul>
<li><code>MockitoAnnotations.initMocks(this)</code>: 将打上Mockito标签的对象起作用，使得Mock的类被Mock，使用了Mock对象的类自动与Mock对象关联。</li>
<li><code>mockMvc</code>: 这个对象是Controller单元测试的关键，它的初始化也是在setup方法里面。</li>
</ul>
<p><strong>Test Case</strong></p>
<ul>
<li>首先mock了UserService的方法，让其返回一个成功的Result对象。</li>
<li><code>mockMvc.perform</code>: 发起一个http请求。</li>
<li><code>post(url)</code>: 表示一个post请求，url对应的是Controller中被测方法的Rest url。</li>
<li><code>param(key, value)</code>: 表示一个request parameter，方法参数是key和value。</li>
<li><code>andDo（print()）</code>: 表示打印出request和response的详细信息，便于调试。</li>
<li><code>andExpect（status().isOk()）</code>: 表示期望返回的Response Status是200。</li>
<li><code>andExpect（content().string(is（expectstring））</code>: 表示期望返回的Response Body内容是期望的字符串。</li>
</ul>
<p>spring mvc测试框架提供了两种方式，独立安装和集成Web环境测试（此种方式并不会集成真正的web环境，而是通过相应的Mock API进行模拟测试，无须启动服务器）。</p>
<a id="more"></a>
<h4 id="方案一：独立安装"><a href="#方案一：独立安装" class="headerlink" title="方案一：独立安装"></a>方案一：独立安装</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</div><div class="line"><span class="meta">@ContextConfiguration</span>(&#123; <span class="string">"classpath:test-context.xml"</span> &#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserControllerTest</span> </span>&#123;</div><div class="line">  <span class="meta">@InjectMocks</span></div><div class="line">  <span class="keyword">private</span> UserController userController;</div><div class="line">  <span class="meta">@Mock</span></div><div class="line">  <span class="keyword">private</span> UserServiceImpl userService;</div><div class="line">  <span class="keyword">private</span> MockMvc mockMvc;</div><div class="line">  </div><div class="line">  <span class="meta">@Before</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</div><div class="line">    MockitoAnnotations.initMocks(<span class="keyword">this</span>);</div><div class="line">    mockMvc = MockMvcBuilders.standaloneSetup(userController).build();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>1、首先自己创建相应的控制器，注入相应的依赖</p>
<p>2、通过MockMvcBuilders.standaloneSetup模拟一个Mvc测试环境，通过build得到一个MockMvc </p>
<p><strong>1.1、配置文件:</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">	<span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></div><div class="line">	<span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></div><div class="line">	<span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span> <span class="attr">xmlns:util</span>=<span class="string">"http://www.springframework.org/schema/util"</span></div><div class="line">	<span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></div><div class="line">       http://www.springframework.org/schema/beans</div><div class="line">       http://www.springframework.org/schema/beans/spring-beans-3.2.xsd</div><div class="line">       http://www.springframework.org/schema/context</div><div class="line">       http://www.springframework.org/schema/context/spring-context-3.2.xsd</div><div class="line">       http://www.springframework.org/schema/mvc</div><div class="line">       http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd</div><div class="line">	   http://www.springframework.org/schema/util</div><div class="line">	   http://www.springframework.org/schema/util/spring-util-3.2.xsd"&gt;</div><div class="line"></div><div class="line">	<span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"org.zsr.mvc"</span> /&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">mvc:message-converters</span> <span class="attr">register-defaults</span>=<span class="string">"false"</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.http.converter.StringHttpMessageConverter"</span>&gt;</span></div><div class="line">				<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"UTF-8"</span> /&gt;</span></div><div class="line">				<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"supportedMediaTypes"</span>&gt;</span></div><div class="line">					<span class="tag">&lt;<span class="name">util:list</span>&gt;</span></div><div class="line">						<span class="tag">&lt;<span class="name">value</span>&gt;</span>application/json<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">					<span class="tag">&lt;/<span class="name">util:list</span>&gt;</span></div><div class="line">				<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">				<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"writeAcceptCharset"</span> <span class="attr">value</span>=<span class="string">"false"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">			<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">bean</span></span></div><div class="line">				<span class="attr">class</span>=<span class="string">"com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter"</span>&gt;</div><div class="line">			<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="name">mvc:message-converters</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
<p><strong>1.2、测试代码:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.zsr.mvc.controller;</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.hamcrest.Matchers.is;</div><div class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders.delete;</div><div class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;</div><div class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;</div><div class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders.put;</div><div class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;</div><div class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;</div><div class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.junit.Before;</div><div class="line"><span class="keyword">import</span> org.junit.Test;</div><div class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</div><div class="line"><span class="keyword">import</span> org.mockito.Mock;</div><div class="line"><span class="keyword">import</span> org.mockito.Mockito;</div><div class="line"><span class="keyword">import</span> org.mockito.MockitoAnnotations;</div><div class="line"><span class="keyword">import</span> org.mockito.invocation.InvocationOnMock;</div><div class="line"><span class="keyword">import</span> org.mockito.stubbing.Answer;</div><div class="line"><span class="keyword">import</span> org.zsr.mvc.domain.User;</div><div class="line"><span class="keyword">import</span> org.zsr.mvc.service.impl.UserServiceImpl;</div><div class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</div><div class="line"><span class="keyword">import</span> org.springframework.http.MediaType;</div><div class="line"><span class="keyword">import</span> org.springframework.test.context.ContextConfiguration;</div><div class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</div><div class="line"><span class="keyword">import</span> org.springframework.test.context.web.WebAppConfiguration;</div><div class="line"><span class="keyword">import</span> org.springframework.test.web.servlet.MockMvc;</div><div class="line"><span class="keyword">import</span> org.springframework.test.web.servlet.setup.MockMvcBuilders;</div><div class="line"><span class="keyword">import</span> org.springframework.web.context.WebApplicationContext;</div><div class="line"></div><div class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</div><div class="line"></div><div class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</div><div class="line"><span class="meta">@ContextConfiguration</span>(&#123; <span class="string">"classpath:test-context.xml"</span> &#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserControllerTest</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="meta">@InjectMocks</span></div><div class="line">  <span class="keyword">private</span> UserController userController;</div><div class="line">  <span class="meta">@Mock</span></div><div class="line">  <span class="keyword">private</span> UserServiceImpl userService;</div><div class="line">  <span class="keyword">private</span> MockMvc mockMvc;</div><div class="line"></div><div class="line">  <span class="meta">@Before</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</div><div class="line">    MockitoAnnotations.initMocks(<span class="keyword">this</span>);</div><div class="line">    mockMvc = MockMvcBuilders.standaloneSetup(userController).build();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Test</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> userId = <span class="number">3</span>;</div><div class="line"></div><div class="line">    Mockito.when(userService.getUser(userId)).thenAnswer(<span class="keyword">new</span> Answer&lt;User&gt;() &#123;</div><div class="line"></div><div class="line">      <span class="function"><span class="keyword">public</span> User <span class="title">answer</span><span class="params">(InvocationOnMock invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        User user = <span class="keyword">new</span> User();</div><div class="line">        user.setId(userId);</div><div class="line">        user.setAge(<span class="number">20</span>);</div><div class="line">        user.setFirstName(<span class="string">"bob"</span>);</div><div class="line">        <span class="keyword">return</span> user;</div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    mockMvc.perform(get(<span class="string">"/user/"</span> + userId)).andExpect(status().isOk())</div><div class="line">        .andExpect(content().contentTypeCompatibleWith(MediaType.APPLICATION_JSON))</div><div class="line">        .andExpect(jsonPath(<span class="string">"$.data.age"</span>, is(<span class="number">20</span>))).andExpect(jsonPath(<span class="string">"$.data.firstName"</span>, is(<span class="string">"bob"</span>)))</div><div class="line">        .andExpect(jsonPath(<span class="string">"$.data.id"</span>, is(userId))).andExpect(jsonPath(<span class="string">"$.success"</span>, is(<span class="keyword">true</span>)));</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Test</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSave</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    mockMvc.perform(post(<span class="string">"/user"</span>).contentType(MediaType.APPLICATION_JSON).content(JSON.toJSONString(<span class="keyword">new</span> User())))</div><div class="line">        .andExpect(status().isOk()).andExpect(content().contentTypeCompatibleWith(MediaType.APPLICATION_JSON))</div><div class="line">        .andExpect(jsonPath(<span class="string">"$.success"</span>, is(<span class="keyword">true</span>)));</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>方案二：集成Web环境方式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</div><div class="line"><span class="meta">@WebAppConfiguration</span>(value = <span class="string">"src/main/webapp"</span>)</div><div class="line"><span class="meta">@ContextConfiguration</span>(&#123; <span class="string">"classpath:test-context.xml"</span> &#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserControllerTest</span> </span>&#123;</div><div class="line">  <span class="meta">@Autowired</span></div><div class="line">  <span class="keyword">private</span> WebApplicationContext wac;</div><div class="line">  <span class="keyword">private</span> MockMvc mockMvc;</div><div class="line"></div><div class="line">  <span class="meta">@Before</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</div><div class="line">    MockitoAnnotations.initMocks(<span class="keyword">this</span>);</div><div class="line">    mockMvc = MockMvcBuilders.webAppContextSetup(wac).build();</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>1、@WebAppConfiguration：测试环境使用，用来表示测试环境使用的ApplicationContext将是WebApplicationContext类型的；value指定web应用的根；</p>
<p>2、通过@Autowired WebApplicationContext wac：注入web环境的ApplicationContext容器；</p>
<p>3、然后通过MockMvcBuilders.webAppContextSetup(wac).build()创建一个MockMvc进行测试；</p>
<p><strong>注意：</strong>集成Web环境方式是根据指定的xml配置文件(或者Java注解类)构造应用上下文ApplicationContext，如果配置文件中没有将依赖的服务(本案例是：userService)模拟出来，则依赖的服务是真实的；在使用mockMvc测试Controller中的Method时候(其中涉及userService接口调用)，依赖的服务userService实际上会执行其中的逻辑(可能有复杂的计算或者RPC调用等)。这种情况不是我所预期的，实际的需求是：模拟依赖的服务userService调用接口，返回自定义的数据。总结一句话：Controller依赖的所有服务都是mock的。解决方法：<strong><a href="https://github.com/springockito/springockito" target="_blank" rel="external">springockito</a></strong></p>
<p><strong>2.1、配置文件:</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.kubek2k<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springockito<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">	<span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></div><div class="line">	<span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></div><div class="line">	<span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span> <span class="attr">xmlns:util</span>=<span class="string">"http://www.springframework.org/schema/util"</span></div><div class="line">	<span class="attr">xmlns:mockito</span>=<span class="string">"http://www.mockito.org/spring/mockito"</span></div><div class="line">	<span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></div><div class="line">       http://www.springframework.org/schema/beans</div><div class="line">       http://www.springframework.org/schema/beans/spring-beans-3.2.xsd</div><div class="line">       http://www.springframework.org/schema/context</div><div class="line">       http://www.springframework.org/schema/context/spring-context-3.2.xsd</div><div class="line">       http://www.springframework.org/schema/mvc</div><div class="line">       http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd</div><div class="line">	   http://www.springframework.org/schema/util</div><div class="line">	   http://www.springframework.org/schema/util/spring-util-3.2.xsd</div><div class="line">	   http://www.mockito.org/spring/mockito</div><div class="line">       http://www.mockito.org/spring/mockito.xsd"&gt;</div><div class="line"></div><div class="line">	<span class="comment">&lt;!-- &lt;context:component-scan base-package="org.royrusso.mvc" /&gt; --&gt;</span></div><div class="line"></div><div class="line">	<span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">mvc:message-converters</span> <span class="attr">register-defaults</span>=<span class="string">"false"</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.http.converter.StringHttpMessageConverter"</span>&gt;</span></div><div class="line">				<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"UTF-8"</span> /&gt;</span></div><div class="line">				<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"supportedMediaTypes"</span>&gt;</span></div><div class="line">					<span class="tag">&lt;<span class="name">util:list</span>&gt;</span></div><div class="line">						<span class="tag">&lt;<span class="name">value</span>&gt;</span>application/json<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">					<span class="tag">&lt;/<span class="name">util:list</span>&gt;</span></div><div class="line">				<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">				<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"writeAcceptCharset"</span> <span class="attr">value</span>=<span class="string">"false"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">			<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">bean</span></span></div><div class="line">				<span class="attr">class</span>=<span class="string">"com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter"</span>&gt;</div><div class="line">			<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="name">mvc:message-converters</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></div><div class="line"></div><div class="line">	<span class="tag">&lt;<span class="name">mockito:mock</span> <span class="attr">id</span>=<span class="string">"userService"</span></span></div><div class="line">		<span class="attr">class</span>=<span class="string">"org.zsr.mvc.service.impl.UserServiceImpl"</span> /&gt;</div><div class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.zsr.mvc.controller.UserController"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
<p><strong>2.2、测试代码:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.zsr.mvc.controller;</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.hamcrest.Matchers.is;</div><div class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders.delete;</div><div class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;</div><div class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;</div><div class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders.put;</div><div class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;</div><div class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;</div><div class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.junit.Before;</div><div class="line"><span class="keyword">import</span> org.junit.Test;</div><div class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</div><div class="line"><span class="keyword">import</span> org.mockito.Mockito;</div><div class="line"><span class="keyword">import</span> org.mockito.MockitoAnnotations;</div><div class="line"><span class="keyword">import</span> org.mockito.invocation.InvocationOnMock;</div><div class="line"><span class="keyword">import</span> org.mockito.stubbing.Answer;</div><div class="line"><span class="keyword">import</span> org.zsr.mvc.domain.User;</div><div class="line"><span class="keyword">import</span> org.zsr.mvc.service.impl.UserServiceImpl;</div><div class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</div><div class="line"><span class="keyword">import</span> org.springframework.http.MediaType;</div><div class="line"><span class="keyword">import</span> org.springframework.test.context.ContextConfiguration;</div><div class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</div><div class="line"><span class="keyword">import</span> org.springframework.test.context.web.WebAppConfiguration;</div><div class="line"><span class="keyword">import</span> org.springframework.test.web.servlet.MockMvc;</div><div class="line"><span class="keyword">import</span> org.springframework.test.web.servlet.setup.MockMvcBuilders;</div><div class="line"><span class="keyword">import</span> org.springframework.web.context.WebApplicationContext;</div><div class="line"></div><div class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</div><div class="line"></div><div class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</div><div class="line"><span class="meta">@WebAppConfiguration</span>(value = <span class="string">"src/main/webapp"</span>)</div><div class="line"><span class="meta">@ContextConfiguration</span>(&#123; <span class="string">"classpath:test-context.xml"</span> &#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserControllerTest</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="meta">@Autowired</span></div><div class="line">  <span class="keyword">private</span> WebApplicationContext wac;</div><div class="line">  <span class="meta">@Autowired</span></div><div class="line">  <span class="keyword">private</span> UserServiceImpl userService;</div><div class="line">  <span class="keyword">private</span> MockMvc mockMvc;</div><div class="line"></div><div class="line">  <span class="meta">@Before</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</div><div class="line">    MockitoAnnotations.initMocks(<span class="keyword">this</span>);</div><div class="line">    mockMvc = MockMvcBuilders.webAppContextSetup(wac).build();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Test</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> userId = <span class="number">3</span>;</div><div class="line"></div><div class="line">    Mockito.when(userService.getUser(userId)).thenAnswer(<span class="keyword">new</span> Answer&lt;User&gt;() &#123;</div><div class="line"></div><div class="line">      <span class="function"><span class="keyword">public</span> User <span class="title">answer</span><span class="params">(InvocationOnMock invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        User user = <span class="keyword">new</span> User();</div><div class="line">        user.setId(userId);</div><div class="line">        user.setAge(<span class="number">16</span>);</div><div class="line">        user.setFirstName(<span class="string">"bob"</span>);</div><div class="line">        <span class="keyword">return</span> user;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    mockMvc.perform(get(<span class="string">"/user/"</span> + userId)).andExpect(status().isOk())</div><div class="line">        .andExpect(content().contentTypeCompatibleWith(MediaType.APPLICATION_JSON))</div><div class="line">        .andExpect(jsonPath(<span class="string">"$.data.age"</span>, is(<span class="number">16</span>))).andExpect(jsonPath(<span class="string">"$.data.firstName"</span>, is(<span class="string">"bob"</span>)))</div><div class="line">        .andExpect(jsonPath(<span class="string">"$.data.id"</span>, is(userId))).andExpect(jsonPath(<span class="string">"$.success"</span>, is(<span class="keyword">true</span>)));</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Test</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSave</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    mockMvc.perform(post(<span class="string">"/user"</span>).contentType(MediaType.APPLICATION_JSON).content(JSON.toJSONString(<span class="keyword">new</span> User())))</div><div class="line">        .andExpect(status().isOk()).andExpect(content().contentTypeCompatibleWith(MediaType.APPLICATION_JSON))</div><div class="line">        .andExpect(jsonPath(<span class="string">"$.success"</span>, is(<span class="keyword">true</span>)));</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="其它代码"><a href="#其它代码" class="headerlink" title="其它代码"></a>其它代码</h3><h4 id="UserServiceImpl类"><a href="#UserServiceImpl类" class="headerlink" title="UserServiceImpl类"></a>UserServiceImpl类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.zsr.mvc.service.impl;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.zsr.mvc.domain.User;</div><div class="line"><span class="keyword">import</span> org.zsr.mvc.service.IUserService;</div><div class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</div><div class="line"></div><div class="line"><span class="meta">@Service</span>(<span class="string">"userService"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">IUserService</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</div><div class="line">    User user = <span class="keyword">new</span> User();</div><div class="line">    <span class="keyword">return</span> user;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span><span class="params">(User user)</span> </span>&#123;</div><div class="line"></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="RestResponse类"><a href="#RestResponse类" class="headerlink" title="RestResponse类"></a>RestResponse类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.zsr.mvc.rest;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestResponse</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> success;</div><div class="line">    <span class="keyword">private</span> String message;</div><div class="line">    <span class="keyword">private</span> T data;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RestResponse</span><span class="params">(<span class="keyword">boolean</span> success, String message, T data)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.success = success;</div><div class="line">        <span class="keyword">this</span>.message = message;</div><div class="line">        <span class="keyword">this</span>.data = data;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="UserController类"><a href="#UserController类" class="headerlink" title="UserController类"></a>UserController类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.zsr.mvc.controller;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.zsr.mvc.domain.User;</div><div class="line"><span class="keyword">import</span> org.zsr.mvc.rest.RestResponse;</div><div class="line"><span class="keyword">import</span> org.zsr.mvc.service.IUserService;</div><div class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</div><div class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</div><div class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</div><div class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestBody;</div><div class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</div><div class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMethod;</div><div class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</div><div class="line"></div><div class="line"><span class="meta">@Controller</span></div><div class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="meta">@Autowired</span></div><div class="line">  <span class="keyword">private</span> IUserService userService;</div><div class="line"></div><div class="line">  <span class="meta">@ResponseBody</span></div><div class="line">  <span class="meta">@RequestMapping</span>(value = <span class="string">"/&#123;id&#125;"</span>, method = RequestMethod.GET)</div><div class="line">  <span class="function"><span class="keyword">public</span> RestResponse&lt;User&gt; <span class="title">getUser</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> <span class="keyword">int</span> id) </span>&#123;</div><div class="line">    User user = userService.getUser(id);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RestResponse&lt;User&gt;(<span class="keyword">true</span>, <span class="string">""</span>, user);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@ResponseBody</span></div><div class="line">  <span class="meta">@RequestMapping</span>(method = RequestMethod.POST)</div><div class="line">  <span class="function"><span class="keyword">public</span> RestResponse <span class="title">saveUser</span><span class="params">(@RequestBody User user)</span> </span>&#123;</div><div class="line">    userService.saveUser(user);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RestResponse&lt;String&gt;(<span class="keyword">true</span>, <span class="string">""</span>, <span class="keyword">null</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a><strong>参考：</strong></h3><p><a href="http://zhaozhiming.github.io/blog/2014/06/16/spring-mvc-unit-test-part-1/" target="_blank" rel="external">基于Spring MVC做单元测试</a></p>
<p><a href="http://sishuok.com/forum/blogPost/list/7981.html" target="_blank" rel="external">Spring MVC测试框架详解</a></p>
<p><a href="http://memorynotfound.com/unit-test-spring-mvc-rest-service-junit-mockito/" target="_blank" rel="external">Unit Test Spring MVC Rest Service</a></p>
<p><a href="https://blog.gmem.cc/ut-with-spring-and-mockito" target="_blank" rel="external">基于Spring Test和Mockito进行单元测试</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CopyOnWrite]]></title>
      <url>http://zsr.github.io/2017/01/23/CopyOnWrite/</url>
      <content type="html"><![CDATA[<p>Copy-On-Write简称COW，是一种用于程序设计中的优化策略。其基本思路是，从一开始大家都在共享同一个内容，当某个人想要修改这个内容的时候，才会真正把内容Copy出去形成一个新的内容然后再改，这是一种延时懒惰策略。从JDK1.5开始Java并发包里提供了两个使用CopyOnWrite机制实现的并发容器,它们是CopyOnWriteArrayList和CopyOnWriteArraySet。</p>
<p><strong>特点:</strong></p>
<ul>
<li>读取安全（但是不保证缓存一致性），写入安全（代价是加了锁，而且需要全量复制）</li>
<li>不建议用于频繁读写场景下，全量复制很容易造成GC停顿，因此建议使用平时的Concurrent包来实现。</li>
<li>适用于对象空间占用大，修改次数少，而且对数据实效性要求不高的场景。</li>
</ul>
<h3 id="什么是CopyOnWrite容器"><a href="#什么是CopyOnWrite容器" class="headerlink" title="什么是CopyOnWrite容器"></a>什么是CopyOnWrite容器</h3><p>CopyOnWrite容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。</p>
<h4 id="CopyOnWriteArrayList的实现原理"><a href="#CopyOnWriteArrayList的实现原理" class="headerlink" title="CopyOnWriteArrayList的实现原理"></a>CopyOnWriteArrayList的实现原理</h4><p>以下代码是向ArrayList里添加元素，可以发现在添加的时候是需要加锁的，否则多线程写的时候会Copy出N个副本出来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">    <span class="comment">/**</span></div><div class="line">     * 读取操作(没有加锁)</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;  </div><div class="line">       <span class="keyword">return</span> (E)(getArray()[index]);  </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/** </span></div><div class="line">     *写操作(加锁的目的：防止并发量大时，产生过多的元数据副本，耗内存) </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;  </div><div class="line">       <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;  </div><div class="line">       lock.lock();  </div><div class="line">       <span class="keyword">try</span> &#123;  </div><div class="line">          Object[] elements = getArray();  </div><div class="line">          <span class="keyword">int</span> len = elements.length;</div><div class="line">          <span class="comment">// 对元数据进行拷贝</span></div><div class="line">          Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);  </div><div class="line">          <span class="comment">// 把新元素添加到新数组里 </span></div><div class="line">          newElements[len] = e;  </div><div class="line">          <span class="comment">// 把原数组引用指向新数组</span></div><div class="line">          setArray(newElements);</div><div class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;  </div><div class="line">        &#125; <span class="keyword">finally</span> &#123;  </div><div class="line">          lock.unlock();  </div><div class="line">        &#125;  </div><div class="line">   &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>读的时候不需要加锁，如果读的时候有多个线程正在向ArrayList添加数据，读还是会读到旧的数据，因为写的时候不会锁住旧的ArrayList。</p>
<p>JDK中并没有提供CopyOnWriteMap，我们可以参考CopyOnWriteArrayList来实现一个，基本代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Collection;</div><div class="line"><span class="keyword">import</span> java.util.Map;</div><div class="line"><span class="keyword">import</span> java.util.Set;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;, <span class="title">Cloneable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;K, V&gt; internalMap;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteMap</span><span class="params">()</span> </span>&#123;</div><div class="line">        internalMap = <span class="keyword">new</span> HashMap&lt;K, V&gt;();</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line"> </div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">            Map&lt;K, V&gt; newMap = <span class="keyword">new</span> HashMap&lt;K, V&gt;(internalMap);</div><div class="line">            V val = newMap.put(key, value);</div><div class="line">            internalMap = newMap;</div><div class="line">            <span class="keyword">return</span> val;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> internalMap.get(key);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; newData)</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">            Map&lt;K, V&gt; newMap = <span class="keyword">new</span> HashMap&lt;K, V&gt;(internalMap);</div><div class="line">            newMap.putAll(newData);</div><div class="line">            internalMap = newMap;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="CopyOnWrite的应用场景"><a href="#CopyOnWrite的应用场景" class="headerlink" title="CopyOnWrite的应用场景"></a>CopyOnWrite的应用场景</h3><p>写时复制最擅长的是并发读取场景，即多个线程/进程可以通过对一份相同快照，去处理实效性要求不是很高但是仍然要做的业务（比如实现FS\DB备份、日志、分析）。</p>
<h4 id="1-Unix下的fork-系统调用"><a href="#1-Unix下的fork-系统调用" class="headerlink" title="1. Unix下的fork()系统调用"></a>1. Unix下的fork()系统调用</h4><p>fork()是一个系统调用，用于创建新的进程(process)。</p>
<p>fork内部实际上是对clone()系统函数的调用，它的参数<code>CLONE_FLAG</code>决定了需要共享哪些数据。在fork中，没有<code>CLONE_VM</code>参数，也就意味着不会共享\竞争同一个内存，而是复制一个内存快照给子进程，这个内存在32位下是4G的大小，占用空间相当的大，如果通过类似memcpy进行内存复制的话，fork调用的耗时将相当显著，甚至阻塞业务，那么为什么在真正开发调用时却没有发生呢？因为内部也是通过COW机制实现的。</p>
<p><strong>内核实现：</strong></p>
<p>在内核侧，在进行了内存“复制”后，子进程与父进程指向同一个只读的Page分页。当子进程或者父进程发送修改内存请求后，由于是分页是只读的，OS此时才将内存进行复制为两份，并将这两份内存设置为可写权限，最后再处理刚刚发送的修改内存请求。通过上述策略，实现了延迟复制.</p>
<h4 id="2-Redis的持久化"><a href="#2-Redis的持久化" class="headerlink" title="2. Redis的持久化"></a>2. Redis的持久化</h4><p>Redis是一个基于KV的MemCache框架，可以将数据全部存储在内存中，特别适用于抢购、红包等高并发场景，当你希望对数据进行全量Dump(bgsave)到文件中或者进行主从同步时，将进行下面的步骤。</p>
<ul>
<li>Redis forks. We now have a child and a parent process.</li>
<li>The child starts to write the dataset to a temporary RDB file.</li>
<li>When the child is done writing the new RDB file, it replaces the old one.</li>
</ul>
<p>可以看出，Redis通过fork()系统调用实现了写时复制，而没有自己去造轮子.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbSaveBackground</span><span class="params">(<span class="keyword">char</span> *filename)</span> </span>&#123;</div><div class="line">    <span class="keyword">pid_t</span> childpid;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> start;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (server.aof_child_pid != <span class="number">-1</span> || server.rdb_child_pid != <span class="number">-1</span>) <span class="keyword">return</span> C_ERR;</div><div class="line"></div><div class="line">    server.dirty_before_bgsave = server.dirty;</div><div class="line">    server.lastbgsave_try = time(<span class="literal">NULL</span>);</div><div class="line"></div><div class="line">    start = ustime();</div><div class="line">    <span class="comment">//指向子线程的pid如果为0，表示fork成功，为正表示为parent线程</span></div><div class="line">    <span class="keyword">if</span> ((childpid = fork()) == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">int</span> retval;</div><div class="line"></div><div class="line">        <span class="comment">/* Child进程要执行的代码 */</span></div><div class="line">        closeListeningSockets(<span class="number">0</span>);</div><div class="line">        redisSetProcTitle(<span class="string">"redis-rdb-bgsave"</span>);</div><div class="line">        retval = rdbSave(filename);</div><div class="line">        <span class="keyword">if</span> (retval == C_OK) &#123;</div><div class="line">            <span class="keyword">size_t</span> private_dirty = zmalloc_get_private_dirty();</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (private_dirty) &#123;</div><div class="line">                serverLog(LL_NOTICE,</div><div class="line">                    <span class="string">"RDB: %zu MB of memory used by copy-on-write"</span>,</div><div class="line">                    private_dirty/(<span class="number">1024</span>*<span class="number">1024</span>));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        exitFromChild((retval == C_OK) ? <span class="number">0</span> : <span class="number">1</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">/* Parent */</span></div><div class="line">        ...</div><div class="line">        <span class="keyword">return</span> C_OK;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> C_OK; <span class="comment">/* unreached */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在rdbSave中(目前已经为子线程中)，具体实现如下:</p>
<ol>
<li>创建了一个<code>temp-${getPid()}.rdb</code>的文件</li>
<li>调用<code>rioInitWithFile(rio *r, FILE *tmp)</code>，将<code>r</code>初始化为<code>rioBufferIO</code></li>
<li>对全局变量<code>server</code>进行forEach反序列化，并保持到缓存r中，并写入文件，注意这个Server指针已经与父进程无关了</li>
<li>进行fflush、fsync、fclose系统调用清除OS的FS缓存（这也是OS内部的COW优化）</li>
<li>进行<code>rename</code>系统调用，进行重命名</li>
</ol>
<p>可以看出，在Redis中没有memcpy等内存复制过程，而是直接使用server指针进行读取并写入文件，因为在fork时，已经duplicated了快照。</p>
<h3 id="CopyOnWrite容器的缺点"><a href="#CopyOnWrite容器的缺点" class="headerlink" title="CopyOnWrite容器的缺点"></a>CopyOnWrite容器的缺点</h3><p>CopyOnWrite有很多优点，但是同时也存在两个问题，即内存占用问题和数据一致性问题。</p>
<p><strong>内存占用问题</strong>。因为CopyOnWrite的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存，旧的对象和新写入的对象（<strong>注意:在复制的时候只是复制容器里的引用，只是在写的时候会创建新对象添加到新容器里，而旧容器的对象还在使用，所以有两份对象内存</strong>）。如果这些对象占用的内存比较大，比如说200M左右，那么再写入100M数据进去，内存就会占用300M，那么这个时候很有可能造成频繁的Yong GC和Full GC。</p>
<p>针对内存占用问题，可以通过压缩容器中的元素的方法来减少大对象的内存消耗，比如，如果元素全是10进制的数字，可以考虑把它压缩成36进制或64进制。或者不使用CopyOnWrite容器，而使用其他的并发容器，如<a href="http://ifeve.com/concurrenthashmap/" target="_blank" rel="external">ConcurrentHashMap</a>。</p>
<p><strong>数据一致性问题</strong>。CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用CopyOnWrite容器。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java8 HashMap]]></title>
      <url>http://zsr.github.io/2016/12/14/Java8-HashMap/</url>
      <content type="html"><![CDATA[<p>JDK1.8对HashMap底层的实现进行了优化，例如引入红黑树的数据结构和扩容的优化等.</p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h3><p>Java为数据结构中的映射定义了一个接口java.util.Map，此接口主要有四个常用的实现类，分别是HashMap、Hashtable、LinkedHashMap和TreeMap，类继承关系如下图所示：</p>
<p><img src="http://tech.meituan.com/img/java-hashmap/java.util.map%E7%B1%BB%E5%9B%BE.png" alt="java.util.map类图"></p>
<p>下面针对各个实现类的特点做一些说明：</p>
<ul>
<li>(1) HashMap：它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 HashMap最多只允许一条记录的键为null，允许多条记录的值为null。HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。</li>
<li>(2) Hashtable：Hashtable是遗留类，很多映射的常用功能与HashMap类似，不同的是它承自Dictionary类，并且是线程安全的，任一时间只有一个线程能写Hashtable，并发性不如ConcurrentHashMap，因为ConcurrentHashMap引入了分段锁。Hashtable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。</li>
<li>(3) LinkedHashMap：LinkedHashMap是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。</li>
<li>(4) TreeMap：TreeMap实现SortedMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。如果使用排序的映射，建议使用TreeMap。在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator，否则会在运行时抛出java.lang.ClassCastException类型的异常。</li>
</ul>
<p>对于上述四种Map类型的类，要求映射中的key是不可变对象。不可变对象是该对象在创建后它的哈希值不会被改变。如果对象的哈希值发生变化，Map对象很可能就定位不到映射的位置了。</p>
<p>通过上面的比较，我们知道了HashMap是Java的Map家族中一个普通成员，鉴于它可以满足大多数场景的使用条件，所以是使用频度最高的一个。</p>
<h3 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a><strong>内部实现</strong></h3><p>搞清楚HashMap，首先需要知道HashMap是什么，即它的存储结构-字段；其次弄明白它能干什么，即它的功能实现-方法。下面我们针对这两个方面详细展开讲解。</p>
<h4 id="存储结构-字段"><a href="#存储结构-字段" class="headerlink" title="存储结构-字段"></a>存储结构-字段</h4><p>从结构实现来讲，HashMap是数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下如所示。</p>
<p><img src="http://tech.meituan.com/img/java-hashmap/hashMap%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="hashMap内存结构图"></p>
<p>这里需要讲明白两个问题：数据底层具体存储的是什么？这样的存储方式有什么优点呢？</p>
<a id="more"></a>
<p>(1) 从源码可知，HashMap类中有一个重要的字段，就是 Node[] table，即哈希桶数组，明显它是一个Node的数组。我们来看Node[JDK1.8]是何物。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;    <span class="comment">//用来定位数组索引位置</span></div><div class="line">        <span class="keyword">final</span> K key;</div><div class="line">        V value;</div><div class="line">        Node&lt;K,V&gt; next;   <span class="comment">//链表的下一个node</span></div><div class="line"></div><div class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123; ... &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span></span>&#123; ... &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123; ... &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; ... &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123; ... &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123; ... &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123; ... &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Node是HashMap的一个内部类，实现了Map.Entry接口，本质是就是一个映射(键值对)。上图中的每个黑色圆点就是一个Node对象。</p>
<p>(2) HashMap就是使用哈希表来存储的。哈希表为解决冲突，可以采用开放地址法和链地址法等来解决问题，Java中HashMap采用了链地址法。链地址法，简单来说，就是数组加链表的结合。在每个数组元素上都一个链表结构，当数据被Hash后，得到数组下标，把数据放在对应下标元素的链表上。例如程序执行下面代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">map.put(<span class="string">"hello"</span>,<span class="string">"world"</span>);</div></pre></td></tr></table></figure>
<p>系统将调用”hello”这个key的hashCode()方法得到其hashCode 值（该方法适用于每个Java对象），然后再通过Hash算法的后两步运算（高位运算和取模运算，下文有介绍）来定位该键值对的存储位置，有时两个key会定位到相同的位置，表示发生了Hash碰撞。当然Hash算法计算结果越分散均匀，Hash碰撞的概率就越小，map的存取效率就会越高。</p>
<p>如果哈希桶数组很大，即使较差的Hash算法也会比较分散，如果哈希桶数组数组很小，即使好的Hash算法也会出现较多碰撞，所以就需要在空间成本和时间成本之间权衡，其实就是在根据实际情况确定哈希桶数组的大小，并在此基础上设计好的hash算法减少Hash碰撞。那么通过什么方式来控制map使得Hash碰撞的概率又小，哈希桶数组（Node[] table）占用空间又少呢？答案就是好的Hash算法和扩容机制。</p>
<p>在理解Hash和扩容流程之前，我们得先了解下HashMap的几个字段。从HashMap的默认构造函数源码可知，构造函数就是对下面几个字段进行初始化，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> threshold;             <span class="comment">// 所能容纳的key-value对极限 </span></div><div class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;    <span class="comment">// 负载因子</span></div><div class="line"><span class="keyword">int</span> modCount;  </div><div class="line"><span class="keyword">int</span> size;</div></pre></td></tr></table></figure>
<p>首先，Node[] table的初始化长度length(默认值是16)，Load factor为负载因子(默认值是0.75)，threshold是HashMap所能容纳的最大数据量的Node(键值对)个数。threshold = length * Load factor。也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数越多。</p>
<p>结合负载因子的定义公式可知，threshold就是在此Load factor和length(数组长度)对应下允许的最大元素数目，超过这个数目就重新resize(扩容)，扩容后的HashMap容量是之前容量的两倍。默认的负载因子0.75是对空间和时间效率的一个平衡选择，建议大家不要修改，除非在时间和空间比较特殊的情况下，如果内存空间很多而又对时间效率要求很高，可以降低负载因子Load factor的值；相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，这个值可以大于1。</p>
<p>size这个字段其实很好理解，就是HashMap中实际存在的键值对数量。注意和table的长度length、容纳最大键值对数量threshold的区别。而modCount字段主要用来记录HashMap内部结构发生变化的次数，主要用于迭代的快速失败。强调一点，内部结构发生变化指的是结构发生变化，例如put新键值对，但是某个key对应的value值被覆盖不属于结构变化。</p>
<p>在HashMap中，哈希桶数组table的长度length大小必须为2的n次方(一定是合数)，这是一种非常规的设计，常规的设计是把桶的大小设计为素数。相对来说素数导致冲突的概率要小于合数，具体证明可以参考<a href="http://blog.csdn.net/liuqiyao_01/article/details/14475159" target="_blank" rel="external">http://blog.csdn.net/liuqiyao_01/article/details/14475159</a>，Hashtable初始化桶大小为11，就是桶大小设计为素数的应用（Hashtable扩容后不能保证还是素数）。HashMap采用这种非常规设计，主要是为了在取模和扩容时做优化，同时为了减少冲突，HashMap定位哈希桶索引位置时，也加入了高位参与运算的过程。</p>
<p>这里存在一个问题，即使负载因子和Hash算法设计的再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，则会严重影响HashMap的性能。于是，在JDK1.8版本中，对数据结构做了进一步的优化，引入了红黑树。而当链表长度太长（默认超过8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能，其中会用到红黑树的插入、删除、查找等算法。本文不再对红黑树展开讨论，想了解更多红黑树数据结构的工作原理可以参考<a href="http://blog.csdn.net/v_july_v/article/details/6105630" target="_blank" rel="external">http://blog.csdn.net/v_july_v/article/details/6105630</a>。</p>
<h3 id="功能实现-方法"><a href="#功能实现-方法" class="headerlink" title="功能实现-方法"></a>功能实现-方法</h3><p>HashMap的内部功能实现很多，本文主要从根据key获取哈希桶数组索引位置、put方法的详细执行、扩容过程三个具有代表性的点深入展开讲解。</p>
<h4 id="1-确定哈希桶数组索引位置"><a href="#1-确定哈希桶数组索引位置" class="headerlink" title="1. 确定哈希桶数组索引位置"></a>1. 确定哈希桶数组索引位置</h4><p>不管增加、删除、查找键值对，定位到哈希桶数组的位置都是很关键的第一步。前面说过HashMap的数据结构是数组和链表的结合，所以我们当然希望这个HashMap里面的元素位置尽量分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，不用遍历链表，大大优化了查询的效率。HashMap定位数组索引位置，直接决定了hash方法的离散性能。先看看源码的实现(方法一+方法二):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">方法一：</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;   <span class="comment">//jdk1.8 &amp; jdk1.7</span></div><div class="line">     <span class="keyword">int</span> h;</div><div class="line">     <span class="comment">// h = key.hashCode() 为第一步 取hashCode值</span></div><div class="line">     <span class="comment">// h ^ (h &gt;&gt;&gt; 16)  为第二步 高位参与运算</span></div><div class="line">     <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</div><div class="line">&#125;</div><div class="line">方法二：</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;  <span class="comment">//jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的</span></div><div class="line">     <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);  <span class="comment">//第三步 取模运算</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的Hash算法本质上就是三步：<strong>取key的hashCode值、高位运算、取模运算</strong>。</p>
<p>对于任意给定的对象，只要它的hashCode()返回值相同，那么程序调用方法一所计算得到的Hash码值总是相同的。我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，模运算的消耗还是比较大的，在HashMap中是这样做的：调用方法二来计算该对象应该保存在table数组的哪个索引处。</p>
<p>这个方法非常巧妙，它通过h &amp; (table.length -1)来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当length总是2的n次方时，h&amp; (length-1)运算等价于对length取模，也就是h%length，但是&amp;比%具有更高的效率。</p>
<p>在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到高低位都参与到Hash的计算中，同时不会有太大的开销。</p>
<p>下面举例说明下，n为table的长度。</p>
<p><img src="http://tech.meituan.com/img/java-hashmap/hashMap%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E4%BE%8B%E5%9B%BE.png" alt="hashMap哈希算法例图"></p>
<h4 id="2-分析HashMap的put方法"><a href="#2-分析HashMap的put方法" class="headerlink" title="2. 分析HashMap的put方法"></a>2. 分析HashMap的put方法</h4><p>HashMap的put方法执行过程可以通过下图来理解，自己有兴趣可以去对比源码更清楚地研究学习。</p>
<p><img src="http://tech.meituan.com/img/java-hashmap/hashMap%20put%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="hashMap put方法执行流程图"></p>
<p>①.判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容；</p>
<p>②.根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③；</p>
<p>③.判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals；</p>
<p>④.判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤；</p>
<p>⑤.遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；</p>
<p>⑥.插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。</p>
<p>JDK1.8HashMap的put方法源码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"> <span class="number">1</span> <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line"> <span class="number">2</span>     <span class="comment">// 对key的hashCode()做hash</span></div><div class="line"> <span class="number">3</span>     <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</div><div class="line"> <span class="number">4</span> &#125;</div><div class="line"> <span class="number">5</span> </div><div class="line"> <span class="number">6</span> <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></div><div class="line"> <span class="number">7</span>                <span class="keyword">boolean</span> evict) &#123;</div><div class="line"> <span class="number">8</span>     Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</div><div class="line"> <span class="number">9</span>     <span class="comment">// 步骤①：tab为空则创建</span></div><div class="line"><span class="number">10</span>     <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</div><div class="line"><span class="number">11</span>         n = (tab = resize()).length;</div><div class="line"><span class="number">12</span>     <span class="comment">// 步骤②：计算index，并对null做处理 </span></div><div class="line"><span class="number">13</span>     <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>) </div><div class="line"><span class="number">14</span>         tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</div><div class="line"><span class="number">15</span>     <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">16</span>         Node&lt;K,V&gt; e; K k;</div><div class="line"><span class="number">17</span>         <span class="comment">// 步骤③：节点key存在，直接覆盖value</span></div><div class="line"><span class="number">18</span>         <span class="keyword">if</span> (p.hash == hash &amp;&amp;</div><div class="line"><span class="number">19</span>             ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line"><span class="number">20</span>             e = p;</div><div class="line"><span class="number">21</span>         <span class="comment">// 步骤④：判断该链为红黑树</span></div><div class="line"><span class="number">22</span>         <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</div><div class="line"><span class="number">23</span>             e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</div><div class="line"><span class="number">24</span>         <span class="comment">// 步骤⑤：该链为链表</span></div><div class="line"><span class="number">25</span>         <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">26</span>             <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</div><div class="line"><span class="number">27</span>                 <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">28</span>                     p.next = newNode(hash, key,value,<span class="keyword">null</span>);</div><div class="line">                        <span class="comment">//链表长度大于8转换为红黑树进行处理</span></div><div class="line"><span class="number">29</span>                     <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st  </span></div><div class="line"><span class="number">30</span>                         treeifyBin(tab, hash);</div><div class="line"><span class="number">31</span>                     <span class="keyword">break</span>;</div><div class="line"><span class="number">32</span>                 &#125;</div><div class="line">                    <span class="comment">// key已经存在直接覆盖value</span></div><div class="line"><span class="number">33</span>                 <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line"><span class="number">34</span>                     ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) </div><div class="line"><span class="number">35</span>                            <span class="keyword">break</span>;</div><div class="line"><span class="number">36</span>                 p = e;</div><div class="line"><span class="number">37</span>             &#125;</div><div class="line"><span class="number">38</span>         &#125;</div><div class="line"><span class="number">39</span>         </div><div class="line"><span class="number">40</span>         <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></div><div class="line"><span class="number">41</span>             V oldValue = e.value;</div><div class="line"><span class="number">42</span>             <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</div><div class="line"><span class="number">43</span>                 e.value = value;</div><div class="line"><span class="number">44</span>             afterNodeAccess(e);</div><div class="line"><span class="number">45</span>             <span class="keyword">return</span> oldValue;</div><div class="line"><span class="number">46</span>         &#125;</div><div class="line"><span class="number">47</span>     &#125;</div><div class="line"></div><div class="line"><span class="number">48</span>     ++modCount;</div><div class="line"><span class="number">49</span>     <span class="comment">// 步骤⑥：超过最大容量 就扩容</span></div><div class="line"><span class="number">50</span>     <span class="keyword">if</span> (++size &gt; threshold)</div><div class="line"><span class="number">51</span>         resize();</div><div class="line"><span class="number">52</span>     afterNodeInsertion(evict);</div><div class="line"><span class="number">53</span>     <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line"><span class="number">54</span> &#125;</div></pre></td></tr></table></figure>
<h4 id="3-扩容机制"><a href="#3-扩容机制" class="headerlink" title="3. 扩容机制"></a>3. 扩容机制</h4><p>扩容(resize)就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。当然Java里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组，就像我们用一个小桶装水，如果想装更多的水，就得换大水桶。</p>
<p>我们分析下resize的源码，鉴于JDK1.8融入了红黑树，较复杂，为了便于理解我们仍然使用JDK1.7的代码，好理解一些，本质上区别不大，具体区别后文再说。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"> <span class="number">1</span> <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;   <span class="comment">//传入新的容量</span></div><div class="line"> <span class="number">2</span>     Entry[] oldTable = table;    <span class="comment">//引用扩容前的Entry数组</span></div><div class="line"> <span class="number">3</span>     <span class="keyword">int</span> oldCapacity = oldTable.length;         </div><div class="line"> <span class="number">4</span>     <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;  <span class="comment">//扩容前的数组大小如果已经达到最大(2^30)了</span></div><div class="line"> <span class="number">5</span>         threshold = Integer.MAX_VALUE; <span class="comment">//修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了</span></div><div class="line"> <span class="number">6</span>         <span class="keyword">return</span>;</div><div class="line"> <span class="number">7</span>     &#125;</div><div class="line"> <span class="number">8</span>  </div><div class="line"> <span class="number">9</span>     Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];  <span class="comment">//初始化一个新的Entry数组</span></div><div class="line"><span class="number">10</span>     transfer(newTable);                         <span class="comment">//！！将数据转移到新的Entry数组里</span></div><div class="line"><span class="number">11</span>     table = newTable;                           <span class="comment">//HashMap的table属性引用新的Entry数组</span></div><div class="line"><span class="number">12</span>     threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);<span class="comment">//修改阈值</span></div><div class="line"><span class="number">13</span> &#125;</div></pre></td></tr></table></figure>
<p>这里就是使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"> <span class="number">1</span> <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</div><div class="line"> <span class="number">2</span>     Entry[] src = table;                   <span class="comment">//src引用了旧的Entry数组</span></div><div class="line"> <span class="number">3</span>     <span class="keyword">int</span> newCapacity = newTable.length;</div><div class="line"> <span class="number">4</span>     <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123; <span class="comment">//遍历旧的Entry数组</span></div><div class="line"> <span class="number">5</span>         Entry&lt;K,V&gt; e = src[j];             <span class="comment">//取得旧Entry数组的每个元素</span></div><div class="line"> <span class="number">6</span>         <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</div><div class="line"> <span class="number">7</span>             src[j] = <span class="keyword">null</span>;<span class="comment">//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）</span></div><div class="line"> <span class="number">8</span>             do &#123;</div><div class="line"> <span class="number">9</span>                 Entry&lt;K,V&gt; next = e.next;</div><div class="line"><span class="number">10</span>                 <span class="keyword">int</span> i = indexFor(e.hash, newCapacity); <span class="comment">//！！重新计算每个元素在数组中的位置</span></div><div class="line"><span class="number">11</span>                 e.next = newTable[i]; <span class="comment">//标记[1]</span></div><div class="line"><span class="number">12</span>                 newTable[i] = e;      <span class="comment">//将元素放在数组上</span></div><div class="line"><span class="number">13</span>                 e = next;             <span class="comment">//访问下一个Entry链上的元素</span></div><div class="line"><span class="number">14</span>             &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</div><div class="line"><span class="number">15</span>         &#125;</div><div class="line"><span class="number">16</span>     &#125;</div><div class="line"><span class="number">17</span> &#125;</div></pre></td></tr></table></figure>
<p>newTable[i]的引用赋给了e.next，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置；这样先放在一个索引上的元素终会被放到Entry链的尾部(如果发生了hash冲突的话），这一点和Jdk1.8有区别，下文详解。在旧数组中同一条Entry链上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上。</p>
<p>下面举个例子说明下扩容过程。假设了我们的hash算法就是简单的用key mod 一下表的大小（也就是数组的长度）。其中的哈希桶数组table的size=2， 所以key = 3、7、5，put顺序依次为 5、7、3。在mod 2以后都冲突在table[1]这里了。这里假设负载因子 loadFactor=1，即当键值对的实际大小size 大于 table的实际大小时进行扩容。接下来的三个步骤是哈希桶数组 resize成4，然后所有的Node重新rehash的过程。</p>
<p><img src="http://tech.meituan.com/img/java-hashmap/jdk1.7%E6%89%A9%E5%AE%B9%E4%BE%8B%E5%9B%BE.png" alt="jdk1.7扩容例图"></p>
<p>下面我们讲解下JDK1.8做了哪些优化。经过观测可以发现，我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。看下图可以明白这句话的意思，n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。</p>
<p><img src="http://tech.meituan.com/img/java-hashmap/hashMap%201.8%20%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E4%BE%8B%E5%9B%BE1.png" alt="hashMap 1.8 哈希算法例图1"></p>
<p>元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：</p>
<p><img src="http://tech.meituan.com/img/java-hashmap/hashMap%201.8%20%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E4%BE%8B%E5%9B%BE2.png" alt="hashMap 1.8 哈希算法例图2"></p>
<p>因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图：</p>
<p><img src="http://tech.meituan.com/img/java-hashmap/jdk1.8%20hashMap%E6%89%A9%E5%AE%B9%E4%BE%8B%E5%9B%BE.png" alt="jdk1.8 hashMap扩容例图"></p>
<p>这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。有一点注意区别，JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从上图可以看出，JDK1.8不会倒置。有兴趣的同学可以研究下JDK1.8的resize源码，写的很赞，如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line"> <span class="number">1</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</div><div class="line"> <span class="number">2</span>     Node&lt;K,V&gt;[] oldTab = table;</div><div class="line"> <span class="number">3</span>     <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</div><div class="line"> <span class="number">4</span>     <span class="keyword">int</span> oldThr = threshold;</div><div class="line"> <span class="number">5</span>     <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</div><div class="line"> <span class="number">6</span>     <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</div><div class="line"> <span class="number">7</span>         <span class="comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span></div><div class="line"> <span class="number">8</span>         <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</div><div class="line"> <span class="number">9</span>             threshold = Integer.MAX_VALUE;</div><div class="line"><span class="number">10</span>             <span class="keyword">return</span> oldTab;</div><div class="line"><span class="number">11</span>         &#125;</div><div class="line"><span class="number">12</span>         <span class="comment">// 没超过最大值，就扩充为原来的2倍</span></div><div class="line"><span class="number">13</span>         <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</div><div class="line"><span class="number">14</span>                  oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</div><div class="line"><span class="number">15</span>             newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></div><div class="line"><span class="number">16</span>     &#125;</div><div class="line"><span class="number">17</span>     <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></div><div class="line"><span class="number">18</span>         newCap = oldThr;</div><div class="line"><span class="number">19</span>     <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></div><div class="line"><span class="number">20</span>         newCap = DEFAULT_INITIAL_CAPACITY;</div><div class="line"><span class="number">21</span>         newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</div><div class="line"><span class="number">22</span>     &#125;</div><div class="line"><span class="number">23</span>     <span class="comment">// 计算新的resize上限</span></div><div class="line"><span class="number">24</span>     <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</div><div class="line"><span class="number">25</span> </div><div class="line"><span class="number">26</span>         <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</div><div class="line"><span class="number">27</span>         newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</div><div class="line"><span class="number">28</span>                   (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</div><div class="line"><span class="number">29</span>     &#125;</div><div class="line"><span class="number">30</span>     threshold = newThr;</div><div class="line"><span class="number">31</span>     <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>，<span class="string">"unchecked"</span>&#125;)</div><div class="line"><span class="number">32</span>         Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</div><div class="line"><span class="number">33</span>     table = newTab;</div><div class="line"><span class="number">34</span>     <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">35</span>         <span class="comment">// 把每个bucket都移动到新的buckets中</span></div><div class="line"><span class="number">36</span>         <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</div><div class="line"><span class="number">37</span>             Node&lt;K,V&gt; e;</div><div class="line"><span class="number">38</span>             <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">39</span>                 oldTab[j] = <span class="keyword">null</span>;</div><div class="line"><span class="number">40</span>                 <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</div><div class="line"><span class="number">41</span>                     newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</div><div class="line"><span class="number">42</span>                 <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</div><div class="line"><span class="number">43</span>                     ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</div><div class="line"><span class="number">44</span>                 <span class="keyword">else</span> &#123; <span class="comment">// 链表优化重hash的代码块</span></div><div class="line"><span class="number">45</span>                     Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</div><div class="line"><span class="number">46</span>                     Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</div><div class="line"><span class="number">47</span>                     Node&lt;K,V&gt; next;</div><div class="line"><span class="number">48</span>                     do &#123;</div><div class="line"><span class="number">49</span>                         next = e.next;</div><div class="line"><span class="number">50</span>                         <span class="comment">// 原索引</span></div><div class="line"><span class="number">51</span>                         <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</div><div class="line"><span class="number">52</span>                             <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</div><div class="line"><span class="number">53</span>                                 loHead = e;</div><div class="line"><span class="number">54</span>                             <span class="keyword">else</span></div><div class="line"><span class="number">55</span>                                 loTail.next = e;</div><div class="line"><span class="number">56</span>                             loTail = e;</div><div class="line"><span class="number">57</span>                         &#125;</div><div class="line"><span class="number">58</span>                         <span class="comment">// 原索引+oldCap</span></div><div class="line"><span class="number">59</span>                         <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">60</span>                             <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</div><div class="line"><span class="number">61</span>                                 hiHead = e;</div><div class="line"><span class="number">62</span>                             <span class="keyword">else</span></div><div class="line"><span class="number">63</span>                                 hiTail.next = e;</div><div class="line"><span class="number">64</span>                             hiTail = e;</div><div class="line"><span class="number">65</span>                         &#125;</div><div class="line"><span class="number">66</span>                     &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</div><div class="line"><span class="number">67</span>                     <span class="comment">// 原索引放到bucket里</span></div><div class="line"><span class="number">68</span>                     <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">69</span>                         loTail.next = <span class="keyword">null</span>;</div><div class="line"><span class="number">70</span>                         newTab[j] = loHead;</div><div class="line"><span class="number">71</span>                     &#125;</div><div class="line"><span class="number">72</span>                     <span class="comment">// 原索引+oldCap放到bucket里</span></div><div class="line"><span class="number">73</span>                     <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">74</span>                         hiTail.next = <span class="keyword">null</span>;</div><div class="line"><span class="number">75</span>                         newTab[j + oldCap] = hiHead;</div><div class="line"><span class="number">76</span>                     &#125;</div><div class="line"><span class="number">77</span>                 &#125;</div><div class="line"><span class="number">78</span>             &#125;</div><div class="line"><span class="number">79</span>         &#125;</div><div class="line"><span class="number">80</span>     &#125;</div><div class="line"><span class="number">81</span>     <span class="keyword">return</span> newTab;</div><div class="line"><span class="number">82</span> &#125;</div></pre></td></tr></table></figure>
<h3 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a><strong>线程安全性</strong></h3><p>在多线程使用场景中，应该尽量避免使用线程不安全的HashMap，而使用线程安全的ConcurrentHashMap。那么为什么说HashMap是线程不安全的，下面举例子说明在并发的多线程使用场景中使用HashMap可能造成死循环。代码例子如下(便于理解，仍然使用JDK1.7的环境)：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public class HashMapInfiniteLoop &#123;  </div><div class="line"></div><div class="line">    private static HashMap&lt;Integer,String&gt; map = new HashMap&lt;Integer,String&gt;(2，0.75f);  </div><div class="line">    public static void main(String[] args) &#123;  </div><div class="line">        map.put(5， "C");  </div><div class="line"></div><div class="line">        new Thread("Thread1") &#123;  </div><div class="line">            public void run() &#123;  </div><div class="line">                map.put(7, "B");  </div><div class="line">                System.out.println(map);  </div><div class="line">            &#125;;  </div><div class="line">        &#125;.start();  </div><div class="line">        new Thread("Thread2") &#123;  </div><div class="line">            public void run() &#123;  </div><div class="line">                map.put(3, "A);  </div><div class="line">                System.out.println(map);  </div><div class="line">            &#125;;  </div><div class="line">        &#125;.start();        </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中，map初始化为一个长度为2的数组，loadFactor=0.75，threshold=2*0.75=1，也就是说当put第二个key的时候，map就需要进行resize。</p>
<p>通过设置断点让线程1和线程2同时debug到transfer方法(3.3小节代码块)的首行。注意此时两个线程已经成功添加数据。放开thread1的断点至transfer方法的“Entry next = e.next;” 这一行；然后放开线程2的的断点，让线程2进行resize。结果如下图。</p>
<p><img src="http://tech.meituan.com/img/java-hashmap/jdk1.7%20hashMap%E6%AD%BB%E5%BE%AA%E7%8E%AF%E4%BE%8B%E5%9B%BE1.png" alt="jdk1.7 hashMap死循环例图1"></p>
<p>注意，Thread1的 e 指向了key(3)，而next指向了key(7)，其在线程二rehash后，指向了线程二重组后的链表。</p>
<p>线程一被调度回来执行，先是执行 newTalbe[i] = e， 然后是e = next，导致了e指向了key(7)，而下一次循环的next = e.next导致了next指向了key(3)。</p>
<p><img src="http://tech.meituan.com/img/java-hashmap/jdk1.7%20hashMap%E6%AD%BB%E5%BE%AA%E7%8E%AF%E4%BE%8B%E5%9B%BE2.png" alt="jdk1.7 hashMap死循环例图2"></p>
<p><img src="http://tech.meituan.com/img/java-hashmap/jdk1.7%20hashMap%E6%AD%BB%E5%BE%AA%E7%8E%AF%E4%BE%8B%E5%9B%BE3.png" alt="jdk1.7 hashMap死循环例图3"></p>
<p>e.next = newTable[i] 导致 key(3).next 指向了 key(7)。注意：此时的key(7).next 已经指向了key(3)， 环形链表就这样出现了。</p>
<p><img src="http://tech.meituan.com/img/java-hashmap/jdk1.7%20hashMap%E6%AD%BB%E5%BE%AA%E7%8E%AF%E4%BE%8B%E5%9B%BE4.png" alt="jdk1.7 hashMap死循环例图4"></p>
<p>于是，当我们用线程一调用map.get(11)时，悲剧就出现了——Infinite Loop。</p>
<h3 id="JDK1-8与JDK1-7的性能对比"><a href="#JDK1-8与JDK1-7的性能对比" class="headerlink" title="JDK1.8与JDK1.7的性能对比"></a><strong>JDK1.8与JDK1.7的性能对比</strong></h3><p>HashMap中，如果key经过hash算法得出的数组索引位置全部不相同，即Hash算法非常好，那样的话，getKey方法的时间复杂度就是O(1)，如果Hash算法技术的结果碰撞非常多，假如Hash算极其差，所有的Hash算法结果得出的索引位置一样，那样所有的键值对都集中到一个桶中，或者在一个链表中，或者在一个红黑树中，时间复杂度分别为O(n)和O(lgn)。 鉴于JDK1.8做了多方面的优化，总体性能优于JDK1.7，下面我们从两个方面用例子证明这一点。</p>
<h4 id="Hash较均匀的情况"><a href="#Hash较均匀的情况" class="headerlink" title="Hash较均匀的情况"></a>Hash较均匀的情况</h4><p>为了便于测试，我们先写一个类Key，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Key</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</div><div class="line"></div><div class="line">    Key(<span class="keyword">int</span> value) &#123;</div><div class="line">        <span class="keyword">this</span>.value = value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Key o)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> Integer.compare(<span class="keyword">this</span>.value, o.value);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass())</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        Key key = (Key) o;</div><div class="line">        <span class="keyword">return</span> value == key.value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> value;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个类复写了equals方法，并且提供了相当好的hashCode函数，任何一个值的hashCode都不会相同，因为直接使用value当做hashcode。为了避免频繁的GC，我将不变的Key实例缓存了起来，而不是一遍一遍的创建它们。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Keys</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_KEY = <span class="number">10_000_000</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Key[] KEYS_CACHE = <span class="keyword">new</span> Key[MAX_KEY];</div><div class="line"></div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_KEY; ++i) &#123;</div><div class="line">            KEYS_CACHE[i] = <span class="keyword">new</span> Key(i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Key <span class="title">of</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> KEYS_CACHE[value];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在开始我们的试验，测试需要做的仅仅是，创建不同size的HashMap（1、10、100、……10000000），屏蔽了扩容的情况，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> mapSize)</span> </span>&#123;</div><div class="line"></div><div class="line">     HashMap&lt;Key, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Key,Integer&gt;(mapSize);</div><div class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mapSize; ++i) &#123;</div><div class="line">         map.put(Keys.of(i), i);</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="keyword">long</span> beginTime = System.nanoTime(); <span class="comment">//获取纳秒</span></div><div class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mapSize; i++) &#123;</div><div class="line">         map.get(Keys.of(i));</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">long</span> endTime = System.nanoTime();</div><div class="line">     System.out.println(endTime - beginTime);</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">10</span>;i&lt;= <span class="number">1000</span> <span class="number">0000</span>;i*= <span class="number">10</span>)&#123;</div><div class="line">         test(i);</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>在测试中会查找不同的值，然后度量花费的时间，为了计算getKey的平均时间，我们遍历所有的get方法，计算总的时间，除以key的数量，计算一个平均值，主要用来比较，绝对值可能会受很多环境因素的影响。结果如下：</p>
<p><img src="http://tech.meituan.com/img/java-hashmap/%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83%E8%A1%A81.png" alt="性能比较表1.png"></p>
<p>通过观测测试结果可知，JDK1.8的性能要高于JDK1.7 15%以上，在某些size的区域上，甚至高于100%。由于Hash算法较均匀，JDK1.8引入的红黑树效果不明显，下面我们看看Hash不均匀的的情况。</p>
<h4 id="Hash极不均匀的情况"><a href="#Hash极不均匀的情况" class="headerlink" title="Hash极不均匀的情况"></a>Hash极不均匀的情况</h4><p>假设我们又一个非常差的Key，它们所有的实例都返回相同的hashCode值。这是使用HashMap最坏的情况。代码修改如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Key</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//...</span></div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>仍然执行main方法，得出的结果如下表所示：</p>
<p><img src="http://tech.meituan.com/img/java-hashmap/%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83%E8%A1%A82.png" alt="性能比较表2.png"></p>
<p>从表中结果中可知，随着size的变大，JDK1.7的花费时间是增长的趋势，而JDK1.8是明显的降低趋势，并且呈现对数增长稳定。当一个链表太长的时候，HashMap会动态的将它替换成一个红黑树，这话的话会将时间复杂度从O(n)降为O(logn)。hash算法均匀和不均匀所花费的时间明显也不相同，这两种情况的相对比较，可以说明一个好的hash算法的重要性。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h3><p>(1) 扩容是一个特别耗性能的操作，所以当程序员在使用HashMap的时候，估算map的大小，初始化的时候给一个大致的数值，避免map进行频繁的扩容。</p>
<p>(2) 负载因子是可以修改的，也可以大于1，但是建议不要轻易修改，除非情况非常特殊。</p>
<p>(3) HashMap是线程不安全的，不要在并发的环境中同时操作HashMap，建议使用ConcurrentHashMap。</p>
<p>(4) JDK1.8引入红黑树大程度优化了HashMap的性能。</p>
<p><a href="http://tech.meituan.com/java-hashmap.html" target="_blank" rel="external">转载</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[红黑树]]></title>
      <url>http://zsr.github.io/2016/12/13/%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
      <content type="html"><![CDATA[<p>红黑树是平衡二叉查找树的一种。为了深入理解红黑树，我们需要从二叉查找树开始讲起。</p>
<h2 id="BST"><a href="#BST" class="headerlink" title="BST"></a>BST</h2><p>二叉查找树（Binary Search Tree，简称BST）是一棵二叉树，它的左子节点的值比父节点的值要小，右节点的值要比父节点的值大。它的高度决定了它的查找效率。</p>
<p>在理想的情况下，二叉查找树增删查改的时间复杂度为O(logN)（其中N为节点数），最坏的情况下为O(N)。当它的高度为logN+1时，我们就说二叉查找树是平衡的。<br><img src="http://tech.meituan.com/img/redblack-tree/tree-all.png" alt="BST"></p>
<h3 id="BST的查找操作"><a href="#BST的查找操作" class="headerlink" title="BST的查找操作"></a>BST的查找操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">T  key = a search key</div><div class="line">Node root = <span class="function">point to the root of a BST</span></div><div class="line"></div><div class="line"><span class="title">while</span><span class="params">(<span class="keyword">true</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(root.value.equals(key))&#123;</div><div class="line">        <span class="keyword">return</span> root;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key.compareTo(root.value)&lt;<span class="number">0</span>)&#123;</div><div class="line">        root = root.left;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">        root = root.right;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</div></pre></td></tr></table></figure>
<h3 id="BST的插入操作"><a href="#BST的插入操作" class="headerlink" title="BST的插入操作"></a>BST的插入操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">Node node = create a <span class="keyword">new</span> node with specify value</div><div class="line">Node root = point the root node of a BST</div><div class="line">Node parent = <span class="keyword">null</span>;</div><div class="line"></div><div class="line"><span class="comment">//find the parent node to append the new node</span></div><div class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">   <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">break</span>;</div><div class="line">   parent = root;</div><div class="line">   <span class="keyword">if</span>(node.value.compareTo(root.value)&lt;=<span class="number">0</span>)&#123;</div><div class="line">      root = root.left;  </div><div class="line">   &#125;<span class="keyword">else</span>&#123;</div><div class="line">      root = root.right;</div><div class="line">   &#125; </div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span>(parent!=<span class="keyword">null</span>)&#123;</div><div class="line">   <span class="keyword">if</span>(node.value.compareTo(parent.value)&lt;=<span class="number">0</span>)&#123;<span class="comment">//append to left</span></div><div class="line">      parent.left = node;</div><div class="line">   &#125;<span class="keyword">else</span>&#123;<span class="comment">//append to right</span></div><div class="line">      parent.right = node;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>插入操作先通过循环查找到待插入的节点的父节点，和查找父节点的逻辑一样，都是比大小，小的往左，大的往右。找到父节点后，对比父节点，小的就插入到父节点的左节点，大就插入到父节点的右节点上。</p>
<h3 id="BST的删除操作"><a href="#BST的删除操作" class="headerlink" title="BST的删除操作"></a>BST的删除操作</h3><p>删除操作的步骤如下：</p>
<ol>
<li>查找到要删除的节点。</li>
<li>如果待删除的节点是叶子节点，则直接删除。</li>
<li>如果待删除的节点不是叶子节点，则先找到待删除节点的中序遍历的后继节点，用该后继节点的值替换待删除的节点的值，然后删除后继节点。</li>
</ol>
<p><img src="http://tech.meituan.com/img/redblack-tree/bst-tree-remove.png" alt="BST remove"></p>
<p><strong>BST存在的问题</strong></p>
<p>BST存在的主要问题是，数在插入的时候会导致树倾斜，不同的插入顺序会导致树的高度不一样，而树的高度直接的影响了树的查找效率。理想的高度是logN，最坏的情况是所有的节点都在一条斜线上，这样的树的高度为N。</p>
<a id="more"></a>
<h2 id="RBTree"><a href="#RBTree" class="headerlink" title="RBTree"></a>RBTree</h2><p>基于BST存在的问题，一种新的树——平衡二叉查找树(Balanced BST)产生了。平衡树在插入和删除的时候，会通过旋转操作将高度保持在logN。其中两款具有代表性的平衡树分别为AVL树和红黑树。AVL树由于实现比较复杂，而且插入和删除性能差，在实际环境下的应用不如红黑树。</p>
<p>红黑树（Red-Black Tree，以下简称RBTree）的实际应用非常广泛，比如Linux内核中的完全公平调度器、高精度计时器、ext3文件系统等等，各种语言的函数库如Java的TreeMap和TreeSet，C++ STL的map、multimap、multiset等。</p>
<p>RBTree也是函数式语言中最常用的持久数据结构之一，在计算几何中也有重要作用。值得一提的是，Java 8中HashMap的实现也因为用RBTree取代链表，性能有所提升。</p>
<h3 id="RBTree的定义"><a href="#RBTree的定义" class="headerlink" title="RBTree的定义"></a>RBTree的定义</h3><p>RBTree的定义如下:</p>
<ol>
<li>任何一个节点都有颜色，黑色或者红色</li>
<li>根节点是黑色的</li>
<li>父子节点之间不能出现两个连续的红节点</li>
<li>任何一个节点向下遍历到其子孙的叶子节点，所经过的黑节点个数必须相等</li>
<li>空节点被认为是黑色的</li>
</ol>
<p>数据结构表示如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span>  <span class="title">Node</span>&lt;<span class="title">T</span>&gt;</span>&#123;</div><div class="line">   <span class="keyword">public</span>  T value;</div><div class="line">   <span class="keyword">public</span>   Node&lt;T&gt; parent;</div><div class="line">   <span class="keyword">public</span>   Node&lt;T&gt; left;</div><div class="line">   <span class="keyword">public</span>   Node&lt;T&gt; right;</div><div class="line">   <span class="keyword">public</span>   <span class="keyword">boolean</span> isRed;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>RBTree在理论上还是一棵BST树，但是它在对BST的插入和删除操作时会维持树的平衡，即保证树的高度在[logN,logN+1]（理论上，极端的情况下可以出现RBTree的高度达到2*logN，但实际上很难遇到）。这样RBTree的查找时间复杂度始终保持在O(logN)从而接近于理想的BST。RBTree的删除和插入操作的时间复杂度也是O(logN)。RBTree的查找操作就是BST的查找操作。</p>
<h3 id="RBTree的旋转操作"><a href="#RBTree的旋转操作" class="headerlink" title="RBTree的旋转操作"></a>RBTree的旋转操作</h3><p>旋转操作(Rotate)的目的是使节点颜色符合定义，让RBTree的高度达到平衡。<br>Rotate分为left-rotate（左旋）和right-rotate（右旋），区分左旋和右旋的方法是：待旋转的节点从左边上升到父节点就是右旋，待旋转的节点从右边上升到父节点就是左旋。</p>
<p><img src="http://tech.meituan.com/img/redblack-tree/rotate-all.png" alt="BST remove"></p>
<h3 id="RBTree的查找操作"><a href="#RBTree的查找操作" class="headerlink" title="RBTree的查找操作"></a>RBTree的查找操作</h3><p>RBTree的查找操作和BST的查找操作是一样的。</p>
<h3 id="RBTree的插入操作"><a href="#RBTree的插入操作" class="headerlink" title="RBTree的插入操作"></a>RBTree的插入操作</h3><p>RBTree的插入与BST的插入方式是一致的，只不过是在插入过后，可能会导致树的不平衡，这时就需要对树进行旋转操作和颜色修复（在这里简称插入修复），使得它符合RBTree的定义。</p>
<p>新插入的节点是红色的，插入修复操作如果遇到父节点的颜色为黑则修复操作结束。也就是说，只有在父节点为红色节点的时候是需要插入修复操作的。</p>
<p>插入修复操作分为以下的三种情况，而且新插入的节点的父节点都是红色的：</p>
<ol>
<li>叔叔节点也为红色。</li>
<li>叔叔节点为空，且祖父节点、父节点和新节点处于一条斜线上。</li>
<li>叔叔节点为空，且祖父节点、父节点和新节点不处于一条斜线上。</li>
</ol>
<h4 id="插入操作-case-1"><a href="#插入操作-case-1" class="headerlink" title="插入操作-case 1"></a>插入操作-case 1</h4><p>case 1的操作是将父节点和叔叔节点与祖父节点的颜色互换，这样就符合了RBTRee的定义。即维持了高度的平衡，修复后颜色也符合RBTree定义的第三条和第四条。下图中，操作完成后A节点变成了新的节点。如果A节点的父节点不是黑色的话，则继续做修复操作。<br><img src="http://tech.meituan.com/img/redblack-tree/insert-case1.png" alt="插入修复case 1"></p>
<h4 id="插入操作-case-2"><a href="#插入操作-case-2" class="headerlink" title="插入操作-case 2"></a>插入操作-case 2</h4><p>case 2的操作是将B节点进行右旋操作，并且和父节点A互换颜色。通过该修复操作RBTRee的高度和颜色都符合红黑树的定义。如果B和C节点都是右节点的话，只要将操作变成左旋就可以了。<br><img src="http://tech.meituan.com/img/redblack-tree/insert-case2.png" alt="插入修复case 2"></p>
<h4 id="插入操作-case-3"><a href="#插入操作-case-3" class="headerlink" title="插入操作-case 3"></a>插入操作-case 3</h4><p>case 3的操作是将C节点进行左旋，这样就从case 3转换成case 2了，然后针对case 2进行操作处理就行了。case 2操作做了一个右旋操作和颜色互换来达到目的。如果树的结构是下图的镜像结构，则只需要将对应的左旋变成右旋，右旋变成左旋即可。<br><img src="http://tech.meituan.com/img/redblack-tree/insert-case3.png" alt="插入修复case 3"></p>
<h4 id="插入操作的总结"><a href="#插入操作的总结" class="headerlink" title="插入操作的总结"></a>插入操作的总结</h4><p>插入后的修复操作是一个向root节点回溯的操作，一旦牵涉的节点都符合了红黑树的定义，修复操作结束。之所以会向上回溯是由于case 1操作会将父节点，叔叔节点和祖父节点进行换颜色，有可能会导致祖父节点不平衡(红黑树定义3)。这个时候需要对祖父节点为起点进行调节（向上回溯）。</p>
<p>祖父节点调节后如果还是遇到它的祖父颜色问题，操作就会继续向上回溯，直到root节点为止，根据定义root节点永远是黑色的。在向上的追溯的过程中，针对插入的3中情况进行调节。直到符合红黑树的定义为止。直到牵涉的节点都符合了红黑树的定义，修复操作结束。</p>
<p>如果上面的3中情况如果对应的操作是在右子树上，做对应的镜像操作就是了。</p>
<h3 id="RBTree的删除操作"><a href="#RBTree的删除操作" class="headerlink" title="RBTree的删除操作"></a>RBTree的删除操作</h3><p>删除操作首先需要做的也是BST的删除操作，删除操作会删除对应的节点，如果是叶子节点就直接删除，如果是非叶子节点，会用对应的中序遍历的后继节点来顶替要删除节点的位置。删除后就需要做删除修复操作，使的树符合红黑树的定义，符合定义的红黑树高度是平衡的。</p>
<p>删除修复操作在遇到被删除的节点是红色节点或者到达root节点时，修复操作完毕。</p>
<p>删除修复操作是针对删除黑色节点才有的，当黑色节点被删除后会让整个树不符合RBTree的定义的第四条。需要做的处理是从兄弟节点上借调黑色的节点过来，如果兄弟节点没有黑节点可以借调的话，就只能往上追溯，将每一级的黑节点数减去一个，使得整棵树符合红黑树的定义。</p>
<p>删除操作的总体思想是从兄弟节点借调黑色节点使树保持局部的平衡，如果局部的平衡达到了，就看整体的树是否是平衡的，如果不平衡就接着向上追溯调整。</p>
<p>删除修复操作分为四种情况(删除黑节点后)：</p>
<ol>
<li>待删除的节点的兄弟节点是红色的节点。</li>
<li>待删除的节点的兄弟节点是黑色的节点，且兄弟节点的子节点都是黑色的。</li>
<li>待调整的节点的兄弟节点是黑色的节点，且兄弟节点的左子节点是红色的，右节点是黑色的(兄弟节点在右边)，如果兄弟节点在左边的话，就是兄弟节点的右子节点是红色的，左节点是黑色的。</li>
<li>待调整的节点的兄弟节点是黑色的节点，且右子节点是是红色的(兄弟节点在右边)，如果兄弟节点在左边，则就是对应的就是左节点是红色的。</li>
</ol>
<h4 id="删除操作-case-1"><a href="#删除操作-case-1" class="headerlink" title="删除操作-case 1"></a>删除操作-case 1</h4><p>由于兄弟节点是红色节点的时候，无法借调黑节点，所以需要将兄弟节点提升到父节点，由于兄弟节点是红色的，根据RBTree的定义，兄弟节点的子节点是黑色的，就可以从它的子节点借调了。</p>
<p>case 1这样转换之后就会变成后面的case 2，case 3，或者case 4进行处理了。上升操作需要对C做一个左旋操作，如果是镜像结构的树只需要做对应的右旋操作即可。</p>
<p>之所以要做case 1操作是因为兄弟节点是红色的，无法借到一个黑节点来填补删除的黑节点。</p>
<p><img src="http://tech.meituan.com/img/redblack-tree/remove-case1.png" alt="删除情况1"></p>
<h4 id="删除操作-case-2"><a href="#删除操作-case-2" class="headerlink" title="删除操作-case 2"></a>删除操作-case 2</h4><p>case 2的删除操作是由于兄弟节点可以消除一个黑色节点，因为兄弟节点和兄弟节点的子节点都是黑色的，所以可以将兄弟节点变红，这样就可以保证树的局部的颜色符合定义了。这个时候需要将父节点A变成新的节点，继续向上调整，直到整颗树的颜色符合RBTree的定义为止。</p>
<p>case 2这种情况下之所以要将兄弟节点变红，是因为如果把兄弟节点借调过来，会导致兄弟的结构不符合RBTree的定义，这样的情况下只能是将兄弟节点也变成红色来达到颜色的平衡。当将兄弟节点也变红之后，达到了局部的平衡了，但是对于祖父节点来说是不符合定义4的。这样就需要回溯到父节点，接着进行修复操作。</p>
<p><img src="http://tech.meituan.com/img/redblack-tree/remove-case2.png" alt="删除情况2"></p>
<h4 id="删除操作-case-3"><a href="#删除操作-case-3" class="headerlink" title="删除操作-case 3"></a>删除操作-case 3</h4><p>case 3的删除操作是一个中间步骤，它的目的是将左边的红色节点借调过来，这样就可以转换成case 4状态了，在case 4状态下可以将D，E节点都阶段过来，通过将两个节点变成黑色来保证红黑树的整体平衡。</p>
<p>之所以说case-3是一个中间状态，是因为根据红黑树的定义来说，下图并不是平衡的，他是通过case 2操作完后向上回溯出现的状态。之所以会出现case 3和后面的case 4的情况，是因为可以通过借用侄子节点的红色，变成黑色来符合红黑树定义4.<br><img src="http://tech.meituan.com/img/redblack-tree/remove-case3.png" alt="删除情况3"></p>
<h4 id="删除操作-case-4"><a href="#删除操作-case-4" class="headerlink" title="删除操作-case 4"></a>删除操作-case 4</h4><p>Case 4的操作是真正的节点借调操作，通过将兄弟节点以及兄弟节点的右节点借调过来，并将兄弟节点的右子节点变成红色来达到借调两个黑节点的目的，这样的话，整棵树还是符合RBTree的定义的。</p>
<p>Case 4这种情况的发生只有在待删除的节点的兄弟节点为黑，且子节点不全部为黑，才有可能借调到两个节点来做黑节点使用，从而保持整棵树都符合红黑树的定义。<br><img src="http://tech.meituan.com/img/redblack-tree/remove-case4.png" alt="删除情况4"></p>
<p><strong>删除操作的总结</strong></p>
<p>红黑树的删除操作是最复杂的操作，复杂的地方就在于当删除了黑色节点的时候，如何从兄弟节点去借调节点，以保证树的颜色符合定义。由于红色的兄弟节点是没法借调出黑节点的，这样只能通过选择操作让他上升到父节点，而由于它是红节点，所以它的子节点就是黑的，可以借调。</p>
<p>对于兄弟节点是黑色节点的可以分成3种情况来处理，当所以的兄弟节点的子节点都是黑色节点时，可以直接将兄弟节点变红，这样局部的红黑树颜色是符合定义的。但是整颗树不一定是符合红黑树定义的，需要往上追溯继续调整。</p>
<p>对于兄弟节点的子节点为左红右黑或者 (全部为红，右红左黑)这两种情况，可以先将前面的情况通过选择转换为后一种情况，在后一种情况下，因为兄弟节点为黑，兄弟节点的右节点为红，可以借调出两个节点出来做黑节点，这样就可以保证删除了黑节点，整棵树还是符合红黑树的定义的，因为黑色节点的个数没有改变。</p>
<p>红黑树的删除操作是遇到删除的节点为红色，或者追溯调整到了root节点，这时删除的修复操作完毕。</p>
<h3 id="RBTree的Java实现"><a href="#RBTree的Java实现" class="headerlink" title="RBTree的Java实现"></a>RBTree的Java实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RBTreeNode</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</div><div class="line">    <span class="keyword">private</span> T value;<span class="comment">//node value</span></div><div class="line">    <span class="keyword">private</span> RBTreeNode&lt;T&gt; left;<span class="comment">//left child pointer</span></div><div class="line">    <span class="keyword">private</span> RBTreeNode&lt;T&gt; right;<span class="comment">//right child pointer</span></div><div class="line">    <span class="keyword">private</span> RBTreeNode&lt;T&gt; parent;<span class="comment">//parent pointer</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> red;<span class="comment">//color is red or not red</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RBTreeNode</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RBTreeNode</span><span class="params">(T value)</span></span>&#123;<span class="keyword">this</span>.value=value;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RBTreeNode</span><span class="params">(T value,<span class="keyword">boolean</span> isRed)</span></span>&#123;<span class="keyword">this</span>.value=value;<span class="keyword">this</span>.red = isRed;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getValue</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> value;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T value)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.value = value;</div><div class="line">    &#125;</div><div class="line">    <span class="function">RBTreeNode&lt;T&gt; <span class="title">getLeft</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> left;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setLeft</span><span class="params">(RBTreeNode&lt;T&gt; left)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.left = left;</div><div class="line">    &#125;</div><div class="line">    <span class="function">RBTreeNode&lt;T&gt; <span class="title">getRight</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> right;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setRight</span><span class="params">(RBTreeNode&lt;T&gt; right)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.right = right;</div><div class="line">    &#125;</div><div class="line">    <span class="function">RBTreeNode&lt;T&gt; <span class="title">getParent</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> parent;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setParent</span><span class="params">(RBTreeNode&lt;T&gt; parent)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.parent = parent;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isRed</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> red;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isBlack</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> !red;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">    * is leaf node</div><div class="line">    **/</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isLeaf</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> left==<span class="keyword">null</span> &amp;&amp; right==<span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setRed</span><span class="params">(<span class="keyword">boolean</span> red)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.red = red;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">makeRed</span><span class="params">()</span></span>&#123;</div><div class="line">        red=<span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">makeBlack</span><span class="params">()</span></span>&#123;</div><div class="line">        red=<span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> value.toString();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div><div class="line">346</div><div class="line">347</div><div class="line">348</div><div class="line">349</div><div class="line">350</div><div class="line">351</div><div class="line">352</div><div class="line">353</div><div class="line">354</div><div class="line">355</div><div class="line">356</div><div class="line">357</div><div class="line">358</div><div class="line">359</div><div class="line">360</div><div class="line">361</div><div class="line">362</div><div class="line">363</div><div class="line">364</div><div class="line">365</div><div class="line">366</div><div class="line">367</div><div class="line">368</div><div class="line">369</div><div class="line">370</div><div class="line">371</div><div class="line">372</div><div class="line">373</div><div class="line">374</div><div class="line">375</div><div class="line">376</div><div class="line">377</div><div class="line">378</div><div class="line">379</div><div class="line">380</div><div class="line">381</div><div class="line">382</div><div class="line">383</div><div class="line">384</div><div class="line">385</div><div class="line">386</div><div class="line">387</div><div class="line">388</div><div class="line">389</div><div class="line">390</div><div class="line">391</div><div class="line">392</div><div class="line">393</div><div class="line">394</div><div class="line">395</div><div class="line">396</div><div class="line">397</div><div class="line">398</div><div class="line">399</div><div class="line">400</div><div class="line">401</div><div class="line">402</div><div class="line">403</div><div class="line">404</div><div class="line">405</div><div class="line">406</div><div class="line">407</div><div class="line">408</div><div class="line">409</div><div class="line">410</div><div class="line">411</div><div class="line">412</div><div class="line">413</div><div class="line">414</div><div class="line">415</div><div class="line">416</div><div class="line">417</div><div class="line">418</div><div class="line">419</div><div class="line">420</div><div class="line">421</div><div class="line">422</div><div class="line">423</div><div class="line">424</div><div class="line">425</div><div class="line">426</div><div class="line">427</div><div class="line">428</div><div class="line">429</div><div class="line">430</div><div class="line">431</div><div class="line">432</div><div class="line">433</div><div class="line">434</div><div class="line">435</div><div class="line">436</div><div class="line">437</div><div class="line">438</div><div class="line">439</div><div class="line">440</div><div class="line">441</div><div class="line">442</div><div class="line">443</div><div class="line">444</div><div class="line">445</div><div class="line">446</div><div class="line">447</div><div class="line">448</div><div class="line">449</div><div class="line">450</div><div class="line">451</div><div class="line">452</div><div class="line">453</div><div class="line">454</div><div class="line">455</div><div class="line">456</div><div class="line">457</div><div class="line">458</div><div class="line">459</div><div class="line">460</div><div class="line">461</div><div class="line">462</div><div class="line">463</div><div class="line">464</div><div class="line">465</div><div class="line">466</div><div class="line">467</div><div class="line">468</div><div class="line">469</div><div class="line">470</div><div class="line">471</div><div class="line">472</div><div class="line">473</div><div class="line">474</div><div class="line">475</div><div class="line">476</div><div class="line">477</div><div class="line">478</div><div class="line">479</div><div class="line">480</div><div class="line">481</div><div class="line">482</div><div class="line">483</div><div class="line">484</div><div class="line">485</div><div class="line">486</div><div class="line">487</div><div class="line">488</div><div class="line">489</div><div class="line">490</div><div class="line">491</div><div class="line">492</div><div class="line">493</div><div class="line">494</div><div class="line">495</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RBTree</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RBTreeNode&lt;T&gt; root;</div><div class="line">    <span class="comment">//node number</span></div><div class="line">    <span class="keyword">private</span> java.util.concurrent.atomic.AtomicLong size = </div><div class="line">                    <span class="keyword">new</span> java.util.concurrent.atomic.AtomicLong(<span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="comment">//in overwrite mode,all node's value can not  has same    value</span></div><div class="line">    <span class="comment">//in non-overwrite mode,node can have same value, suggest don't use non-overwrite mode.</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> overrideMode=<span class="keyword">true</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RBTree</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.root = <span class="keyword">new</span> RBTreeNode&lt;T&gt;();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RBTree</span><span class="params">(<span class="keyword">boolean</span> overrideMode)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>();</div><div class="line">        <span class="keyword">this</span>.overrideMode=overrideMode;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOverrideMode</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> overrideMode;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOverrideMode</span><span class="params">(<span class="keyword">boolean</span> overrideMode)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.overrideMode = overrideMode;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * number of tree number</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> size.get();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * get the root node</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> RBTreeNode&lt;T&gt; <span class="title">getRoot</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> root.getLeft();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * add value to a new node,if this value exist in this tree,</div><div class="line">     * if value exist,it will return the exist value.otherwise return null</div><div class="line">     * if override mode is true,if value exist in the tree,</div><div class="line">     * it will override the old value in the tree</div><div class="line">     * </div><div class="line">     * <span class="doctag">@param</span> value</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">addNode</span><span class="params">(T value)</span></span>&#123;</div><div class="line">        RBTreeNode&lt;T&gt; t = <span class="keyword">new</span> RBTreeNode&lt;T&gt;(value);</div><div class="line">        <span class="keyword">return</span> addNode(t);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * find the value by give value(include key,key used for search,</div><div class="line">     * other field is not used,<span class="doctag">@see</span> compare method).if this value not exist return null</div><div class="line">     * <span class="doctag">@param</span> value</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">find</span><span class="params">(T value)</span></span>&#123;</div><div class="line">        RBTreeNode&lt;T&gt; dataRoot = getRoot();</div><div class="line">        <span class="keyword">while</span>(dataRoot!=<span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">int</span> cmp = dataRoot.getValue().compareTo(value);</div><div class="line">            <span class="keyword">if</span>(cmp&lt;<span class="number">0</span>)&#123;</div><div class="line">                dataRoot = dataRoot.getRight();</div><div class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cmp&gt;<span class="number">0</span>)&#123;</div><div class="line">                dataRoot = dataRoot.getLeft();</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                <span class="keyword">return</span> dataRoot.getValue();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * remove the node by give value,if this value not exists in tree return null</div><div class="line">     * <span class="doctag">@param</span> value include search key</div><div class="line">     * <span class="doctag">@return</span> the value contain in the removed node</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">remove</span><span class="params">(T value)</span></span>&#123;</div><div class="line">        RBTreeNode&lt;T&gt; dataRoot = getRoot();</div><div class="line">        RBTreeNode&lt;T&gt; parent = root;</div><div class="line"></div><div class="line">        <span class="keyword">while</span>(dataRoot!=<span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">int</span> cmp = dataRoot.getValue().compareTo(value);</div><div class="line">            <span class="keyword">if</span>(cmp&lt;<span class="number">0</span>)&#123;</div><div class="line">                parent = dataRoot;</div><div class="line">                dataRoot = dataRoot.getRight();</div><div class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cmp&gt;<span class="number">0</span>)&#123;</div><div class="line">                parent = dataRoot;</div><div class="line">                dataRoot = dataRoot.getLeft();</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                <span class="keyword">if</span>(dataRoot.getRight()!=<span class="keyword">null</span>)&#123;</div><div class="line">                    RBTreeNode&lt;T&gt; min = removeMin(dataRoot.getRight());</div><div class="line">                    <span class="comment">//x used for fix color balance</span></div><div class="line">                    RBTreeNode&lt;T&gt; x = min.getRight()==<span class="keyword">null</span> ? min.getParent() : min.getRight();</div><div class="line">                    <span class="keyword">boolean</span> isParent = min.getRight()==<span class="keyword">null</span>;</div><div class="line"></div><div class="line">                    min.setLeft(dataRoot.getLeft());</div><div class="line">                    setParent(dataRoot.getLeft(),min);</div><div class="line">                    <span class="keyword">if</span>(parent.getLeft()==dataRoot)&#123;</div><div class="line">                        parent.setLeft(min);</div><div class="line">                    &#125;<span class="keyword">else</span>&#123;</div><div class="line">                        parent.setRight(min);</div><div class="line">                    &#125;</div><div class="line">                    setParent(min,parent);</div><div class="line"></div><div class="line">                    <span class="keyword">boolean</span> curMinIsBlack = min.isBlack();</div><div class="line">                    <span class="comment">//inherit dataRoot's color</span></div><div class="line">                    min.setRed(dataRoot.isRed());</div><div class="line"></div><div class="line">                    <span class="keyword">if</span>(min!=dataRoot.getRight())&#123;</div><div class="line">                        min.setRight(dataRoot.getRight());</div><div class="line">                        setParent(dataRoot.getRight(),min);</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">//remove a black node,need fix color</span></div><div class="line">                    <span class="keyword">if</span>(curMinIsBlack)&#123;</div><div class="line">                        <span class="keyword">if</span>(min!=dataRoot.getRight())&#123;</div><div class="line">                            fixRemove(x,isParent);</div><div class="line">                        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(min.getRight()!=<span class="keyword">null</span>)&#123;</div><div class="line">                            fixRemove(min.getRight(),<span class="keyword">false</span>);</div><div class="line">                        &#125;<span class="keyword">else</span>&#123;</div><div class="line">                            fixRemove(min,<span class="keyword">true</span>);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;<span class="keyword">else</span>&#123;</div><div class="line">                    setParent(dataRoot.getLeft(),parent);</div><div class="line">                    <span class="keyword">if</span>(parent.getLeft()==dataRoot)&#123;</div><div class="line">                        parent.setLeft(dataRoot.getLeft());</div><div class="line">                    &#125;<span class="keyword">else</span>&#123;</div><div class="line">                        parent.setRight(dataRoot.getLeft());</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">//current node is black and tree is not empty</span></div><div class="line">                    <span class="keyword">if</span>(dataRoot.isBlack() &amp;&amp; !(root.getLeft()==<span class="keyword">null</span>))&#123;</div><div class="line">                        RBTreeNode&lt;T&gt; x = dataRoot.getLeft()==<span class="keyword">null</span> </div><div class="line">                                            ? parent :dataRoot.getLeft();</div><div class="line">                        <span class="keyword">boolean</span> isParent = dataRoot.getLeft()==<span class="keyword">null</span>;</div><div class="line">                        fixRemove(x,isParent);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                setParent(dataRoot,<span class="keyword">null</span>);</div><div class="line">                dataRoot.setLeft(<span class="keyword">null</span>);</div><div class="line">                dataRoot.setRight(<span class="keyword">null</span>);</div><div class="line">                <span class="keyword">if</span>(getRoot()!=<span class="keyword">null</span>)&#123;</div><div class="line">                    getRoot().setRed(<span class="keyword">false</span>);</div><div class="line">                    getRoot().setParent(<span class="keyword">null</span>);</div><div class="line">                &#125;</div><div class="line">                size.decrementAndGet();</div><div class="line">                <span class="keyword">return</span> dataRoot.getValue();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * fix remove action</div><div class="line">     * <span class="doctag">@param</span> node</div><div class="line">     * <span class="doctag">@param</span> isParent</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixRemove</span><span class="params">(RBTreeNode&lt;T&gt; node,<span class="keyword">boolean</span> isParent)</span></span>&#123;</div><div class="line">        RBTreeNode&lt;T&gt; cur = isParent ? <span class="keyword">null</span> : node;</div><div class="line">        <span class="keyword">boolean</span> isRed = isParent ? <span class="keyword">false</span> : node.isRed();</div><div class="line">        RBTreeNode&lt;T&gt; parent = isParent ? node : node.getParent();</div><div class="line"></div><div class="line">        <span class="keyword">while</span>(!isRed &amp;&amp; !isRoot(cur))&#123;</div><div class="line">            RBTreeNode&lt;T&gt; sibling = getSibling(cur,parent);</div><div class="line">            <span class="comment">//sibling is not null,due to before remove tree color is balance</span></div><div class="line"></div><div class="line">            <span class="comment">//if cur is a left node</span></div><div class="line">            <span class="keyword">boolean</span> isLeft = parent.getRight()==sibling;</div><div class="line">            <span class="keyword">if</span>(sibling.isRed() &amp;&amp; !isLeft)&#123;<span class="comment">//case 1</span></div><div class="line">                <span class="comment">//cur in right</span></div><div class="line">                parent.makeRed();</div><div class="line">                sibling.makeBlack();</div><div class="line">                rotateRight(parent);</div><div class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sibling.isRed() &amp;&amp; isLeft)&#123;</div><div class="line">                <span class="comment">//cur in left</span></div><div class="line">                parent.makeRed();</div><div class="line">                sibling.makeBlack();</div><div class="line">                rotateLeft(parent);</div><div class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(isBlack(sibling.getLeft()) &amp;&amp; isBlack(sibling.getRight()))&#123;<span class="comment">//case 2</span></div><div class="line">                sibling.makeRed();</div><div class="line">                cur = parent;</div><div class="line">                isRed = cur.isRed();</div><div class="line">                parent=parent.getParent();</div><div class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(isLeft &amp;&amp; !isBlack(sibling.getLeft()) </div><div class="line">                                    &amp;&amp; isBlack(sibling.getRight()))&#123;<span class="comment">//case 3</span></div><div class="line">                sibling.makeRed();</div><div class="line">                sibling.getLeft().makeBlack();</div><div class="line">                rotateRight(sibling);</div><div class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!isLeft &amp;&amp; !isBlack(sibling.getRight()) </div><div class="line">                                            &amp;&amp; isBlack(sibling.getLeft()) )&#123;</div><div class="line">                sibling.makeRed();</div><div class="line">                sibling.getRight().makeBlack();</div><div class="line">                rotateLeft(sibling);</div><div class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(isLeft &amp;&amp; !isBlack(sibling.getRight()))&#123;<span class="comment">//case 4</span></div><div class="line">                sibling.setRed(parent.isRed());</div><div class="line">                parent.makeBlack();</div><div class="line">                sibling.getRight().makeBlack();</div><div class="line">                rotateLeft(parent);</div><div class="line">                cur=getRoot();</div><div class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!isLeft &amp;&amp; !isBlack(sibling.getLeft()))&#123;</div><div class="line">                sibling.setRed(parent.isRed());</div><div class="line">                parent.makeBlack();</div><div class="line">                sibling.getLeft().makeBlack();</div><div class="line">                rotateRight(parent);</div><div class="line">                cur=getRoot();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(isRed)&#123;</div><div class="line">            cur.makeBlack();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(getRoot()!=<span class="keyword">null</span>)&#123;</div><div class="line">            getRoot().setRed(<span class="keyword">false</span>);</div><div class="line">            getRoot().setParent(<span class="keyword">null</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="comment">//get sibling node</span></div><div class="line">    <span class="function"><span class="keyword">private</span> RBTreeNode&lt;T&gt; <span class="title">getSibling</span><span class="params">(RBTreeNode&lt;T&gt; node,RBTreeNode&lt;T&gt; parent)</span></span>&#123;</div><div class="line">        parent = node==<span class="keyword">null</span> ? parent : node.getParent();</div><div class="line">        <span class="keyword">if</span>(node==<span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> parent.getLeft()==<span class="keyword">null</span> ? parent.getRight() : parent.getLeft();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(node==parent.getLeft())&#123;</div><div class="line">            <span class="keyword">return</span> parent.getRight();</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">return</span> parent.getLeft();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isBlack</span><span class="params">(RBTreeNode&lt;T&gt; node)</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> node==<span class="keyword">null</span> || node.isBlack();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isRoot</span><span class="params">(RBTreeNode&lt;T&gt; node)</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> root.getLeft() == node &amp;&amp; node.getParent()==<span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * find the successor node</div><div class="line">     * <span class="doctag">@param</span> node current node's right node</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> RBTreeNode&lt;T&gt; <span class="title">removeMin</span><span class="params">(RBTreeNode&lt;T&gt; node)</span></span>&#123;</div><div class="line">        <span class="comment">//find the min node</span></div><div class="line">        RBTreeNode&lt;T&gt; parent = node;</div><div class="line">        <span class="keyword">while</span>(node!=<span class="keyword">null</span> &amp;&amp; node.getLeft()!=<span class="keyword">null</span>)&#123;</div><div class="line">            parent = node;</div><div class="line">            node = node.getLeft();</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//remove min node</span></div><div class="line">        <span class="keyword">if</span>(parent==node)&#123;</div><div class="line">            <span class="keyword">return</span> node;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        parent.setLeft(node.getRight());</div><div class="line">        setParent(node.getRight(),parent);</div><div class="line"></div><div class="line">        <span class="comment">//don't remove right pointer,it is used for fixed color balance</span></div><div class="line">        <span class="comment">//node.setRight(null);</span></div><div class="line">        <span class="keyword">return</span> node;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> T <span class="title">addNode</span><span class="params">(RBTreeNode&lt;T&gt; node)</span></span>&#123;</div><div class="line">        node.setLeft(<span class="keyword">null</span>);</div><div class="line">        node.setRight(<span class="keyword">null</span>);</div><div class="line">        node.setRed(<span class="keyword">true</span>);</div><div class="line">        setParent(node,<span class="keyword">null</span>);</div><div class="line">        <span class="keyword">if</span>(root.getLeft()==<span class="keyword">null</span>)&#123;</div><div class="line">            root.setLeft(node);</div><div class="line">            <span class="comment">//root node is black</span></div><div class="line">            node.setRed(<span class="keyword">false</span>);</div><div class="line">            size.incrementAndGet();</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            RBTreeNode&lt;T&gt; x = findParentNode(node);</div><div class="line">            <span class="keyword">int</span> cmp = x.getValue().compareTo(node.getValue());</div><div class="line"></div><div class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.overrideMode &amp;&amp; cmp==<span class="number">0</span>)&#123;</div><div class="line">                T v = x.getValue();</div><div class="line">                x.setValue(node.getValue());</div><div class="line">                <span class="keyword">return</span> v;</div><div class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cmp==<span class="number">0</span>)&#123;</div><div class="line">                <span class="comment">//value exists,ignore this node</span></div><div class="line">                <span class="keyword">return</span> x.getValue();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            setParent(node,x);</div><div class="line"></div><div class="line">            <span class="keyword">if</span>(cmp&gt;<span class="number">0</span>)&#123;</div><div class="line">                x.setLeft(node);</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                x.setRight(node);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            fixInsert(node);</div><div class="line">            size.incrementAndGet();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * find the parent node to hold node x,if parent value equals x.value return parent.</div><div class="line">     * <span class="doctag">@param</span> x</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> RBTreeNode&lt;T&gt; <span class="title">findParentNode</span><span class="params">(RBTreeNode&lt;T&gt; x)</span></span>&#123;</div><div class="line">        RBTreeNode&lt;T&gt; dataRoot = getRoot();</div><div class="line">        RBTreeNode&lt;T&gt; child = dataRoot;</div><div class="line"></div><div class="line">        <span class="keyword">while</span>(child!=<span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">int</span> cmp = child.getValue().compareTo(x.getValue());</div><div class="line">            <span class="keyword">if</span>(cmp==<span class="number">0</span>)&#123;</div><div class="line">                <span class="keyword">return</span> child;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(cmp&gt;<span class="number">0</span>)&#123;</div><div class="line">                dataRoot = child;</div><div class="line">                child = child.getLeft();</div><div class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cmp&lt;<span class="number">0</span>)&#123;</div><div class="line">                dataRoot = child;</div><div class="line">                child = child.getRight();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> dataRoot;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * red black tree insert fix.</div><div class="line">     * <span class="doctag">@param</span> x</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixInsert</span><span class="params">(RBTreeNode&lt;T&gt; x)</span></span>&#123;</div><div class="line">        RBTreeNode&lt;T&gt; parent = x.getParent();</div><div class="line"></div><div class="line">        <span class="keyword">while</span>(parent!=<span class="keyword">null</span> &amp;&amp; parent.isRed())&#123;</div><div class="line">            RBTreeNode&lt;T&gt; uncle = getUncle(x);</div><div class="line">            <span class="keyword">if</span>(uncle==<span class="keyword">null</span>)&#123;<span class="comment">//need to rotate</span></div><div class="line">                RBTreeNode&lt;T&gt; ancestor = parent.getParent();</div><div class="line">                <span class="comment">//ancestor is not null due to before before add,tree color is balance</span></div><div class="line">                <span class="keyword">if</span>(parent == ancestor.getLeft())&#123;</div><div class="line">                    <span class="keyword">boolean</span> isRight = x == parent.getRight();</div><div class="line">                    <span class="keyword">if</span>(isRight)&#123;</div><div class="line">                        rotateLeft(parent);</div><div class="line">                    &#125;</div><div class="line">                    rotateRight(ancestor);</div><div class="line"></div><div class="line">                    <span class="keyword">if</span>(isRight)&#123;</div><div class="line">                        x.setRed(<span class="keyword">false</span>);</div><div class="line">                        parent=<span class="keyword">null</span>;<span class="comment">//end loop</span></div><div class="line">                    &#125;<span class="keyword">else</span>&#123;</div><div class="line">                        parent.setRed(<span class="keyword">false</span>);</div><div class="line">                    &#125;</div><div class="line">                    ancestor.setRed(<span class="keyword">true</span>);</div><div class="line">                &#125;<span class="keyword">else</span>&#123;</div><div class="line">                    <span class="keyword">boolean</span> isLeft = x == parent.getLeft();</div><div class="line">                    <span class="keyword">if</span>(isLeft)&#123;</div><div class="line">                        rotateRight(parent);</div><div class="line">                    &#125;</div><div class="line">                    rotateLeft(ancestor);</div><div class="line"></div><div class="line">                    <span class="keyword">if</span>(isLeft)&#123;</div><div class="line">                        x.setRed(<span class="keyword">false</span>);</div><div class="line">                        parent=<span class="keyword">null</span>;<span class="comment">//end loop</span></div><div class="line">                    &#125;<span class="keyword">else</span>&#123;</div><div class="line">                        parent.setRed(<span class="keyword">false</span>);</div><div class="line">                    &#125;</div><div class="line">                    ancestor.setRed(<span class="keyword">true</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//uncle is red</span></div><div class="line">                parent.setRed(<span class="keyword">false</span>);</div><div class="line">                uncle.setRed(<span class="keyword">false</span>);</div><div class="line">                parent.getParent().setRed(<span class="keyword">true</span>);</div><div class="line">                x=parent.getParent();</div><div class="line">                parent = x.getParent();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        getRoot().makeBlack();</div><div class="line">        getRoot().setParent(<span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * get uncle node</div><div class="line">     * <span class="doctag">@param</span> node</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> RBTreeNode&lt;T&gt; <span class="title">getUncle</span><span class="params">(RBTreeNode&lt;T&gt; node)</span></span>&#123;</div><div class="line">        RBTreeNode&lt;T&gt; parent = node.getParent();</div><div class="line">        RBTreeNode&lt;T&gt; ancestor = parent.getParent();</div><div class="line">        <span class="keyword">if</span>(ancestor==<span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(parent == ancestor.getLeft())&#123;</div><div class="line">            <span class="keyword">return</span> ancestor.getRight();</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">return</span> ancestor.getLeft();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rotateLeft</span><span class="params">(RBTreeNode&lt;T&gt; node)</span></span>&#123;</div><div class="line">        RBTreeNode&lt;T&gt; right = node.getRight();</div><div class="line">        <span class="keyword">if</span>(right==<span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> java.lang.IllegalStateException(<span class="string">"right node is null"</span>);</div><div class="line">        &#125;</div><div class="line">        RBTreeNode&lt;T&gt; parent = node.getParent();</div><div class="line">        node.setRight(right.getLeft());</div><div class="line">        setParent(right.getLeft(),node);</div><div class="line"></div><div class="line">        right.setLeft(node);</div><div class="line">        setParent(node,right);</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(parent==<span class="keyword">null</span>)&#123;<span class="comment">//node pointer to root</span></div><div class="line">            <span class="comment">//right  raise to root node</span></div><div class="line">            root.setLeft(right);</div><div class="line">            setParent(right,<span class="keyword">null</span>);</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">if</span>(parent.getLeft()==node)&#123;</div><div class="line">                parent.setLeft(right);</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                parent.setRight(right);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//right.setParent(parent);</span></div><div class="line">            setParent(right,parent);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rotateRight</span><span class="params">(RBTreeNode&lt;T&gt; node)</span></span>&#123;</div><div class="line">        RBTreeNode&lt;T&gt; left = node.getLeft();</div><div class="line">        <span class="keyword">if</span>(left==<span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> java.lang.IllegalStateException(<span class="string">"left node is null"</span>);</div><div class="line">        &#125;</div><div class="line">        RBTreeNode&lt;T&gt; parent = node.getParent();</div><div class="line">        node.setLeft(left.getRight());</div><div class="line">        setParent(left.getRight(),node);</div><div class="line"></div><div class="line">        left.setRight(node);</div><div class="line">        setParent(node,left);</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(parent==<span class="keyword">null</span>)&#123;</div><div class="line">            root.setLeft(left);</div><div class="line">            setParent(left,<span class="keyword">null</span>);</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">if</span>(parent.getLeft()==node)&#123;</div><div class="line">                parent.setLeft(left);</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                parent.setRight(left);</div><div class="line">            &#125;</div><div class="line">            setParent(left,parent);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setParent</span><span class="params">(RBTreeNode&lt;T&gt; node,RBTreeNode&lt;T&gt; parent)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(node!=<span class="keyword">null</span>)&#123;</div><div class="line">            node.setParent(parent);</div><div class="line">            <span class="keyword">if</span>(parent==root)&#123;</div><div class="line">                node.setParent(<span class="keyword">null</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * debug method,it used print the given node and its children nodes,</div><div class="line">     * every layer output in one line</div><div class="line">     * <span class="doctag">@param</span> root</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printTree</span><span class="params">(RBTreeNode&lt;T&gt; root)</span></span>&#123;</div><div class="line">        java.util.LinkedList&lt;RBTreeNode&lt;T&gt;&gt; queue =<span class="keyword">new</span> java.util.LinkedList&lt;RBTreeNode&lt;T&gt;&gt;();</div><div class="line">        java.util.LinkedList&lt;RBTreeNode&lt;T&gt;&gt; queue2 =<span class="keyword">new</span> java.util.LinkedList&lt;RBTreeNode&lt;T&gt;&gt;();</div><div class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> ;</div><div class="line">        &#125;</div><div class="line">        queue.add(root);</div><div class="line">        <span class="keyword">boolean</span> firstQueue = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">        <span class="keyword">while</span>(!queue.isEmpty() || !queue2.isEmpty())&#123;</div><div class="line">            java.util.LinkedList&lt;RBTreeNode&lt;T&gt;&gt; q = firstQueue ? queue : queue2;</div><div class="line">            RBTreeNode&lt;T&gt; n = q.poll();</div><div class="line"></div><div class="line">            <span class="keyword">if</span>(n!=<span class="keyword">null</span>)&#123;</div><div class="line">                String pos = n.getParent()==<span class="keyword">null</span> ? <span class="string">""</span> : ( n == n.getParent().getLeft() </div><div class="line">                                                                        ? <span class="string">" LE"</span> : <span class="string">" RI"</span>);</div><div class="line">                String pstr = n.getParent()==<span class="keyword">null</span> ? <span class="string">""</span> : n.getParent().toString();</div><div class="line">                String cstr = n.isRed()?<span class="string">"R"</span>:<span class="string">"B"</span>;</div><div class="line">                cstr = n.getParent()==<span class="keyword">null</span> ? cstr : cstr+<span class="string">" "</span>;</div><div class="line">                System.out.print(n+<span class="string">"("</span>+(cstr)+pstr+(pos)+<span class="string">")"</span>+<span class="string">"\t"</span>);</div><div class="line">                <span class="keyword">if</span>(n.getLeft()!=<span class="keyword">null</span>)&#123;</div><div class="line">                    (firstQueue ? queue2 : queue).add(n.getLeft());</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span>(n.getRight()!=<span class="keyword">null</span>)&#123;</div><div class="line">                    (firstQueue ? queue2 : queue).add(n.getRight());</div><div class="line">                &#125;</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                System.out.println();</div><div class="line">                firstQueue = !firstQueue;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        RBTree&lt;String&gt; bst = <span class="keyword">new</span> RBTree&lt;String&gt;();</div><div class="line">        bst.addNode(<span class="string">"d"</span>);</div><div class="line">        bst.addNode(<span class="string">"d"</span>);</div><div class="line">        bst.addNode(<span class="string">"c"</span>);</div><div class="line">        bst.addNode(<span class="string">"c"</span>);</div><div class="line">        bst.addNode(<span class="string">"b"</span>);</div><div class="line">        bst.addNode(<span class="string">"f"</span>);</div><div class="line"></div><div class="line">        bst.addNode(<span class="string">"a"</span>);</div><div class="line">        bst.addNode(<span class="string">"e"</span>);</div><div class="line"></div><div class="line">        bst.addNode(<span class="string">"g"</span>);</div><div class="line">        bst.addNode(<span class="string">"h"</span>);</div><div class="line"></div><div class="line"></div><div class="line">        bst.remove(<span class="string">"c"</span>);</div><div class="line"></div><div class="line">        bst.printTree(bst.getRoot());</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>输出格式如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">d(B)</div><div class="line">b(B d LE) g(R d RI)</div><div class="line">a(R b LE) e(B g LE) h(B g RI)</div><div class="line">f(R e RI)</div></pre></td></tr></table></figure>
<p>括号左边表示元素的内容。括号内的第一个元素表示颜色，B表示black，R表示red；第二个元素表示父元素的值；第三个元素表示左右，LE表示在父元素的左边。RI表示在父元素的右边。</p>
<p>第一个元素d是root节点，由于它没有父节点，所以括号内只有一个元素。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>作为平衡二叉查找树里面众多的实现之一，红黑树无疑是最简洁、实现最为简单的。红黑树通过引入颜色的概念，通过颜色这个约束条件的使用来保持树的高度平衡。作为平衡二叉查找树，旋转是一个必不可少的操作。通过旋转可以降低树的高度，在红黑树里面还可以转换颜色。</p>
<p>红黑树里面的插入和删除的操作比较难理解，这时要注意记住一点：操作之前红黑树是平衡的，颜色是符合定义的。在操作的时候就需要向兄弟节点、父节点、侄子节点借调和互换颜色，要达到这个目的，就需要不断的进行旋转。所以红黑树的插入删除操作需要不停的旋转，一旦借调了别的节点，删除和插入的节点就会达到局部的平衡（局部符合红黑树的定义），但是被借调的节点就不会平衡了，这时就需要以被借调的节点为起点继续进行调整，直到整棵树都是平衡的。在整个修复的过程中，插入具体的分为3种情况，删除分为4种情况。</p>
<p>整个红黑树的查找，插入和删除都是O(logN)的，原因就是整个红黑树的高度是logN，查找从根到叶，走过的路径是树的高度，删除和插入操作是从叶到根的，所以经过的路径都是logN。</p>
<p><a href="http://tech.meituan.com/redblack-tree.html" target="_blank" rel="external">转载</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Redis持久化]]></title>
      <url>http://zsr.github.io/2016/12/11/Redis%E6%8C%81%E4%B9%85%E5%8C%96/</url>
      <content type="html"><![CDATA[<h1 id="Redis的持久化"><a href="#Redis的持久化" class="headerlink" title="Redis的持久化"></a>Redis的持久化</h1><p>Redis有两种持久化的方式：快照（RDB文件）和追加式文件（AOF文件）：</p>
<ul>
<li>RDB持久化方式会在一个特定的间隔保存那个时间点的一个数据快照。</li>
<li>AOF持久化方式则会记录每一个服务器收到的写操作。在服务启动时，这些记录的操作会逐条执行从而重建出原来的数据。写操作命令记录的格式跟Redis协议一致，以追加的方式进行保存。</li>
<li>Redis的持久化是可以禁用的，就是说你可以让数据的生命周期只存在于服务器的运行时间里。</li>
<li>两种方式的持久化是可以同时存在的，但是当Redis重启时，AOF文件会被优先用于重建数据。</li>
</ul>
<h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><ul>
<li>Redis调用fork()，产生一个子进程。</li>
<li>子进程把数据写到一个临时的RDB文件。</li>
<li>当子进程写完新的RDB文件后，把旧的RDB文件替换掉。</li>
</ul>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>RDB文件是一个很简洁的单文件，它保存了某个时间点的Redis数据，很适合用于做备份。你可以设定一个时间点对RDB文件进行归档，这样就能在需要的时候很轻易的把数据恢复到不同的版本。</li>
<li>基于上面所描述的特性，RDB很适合用于灾备。单文件很方便就能传输到远程的服务器上。</li>
<li>RDB的性能很好，需要进行持久化时，主进程会fork一个子进程出来，然后把持久化的工作交给子进程，自己不会有相关的I/O操作。</li>
<li>比起AOF，在数据量比较大的情况下，RDB的启动速度更快。</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>RDB容易造成数据的丢失。假设每5分钟保存一次快照，如果Redis因为某些原因不能正常工作，那么从上次产生快照到Redis出现问题这段时间的数据就会丢失了。</li>
<li>RDB使用fork()产生子进程进行数据的持久化，如果数据比较大的话可能就会花费点时间，造成Redis停止服务几毫秒。如果数据量很大且CPU性能不是很好的时候，停止服务的时间甚至会到1秒。</li>
</ul>
<h4 id="文件路径和名称"><a href="#文件路径和名称" class="headerlink" title="文件路径和名称"></a>文件路径和名称</h4><p>默认Redis会把快照文件存储为当前目录下一个名为dump.rdb的文件。要修改文件的存储路径和名称，可以通过修改配置文件redis.conf实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">RDB文件名，默认为dump.rdb。</div><div class="line">dbfilename dump.rdb</div><div class="line"></div><div class="line">文件存放的目录，AOF文件同样存放在此目录下。默认为当前工作目录。</div><div class="line">dir ./</div></pre></td></tr></table></figure>
<h4 id="保存点（RDB的启用和禁用）"><a href="#保存点（RDB的启用和禁用）" class="headerlink" title="保存点（RDB的启用和禁用）"></a>保存点（RDB的启用和禁用）</h4><p>可以配置保存点，使Redis如果在每N秒后数据发生了M次改变就保存快照文件。例如下面这个保存点配置表示每60秒，如果数据发生了1000次以上的变动，Redis就会自动保存快照文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">save 60 1000</div></pre></td></tr></table></figure>
<p>保存点可以设置多个，Redis的配置文件就默认设置了3个保存点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># 格式为：save &lt;seconds&gt; &lt;changes&gt;</div><div class="line"># 可以设置多个。</div><div class="line">save 900 1 #900秒后至少1个key有变动</div><div class="line">save 300 10 #300秒后至少10个key有变动</div><div class="line">save 60 10000 #60秒后至少10000个key有变动</div></pre></td></tr></table></figure>
<p>如果想禁用快照保存的功能，可以通过注释掉所有”save”配置达到，或者在最后一条”save”配置后添加如下的配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">save &quot;&quot;</div></pre></td></tr></table></figure>
<h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>默认情况下，如果Redis在后台生成快照的时候失败，那么就会停止接收数据，目的是让用户能知道数据没有持久化成功。但是如果你有其他的方式可以监控到Redis及其持久化的状态，那么可以把这个功能禁止掉。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">stop-writes-on-bgsave-error yes</div></pre></td></tr></table></figure>
<h4 id="数据压缩"><a href="#数据压缩" class="headerlink" title="数据压缩"></a>数据压缩</h4><p>默认Redis会采用LZF对数据进行压缩。如果你想节省点CPU的性能，你可以把压缩功能禁用掉，但是数据集就会比没压缩的时候要大。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rdbcompression yes</div></pre></td></tr></table></figure>
<h4 id="数据校验"><a href="#数据校验" class="headerlink" title="数据校验"></a>数据校验</h4><p>从版本5的RDB的开始，一个CRC64的校验码会放在文件的末尾。这样更能保证文件的完整性，但是在保存或者加载文件时会损失一定的性能（大概10%）。如果想追求更高的性能，可以把它禁用掉，这样文件在写入校验码时会用0替代，加载的时候看到0就会直接跳过校验。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rdbchecksum yes</div></pre></td></tr></table></figure>
<h4 id="手动生成快照"><a href="#手动生成快照" class="headerlink" title="手动生成快照"></a>手动生成快照</h4><p>Redis提供了两个命令用于手动生成快照:SAVE, BGSAVE。</p>
<h5 id="SAVE"><a href="#SAVE" class="headerlink" title="SAVE"></a>SAVE</h5><p>SAVE命令会使用同步的方式生成RDB快照文件，这意味着在这个过程中会阻塞所有其他客户端的请求。因此不建议在生产环境使用这个命令，除非因为某种原因需要去阻止Redis使用子进程进行后台生成快照（例如调用fork(2)出错）。</p>
<h5 id="BGSAVE"><a href="#BGSAVE" class="headerlink" title="BGSAVE"></a>BGSAVE</h5><p>BGSAVE命令使用后台的方式保存RDB文件，调用此命令后，会立刻返回OK返回码。Redis会产生一个子进程进行处理并立刻恢复对客户端的服务。在客户端我们可以使用LASTSAVE命令查看操作是否成功。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; BGSAVE</div><div class="line">Background saving started</div><div class="line">127.0.0.1:6379&gt; LASTSAVE</div><div class="line">(integer) 1433936394</div></pre></td></tr></table></figure>
<p><strong>注意：配置文件里禁用了快照生成功能不影响SAVE和BGSAVE命令的效果。</strong></p>
<a id="more"></a>
<h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>快照并不是很可靠。如果你的电脑突然宕机了，或者电源断了，又或者不小心杀掉了进程，那么最新的数据就会丢失。而AOF文件则提供了一种更为可靠的持久化方式。每当Redis接受到会修改数据集的命令时，就会把命令追加到AOF文件里，当你重启Redis时，AOF里的命令会被重新执行一次，重建数据。</p>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul>
<li>比RDB可靠。你可以制定不同的fsync策略：不进行fsync、每秒fsync一次和每次查询进行fsync。<strong>默认是每秒fsync一次。</strong>这意味着你最多丢失一秒钟的数据。</li>
<li>AOF日志文件是一个纯追加的文件。就算是遇到突然停电的情况，也不会出现日志的定位或者损坏问题。甚至如果因为某些原因（例如磁盘满了）命令只写了一半到日志文件里，我们也可以用redis-check-aof这个工具很简单的进行修复。</li>
<li>当AOF文件太大时，Redis会自动在后台进行重写。重写很安全，因为重写是在一个新的文件上进行，同时Redis会继续往旧的文件追加数据。新文件上会写入能重建当前数据集的最小操作命令的集合。当新文件重写完，Redis会把新旧文件进行切换，然后开始把数据写到新文件上。</li>
<li>AOF把操作命令以简单易懂的格式一条接一条的保存在文件里，很容易导出来用于恢复数据。例如我们不小心用FLUSHALL命令把所有数据刷掉了，只要文件没有被重写，我们可以把服务停掉，把最后那条命令删掉，然后重启服务，这样就能把被刷掉的数据恢复回来。</li>
</ul>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>在相同的数据集下，AOF文件的大小一般会比RDB文件大。</li>
<li>在某些fsync策略下，AOF的速度会比RDB慢。通常fsync设置为每秒一次就能获得比较高的性能，而在禁止fsync的情况下速度可以达到RDB的水平。</li>
<li>在过去曾经发现一些很罕见的BUG导致使用AOF重建的数据跟原数据不一致的问题。</li>
</ul>
<h4 id="启用AOF"><a href="#启用AOF" class="headerlink" title="启用AOF"></a>启用AOF</h4><p>把配置项appendonly设为yes：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">appendonly yes</div></pre></td></tr></table></figure>
<h4 id="文件路径和名称-1"><a href="#文件路径和名称-1" class="headerlink" title="文件路径和名称"></a>文件路径和名称</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">文件存放目录，与RDB共用。默认为当前工作目录。</div><div class="line">dir ./</div><div class="line"></div><div class="line">默认文件名为appendonly.aof</div><div class="line">appendfilename &quot;appendonly.aof&quot;</div></pre></td></tr></table></figure>
<h4 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h4><p>你可以配置Redis调用fsync的频率，有三个选项：</p>
<ul>
<li>每当有新命令追加到AOF的时候调用fsync。速度最慢，但是最安全。</li>
<li>每秒fsync一次。速度快（2.4版本跟快照方式速度差不多），安全性不错（最多丢失1秒的数据）。</li>
<li>从不fsync，交由系统去处理。这个方式速度最快，但是安全性一般。</li>
</ul>
<p><strong>推荐使用每秒fsync一次的方式（默认的方式），因为它速度快，安全性也不错。</strong>相关配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># appendfsync always</div><div class="line">appendfsync everysec</div><div class="line"># appendfsync no</div></pre></td></tr></table></figure>
<h4 id="日志重写"><a href="#日志重写" class="headerlink" title="日志重写"></a>日志重写</h4><p>随着写操作的不断增加，AOF文件会越来越大。例如你递增一个计数器100次，那么最终结果就是数据集里的计数器的值为最终的递增结果，但是AOF文件里却会把这100次操作完整的记录下来。而事实上要恢复这个记录，只需要1个命令就行了，也就是说AOF文件里那100条命令其实可以精简为1条。所以Redis支持这样一个功能：在不中断服务的情况下在后台重建AOF文件。</p>
<p>工作原理如下：</p>
<ul>
<li>Redis调用fork()，产生一个子进程。</li>
<li>子进程把新的AOF写到一个临时文件里。</li>
<li>主进程持续把新的变动写到内存里的buffer，同时也会把这些新的变动写到旧的AOF里，这样即使重写失败也能保证数据的安全。</li>
<li>当子进程完成文件的重写后，主进程会获得一个信号，然后把内存里的buffer追加到子进程生成的那个新AOF里。</li>
</ul>
<p>我们可以通过配置设置日志重写的条件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Redis会记住自从上一次重写后AOF文件的大小（如果自Redis启动后还没重写过，则记住启动时使用的AOF文件的大小）。</div><div class="line">如果当前的文件大小比起记住的那个大小超过指定的百分比，则会触发重写。</div><div class="line">同时需要设置一个文件大小最小值，只有大于这个值文件才会重写，以防文件很小，但是已经达到百分比的情况。</div><div class="line"></div><div class="line">auto-aof-rewrite-percentage 100</div><div class="line">auto-aof-rewrite-min-size 64mb</div></pre></td></tr></table></figure>
<p>要禁用自动的日志重写功能，我们可以把百分比设置为0：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">auto-aof-rewrite-percentage 0</div></pre></td></tr></table></figure>
<p><strong>注意：Redis 2.4以上才可以自动进行日志重写，之前的版本需要手动运行BGREWRITEAOF这个命令。</strong></p>
<h4 id="数据损坏修复"><a href="#数据损坏修复" class="headerlink" title="数据损坏修复"></a>数据损坏修复</h4><p>如果因为某些原因（例如服务器崩溃）AOF文件损坏了，导致Redis加载不了，可以通过以下方式进行修复：</p>
<ul>
<li>备份AOF文件。</li>
<li>使用redis-check-aof命令修复原始的AOF文件：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ redis-check-aof --fix</div></pre></td></tr></table></figure>
<ul>
<li>可以使用diff -u命令看下两个文件的差异。</li>
<li>使用修复过的文件重启Redis服务。</li>
</ul>
<h4 id="从RDB切换到AOF"><a href="#从RDB切换到AOF" class="headerlink" title="从RDB切换到AOF"></a>从RDB切换到AOF</h4><p>这里只说Redis &gt;= 2.2版本的方式：</p>
<ul>
<li>备份一个最新的dump.rdb的文件，并把备份文件放在一个安全的地方。</li>
<li>运行以下两条命令：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ redis-cli config set appendonly yes</div><div class="line">$ redis-cli config set save &quot;&quot;</div></pre></td></tr></table></figure>
<ul>
<li>确保数据跟切换前一致。</li>
<li>确保数据正确的写到AOF文件里。</li>
</ul>
<p><strong>第二条命令是用来禁用RDB的持久化方式，但是这不是必须的，因为你可以同时启用两种持久化方式。</strong><br><strong>记得对配置文件redis.conf进行编辑启用AOF，因为命令行方式修改配置在重启Redis后就会失效。</strong></p>
<h3 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h3><p>建议的备份方法：</p>
<ul>
<li>创建一个定时任务，每小时和每天创建一个快照，保存在不同的文件夹里。</li>
<li>定时任务运行时，把太旧的文件进行删除。例如只保留48小时的按小时创建的快照和一到两个月的按天创建的快照。</li>
<li>每天确保一次把快照文件传输到数据中心外的地方进行保存，至少不能保存在Redis服务所在的服务器。</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://redis.io/topics/persistence" target="_blank" rel="external">redis</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Epoll模型详解]]></title>
      <url>http://zsr.github.io/2016/12/11/Epoll%E6%A8%A1%E5%9E%8B/</url>
      <content type="html"><![CDATA[<p> Linux 2.6内核中提高网络I/O性能的新方法—epoll I/O多路复用技术在比较多的TCP网络服务器中有使用.</p>
<h3 id="1、为什么select落后"><a href="#1、为什么select落后" class="headerlink" title="1、为什么select落后"></a>1、为什么select落后</h3><pre><code>首先，在Linux内核中，select所用到的`FD_SET`是有限的，即内核中有个参数__FD_SETSIZE定义了每个FD_SET的句柄个数，在 我用的2.6.15-25-386内核中，该值是1024，搜索内核源代码得到：
</code></pre><p>include/linux/posix_types.h:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">define <span class="number">__F</span>D_SETSIZE         <span class="number">1024</span></div></pre></td></tr></table></figure>
<p>也就是说，如果想要同时检测1025个句柄的可读状态是不可能用select实现的。或者 同时检测1025个句柄的可写状态也是不可能的。其次，内核中实现<code>select</code>是用轮询方法，即每次检测都会遍历所有FD_SET中的句柄，显然，select函数执行时间与FD_SET中的句柄个数有一个比例关系，即 select要检测的句柄数越多就会越费时。当然，在前文中我并没有提及poll方法，事实上用select的朋友一定也试过poll，我个人觉得 select和poll大同小异，个人偏好于用select而已。</p>
<h3 id="2、内核中提高I-O性能的新方法epoll"><a href="#2、内核中提高I-O性能的新方法epoll" class="headerlink" title="2、内核中提高I/O性能的新方法epoll"></a>2、内核中提高I/O性能的新方法epoll</h3><pre><code>epoll是什么？按照man手册的说法：是为处理大批量句柄而作了改进的poll。要使用epoll只需要这三个系统调用：epoll_create(2)， epoll_ctl(2)， epoll_wait(2)。
</code></pre><h3 id="3、epoll的优点"><a href="#3、epoll的优点" class="headerlink" title="3、epoll的优点"></a>3、epoll的优点</h3><ul>
<li><p>支持一个进程打开大数目的socket描述符(FD)</p>
<p>  select 最不能忍受的是一个进程所打开的FD是有一定限制的，由FD_SETSIZE设置，默认值是2048。对于那些需要支持的上万连接数目的IM服务器来说显然太少了。这时候你一是可以选择修改这个宏然后重新编译内核，不过资料也同时指出这样会带来网络效率的下降，二是可以选择多进程的解决方案(传统的 Apache方案)，不过虽然linux上面创建进程的代价比较小，但仍旧是不可忽视的，加上进程间数据同步远比不上线程间同步的高效，所以也不是一种完 美的方案。不过epoll则没有这个限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子,在1GB内存的机器上大约是10万左 右，具体数目可以cat /proc/sys/fs/file-max察看,一般来说这个数目和系统内存关系很大。</p>
</li>
<li><p>IO 效率不随FD数目增加而线性下降</p>
<p>   传统的<code>select/poll</code>另一个致命弱点就是当你拥有一个很大的socket集合，不过由于网络延时，任一时间只有部分的socket是”活跃”的， 但是select/poll每次调用都会线性扫描全部的集合，导致效率呈现线性下降。但是<code>epoll</code>不存在这个问题，它只会对”活跃”的socket进行操作—这是因为在内核实现中epoll是根据每个fd上面的<code>callback</code>函数实现的。那么，只有”活跃”的socket才会主动的去调用 callback函数，其他idle状态socket则不会，在这点上，epoll实现了一个”伪”AIO，因为这时候推动力在os内核。在一些 benchmark中，如果所有的socket基本上都是活跃的—比如一个高速LAN环境，epoll并不比select/poll有什么效率，相反，如果过多使用epoll_ctl,效率相比还有稍微的下降。但是一旦使用idle connections模拟WAN环境,epoll的效率就远在select/poll之上了。</p>
</li>
<li><p>使用mmap加速内核与用户空间的消息传递。</p>
<p>  这点实际上涉及到epoll的具体实现了。无论是select,poll还是epoll都需要内核把FD消息通知给用户空间，如何避免不必要的内存拷贝就很重要，在这点上，epoll是通过内核与用户空间mmap(内存映射)同一块内存实现的。而如果你想我一样从2.5内核就关注epoll的话，一定不会忘记手工 mmap这一步的。</p>
</li>
<li><p>内核微调</p>
<p>  这一点其实不算epoll的优点了，而是整个linux平台的优点。也许你可以怀疑linux平台，但是你无法回避linux平台赋予你微调内核的能力。比如，内核TCP/IP协议栈使用内存池管理sk_buff结构，那么可以在运行时 期动态调整这个内存pool(skb_head_pool)的大小— 通过echo XXXX&gt;/proc/sys/net/core/hot_list_length完成。再比如listen函数的第2个参数(TCP完成3次握手的数据包队列长度)，也可以根据你平台内存大小动态调整。更甚至在一个数据包数目巨大但同时每个数据包本身大小却很小的特殊系统上尝试最新的NAPI网卡驱动架构。</p>
</li>
</ul>
<h3 id="4、epoll的工作模式"><a href="#4、epoll的工作模式" class="headerlink" title="4、epoll的工作模式"></a>4、epoll的工作模式</h3><pre><code>令人高兴的是，2.6内核的epoll比其2.5开发版本的/dev/epoll简洁了许多，所以，大部分情况下，强大的东西往往是简单的。唯一有点麻烦是epoll有2种工作方式:LT和ET。
</code></pre><p>LT(level triggered)是缺省的工作方式，并且同时支持block和no-block socket.在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你 的，所以，这种模式编程出错误可能性要小一点。传统的select/poll都是这种模型的代表．<br>ET (edge-triggered)是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述 符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了(比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致 了一个EWOULDBLOCK 错误）。但是请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once)。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Redis设计思路学习与总结]]></title>
      <url>http://zsr.github.io/2016/12/11/Redis%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>Redis是业界普遍应用的缓存组件，研究一个组件框架，最直观的办法就是从应用方的角度出发，将每个步骤的考虑一番，从这些步骤入手去研究往往能够最快的体会到一个组件框架的设计哲学。以Redis为例，每当发起一条请求时，redis是如何管理管理网络请求，收到请求后又是通过什么样的数据结构进行组织并操作内存，这些数据又是如何dump到磁盘实现持久化，再到多机环境下如何同步和保证一致性……本文就是从网络模型、数据结构设计与内存管理、持久化方法和多机四个角度简要描述了redis的设计和自己的一点体会。</p>
<h3 id="一-网络模型"><a href="#一-网络模型" class="headerlink" title="一.网络模型"></a>一.网络模型</h3><p>Redis是典型的基于Reactor的事件驱动模型，单进程单线程，高效的框架总是类似的。网络模型与select,epoll异步模型几乎一致。</p>
<p>Redis流程上整体分为<code>接受请求处理器</code>、<code>响应处理器</code>和<code>应答处理器</code>三个同步模块，每一个请求都是要经历这三个部分。</p>
<p>Redis集成了<code>libevent/epoll/kqueue/select</code>等多种事件管理机制，可以根据操作系统版本自由选择合适的管理机制，其中libevent是最优选择的机制。</p>
<p>Redis的网络模型有着所有事件驱动模型的优点，高效低耗。但是面对耗时较长的操作的时候，同样无法处理请求，只能等到事件处理完毕才能响应，比如删除redis中全量的key-value，整个操作时间较长，操作期间所有的请求都无法响应。所以了解清楚网络模型有助于在业务中扬长避短，减少长耗时的请求，尽可能多一些简单的短耗时请求发挥异步模型的最大的威力，事实上在Redis的设计中也多次体现这一点。</p>
<h3 id="二-数据结构和内存管理"><a href="#二-数据结构和内存管理" class="headerlink" title="二.数据结构和内存管理"></a>二.数据结构和内存管理</h3><h4 id="1-字符串"><a href="#1-字符串" class="headerlink" title="1.字符串"></a>1.字符串</h4><h5 id="1-1-结构"><a href="#1-1-结构" class="headerlink" title="1.1 结构"></a>1.1 结构</h5><p>Redis的字符串是对C语言原始字符串的二次封装，结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> sdshdr &#123;</div><div class="line">    <span class="keyword">long</span> len;</div><div class="line">    <span class="keyword">long</span> <span class="built_in">free</span>;</div><div class="line">    <span class="keyword">char</span> buf[];</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>可以看出，每当定义一个字符串时，除了保存字符的空间，Redis还分配了额外的空间用于管理属性字段。</p>
<h4 id="1-2-内存管理方式"><a href="#1-2-内存管理方式" class="headerlink" title="1.2 内存管理方式"></a>1.2 内存管理方式</h4><p>动态内存管理方式，动态方式最大的好处就是能够较为充分的利用内存空间，减少内存碎片化，与此同时带来的劣势就是容易引起频繁的内存抖动，通常采用“空间预分配”和“惰性空间释放”两种优化策略来减少内存抖动，redis也不例外。</p>
<p>每次修改字符串内容时，首先检查内存空间是否符合要求，否则就扩大2倍或者按M增长；减少字符串内容时，内存并不会立刻回收，而是按需回收。</p>
<p>关于内存管理的优化，最基本的出发点就是浪费一点空间还是牺牲一些时间的权衡，像STL、tcmalloc、protobuf3的arena机制等采用的核心思路都是“预分配迟回收”，Redis也是一样的。</p>
<h4 id="1-3-二进制安全"><a href="#1-3-二进制安全" class="headerlink" title="1.3 二进制安全"></a>1.3 二进制安全</h4><p>判断字符串结束与否的标识是len字段，而不是C语言的’\0’，因此是二进制安全的。<br>放心的将pb序列化后的二进制字符串存入redis。<br>简而言之，通过redis的简单封装，redis的字符串的操作更加方便，性能更友好，并且屏蔽了C语言字符串的一些需要用户关心的问题。</p>
<h3 id="2-字典（哈希）"><a href="#2-字典（哈希）" class="headerlink" title="2.字典（哈希）"></a>2.字典（哈希）</h3><p>字典的底层一定是hash，涉及到hash一定会涉及到hash算法、冲突的解决方法和hash表扩容和缩容。</p>
<h4 id="2-1-hash算法"><a href="#2-1-hash算法" class="headerlink" title="2.1 hash算法"></a>2.1 hash算法</h4><p>Redis使用的就是常用的Murmurhash2，Murmurhash算法能够给出在任意输入序列下的散列分布性，并且计算速度很快。之前做共享内存的Local-Cache的需求时也正是利用了Murmurhash的优势，解决了原有结构的hash函数散列分布性差的问题。</p>
<h4 id="2-2-hash冲突解决方法"><a href="#2-2-hash冲突解决方法" class="headerlink" title="2.2 hash冲突解决方法"></a>2.2 hash冲突解决方法</h4><p>链地址法解决hash冲突，通用解决方案没什么特殊的。多说一句，如果选用链地址解决冲突，那么势必要有一个散列性非常好的hash函数，否则hash的性能将会大大折扣。Redis选用了Murmurhash，所以可以放心大胆的采用链地址方案。</p>
<h4 id="2-3-hash扩容和缩容"><a href="#2-3-hash扩容和缩容" class="headerlink" title="2.3 hash扩容和缩容"></a>2.3 hash扩容和缩容</h4><p>维持hash表在一个合理的负载范围之内，简称为rehash过程。<br>rehash的过程也是一个权衡的过程，在做评估之前首先明确一点，不管中间采用什么样的rehash策略，rehash在宏观上看一定是：分配一个新的内存块，老数据搬到新的内存块上，释放旧内存块。<br>老数据何时搬？怎么搬？就变成了一个需要权衡的问题。<br>第一部分的网络模型上明确的指出Redis的事件驱动模型特点，不适合玩长耗时操作。如果一个hashtable非常大，需要进行扩容就一次性把老数据copy过去，那就会非常耗时，违背事件驱动的特点。所以Redis依旧采用了一种惰性的方案：<br>新空间分配完毕后，启动rehashidx标识符表明rehash过程的开始；之后所有增删改查涉及的操作时都会将数据迁移到新空间，直到老空间数据大小为0表明数据已经全部在新空间，将rehashidx禁用，表明rehash结束。<br>将一次性的集中问题分而治之，在Redis的设计哲学中体现的淋漓尽致，主要是为了避免大耗时操作，影响Redis响应客户请求。</p>
<h3 id="3-整数集合"><a href="#3-整数集合" class="headerlink" title="3.整数集合"></a>3.整数集合</h3><p>变长整数存储，整数分为16/32/64三个变长尺度，根据存入的数据所属的类型，进行规划。<br>每次插入新元素都有可能导致尺度升级（例如由16位涨到32位），因此插入整数的时间复杂度为O（n）。这里也是一个权衡，内存空间和时间的一个折中，尽可能节省内存。</p>
<h3 id="4-跳跃表"><a href="#4-跳跃表" class="headerlink" title="4.跳跃表"></a>4.跳跃表</h3><p>Redis的skilplist和普通的skiplist没什么不同，都是冗余数据实现的从粗到细的多层次链表，Redis中应用跳表的地方不多，常见的就是有序集合。<br>Redis的跳表和普通skiplist没有什么特殊之处。</p>
<h3 id="5-链表"><a href="#5-链表" class="headerlink" title="5.链表"></a>5.链表</h3><p>Redis的链表是双向非循环链表，拥有表头和表尾指针，对于首尾的操作时间复杂度是O(1)，查找时间复杂度O(n)，插入时间复杂度O(1)。<br>Redis的链表和普通链表没有什么特殊之处。</p>
<h3 id="三-AOF和RDB持久化"><a href="#三-AOF和RDB持久化" class="headerlink" title="三.AOF和RDB持久化"></a>三.AOF和RDB持久化</h3><p>AOF持久化日志，RDB持久化实体数据，AOF优先级大于RDB。</p>
<h4 id="1-AOF持久化"><a href="#1-AOF持久化" class="headerlink" title="1.AOF持久化"></a>1.AOF持久化</h4><p>机制：通过定时事件将aof缓冲区内的数据定时写到磁盘上。</p>
<h4 id="2-AOF重写"><a href="#2-AOF重写" class="headerlink" title="2.AOF重写"></a>2.AOF重写</h4><p>为了减少AOF大小，Redis提供了AOF重写功能，这个重写功能做的工作就是创建一个新AOF文件代替老的AOF，并且这个新的AOF文件没有一条冗余指令。（例如对list先插入A/B/C，后删除B/C，再插入D共6条指令，最终状态为A/D，只需1条指令就可以）<br>实现原理就是读现有数据库的状态，根据状态反推指令，跟之前的AOF无关。同样，为了避免长时间耗时，重写工作放在子进程进行。</p>
<h4 id="3-RDB持久化"><a href="#3-RDB持久化" class="headerlink" title="3.RDB持久化"></a>3.RDB持久化</h4><p>SAVE和BGSAVE两个命令都是用于生成RDB文件，区别在于BGSAVE会fork出一个子进程单独进行，不影响Redis处理正常请求。<br>定时和定次数后进行持久化操作。<br>简而言之，RDB的过程其实是比较简单的，满足条件后直接去写RDB文件就结束了。</p>
<h3 id="四-多机和集群"><a href="#四-多机和集群" class="headerlink" title="四.多机和集群"></a>四.多机和集群</h3><h4 id="1-主从服务器"><a href="#1-主从服务器" class="headerlink" title="1.主从服务器"></a>1.主从服务器</h4><p>避免单点是所有服务的通用问题，Redis也不例外。解决单点就要有备机，有备机就要解决固有的数据同步问题。</p>
<h5 id="1-1-sync——原始版主从同步"><a href="#1-1-sync——原始版主从同步" class="headerlink" title="1.1 sync——原始版主从同步"></a>1.1 sync——原始版主从同步</h5><p>Redis最初的同步做法是sync指令，通过sync每次都会全量数据，显然每次都全量复制的设计比较消耗资源。改进思路也是常规逻辑，第一次全量，剩下的增量，这就是现在的psync指令的活。</p>
<h5 id="1-2-psync"><a href="#1-2-psync" class="headerlink" title="1.2 psync"></a>1.2 psync</h5><p>部分重同步实现的技术手段是“偏移序号+积压缓冲区”，具体做法如下：<br>（1）主从分别维护一个seq，主每次完成一个请求便seq+1，从每同步完后更新自己seq；<br>（2）从每次打算同步时都是携带着自己的seq到主，主将自身的seq与从做差结果与积压缓冲区大小比较，如果小于积压缓冲区大小，直接从积压缓冲区取相应的操作进行部分重同步；<br>（3）否则说明积压缓冲区不能够cover掉主从不一致的数据，进行全量同步。<br>本质做法用空间换时间，显然在这里牺牲部分空间换回高效的部分重同步，收益比很大。</p>
<h4 id="2-集群"><a href="#2-集群" class="headerlink" title="2.集群"></a>2.集群</h4><p>Redis的官方版集群尚未在工业界普及起来，下面主要介绍一下集群的管理体系和运转体系。</p>
<h5 id="2-1-slot-集群单位"><a href="#2-1-slot-集群单位" class="headerlink" title="2.1 slot-集群单位"></a>2.1 slot-集群单位</h5><p>集群的数据区由slot组成，每个节点负责的slot是在集群启动时分配的。</p>
<h5 id="2-2-客户请求"><a href="#2-2-客户请求" class="headerlink" title="2.2 客户请求"></a>2.2 客户请求</h5><p>客户请求时如果相应数据hash后不属于请求节点所管理的slots，会给客户返回MOVED错误，并给出正确的slots。<br>从这个层面看，redis的集群还不够友好，集群内部的状态必须由客户感知。</p>
<h5 id="2-3-容灾"><a href="#2-3-容灾" class="headerlink" title="2.3 容灾"></a>2.3 容灾</h5><p>主从服务器，从用于备份主，一旦主故障，从代替主。</p>
<p>通过Redis的研究，深刻体会到的一点就是：所有设计的过程都是权衡和割舍的过程。同样放到日常的工作和开发中也是如此，一句代码写的好不好，一个模块设计的是否科学，就从速度和内存的角度去衡量看是否需要优化，并去评估每一种优化会收益到什么，同时会损失什么，收益远大于损失的就是好的优化，这样往往对于开发和提升更有针对性，更能提高效率。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java 单例模式的五种写法]]></title>
      <url>http://zsr.github.io/2016/12/10/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>单例模式作为对象的一种创建模式，它的作用是确保某一个类在整个系统中只有一个实例，而且自行实例化并向整个系统提供这个实例。</p>
<p>由此可见，单例模式具有以下的特点：</p>
<ol>
<li>单例类只能有一个实例。</li>
<li>单例类必须自己创建自己的唯一的实例。</li>
<li>单例类必须给所有其他对象提供这一实例。</li>
</ol>
<p>由于Java语言的特点，使得单例模式在Java语言的实现上有自己的特点。这些特点主要表现在单例类如何将自己实例化。</p>
<h3 id="饿汉式单例类"><a href="#饿汉式单例类" class="headerlink" title="饿汉式单例类"></a><strong>饿汉式单例类</strong></h3><p>饿汉式单例类是在Java语言里实现起来最为简便的单例类。其源代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EagerSingleton</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">/** 通过静态变量初始化的类实例 */</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> EagerSingleton instance = <span class="keyword">new</span> EagerSingleton();</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 私有的默认构造</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="title">EagerSingleton</span><span class="params">()</span> </span>&#123;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 获取唯一类实例的静态工厂方法</div><div class="line">	 * </div><div class="line">	 * <span class="doctag">@return</span></div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EagerSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> instance;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由Java语言类的初始化顺序可知，在这个类被加载时，静态变量会被初始化，此时类的私有构造会被调用。这时候，单例类的唯一实例就被创建出来了。</p>
<p><strong>Java语言中单例类的一个最重要的特点是类的构造是私有的</strong>，从而避免外界使用构造子直接创建出任意多该类的实例。值得指出的是，由于构造是私有的，因此该类不能被继承。</p>
<h3 id="懒汉式单例类"><a href="#懒汉式单例类" class="headerlink" title="懒汉式单例类"></a><strong>懒汉式单例类</strong></h3><p>与饿汉式单例类相同之处是，懒汉式单例类的构造也是私有的。而与饿汉式单例类不同的是，懒汉式单例类在第一次被引用时将自己实例化。在懒汉式单例类被加载时，不会将自己实例化。其源代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 此时静态变量不能声明为final，因为需要在工厂方法中对它进行实例化</div><div class="line">	 */</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LazySingleton instance;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 私有构造，确保无法在类外实例化该类</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span> </span>&#123;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * synchronized关键字解决多个线程的同步问题</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</div><div class="line">			instance = <span class="keyword">new</span> LazySingleton();</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> instance;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对singleton对象使用volatile关键字进行限制，保证其对所有线程的可见性，并且禁止对其进行指令重排序优化; 静态工厂方法中synchronized关键字提供的同步是必须的，否则当多个线程同时访问该方法时，无法确保获得的总是同一个实例。然而我们也看到，在所有的代码路径中，虽然只有第一次引用的时候需要对instance变量进行实例化，但是synchronized同步机制要求所有的代码执行路径都必须先获取类锁。在并发访问比较低时，效果并不显著，但是当并发访问量上升时，这里有可能会成为并发访问的瓶颈。</p>
<h3 id="双重检查锁"><a href="#双重检查锁" class="headerlink" title="双重检查锁"></a><strong>双重检查锁</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton = <span class="keyword">null</span>;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</div><div class="line">                <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</div><div class="line">                    singleton = <span class="keyword">new</span> Singleton();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> singleton;</div><div class="line">    &#125;    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种写法被称为“双重检查锁”，顾名思义，就是在getSingleton()方法中，进行两次null检查。看似多此一举，但实际上却极大提升了并发度，进而提升了性能。为什么可以提高并发度呢？就像上文说的，在单例中new的情况非常少，绝大多数都是可以并行的读操作。因此在加锁前多进行一次null检查就可以减少绝大多数的加锁操作，执行效率提高的目的也就达到了。</p>
<p><strong>坑:</strong> volatile这个关键字。其实这个关键字有两层语义。第一层语义就是可见性。可见性指的是在一个线程中对该变量的修改会马上由工作内存（Work Memory）写回主内存（Main Memory），所以会马上反应在其它线程的读取操作中.volatile的第二层语义是禁止指令重排序优化。我们写的代码（尤其是多线程代码），由于编译器优化，在实际执行的时候可能与我们编写的顺序不同。编译器只保证程序执行结果与源代码相同，却不保证实际指令的顺序与源代码相同,引入多线程这种乱序就可能导致严重问题.</p>
<p>禁止指令重排优化这条语义直到jdk1.5以后才能正确工作。此前的JDK中即使将变量声明为volatile也无法完全避免重排序所导致的问题。所以，在jdk1.5版本前，双重检查锁形式的单例模式是无法保证线程安全的。</p>
<h3 id="静态内部内"><a href="#静态内部内" class="headerlink" title="静态内部内"></a><strong>静态内部内</strong></h3><p>这种单例模式的写法，是著名的《Java Concurrency in Practice》一书中介绍对象的安全发布时介绍的。我们先来看它的源代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceFactory</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceHolder</span> </span>&#123;</div><div class="line">		<span class="keyword">public</span> <span class="keyword">static</span> Resource resource = <span class="keyword">new</span> Resource();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Resource <span class="title">getResource</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> ResourceHolder.resource;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>要理解上面这种单例类的写法，你需要先学习一些关于Java虚拟机如何初始化一个类的知识。</p>
<p>在java虚拟机中，类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括了：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）七个阶段。其中，验证、准备和解析三个部分统称为连接（Linking）。</p>
<p>加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也被称为动态绑定或晚期绑定）。</p>
<p>什么情况下需要开始类加载的第一个阶段：加载。虚拟机规范中并没有进行强制约束，这点可以交给虚拟机的具体实现来自由把握。但是对于初始化阶段，虚拟机规范则是严格规定了有且只有四种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：</p>
<p>1）遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这四条字节码指令最常见的Java代码场景是：使用new关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。</p>
<p>2）使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。</p>
<p>3）当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</p>
<p>4）当虚拟机启动时，用户需要指定一个要执行的主类（包含main（）方法的那个类），虚拟机会先初始化这个主类。</p>
<p>这四种场景中的行为称为对一个类进行主动引用，除此之外所有引用类的方式，都不会触发类的初始化，被称为被动引用。以下是三个例子：</p>
<p>1）通过子类引用父类的静态字段，不会导致子类初始化。</p>
<p>2）通过数组定义来引用类，不会触发此类的初始化。</p>
<p>3）常量在编译阶段会存入调用类的常量池，本质上没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</p>
<p>（以上摘自《深入理解Java虚拟机》）</p>
<p>从上面介绍的知识可以知道，JVM将推迟ResourceHolder类的初始化，直到第一个代码访问路径调用getResource()方法。此时，由于ResourceHolder.resource是一个读取静态字段的主动引用，虚拟机将第一次加载ResourceHolder类，并且通过一个静态变量来初始化Resource实例。而其他访问getResource()方法的代码路径，并不需要同步。</p>
<p>不需要额外的同步，但是又能确保对象可见性的正确发布，这是由Java的虚拟机规范所决定的！上面这种单例模式的写法，体现出对虚拟机规范的深刻理解，实在是专家级别的写法。</p>
<p><strong>注意</strong>:上面提到的所有实现方式都有两个共同的缺点：</p>
<ul>
<li>都需要额外的工作(Serializable、transient、readResolve())来实现序列化，否则每次反序列化一个序列化的对象实例时都会创建一个新的实例。</li>
<li>可能会有人使用反射强行调用我们的私有构造器（如果要避免这种情况，可以修改构造器，让它在创建第二个实例的时候抛异常）。</li>
</ul>
<h3 id="枚举写法-推荐"><a href="#枚举写法-推荐" class="headerlink" title="枚举写法(推荐)"></a><strong>枚举写法</strong>(推荐)</h3><p>只能包含单个元素的枚举类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</div><div class="line">    INSTANCE; <span class="comment">//定义一个枚举的元素，就代表Singleton的一个实例</span></div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用枚举除了线程安全和防止反射强行调用构造器之外，还提供了自动序列化机制，防止反序列化的时候创建新的对象。因此，<a href="http://www.amazon.com/gp/product/B000WJOUPA/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=B000WJOUPA&amp;linkCode=as2&amp;tag=job0ae-20" target="_blank" rel="external">Effective Java</a>推荐尽可能地使用枚举来实现单例。</p>
<p>调用方式：Singleton.INSTANCE.getName();</p>
<p>最后，不管采取何种方案，请时刻牢记单例的三大要点：</p>
<ul>
<li><strong>线程安全</strong></li>
<li><strong>延迟加载</strong></li>
<li><strong>序列化与反序列化安全</strong></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ThreadLocal]]></title>
      <url>http://zsr.github.io/2016/12/10/ThreadLocal/</url>
      <content type="html"><![CDATA[<p><code>Synchronized</code>这类线程同步的机制可以解决多线程并发问题，在这种解决方案下，多个线程访问到的，都是同一份变量的内容。为了防止在多线程访问的过程中，可能会出现的并发错误。不得不对多个线程的访问进行同步，这样也就意味着，多个线程必须先后对变量的值进行访问或者修改，这是一种以延长访问时间来换取线程安全性的策略。</p>
<p>而<code>ThreadLocal</code>类为每一个线程都维护了自己独有的变量拷贝。每个线程都拥有了自己独立的一个变量，竞争条件被彻底消除了，那就没有任何必要对这些线程进行同步，它们也能最大限度的由CPU调度，并发执行。并且由于每个线程在访问该变量时，读取和修改的，都是自己独有的那一份变量拷贝，变量被彻底封闭在每个访问的线程中，并发错误出现的可能也完全消除了。对比前一种方案，这是一种以空间来换取线程安全性的策略。</p>
<p>来看一个运用ThreadLocal来实现数据库连接Connection对象线程隔离的例子。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.sql.Connection;</div><div class="line"><span class="keyword">import</span> java.sql.DriverManager;</div><div class="line"><span class="keyword">import</span> java.sql.SQLException;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionManager</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Connection&gt; connectionHolder = <span class="keyword">new</span> ThreadLocal&lt;Connection&gt;() &#123;</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">protected</span> Connection <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</div><div class="line">			Connection conn = <span class="keyword">null</span>;</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				conn = DriverManager.getConnection(</div><div class="line">						<span class="string">"jdbc:mysql://localhost:3306/test"</span>, <span class="string">"username"</span>,</div><div class="line">						<span class="string">"password"</span>);</div><div class="line">			&#125; <span class="keyword">catch</span> (SQLException e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">return</span> conn;</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> connectionHolder.get();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setConnection</span><span class="params">(Connection conn)</span> </span>&#123;</div><div class="line">		connectionHolder.set(conn);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过调用ConnectionManager.getConnection()方法，每个线程获取到的，都是和当前线程绑定的那个Connection对象，第一次获取时，是通过initialValue()方法的返回值来设置值的。通过ConnectionManager.setConnection(Connection conn)方法设置的Connection对象，也只会和当前线程绑定。这样就实现了Connection对象在多个线程中的完全隔离。在Spring容器中管理多线程环境下的Connection对象时，采用的思路和以上代码非常相似。</p>
<p>到底ThreadLocal类是如何实现这种“为每个线程提供不同的变量拷贝”的呢？先来看一下ThreadLocal的set()方法的源码是如何实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">    <span class="comment">/**</span></div><div class="line">     * Sets the current thread's copy of this thread-local variable</div><div class="line">     * to the specified value.  Most subclasses will have no need to </div><div class="line">     * override this method, relying solely on the &#123;<span class="doctag">@link</span> #initialValue&#125;</div><div class="line">     * method to set the values of thread-locals.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> value the value to be stored in the current thread's copy of</div><div class="line">     *        this thread-local.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</div><div class="line">        Thread t = Thread.currentThread();</div><div class="line">        ThreadLocalMap map = getMap(t);</div><div class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</div><div class="line">            map.set(<span class="keyword">this</span>, value);</div><div class="line">        <span class="keyword">else</span></div><div class="line">            createMap(t, value);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>在这个方法内部我们看到，首先通过getMap(Thread t)方法获取一个和当前线程相关的ThreadLocalMap，然后将变量的值设置到这个ThreadLocalMap对象中，当然如果获取到的ThreadLocalMap对象为空，就通过createMap方法创建。</p>
<p>线程隔离的秘密，就在于ThreadLocalMap这个类。<strong>ThreadLocalMap是ThreadLocal类的一个静态内部类，它实现了键值对的设置和获取（对比Map对象来理解），每个线程中都有一个独立的ThreadLocalMap副本，它所存储的值，只能被当前线程读取和修改。ThreadLocal类通过操作每一个线程特有的ThreadLocalMap副本，从而实现了变量访问在不同线程中的隔离。因为每个线程的变量都是自己特有的，完全不会有并发错误。还有一点就是，ThreadLocalMap存储的键值对中的键是this对象指向的ThreadLocal对象，而值就是你所设置的对象了。</strong></p>
<p>为了加深理解，我们接着看上面代码中出现的getMap和createMap方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> t.threadLocals;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</div><div class="line">        t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>代码已经说的非常直白，就是获取和设置Thread内的一个叫threadLocals的变量，而这个变量的类型就是ThreadLocalMap，这样进一步验证了上文中的观点：每个线程都有自己独立的ThreadLocalMap对象。打开java.lang.Thread类的源代码，我们能得到更直观的证明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></div><div class="line">     * by the ThreadLocal class. */</div><div class="line">    ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</div></pre></td></tr></table></figure>
<p>那么接下来再看一下ThreadLocal类中的get()方法，代码是这么说的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * Returns the value in the current thread's copy of this</div><div class="line">     * thread-local variable.  If the variable has no value for the</div><div class="line">     * current thread, it is first initialized to the value returned</div><div class="line">     * by an invocation of the &#123;<span class="doctag">@link</span> #initialValue&#125; method.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@return</span> the current thread's value of this thread-local</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">        Thread t = Thread.currentThread();</div><div class="line">        ThreadLocalMap map = getMap(t);</div><div class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</div><div class="line">            ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</div><div class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>)</div><div class="line">                <span class="keyword">return</span> (T)e.value;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> setInitialValue();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Variant of set() to establish initialValue. Used instead</div><div class="line">     * of set() in case user has overridden the set() method.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@return</span> the initial value</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</div><div class="line">        T value = initialValue();</div><div class="line">        Thread t = Thread.currentThread();</div><div class="line">        ThreadLocalMap map = getMap(t);</div><div class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</div><div class="line">            map.set(<span class="keyword">this</span>, value);</div><div class="line">        <span class="keyword">else</span></div><div class="line">            createMap(t, value);</div><div class="line">        <span class="keyword">return</span> value;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这两个方法的代码告诉我们，在获取和当前线程绑定的值时，ThreadLocalMap对象是以this指向的ThreadLocal对象为键进行查找的，这当然和前面set()方法的代码是相呼应的。</p>
<p>进一步地，我们可以创建不同的ThreadLocal实例来实现多个变量在不同线程间的访问隔离，为什么可以这么做？因为不同的ThreadLocal对象作为不同键，当然也可以在线程的ThreadLocalMap对象中设置不同的值了。通过ThreadLocal对象，在多线程中共享一个值和多个值的区别，就像你在一个HashMap对象中存储一个键值对和多个键值对一样，仅此而已。</p>
<p>设置到这些线程中的隔离变量，会不会导致内存泄漏呢？ThreadLocalMap对象保存在Thread对象中，当某个线程终止后，存储在其中的线程隔离的变量，也将作为Thread实例的垃圾被回收掉，所以完全不用担心内存泄漏的问题。在多个线程中隔离的变量，光荣的生，合理的死，真是圆满，不是么？</p>
<p>最后再提一句，ThreadLocal变量的这种隔离策略，也不是任何情况下都能使用的。如果多个线程并发访问的对象实例只允许，也只能创建那么一个，那就没有别的办法了，老老实实的使用同步机制来访问吧。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[mvc:message-converters]]></title>
      <url>http://zsr.github.io/2016/12/10/mvc-message-converters/</url>
      <content type="html"><![CDATA[<p><strong>摘要: SpringMVC使用消息转换器HttpMessageConverter实现请求报文和对象、对象和响应报文之间的自动转换</strong></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在SpringMVC中，可以使用<code>@RequestBody</code>和<code>@ResponseBody</code>两个注解，分别完成请求报文到对象和对象到响应报文的转换，底层这种灵活的消息转换机制，就是Spring3.x中新引入的<code>HttpMessageConverter</code>即消息转换器机制。</p>
<h2 id="Http请求的抽象"><a href="#Http请求的抽象" class="headerlink" title="Http请求的抽象"></a>Http请求的抽象</h2><p>还是回到请求-响应，也就是解析请求体，然后返回响应报文这个最基本的Http请求过程中来。我们知道，在servlet标准中，可以用javax.servlet.ServletRequest接口中的以下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ServletInputStream <span class="title">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</div></pre></td></tr></table></figure>
<p>来得到一个ServletInputStream。这个ServletInputStream中，可以读取到一个原始请求报文的所有内容。同样的，在javax.servlet.ServletResponse接口中，可以用以下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ServletOutputStream <span class="title">getOutputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</div></pre></td></tr></table></figure>
<p>来得到一个ServletOutputStream，这个ServletOutputSteam，继承自java中的OutputStream，可以让你输出Http的响应报文内容。</p>
<p>我们知道，Http请求和响应报文本质上都是一串字符串，当请求报文来到java世界，它会被封装成为一个ServletInputStream的输入流，供我们读取报文。响应报文则是通过一个ServletOutputStream的输出流，来输出响应报文。</p>
<p>我们从流中，只能读取到原始的字符串报文，同样，我们往输出流中，也只能写原始的字符。而在java世界中，处理业务逻辑，都是以一个个有业务意义的<strong>对象</strong>为处理维度的，那么在报文到达SpringMVC和从SpringMVC出去，都存在一个字符串到java对象的阻抗问题。这一过程，不可能由开发者手工转换。我们知道，在Struts2中，采用了OGNL来应对这个问题，而在SpringMVC中，它是HttpMessageConverter机制。我们先来看两个接口。</p>
<h3 id="HttpInputMessage"><a href="#HttpInputMessage" class="headerlink" title="HttpInputMessage"></a>HttpInputMessage</h3><p>这个类是SpringMVC内部对一次Http请求报文的抽象，在HttpMessageConverter的read()方法中，有一个HttpInputMessage的形参，它正是SpringMVC的消息转换器所作用的受体“请求消息”的内部抽象，消息转换器从“请求消息”中按照规则提取消息，转换为方法形参中声明的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.springframework.http;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.io.InputStream;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HttpInputMessage</span> <span class="keyword">extends</span> <span class="title">HttpMessage</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function">InputStream <span class="title">getBody</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="HttpOutputMessage"><a href="#HttpOutputMessage" class="headerlink" title="HttpOutputMessage"></a>HttpOutputMessage</h3><p>这个类是SpringMVC内部对一次Http响应报文的抽象，在HttpMessageConverter的write()方法中，有一个HttpOutputMessage的形参，它正是SpringMVC的消息转换器所作用的受体“响应消息”的内部抽象，消息转换器将“响应消息”按照一定的规则写到响应报文中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">package org.springframework.http;</div><div class="line"></div><div class="line">import java.io.IOException;</div><div class="line">import java.io.OutputStream;</div><div class="line"></div><div class="line">public interface HttpOutputMessage extends HttpMessage &#123;</div><div class="line"></div><div class="line">    OutputStream getBody() throws IOException;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="HttpMessageConverter"><a href="#HttpMessageConverter" class="headerlink" title="HttpMessageConverter"></a>HttpMessageConverter</h2><p>对消息转换器最高层次的接口抽象，描述了一个消息转换器的一般特征，我们可以从这个接口中定义的方法，来领悟Spring3.x的设计者对这一机制的思考过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.springframework.http.converter;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.springframework.http.HttpInputMessage;</div><div class="line"><span class="keyword">import</span> org.springframework.http.HttpOutputMessage;</div><div class="line"><span class="keyword">import</span> org.springframework.http.MediaType;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HttpMessageConverter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">canRead</span><span class="params">(Class&lt;?&gt; clazz, MediaType mediaType)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">canWrite</span><span class="params">(Class&lt;?&gt; clazz, MediaType mediaType)</span></span>;</div><div class="line"></div><div class="line">    <span class="function">List&lt;MediaType&gt; <span class="title">getSupportedMediaTypes</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function">T <span class="title">read</span><span class="params">(Class&lt;? extends T&gt; clazz, HttpInputMessage inputMessage)</span></span></div><div class="line">            <span class="keyword">throws</span> IOException, HttpMessageNotReadableException;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(T t, MediaType contentType, HttpOutputMessage outputMessage)</span></span></div><div class="line">            <span class="keyword">throws</span> IOException, HttpMessageNotWritableException;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>HttpMessageConverter接口的定义出现了成对的canRead()，read()和canWrite()，write()方法，MediaType是对请求的Media Type属性的封装。举个例子，当我们声明了下面这个处理方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/string"</span>, method=RequestMethod.POST)</div><div class="line"><span class="keyword">public</span> <span class="meta">@ResponseBody</span> <span class="function">String <span class="title">readString</span><span class="params">(@RequestBody String string)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"Read string '"</span> + string + <span class="string">"'"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在SpringMVC进入readString方法前，会根据@RequestBody注解选择适当的HttpMessageConverter实现类来将请求参数解析到string变量中，具体来说是使用了StringHttpMessageConverter类，它的canRead()方法返回true，然后它的read()方法会从请求中读出请求参数，绑定到readString()方法的string变量中。</p>
<p>当SpringMVC执行readString方法后，由于返回值标识了@ResponseBody，SpringMVC将使用StringHttpMessageConverter的write()方法，将结果作为String值写入响应报文，当然，此时canWrite()方法返回true。</p>
<p>我们可以用下面的图，简单描述一下这个过程。</p>
<p><img src="http://static.oschina.net/uploads/space/2013/1026/091627_zgNV_118997.png" alt="消息转换图"></p>
<h3 id="RequestResponseBodyMethodProcessor"><a href="#RequestResponseBodyMethodProcessor" class="headerlink" title="RequestResponseBodyMethodProcessor"></a>RequestResponseBodyMethodProcessor</h3><p>将上述过程集中描述的一个类是<code>org.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyMethodProcessor</code>，这个类同时实现了<code>HandlerMethodArgumentResolver</code>和<code>HandlerMethodReturnValueHandler</code>两个接口。前者是将请求报文绑定到处理方法形参的策略接口，后者则是对处理方法返回值进行处理的策略接口。两个接口的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.springframework.web.method.support;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.springframework.core.MethodParameter;</div><div class="line"><span class="keyword">import</span> org.springframework.web.bind.WebDataBinder;</div><div class="line"><span class="keyword">import</span> org.springframework.web.bind.support.WebDataBinderFactory;</div><div class="line"><span class="keyword">import</span> org.springframework.web.context.request.NativeWebRequest;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerMethodArgumentResolver</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">supportsParameter</span><span class="params">(MethodParameter parameter)</span></span>;</div><div class="line"></div><div class="line">    <span class="function">Object <span class="title">resolveArgument</span><span class="params">(MethodParameter parameter,</span></span></div><div class="line">                           ModelAndViewContainer mavContainer,</div><div class="line">                           NativeWebRequest webRequest,</div><div class="line">                           WebDataBinderFactory binderFactory) <span class="keyword">throws</span> Exception;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.springframework.web.method.support;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.springframework.core.MethodParameter;</div><div class="line"><span class="keyword">import</span> org.springframework.web.context.request.NativeWebRequest;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerMethodReturnValueHandler</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">supportsReturnType</span><span class="params">(MethodParameter returnType)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handleReturnValue</span><span class="params">(Object returnValue,</span></span></div><div class="line">                           MethodParameter returnType,</div><div class="line">                           ModelAndViewContainer mavContainer,</div><div class="line">                           NativeWebRequest webRequest) <span class="keyword">throws</span> Exception;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>RequestResponseBodyMethodProcessor这个类，同时充当了方法参数解析和返回值处理两种角色。我们从它的源码中，可以找到上面两个接口的方法实现。</p>
<p>对<code>HandlerMethodArgumentResolver</code>接口的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsParameter</span><span class="params">(MethodParameter parameter)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> parameter.hasParameterAnnotation(RequestBody.class);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">resolveArgument</span><span class="params">(MethodParameter parameter, ModelAndViewContainer mavContainer,</span></span></div><div class="line">        NativeWebRequest webRequest, WebDataBinderFactory binderFactory) <span class="keyword">throws</span> Exception &#123;</div><div class="line"></div><div class="line">    Object argument = readWithMessageConverters(webRequest, parameter, parameter.getGenericParameterType());</div><div class="line"></div><div class="line">    String name = Conventions.getVariableNameForParameter(parameter);</div><div class="line">    WebDataBinder binder = binderFactory.createBinder(webRequest, argument, name);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (argument != <span class="keyword">null</span>) &#123;</div><div class="line">        validate(binder, parameter);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    mavContainer.addAttribute(BindingResult.MODEL_KEY_PREFIX + name, binder.getBindingResult());</div><div class="line"></div><div class="line">    <span class="keyword">return</span> argument;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对<code>HandlerMethodReturnValueHandler</code>接口的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsReturnType</span><span class="params">(MethodParameter returnType)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> returnType.getMethodAnnotation(ResponseBody.class) != <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleReturnValue</span><span class="params">(Object returnValue, MethodParameter returnType,</span></span></div><div class="line">        ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</div><div class="line">        <span class="keyword">throws</span> IOException, HttpMediaTypeNotAcceptableException &#123;</div><div class="line"></div><div class="line">    mavContainer.setRequestHandled(<span class="keyword">true</span>);</div><div class="line">    <span class="keyword">if</span> (returnValue != <span class="keyword">null</span>) &#123;</div><div class="line">        writeWithMessageConverters(returnValue, returnType, webRequest);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看完上面的代码，整个<code>HttpMessageConverter</code>消息转换的脉络已经非常清晰。因为两个接口的实现，分别是以是否有<code>@RequestBody</code>和<code>@ResponseBody</code>为条件，然后分别调用HttpMessageConverter来进行消息的读写。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[I/O模型]]></title>
      <url>http://zsr.github.io/2016/10/27/I:O%E6%A8%A1%E5%9E%8B/</url>
      <content type="html"><![CDATA[<h3 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a><strong>同步与异步</strong></h3><p><strong><code>同步与异步主要是从消息通知机制角度来说的.</code></strong></p>
<ul>
<li><code>所谓同步就是一个任务的完成需要依赖另外一个任务时，只有等待被依赖的任务完成后，依赖的任务才能算完成，这是一种可靠的任务序列</code></li>
<li><code>所谓异步是不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作，依赖的任务也立即执行，只要自己完成了整个任务就算完成了</code>。至于被依赖的任务最终是否真正完成，依赖它的任务无法确定，所以它是不可靠的任务序列。</li>
</ul>
<h4 id="消息通知"><a href="#消息通知" class="headerlink" title="消息通知"></a><strong>消息通知</strong></h4><p><code>异步的概念和同步相对</code>。当一个同步调用发出后，<code>调用者要一直等待返回消息（结果）通知后</code>，才能进行后续的执行；当一个异步过程调用发出后，调用者不能立刻得到返回消息（结果）,<code>实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者</code>。</p>
<p>执行部件和调用者通过三种途径返回结果：<code>状态、通知和回调</code>。使用哪一种通知机制，<code>依赖于执行部件的实现</code>，除非执行部件提供多种选择，<code>否则不受调用者控制</code>。</p>
<ul>
<li>如果执行部件用状态来通知，那么调用者就需要每隔一定时间检查一次，效率就很低(Java Future)</li>
<li>如果是使用通知的方式，效率则很高，因为执行部件几乎不需要做额外的操作。至于回调函数，其实和通知没太多区别(Guava Future)</li>
</ul>
<h3 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a><strong>阻塞与非阻塞</strong></h3><p><strong>阻塞和非阻塞这两个概念与程序（线程）等待消息通知(无所谓同步或者异步)时的状态有关。也就是说<code>阻塞与非阻塞主要是程序（线程）等待消息通知时的状态角度来说的</code>。</strong></p>
<ul>
<li><code>阻塞调用是指调用结果返回之前，当前线程会被挂起，一直处于等待消息通知，不能够执行其他业务</code></li>
</ul>
<p>这里的<code>阻塞调用</code>与<code>同步调用</code>容易混淆：</p>
<p>对于同步调用来说，很多时候当前线程可能还是激活的，只是从逻辑上当前函数没有返回而已，此时，这个线程可能也会处理其他的消息</p>
<ul>
<li>非阻塞和阻塞的概念相对应，<code>指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回</code>。虽然表面上看非阻塞的方式可以明显的提高CPU的利用率，<code>但是也带了另外一种后果就是系统的线程切换增加</code>。<code>增加的CPU执行时间能不能补偿系统的切换成本需要好好评估</code>。</li>
</ul>
<h3 id="用户空间与内核空间"><a href="#用户空间与内核空间" class="headerlink" title="用户空间与内核空间"></a><strong>用户空间与内核空间</strong></h3><p>现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。</p>
<h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a><strong>文件描述符</strong></h3><p>文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。</p>
<p>文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。</p>
<h3 id="缓存-I-O"><a href="#缓存-I-O" class="headerlink" title="缓存 I/O"></a><strong>缓存 I/O</strong></h3><p>缓存 I/O 又被称作标准 I/O，大多数文件系统的默认 I/O 操作都是缓存 I/O。在 Linux 的缓存 I/O 机制中，操作系统会将 I/O 的数据缓存在文件系统的页缓存（ page cache ）中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。</p>
<p><strong>缓存 I/O 的缺点：</strong></p>
<p>数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。</p>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a><strong>系统调用</strong></h3><p>进程想要获取磁盘中的数据，而能和硬件打交道的只能是内核，进程通知内核说我要磁盘中的数据，此过程就是系统调用。</p>
<p><strong>一次I/O的完成的步骤:</strong></p>
<pre><code>当进程发起系统调用时，这个系统调用就进入内核模式，然后开始I/O操作
</code></pre><p><strong>I/O操作分为两个步骤:</strong></p>
<ul>
<li>1、磁盘把数据装载到内核的内存空间，</li>
<li>2、内核的内存空间的数据copy到用户的内存空间中(此过程是I/O发生的地方)</li>
</ul>
<p>对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待分组到达时，它被复制到内核总的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。</p>
<p><strong>进程获取数据的详细图解过程:</strong></p>
<p><a href="http://img1.51cto.com/attachment/201309/205126317.png" target="_blank" rel="external"><img src="http://img1.51cto.com/attachment/201309/205126317.png" alt="0.png"></a></p>
<p>  整个过程：此进程需要对磁盘中的数据进行操作，则会向内核发起一个系统调用，然后此进程，将会被切换出去，此进程会被挂起或者进入睡眠状态，也叫不可中断的睡眠，因为数据还没有得到，只有等到系统调用的结果完成后，则进程会被唤醒，继续接下来的操作，从系统调用的开始到系统调用结束经过的步骤：</p>
<p>①进程向内核发起一个系统调用，</p>
<p>②内核接收到系统调用，知道是对文件的请求，于是告诉磁盘，把文件读取出来</p>
<p>③磁盘接收到来着内核的命令后，把文件载入到内核的内存空间里面</p>
<p>④内核的内存空间接收到数据之后，把数据copy到用户进程的内存空间(<strong>此过程是I/O发生的地方</strong>)</p>
<p>⑤进程内存空间得到数据后，给内核发送通知</p>
<p>⑥内核把接收到的通知回复给进程，此过程为唤醒进程，然后进程得到数据，进行下一步操作</p>
<a id="more"></a>
<h3 id="五种I-O模型"><a href="#五种I-O模型" class="headerlink" title="五种I/O模型"></a><strong>五种I/O模型</strong></h3><ul>
<li>阻塞 I/O（blocking IO）</li>
<li>非阻塞 I/O（nonblocking IO）</li>
<li>I/O 多路复用（ IO multiplexing）</li>
<li>信号驱动 I/O（ signal driven IO）</li>
<li>异步 I/O（asynchronous IO）</li>
</ul>
<p><strong>I/O发生的地方才会出现阻塞或非阻塞</strong></p>
<h4 id="阻塞："><a href="#阻塞：" class="headerlink" title="阻塞："></a><strong>阻塞：</strong></h4><p>进程发起I/O调用，进程又不得不等待I/O的完成，此时CPU把进程切换出去，进程处于睡眠状态则此过程为阻塞I/O; I/O完成，系统直接通知进程，则进程被唤醒</p>
<p><strong>blocking IO的特点就是在IO执行的两个阶段都被block了。</strong></p>
<p>阻塞I/O的图解</p>
<p><a href="http://img1.51cto.com/attachment/201309/205500239.png" target="_blank" rel="external"><img src="http://img1.51cto.com/attachment/201309/205500239.png" alt="1.png"></a></p>
<h4 id="非阻塞："><a href="#非阻塞：" class="headerlink" title="非阻塞："></a><strong>非阻塞：</strong></h4><p>进程发起I/O调用，I/O自己知道需过一段时间完成，就立即通知进程进行别的操作，则为非阻塞I/O; 每隔一段时间，用户进程问内核数据是否准备完成，系统完成后，则进程获取数据，继续执行(此过程也称盲等待)</p>
<p><strong>nonblocking IO的特点是用户进程需要不断的主动询问kernel数据好了没有。</strong></p>
<p>非阻塞I/O的图解：</p>
<p><a href="http://img1.51cto.com/attachment/201309/205605819.png" target="_blank" rel="external"><img src="http://img1.51cto.com/attachment/201309/205605819.png" alt="2.png"></a></p>
<h4 id="I-O-多路复用"><a href="#I-O-多路复用" class="headerlink" title="I/O 多路复用"></a><strong>I/O 多路复用</strong></h4><p><strong>多路复用是指使用一个线程来检查多个文件描述符（Socket）的就绪状态，比如调用select和poll函数，传入多个文件描述符，如果有一个文件描述符就绪，则返回，否则阻塞直到超时。得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启动线程执行（比如使用线程池）。</strong></p>
<p>有些地方也称这种IO方式为event driven IO。select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select，poll，epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。</p>
<p><img src="https://segmentfault.com/img/bVm1c5" alt="img"></p>
<p><code>当用户进程调用了select，那么整个进程会被block</code>，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。</p>
<p>I/O复用的图解：</p>
<p><a href="http://img1.51cto.com/attachment/201309/205635176.png" target="_blank" rel="external"><img src="http://img1.51cto.com/attachment/201309/205635176.png" alt="3.png"></a></p>
<p>这样在处理1000个连接时，只需要1个线程监控就绪状态，对就绪的每个连接开一个线程处理就可以了，这样需要的线程数大大减少，减少了内存开销和上下文切换的CPU开销。</p>
<p>这个图和blocking IO的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。但是，用select的优势在于它可以同时处理多个connection。</p>
<p>所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。<strong>select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接</strong></p>
<h4 id="信号驱动I-O"><a href="#信号驱动I-O" class="headerlink" title="信号驱动I/O"></a><strong>信号驱动I/O</strong></h4><p>首先，允许套接口进行信号驱动I/O，并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据。</p>
<p><strong>信号驱动 I/O 模式下，内核可以在复制的时候通知给我们的应用程序发送SIGIO 消息。</strong></p>
<p>具体过程如下图:</p>
<p><a href="http://www.toxingwang.com/wp-content/uploads/2013/11/sigio.jpg" target="_blank" rel="external"><img src="http://www.toxingwang.com/wp-content/uploads/2013/11/sigio.jpg" alt="sigio"></a></p>
<h4 id="异步I-O"><a href="#异步I-O" class="headerlink" title="异步I/O"></a><strong>异步I/O</strong></h4><p>用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。</p>
<p>异步I/O的图解：</p>
<p><a href="http://img1.51cto.com/attachment/201309/210054915.png" target="_blank" rel="external"><img src="http://img1.51cto.com/attachment/201309/210054915.png" alt="5.png"></a></p>
<p>  <strong>前四种I/O属于同步操作，最后的一种则属于异步操作</strong></p>
<h4 id="五种I-O模型的比较："><a href="#五种I-O模型的比较：" class="headerlink" title="五种I/O模型的比较："></a><strong>五种I/O模型的比较：</strong></h4><p><img src="https://segmentfault.com/img/bVm1c9" alt="img"></p>
<h3 id="I-O-多路复用之select、poll、epoll详解"><a href="#I-O-多路复用之select、poll、epoll详解" class="headerlink" title="I/O 多路复用之select、poll、epoll详解"></a><strong>I/O 多路复用之select、poll、epoll详解</strong></h3><p>select，poll，epoll都是IO多路复用的机制。I/O多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。</p>
<ul>
<li><strong>select</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span> <span class="params">(<span class="keyword">int</span> n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span></span>;</div></pre></td></tr></table></figure>
<p>select 函数监视的文件描述符分3类，分别是<code>writefds</code>、<code>readfds</code>、和<code>exceptfds</code>。调用后select函数会阻塞，直到有描述副就绪（有数据可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以通过遍历fdset，来找到就绪的描述符。</p>
<p>select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。select的一 个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但是这样也会造成效率的降低。</p>
<ul>
<li><strong>poll</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span> <span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="keyword">unsigned</span> <span class="keyword">int</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</div></pre></td></tr></table></figure>
<p>不同与select使用三个位图来表示三个fdset的方式，poll使用一个 pollfd的指针实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> pollfd &#123;</div><div class="line">    <span class="keyword">int</span> fd; <span class="comment">/* file descriptor */</span></div><div class="line">    <span class="keyword">short</span> events; <span class="comment">/* requested events to watch */</span></div><div class="line">    <span class="keyword">short</span> revents; <span class="comment">/* returned events witnessed */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>pollfd结构包含了要监视的event和发生的event，不再使用select“参数-值”传递的方式。同时，pollfd并没有最大数量限制（但是数量过大后性能也是会下降）。 和select函数一样，poll返回后，需要轮询pollfd来获取就绪的描述符。</p>
<p><strong>从上面看，select和poll都需要在返回后，<code>通过遍历文件描述符来获取已经就绪的socket</code>。事实上，同时连接的大量客户端在一时刻可能只有很少的处于就绪状态，因此随着监视的描述符数量的增长，其效率也会线性下降。</strong></p>
<ul>
<li><strong>epoll</strong></li>
</ul>
<p>epoll是在2.6内核中提出的，是之前的select和poll的增强版本。相对于select和poll来说，epoll更加灵活，没有描述符限制。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。</p>
<p>epoll操作过程需要三个接口，分别如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int epoll_create(int size)；//创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大</div><div class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</div><div class="line">int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</div></pre></td></tr></table></figure>
<p>在<code>select/poll</code>中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描，而<strong>epoll事先通过epoll_ctl()来注册一个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait() 时便得到通知</strong>。(<code>此处去掉了遍历文件描述符，而是通过监听回调的的机制</code>。这正是epoll的魅力所在。)</p>
<p><strong>epoll的优点主要是一下几个方面：</strong></p>
<ol>
<li>监视的描述符数量不受限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子,在1GB内存的机器上大约是10万左 右，具体数目可以cat /proc/sys/fs/file-max察看,一般来说这个数目和系统内存关系很大。select的最大缺点就是进程打开的fd是有数量限制的。这对于连接数量比较大的服务器来说根本不能满足。虽然也可以选择多进程的解决方案( Apache就是这样实现的)，不过虽然linux上面创建进程的代价比较小，但仍旧是不可忽视的，加上进程间数据同步远比不上线程间同步的高效，所以也不是一种完美的方案。</li>
<li>IO的效率不会随着监视fd的数量的增长而下降。epoll不同于select和poll轮询的方式，而是通过每个fd定义的回调函数来实现的。只有就绪的fd才会执行回调函数。</li>
</ol>
<p><strong>注：如果没有大量的idle -connection或者dead-connection，epoll的效率并不会比select/poll高很多，但是当遇到大量的idle- connection，就会发现epoll的效率大大高于select/poll。</strong></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a><strong>参考</strong></h3><p><a href="http://www.jianshu.com/p/aed6067eeac9" target="_blank" rel="external">同步、异步、阻塞与非阻塞</a></p>
<p><a href="https://segmentfault.com/a/1190000003063859" target="_blank" rel="external">Linux I/O模型</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JAVA NIO]]></title>
      <url>http://zsr.github.io/2016/10/27/JAVA-NIO/</url>
      <content type="html"><![CDATA[<h3 id="NIO优点"><a href="#NIO优点" class="headerlink" title="NIO优点"></a><strong>NIO优点</strong></h3><p>传统流I/O是基于字节的，所有I/O都被视为单个字节的移动；而NIO是基于块的，NIO的性能肯定优于流I/O。其性能的提高要得益于其使用的结构更接近操作系统执行I/O的方式：通道和缓冲器。我们可以把它想象成一个煤矿，通道是一个包含煤层（数据）的矿藏，而缓冲器则是派送 到矿藏的卡车。卡车载满煤炭而归，我们再从卡车上获得煤炭。也就是说，我们并没有直接和通道交互；我们只是和缓冲器交互，并把缓冲器派送到通道。通道要么从缓冲器获得数据，要么向缓冲器发送数据。</p>
<p>I/O的终极目标是效率，而效率离不开底层操作系统和文件系统的特性支持。这些特性包括：文件锁定、非阻塞I/O、就绪性选择、和内存映射。当今操作系统大都支持这些特性，而Java传统I/O机制并没有模拟这些通用的I/O服务。</p>
<p>NIO 的创建目的是为了让 Java 程序员可以实现高速 I/O 而无需编写自定义的本机代码。NIO 将最耗时的 I/O 操作(即填充和提取缓冲区)转移回操作系统，因而可以极大地提高速度。</p>
<h3 id="缓冲区操作"><a href="#缓冲区操作" class="headerlink" title="缓冲区操作"></a><strong>缓冲区操作</strong></h3><p>缓冲区操作是所有I/O的基础，进程执行I/O操作，归结起来就是向操作系统发出请求，让它要么把缓冲区里的数据排干（写），要么把缓冲区填满（读）。如下图<br><a href="http://img1.tbcdn.cn/L1/461/1/455589f44a7d459c13a3782be5c8173734880bb1" target="_blank" rel="external"><img src="http://img1.tbcdn.cn/L1/461/1/455589f44a7d459c13a3782be5c8173734880bb1" alt="15184210_Xonl"></a></p>
<p>进程使用<code>read()</code>系统调用，要求其缓冲区被填满。内核随即向磁盘控制硬件发出命令，要求其从磁盘读取数据。磁盘控制器把数据直接写入内核内存缓冲区，这一步通过 DMA 完成，无需主CPU协助。一旦磁盘控制器把缓冲区装满，内核即把数据从内核空间的临时缓冲区拷贝到进程执行<code>read()</code>调用时指定的缓冲区。</p>
<h3 id="JAVA-NIO"><a href="#JAVA-NIO" class="headerlink" title="JAVA NIO"></a><strong>JAVA NIO</strong></h3><p>JAVA的NIO是基于IO多路复用模型，在不同平台上有不同的实现方式。Linux下面用的是poll和epoll，在BSD上用kqueue，在Windows上是重叠I/O。</p>
<h4 id="1-缓冲区"><a href="#1-缓冲区" class="headerlink" title="1. 缓冲区"></a><strong>1. 缓冲区</strong></h4><p>通道是对原 I/O 包中的流的模拟。到任何目的地(或来自任何地方)的所有数据都必须通过一个 Channel 对象。一个 Buffer 实质上是一个容器对象。发送给一个通道的所有对象都必须首先放到缓冲区中；同样地，从通道中读取的任何数据都要读到缓冲区中。</p>
<p>Buffer是一个对象, 它包含一些要写入或者刚读出的数据。 在 NIO 中加入 Buffer 对象，体现了新库与原 I/O 的一个重要区别。在面向流的 I/O 中，您将数据直接写入或者将数据直接读到 Stream 对象中; 在 NIO 库中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的。在写入数据时，它是写入到缓冲区中的。任何时候访问 NIO 中的数据，都是将它放到缓冲区中。</p>
<p>缓冲区实质上就是一个数组，但它不仅仅是一个数组，缓冲区还提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。</p>
<p>缓冲区类型:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ByteBuffer</div><div class="line">CharBuffer</div><div class="line">ShortBuffer</div><div class="line">IntBuffer</div><div class="line">LongBuffer</div><div class="line">FloatBuffer</div><div class="line">DoubleBuffer</div></pre></td></tr></table></figure>
<h5 id="1-1-缓冲区基础"><a href="#1-1-缓冲区基础" class="headerlink" title="1.1 缓冲区基础"></a><strong>1.1 缓冲区基础</strong></h5><p>所有的缓冲区都具有四个属性来提供关于其所包含的数据元素的信息。</p>
<ul>
<li>容量（Capacity）</li>
</ul>
<blockquote>
<p>缓冲区能够容纳的数据元素的最大数量。这一容量在缓冲区创建时被设定，并且永远不能<br>被改变。</p>
<p>limit 决不能大于 capacity。</p>
</blockquote>
<ul>
<li>上界（Limit）</li>
</ul>
<blockquote>
<p>缓冲区的第一个不能被读或写的元素limit 变量表明还有多少数据需要取出(在从缓冲区写入通道时)，或者还有多少空间可以放入数据(在从通道读入缓冲区时)。</p>
<p>position 总是小于或者等于 limit。或者说，缓冲区中现存元素的计数。</p>
</blockquote>
<ul>
<li>位置（Position）</li>
</ul>
<blockquote>
<p>下一个要被读或写的元素的索引。位置会自动由相应的get()和put( )方法更新。</p>
<p>您可以回想一下，缓冲区实际上就是美化了的数组。在从通道读取时，您将所读取的数据放到底层的数组中。 position 变量跟踪已经写了多少数据。更准确地说，它指定了下一个字节将放到数组的哪一个元素中。因此，如果您从通道中读三个字节到缓冲区中，那么缓冲区的 position 将会设置为3，指向数组中第四个元素。</p>
<p>同样，在写入通道时，您是从缓冲区中获取数据。 position 值跟踪从缓冲区中获取了多少数据。更准确地说，它指定下一个字节来自数组的哪一个元素。因此如果从缓冲区写了5个字节到通道中，那么缓冲区的 position 将被设置为5，指向数组的第六个元素。</p>
</blockquote>
<ul>
<li>标记（Mark）</li>
</ul>
<blockquote>
<p>一个备忘位置。调用mark( )来设定mark= postion。调用reset( )设定position=<br>mark。标记在设定前是未定义的(undefined)。</p>
</blockquote>
<p>这四个属性之间总是遵循以下关系：<code>0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity</code></p>
<a id="more"></a>
<h5 id="1-2-缓冲区API"><a href="#1-2-缓冲区API" class="headerlink" title="1.2 缓冲区API"></a><strong>1.2 缓冲区API</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> java.nio; </div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">     *关于这个API有一点要注意的是，像clear()这类方法，通常应当返回void，而不</div><div class="line">     *是Buffer引用。这些方法将引用返回到它们在（this）上被引用的对象。这是一个允许级</div><div class="line">     *联调用的类设计方法。级联调用允许这种类型的代码：</div><div class="line">     *</div><div class="line">     *对于API还要注意的一点是isReadOnly()方法。所有的缓冲区都是可读的，但并非所</div><div class="line">     *有都可写。</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Buffer</span> </span>&#123; </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">capacity</span><span class="params">()</span></span>;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">position</span><span class="params">()</span></span>;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">position</span><span class="params">(<span class="keyword">int</span> newPosition)</span></span>;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">limit</span><span class="params">()</span></span>;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">limit</span><span class="params">(<span class="keyword">int</span> newLimit)</span></span>; </div><div class="line">        <span class="comment">//缓冲区的标记在mark( )方法被调用之前是未定义的（值为-1）。一些缓冲区方法会抛弃已经设定的标记（rewind()，clear()，以及flip()总是抛弃标记）。如果新设定的值比当前的标记小，调用limit()或position()带有索引参数的版本会抛弃标记。</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">mark</span><span class="params">()</span></span>;</div><div class="line">        <span class="comment">//reset( )方法将位置设为当前的标记值。</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">reset</span><span class="params">()</span></span>;</div><div class="line">        <span class="comment">//将上界设为容量的值，并把位置设回0，这使得缓冲区可以被重新填入。</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">clear</span><span class="params">()</span></span>;</div><div class="line">        <span class="comment">//翻转 相当于limit(buffer.position()).position(0)</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">flip</span><span class="params">()</span></span>;</div><div class="line">        <span class="comment">//与flip()相似，但不影响上界属性。它只是将位置值设回0。您可以使用rewind()后退，重读已经被翻转的缓冲区中的数据。</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">rewind</span><span class="params">()</span></span>;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">remaining</span><span class="params">()</span></span>;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasRemaining</span><span class="params">()</span></span>;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span>  <span class="keyword">boolean</span> <span class="title">isReadOnly</span><span class="params">()</span></span>; </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>上面所列出的的Buffer API并没有包括get()或put()方法。每一个Buffer类都有这两个方法，但它们所采用的参数类型，以及它们返回的数据类型，对每个子类来说都是唯一的，所以它们不能在顶层Buffer类中被抽象地声明。</p>
<h5 id="1-3-字节缓冲区"><a href="#1-3-字节缓冲区" class="headerlink" title="1.3 字节缓冲区"></a><strong>1.3 字节缓冲区</strong></h5><p>字节是操作系统及其I/O设备使用的基本数据类型。当在JVM和操作系统间传递数据时，将其他的数据类型拆分成构成它们的字节是十分必要的。系统层次的I/O面向字节的性质可以在整个缓冲区的设计以及它们互相配合的服务中感受到。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> java.nio; </div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteBuffer</span> <span class="keyword">extends</span> <span class="title">Buffer</span> <span class="keyword">implements</span> <span class="title">Comparable</span> </span></div><div class="line">    &#123; </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocate</span> <span class="params">(<span class="keyword">int</span> capacity)</span></span>; </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocateDirect</span> <span class="params">(<span class="keyword">int</span> capacity)</span></span>; </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span>  <span class="keyword">boolean</span> <span class="title">isDirect</span><span class="params">()</span></span>; </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">wrap</span> <span class="params">(<span class="keyword">byte</span>[] array, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span></span>; </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">wrap</span> <span class="params">(<span class="keyword">byte</span>[] array)</span></span>; </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">duplicate</span><span class="params">()</span></span>; </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span>  ByteBuffer <span class="title">asReadOnlyBuffer</span><span class="params">()</span></span>; </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span>  ByteBuffer <span class="title">slice</span><span class="params">()</span></span>; </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasArray</span><span class="params">()</span></span>; </div><div class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] array(); </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">arrayOffset</span><span class="params">()</span></span>; </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span>  <span class="keyword">byte</span> <span class="title">get</span><span class="params">()</span></span>; </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">byte</span> <span class="title">get</span> <span class="params">(<span class="keyword">int</span> index)</span></span>; </div><div class="line">        <span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">get</span> <span class="params">(<span class="keyword">byte</span>[] dst, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span></span>; </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">put</span> <span class="params">(<span class="keyword">byte</span> b)</span></span>; </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">put</span> <span class="params">(<span class="keyword">int</span> index, <span class="keyword">byte</span> b)</span></span>; </div><div class="line">        <span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">put</span> <span class="params">(ByteBuffer src)</span></span>; </div><div class="line">        <span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">put</span> <span class="params">(<span class="keyword">byte</span>[] src, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span></span>; </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ByteBuffer <span class="title">put</span> <span class="params">(<span class="keyword">byte</span>[] src)</span></span>; </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ByteOrder <span class="title">order</span><span class="params">()</span></span>; </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ByteBuffer <span class="title">order</span> <span class="params">(ByteOrder bo)</span></span>; </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span>  CharBuffer <span class="title">asCharBuffer</span><span class="params">()</span></span>; </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ShortBuffer <span class="title">asShortBuffer</span><span class="params">()</span></span>; </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span>  IntBuffer <span class="title">asIntBuffer</span><span class="params">()</span></span>; </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> LongBuffer <span class="title">asLongBuffer</span><span class="params">()</span></span>; </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span>  FloatBuffer <span class="title">asFloatBuffer</span><span class="params">()</span></span>; </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> DoubleBuffer <span class="title">asDoubleBuffer</span><span class="params">()</span></span>; </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">char</span> <span class="title">getChar</span><span class="params">()</span></span>; </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">char</span> <span class="title">getChar</span> <span class="params">(<span class="keyword">int</span> index)</span></span>; </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">putChar</span> <span class="params">(<span class="keyword">char</span> value)</span></span>; </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">putChar</span> <span class="params">(<span class="keyword">int</span> index, <span class="keyword">char</span> value)</span></span>; </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">short</span> <span class="title">getShort</span><span class="params">()</span></span>; </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">short</span> <span class="title">getShort</span> <span class="params">(<span class="keyword">int</span> index)</span></span>; </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">putShort</span> <span class="params">(<span class="keyword">short</span> value)</span></span>; </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">putShort</span> <span class="params">(<span class="keyword">int</span> index, <span class="keyword">short</span> value)</span></span>; </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span></span>; </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getInt</span> <span class="params">(<span class="keyword">int</span> index)</span></span>; </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">putInt</span> <span class="params">(<span class="keyword">int</span> value)</span></span>; </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">putInt</span> <span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span></span>; </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">getLong</span><span class="params">()</span></span>; </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">getLong</span> <span class="params">(<span class="keyword">int</span> index)</span></span>; </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">putLong</span> <span class="params">(<span class="keyword">long</span> value)</span></span>; </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">putLong</span> <span class="params">(<span class="keyword">int</span> index, <span class="keyword">long</span> value)</span></span>; </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">float</span> <span class="title">getFloat</span><span class="params">()</span></span>; </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">float</span> <span class="title">getFloat</span> <span class="params">(<span class="keyword">int</span> index)</span></span>; </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">putFloat</span> <span class="params">(<span class="keyword">float</span> value)</span></span>; </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">putFloat</span> <span class="params">(<span class="keyword">int</span> index, <span class="keyword">float</span> value)</span></span>; </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">getDouble</span><span class="params">()</span></span>; </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">getDouble</span> <span class="params">(<span class="keyword">int</span> index)</span></span>; </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">putDouble</span> <span class="params">(<span class="keyword">double</span> value)</span></span>; </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">putDouble</span> <span class="params">(<span class="keyword">int</span> index, <span class="keyword">double</span> value)</span></span>; </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">compact</span><span class="params">()</span></span>; </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span> <span class="params">(Object ob)</span></span>; </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span> <span class="params">(Object ob)</span></span>;  </div><div class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>; </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>字节顺序</li>
</ul>
<blockquote>
<p>多字节数值被存储在内存中的方式一般被称为endian-ness（字节顺序）。如果数字数值的最高字节——big end（大端），位于低位地址，那么系统就是大端字节顺序。字节顺序很少由软件设计者决定；它通常取决于硬件设计。如果最低字节最先保存在内存中，那么小端字节顺序。</p>
<p>当Internet的设计者为互联各种类型的计算机而设计网际协议（IP）时，他们意识到了在具有不同内部字节顺序的系统间传递数值数据的问题。因此，IP协议规定了使用大端的网络字节顺序概念。所有在IP分组报文的协议部分中使用的多字节数值必须先在本地主机字节顺序和通用的网络字节顺序之间进行转换。</p>
</blockquote>
<p>在java.nio中，字节顺序由ByteOrder类封装。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> java.nio; </div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteOrder</span> </span></div><div class="line">   &#123; </div><div class="line">       <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ByteOrder BIG_ENDIAN;</div><div class="line">       <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ByteOrder LITTLE_ENDIAN; </div><div class="line">       <span class="comment">//获取JVM运行平台的字节顺序</span></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteOrder <span class="title">nativeOrder</span><span class="params">()</span></span>;</div><div class="line">       <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>ByteBuffer类有所不同：默认字节顺序总是ByteBuffer.BIG_ENDIAN，无论系统的固有字节顺序是什么。Java的默认字节顺序是大端字节顺序，这允许类文件等以及串行化的对象可以在任何JVM中工作。如果固有硬件字节顺序是小端，这会有性能隐患。在使用固有硬件字节顺序时，将ByteBuffer的内容当作其他数据类型存取很可能高效得多。</p>
<h4 id="2-通道"><a href="#2-通道" class="headerlink" title="2. 通道"></a><strong>2. 通道</strong></h4><p>通道（Channel）是java.nio的第二个主要创新。它们既不是一个扩展也不是一项增强，而是全新、极好的Java I/O示例，提供与I/O服务的直接连接。Channel用于在字节缓冲区和位于通道另一侧的实体（通常是一个文件或套接字）之间有效地传输数据。</p>
<h5 id="2-1-通道基础"><a href="#2-1-通道基础" class="headerlink" title="2.1 通道基础"></a><strong>2.1 通道基础</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> java.nio.channels;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Channel</span></span>;</div><div class="line">   &#123;</div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOpen</span><span class="params">()</span></span>;</div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>通道接口允许您以一种受控且可移植的方式来访问底层的I/O服务。</p>
<p>通道是访问I/O服务的导管。I/O可以分为广义的两大类别：File I/O和Stream I/O。那么相应地有两种类型的通道也就不足为怪了，它们是文件（file）通道和套接字（socket）通道 ———— 一个FileChannel类和三个socket通道类：SocketChannel、ServerSocketChannel和 DatagramChannel。</p>
<h5 id="2-2-通道API"><a href="#2-2-通道API" class="headerlink" title="2.2 通道API"></a><strong>2.2 通道API</strong></h5><p>ByteChannel接口，它同时继承了ReadableByteChannel 和WritableByteChannel两个接口。ByteChannel接口本身并不定义新的API方法，它是一个聚集了所继承的多个接口，并重新命名的便捷接口。根据定义，实现ByteChannel接口的通道同时也会实现ReadableByteChannel 和WritableByteChannel两个接口，所以此类通道是双向的。</p>
<p>通道可以以阻塞（blocking）或非阻塞（non-blocking）模式运行。非阻塞模式的通道永远不会让调用的线程休眠。请求的操作要么立即完成，要么返回一个结果表明未进行任何操作。只有面向流的（stream-oriented）的通道，如sockets和pipes才能使用非阻塞模式。</p>
<p>socket通道类继承了SelectableChannel。继承SelectableChannel的类可以和Selector一起使用，后者支持就绪选择。将非阻塞I/O和选择器组合起来可以使您的程序利用多路复用I/O。</p>
<p>与缓冲区不同，通道不能被重复使用。一个打开的通道即代表与一个特定I/O服务的特定连接并封装该连接的状态。当通道关闭时，那个连接会丢失，然后通道将不再连接任何东西。</p>
<p>调用通道的close( )方法时，可能会导致在通道关闭底层I/O服务的过程中线程暂时阻塞，哪怕该通道处于非阻塞模式。通道关闭时的阻塞行为（如果有的话）是高度取决于操作系统或者文件系统的。在一个通道上多次调用close( )方法是没有坏处的，但是如果第一个线程在close( )方法中阻塞，那么在它完成关闭通道之前，任何其他调用close( )方法都会阻塞。后续在该已关闭的通道上调用close( )不会产生任何操作，只会立即返回。</p>
<h5 id="2-3-文件通道API"><a href="#2-3-文件通道API" class="headerlink" title="2.3 文件通道API"></a><strong>2.3 文件通道API</strong></h5><p>FileChannel类可以实现常用的read，write操作.同时它也提供了很多专用于文件的新方法。这些方法中的许多都是我们所熟悉的文件操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> java.nio.channels;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FileChannel</span> <span class="keyword">extends</span> <span class="title">AbstractChannel</span> <span class="keyword">implements</span> <span class="title">ByteChannel</span>, <span class="title">GatheringByteChannel</span>, <span class="title">ScatteringByteChannel</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="comment">// This is a partial API listing</span></div><div class="line">        <span class="comment">// All methods listed here can throw java.io.IOException</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">read</span> <span class="params">(ByteBuffer dst, <span class="keyword">long</span> position)</span></span>;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">write</span> <span class="params">(ByteBuffer src, <span class="keyword">long</span> position)</span></span>;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">size</span><span class="params">()</span></span>;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">position</span><span class="params">()</span></span>;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">position</span> <span class="params">(<span class="keyword">long</span> newPosition)</span></span>;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">truncate</span> <span class="params">(<span class="keyword">long</span> size)</span></span>;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">force</span> <span class="params">(<span class="keyword">boolean</span> metaData)</span></span>;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> FileLock <span class="title">lock</span><span class="params">()</span></span>;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> FileLock <span class="title">lock</span> <span class="params">(<span class="keyword">long</span> position, <span class="keyword">long</span> size, <span class="keyword">boolean</span> shared)</span></span>;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> FileLock <span class="title">tryLock</span><span class="params">()</span></span>;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> FileLock <span class="title">tryLock</span> <span class="params">(<span class="keyword">long</span> position, <span class="keyword">long</span> size, <span class="keyword">boolean</span> shared)</span></span>;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> MappedByteBuffer <span class="title">map</span> <span class="params">(MapMode mode, <span class="keyword">long</span> position, <span class="keyword">long</span> size)</span></span>;</div><div class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MapMode</span></span>;</div><div class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> MapMode READ_ONLY;</div><div class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> MapMode READ_WRITE;</div><div class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> MapMode PRIVATE;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">transferTo</span> <span class="params">(<span class="keyword">long</span> position, <span class="keyword">long</span> count, WritableByteChannel target)</span></span>;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">transferFrom</span> <span class="params">(ReadableByteChannel src, <span class="keyword">long</span> position, <span class="keyword">long</span> count)</span></span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[maven 通过配置打不同环境的包]]></title>
      <url>http://zsr.github.io/2016/10/19/maven-%E9%80%9A%E8%BF%87%E9%85%8D%E7%BD%AE%E6%89%93%E4%B8%8D%E5%90%8C%E7%8E%AF%E5%A2%83%E7%9A%84%E5%8C%85/</url>
      <content type="html"><![CDATA[<h3 id="背景：一"><a href="#背景：一" class="headerlink" title="背景：一"></a><strong>背景：一</strong></h3><p>项目由不同的分支(如：dev， test,  product),每一分支对应的环境变量有差异。需要根据maven打包命令传入不同的参数(如 -Ptest)来实现具体使用哪个分支的配置。</p>
<p><strong>解决方案：</strong></p>
<ul>
<li><strong>在pom.xml配置的<code>&lt;profiles&gt; &lt;/profiles&gt;</code>中添加<code>&lt;profile&gt; &lt;/profile&gt;</code></strong></li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">id</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">activation</span>&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span> <span class="tag">&lt;<span class="name">!</span> <span class="attr">-</span> <span class="attr">-</span>这里默认是<span class="attr">dev-</span> <span class="attr">-</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">envcfg.dir</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">envcfg.dir</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>test<span class="tag">&lt;/<span class="name">id</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">envcfg.dir</span>&gt;</span>test<span class="tag">&lt;/<span class="name">envcfg.dir</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>pro<span class="tag">&lt;/<span class="name">id</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">envcfg.dir</span>&gt;</span>product<span class="tag">&lt;/<span class="name">envcfg.dir</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></div></pre></td></tr></table></figure>
<p>在<code>&lt;properties&gt; &lt;/properties&gt;</code>中配置不同的环境参数(这里是配置文件目录名)。</p>
<ul>
<li><strong>在pom.xml文件中配置build</strong></li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">sourceDirectory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">sourceDirectory</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">testSourceDirectory</span>&gt;</span>src/test/java<span class="tag">&lt;/<span class="name">testSourceDirectory</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>target/classes<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">testOutputDirectory</span>&gt;</span>target/test-classes<span class="tag">&lt;/<span class="name">testOutputDirectory</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">testResources</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">testResource</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/test/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">testResource</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">testResources</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">resource</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">resource</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!--注意这里引用的$&#123;envcfg.dir&#125;--&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/conf/$&#123;envcfg.dir&#125;<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">directory</span>&gt;</span>target<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></div></pre></td></tr></table></figure>
<p>在<code>&lt;build&gt;&lt;/build&gt;</code> 配置中添加上一步的文件目录名，这样使用maven -Ptest 命令打包的时候，会将src/main/conf/test目录下的文件都添加到项目路径下面。</p>
<h3 id="背景-二"><a href="#背景-二" class="headerlink" title="背景: 二"></a><strong>背景: 二</strong></h3><p>如果只配置了<code>&lt;profiles&gt; &lt;/profiles&gt;</code>，则当前仓库中同一版本只能有一个jar包，这样选择-Ptest或者-Ppro命令就会覆盖jar包，导致客户端调用产生问题（比如：location-local-0.3.3.jar,这个版本可能是test或者pro，客户端如果生产版本调用了test jar包则会产生异常）。</p>
<p><strong>解决方案:</strong> 在每一个分支jar包后面带上分支名称，如：location-local-0.3.5-test.jar;这样客户端就可以选择不同分支的jar包。</p>
<ul>
<li><strong>在服务端pom.xml中如下配置</strong>：(注意加**的地方与背景一不同)</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line">在<span class="tag">&lt;<span class="name">build</span>&gt;</span><span class="tag">&lt;/<span class="name">build</span>&gt;</span>标签中配置：</div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">sourceDirectory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">sourceDirectory</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">testSourceDirectory</span>&gt;</span>src/test/java<span class="tag">&lt;/<span class="name">testSourceDirectory</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>target/classes<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">testOutputDirectory</span>&gt;</span>target/test-classes<span class="tag">&lt;/<span class="name">testOutputDirectory</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">testResources</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">testResource</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/test/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">testResource</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">testResources</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">resource</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">resource</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/conf/$&#123;envcfg.dir&#125;<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">directory</span>&gt;</span>target<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!--新增部分配置--&gt;</span></div><div class="line"> **</div><div class="line">    <span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-jar-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">executions</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">execution</span>&gt;</span></div><div class="line">              <span class="tag">&lt;<span class="name">id</span>&gt;</span>default-jar<span class="tag">&lt;/<span class="name">id</span>&gt;</span></div><div class="line">              <span class="tag">&lt;<span class="name">goals</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></div><div class="line">              <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></div><div class="line">              <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">classifier</span>&gt;</span>$&#123;envcfg.classifier&#125;<span class="tag">&lt;/<span class="name">classifier</span>&gt;</span></div><div class="line">              <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></div><div class="line">          <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-jar-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></div><div class="line">**</div><div class="line"></div><div class="line">在<span class="tag">&lt;<span class="name">profile</span>&gt;</span><span class="tag">&lt;/<span class="name">profile</span>&gt;</span>标签中配置：</div><div class="line"></div><div class="line">   <span class="tag">&lt;<span class="name">profile</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">id</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">activation</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">properties</span>&gt;</span></div><div class="line">       ** <span class="tag">&lt;<span class="name">envcfg.classifier</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">envcfg.classifier</span>&gt;</span> **</div><div class="line">        <span class="tag">&lt;<span class="name">envcfg.dir</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">envcfg.dir</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>test<span class="tag">&lt;/<span class="name">id</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">properties</span>&gt;</span></div><div class="line">       ** <span class="tag">&lt;<span class="name">envcfg.classifier</span>&gt;</span>test<span class="tag">&lt;/<span class="name">envcfg.classifier</span>&gt;</span> **</div><div class="line">        <span class="tag">&lt;<span class="name">envcfg.dir</span>&gt;</span>test<span class="tag">&lt;/<span class="name">envcfg.dir</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>pro<span class="tag">&lt;/<span class="name">id</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">properties</span>&gt;</span></div><div class="line">       ** <span class="tag">&lt;<span class="name">envcfg.classifier</span>&gt;</span>product<span class="tag">&lt;/<span class="name">envcfg.classifier</span>&gt;</span> **</div><div class="line">        <span class="tag">&lt;<span class="name">envcfg.dir</span>&gt;</span>product<span class="tag">&lt;/<span class="name">envcfg.dir</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></div></pre></td></tr></table></figure>
<p>这里的<code>classifier</code>指向jar包后缀的名称。</p>
<ul>
<li><strong>客户端pom.xml引用配置如下：</strong></li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.ximalaya.location<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>location-local<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.3.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">classifier</span>&gt;</span>test<span class="tag">&lt;/<span class="name">classifier</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<p>通过<code>classifier</code>可以选择需要引用的jar包。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Google S2]]></title>
      <url>http://zsr.github.io/2016/10/17/Google-S2/</url>
      <content type="html"><![CDATA[<h3 id="Google-S2作用："><a href="#Google-S2作用：" class="headerlink" title="Google S2作用："></a><strong>Google S2作用：</strong></h3><p>根据多边形的边界区域映射成由许多一维数值构成的集合，这样就可以由这个集合代替多边形区域，便于后续计算。<br>典型的可以将不同国家(或者地区)的边界区域(经纬度)计算成一维数值的集合，可以用于判断该区域的任何一个坐标是否包涵在内，简单的说就是地理定位。</p>
<p>s2库提供了一个Cell的概念，<strong>每个Cell相当于一个单元格，在一个单元格内的所有Point，都可以算出同一个CellId</strong>。同时可以认为，一个Polygon可以用一个Cell的集合来表示。<br>那么这时的步骤就是通过区域的坐标，来初始化其内包含的所有的CellId，将这些CellId的id放入redis中做key，对应的value是区域名称(譬如，上海浦东新区)，构建完全国范围的CellId后，查询用户的区域就可以通过用户的坐标获得一个CellId，然后去redis中查询，在使用LocalCache后，基本就没有什么计算成本，完全可以满足性能需求。</p>
<h3 id="操作步骤："><a href="#操作步骤：" class="headerlink" title="操作步骤："></a><strong>操作步骤：</strong></h3><p>1）首先获取地域图形的坐标点集合，可以从Natural Earth网站获取全球的坐标元数据(.shp文件)。<br>2）解析shp文件，生成区域坐标集合，这里选择pyshp(解析shp文件的python插件)，这里需要注意：同一个国家可能包涵多个区域(muti Polygon)，需要分开处理。下载地址：<a href="https://pypi.python.org/pypi/pyshp/" target="_blank" rel="external">https://pypi.python.org/pypi/pyshp/</a><br>3）使用Google S2将多边形的边界坐标集合转化为一维数值集合，代表这个多边形的覆盖区域。</p>
<h3 id="S2原理："><a href="#S2原理：" class="headerlink" title="S2原理："></a><strong>S2原理：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">S2RegionCoverer coverer = <span class="keyword">new</span> S2RegionCoverer();</div><div class="line">ArrayList&lt;S2CellId&gt; covering = <span class="keyword">new</span> ArrayList&lt;S2CellId&gt;();</div><div class="line">coverer.setMinLevel(minLevel);</div><div class="line">coverer.setMaxLevel(maxLevel);</div><div class="line">coverer.setMaxCells(<span class="number">1000000</span>);</div><div class="line">S2Polygon s2Polygon = S2Polygon.makePolygon(polygonValue);</div><div class="line"><span class="comment">//getCovering()表示可以最小程度覆盖整个区域，外接多边形</span></div><div class="line">coverer.getCovering(s2Polygon, covering);</div><div class="line"><span class="comment">//getInteriorCovering()表示最大程度填充整个区域，内接多边形</span></div><div class="line"><span class="comment">// coverer.getInteriorCovering(s2Polygon, covering);</span></div><div class="line">System.out.println(<span class="string">"covering of size:"</span> + covering.size());</div></pre></td></tr></table></figure>
<p>这里采用getCovering()外接多边形模式，避免多边形区域有盲点。MinLevel＝9，MaxLevel＝14 </p>
<p><strong>说明：</strong>MaxLevel最多可以设置30级，每升一级精度提升接近4倍，14级单个Cell可以表示范围：200平米~400平米，层级越高，构建越慢。</p>
<p><a href="http://blog.christianperone.com/wp-content/uploads/2015/08/s2_cell_area.png" target="_blank" rel="external"><img src="http://blog.christianperone.com/wp-content/uploads/2015/08/s2_cell_area.png" alt="Cell areas"></a></p>
<p>S2需要将地理位置表示为计算机可以理解的方式，即二进制码的表示，所以我们的目标就是用二进制码来表示三维空间。如何来做呢？需要进行降维。</p>
<a id="more"></a>
<p>1) 首先从三维降到二维，我们将地球放在一个正方体中，假设地球中心发光，光线穿过球体表面到达正方体平面的点就是球体表面的点的投影。于是我们就可以将地球投影到正方体的六个正方形表面。</p>
<p><img src="https://pic1.zhimg.com/6879b5d273829197535c347f2adddb74_b.png" alt="img"></p>
<p>通过投影我们可以将三维球体映射到二维平面，但是这个方法有一个问题，就是投影长度的比例不同。水平方向上的投影长度比上下两端的投影长度小，这就造成了投射面积不均匀，会影响以后对地图的切分。解决方法就是再进行一次区间转换，对长度进行微挑，将长的拉短，短的拉长，尽量使投影面积分布均匀。</p>
<p><img src="https://pic4.zhimg.com/0e58057b333a6c2935feef0ea27d1ccb_b.png" alt="img"></p>
<p>2) 将二维变成一维。我们有很多点组成的正方形平面，如何对这个平面进行一维表示呢？方法就是遍历，比如我们就可以用00 01 10 11来表示下面四个点组成的平面。将这种方法不断扩展到极限，我们可以得到填充整个二维平面的一条曲线，这就是著名的希尔伯特曲线（Hilbert Curve）。希尔伯特曲线可以把二维平面映射到一条线段上，它还有一个优势就是可以保存局部性，即空间位置相近的点在希尔伯特曲线上的位置也是相近的。<img src="https://pic4.zhimg.com/8803b4a0d220077891ccaafe55cb430b_b.png" alt="img"></p>
<p> <a href="http://blog.christianperone.com/wp-content/uploads/2015/08/hilbert_middle.png" target="_blank" rel="external"><img src="http://blog.christianperone.com/wp-content/uploads/2015/08/hilbert_middle.png" alt="Hilbert Curve"></a></p>
<p>可以发现位置相近的二维坐标在一维线段上面也是邻近的。</p>
<p>3) 创建cell集合：</p>
<p><strong>简单来说，就是将一个能完整覆盖多边形面积的cell，不断的划分(4块cell)，如果4快仍然全部与多边形相交则继续划分，否则有一个或多个cell不与多边形相交则抛弃，直至最大划分到maxLevel。</strong>可以发现如果maxLevel设置的越大，则精度越高(测试效率来看，maxLevel设置为14，15级已经比较精确，层级大于15级非常影响生成cell的效率)。</p>
<p>这里假设多边形区域为二维图形，如果需要对该图形进行覆盖，可能有以下可能：</p>
<ul>
<li><p>cell被包含在多边形内部</p>
<p><img src="/images/Google_s2_1.png"></p>
</li>
<li><p>cell与多边形相交(有一部分在外面)</p>
<p><img src="/images/Google_s2_2.png"></p>
<p>图中大的cell和多边形相交，如果该cell的level已经达到maxLevel则停止划分，并将这个cell加入最后集合；如果这时候该cell的level小于maxLevel,则继续划分为4小块(不一定等分)，可以发现有2个小的cell仍然与多边形相交，如果这2个cell层级已经达到MaxLevel则将这2个加入最终集合，否则继续划分，另外2个cell已经在多边形的外面则抛弃，</p>
</li>
</ul>
<p>如果多边形内部可以完整填充一个cell(注意限制：minLevel，maxLevel; 级别越小，cell越大)，则将该cell直接添加到集合中。比如这里设置的minLevel＝9(一般只有面积非常大的国家才会有level＝9),所以多边形区域所能生成的最大面积cell只有可能是level＝9.</p>
<p>根据实际测试来看，像美国，俄罗斯相对面积比较大的国家，最小的level可以达到7(目测地球所有国家中最小的level就是7)，也就是说这些国家的面积可以内涵完整的level=7的cell，这么做可以将许多高层次的cell由一个低层次的cell替代，减少了生成的cell数量同时表示的范围没有变化。</p>
<p>之所以这里选择minLevel＝9，是为了以后定位方便，目前的定位是通过经纬度由Google S2生成CellId，再由这个CellId查询所有的CellId集合，如果有匹配的则命中。匹配的代码 如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> minLevel = <span class="number">9</span>;</div><div class="line"><span class="keyword">int</span> maxLevel = <span class="number">14</span>;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = minLevel; i &lt; (maxLevel + <span class="number">1</span>); i++) &#123;</div><div class="line">	paCell = s2cell.parent(i);</div><div class="line">	<span class="keyword">if</span> (cellIds.contains(paCell.id())) &#123;</div><div class="line">		System.out.println(<span class="string">"命中!!!"</span>);</div><div class="line">		<span class="keyword">break</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>匹配的规则：先从最低级别判断，如果没有被包含在CellId集合中则判断其父层是否被包含，这样逐层递增直至maxLevel。<strong>所以minLevel设置的太小会增加判断次数</strong>，在并发比较大的情况下会影响效率。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[mvc:interceptors]]></title>
      <url>http://zsr.github.io/2016/10/14/mvc-interceptors/</url>
      <content type="html"><![CDATA[<h3 id="一-spring-MVC-Interceptor-作用"><a href="#一-spring-MVC-Interceptor-作用" class="headerlink" title="一. spring MVC Interceptor 作用:"></a><strong>一. spring MVC Interceptor 作用:</strong></h3><p>Spring MVC框架中的Interceptor，与Servlet API中的Filter十分类似，用于对Web请求进行预处理/后处理。通常情况下这些预处理/后处理逻辑是通用的，可以被应用于所有或多个Web请求，例如：</p>
<ul>
<li>记录Web请求相关日志，可以用于做一些信息监控、统计、分析</li>
<li>检查Web请求访问权限，例如发现用户没有登录后，重定向到登录页面</li>
<li>打开/关闭数据库连接——预处理时打开，后处理关闭，可以避免在所有业务方法中都编写类似代码，也不会忘记关闭数据库连接</li>
</ul>
<h3 id="二-拦截器和过滤器filter的区别："><a href="#二-拦截器和过滤器filter的区别：" class="headerlink" title="二. 拦截器和过滤器filter的区别："></a><strong>二. 拦截器和过滤器filter的区别：</strong></h3><ol>
<li>Filter是Servlet规范规定的，只能用于web<a href="http://www.xuebuyuan.com/" target="_blank" rel="external">程序</a>中。而拦截器既可以用于web程序，也可以用于Application、Swing程序中。</li>
</ol>
<ol>
<li>Filter是在Servlet规范中定义的，是Servlet容器支持的。而拦截器是在Spring容器中的，是Spring框架支持的。</li>
<li>同其他代码块一样，拦截器也是一个Spring的组件，归Spring管理，配置在Spring文件中，因此能使用Spring里的任何资源、对象，例如Service对象、数据源、事务管理等，通过IoC注入到拦截器即可；而Filter则不能</li>
<li>Filter只在Servlet前后起作用。而拦截器能够深入得到方法前后、异常抛出前后等，因为拦截器的使用具有更大的弹性。所以在Spring构架的程序中，要优先使用拦截器。</li>
</ol>
<h3 id="三-Spring-MVC请求处理流程"><a href="#三-Spring-MVC请求处理流程" class="headerlink" title="三. Spring MVC请求处理流程"></a><strong>三. Spring MVC请求处理流程</strong></h3><p><a href="http://assets.tianmaying.com/md-image/97936b6d48e3c678ade5e7307eeb54ba" target="_blank" rel="external"><img src="http://assets.tianmaying.com/md-image/97936b6d48e3c678ade5e7307eeb54ba" alt="alter-text"></a></p>
<p>上图是Spring MVC框架处理Web请求的基本流程，请求会经过<code>DispatcherServlet</code>的分发后，会按顺序经过一系列的<code>Interceptor</code>并执行其中的预处理方法(preHandle)，在请求返回时同样会执行其中的后处理方法(postHandle)。</p>
<h3 id="四-拦截器接口-HandlerInterceptor"><a href="#四-拦截器接口-HandlerInterceptor" class="headerlink" title="四. 拦截器接口-HandlerInterceptor"></a><strong>四. 拦截器接口-HandlerInterceptor</strong></h3><p>Spring MVC中拦截器是实现了<code>HandlerInterceptor</code>接口的Bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerInterceptor</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, </span></span></div><div class="line">                      HttpServletResponse response, </div><div class="line">                      Object handler) <span class="keyword">throws</span> Exception;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, </span></span></div><div class="line">                    HttpServletResponse response, </div><div class="line">                    Object handler, ModelAndView modelAndView) <span class="keyword">throws</span> Exception;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, </span></span></div><div class="line">                         HttpServletResponse response, </div><div class="line">                         Object handler, Exception ex) <span class="keyword">throws</span> Exception;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>HandlerInterceptor</code> 接口中定义了三个方法，就是通过这三个方法来对用户的请求进行拦截处理的。</p>
<ul>
<li>(1). preHandle (HttpServletRequest request, HttpServletResponse response, Object handle) 方法。<strong>该方法将在请求处理之前进行调用</strong>。SpringMVC 中的Interceptor 是链式的调用的，在一个应用中或者说是在一个请求中可以同时存在多个Interceptor 。每个Interceptor 的调用会依据它的声明顺序依次执行，而且最先执行的都是Interceptor 中的preHandle 方法，所以可以在这个方法中进行一些前置初始化操作或者是对当前请求的一个预处理，也可以在这个方法中进行一些判断来决定请求是否要继续进行下去。该方法的返回值是布尔值Boolean 类型的，当它返回为false 时，表示请求结束，后续的Interceptor 和Controller 都不会再执行；当返回值为true 时就会继续调用下一个Interceptor 的preHandle 方法，如果已经是最后一个Interceptor 的时候就会是调用当前请求的Controller 方法。</li>
</ul>
<ul>
<li>(2). postHandle (HttpServletRequest request, HttpServletResponse response, Object handle, ModelAndView modelAndView) 方法，由preHandle 方法的解释我们知道这个方法包括后面要说到的afterCompletion 方法都只能是在当前所属的Interceptor 的preHandle 方法的返回值为true 时才能被调用。<strong>postHandle 方法，顾名思义就是在当前请求进行处理之后，也就是Controller 方法调用之后执行，但是它会在DispatcherServlet 进行视图返回渲染之前被调用，所以我们可以在这个方法中对Controller 处理之后的ModelAndView 对象进行操作</strong>。postHandle 方法被调用的方向跟preHandle 是相反的，也就是说先声明的Interceptor 的postHandle 方法反而会后执行，这和Struts2 里面的Interceptor 的执行过程有点类型。Struts2 里面的Interceptor 的执行过程也是链式的，只是在Struts2 里面需要手动调用ActionInvocation 的invoke 方法来触发对下一个Interceptor 或者是Action 的调用，然后每一个Interceptor 中在invoke 方法调用之前的内容都是按照声明顺序执行的，而invoke 方法之后的内容就是反向的。</li>
<li>(3). afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handle, Exception ex) 方法，该方法也是需要当前对应的Interceptor 的preHandle 方法的返回值为true 时才会执行。顾名思义，<strong>该方法将在整个请求结束之后，也就是在DispatcherServlet 渲染了对应的视图之后执行</strong>。这个方法的主要作用是用于进行资源清理工作的。 我们的系统日志的拦截在这个方法中，可以记录日志的相关的参数，检测方法的执行。</li>
</ul>
<h3 id="五-拦截器配置"><a href="#五-拦截器配置" class="headerlink" title="五. 拦截器配置"></a><strong>五. 拦截器配置</strong></h3><ul>
<li><p><strong><code>DefaultAnnotationHandlerMapping</code></strong></p>
<p>自定义的拦截器可以通过DefaultAnnotationHandlerMapping注入到spring框架中。可以打开org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping，可以看到具体的注入细节。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 通过DefaultAnnotationHandlerMapping将拦截器注入 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span>           <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"interceptors"</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">list</span>&gt;</span></div><div class="line">			<span class="comment">&lt;!-- 这边可以实现多个拦截器 --&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"DefaultInterceptor"</span>  /&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="name">list</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 自定义的default的拦截器 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"DefaultInterceptor"</span> <span class="attr">class</span>=<span class="string">"com.xxx.test.DefaultInterceptor"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p><strong>通过 <code>&lt;mvc:interceptors&gt;</code> 的方式配置：</strong></p>
<p>Spring MVC interceptor一般配置这种模式。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></div><div class="line">    	<span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">"/api/time/get_time/"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.xxx.test.DefaultInterceptor"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></div></pre></td></tr></table></figure>
<p>​</p>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[SSL/TLS协议运行机制]]></title>
      <url>http://zsr.github.io/2016/10/14/SSL-TLS%E5%8D%8F%E8%AE%AE%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<p>互联网的通信安全，建立在SSL/TLS协议之上。</p>
<h3 id="一、作用"><a href="#一、作用" class="headerlink" title="一、作用"></a><strong>一、作用</strong></h3><p>不使用SSL/TLS的HTTP通信，就是不加密的通信。所有信息明文传播，带来了三大风险。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">（1） 窃听风险（eavesdropping）：第三方可以获知通信内容。</div><div class="line">（2） 篡改风险（tampering）：第三方可以修改通信内容。</div><div class="line">（3） 冒充风险（pretending）：第三方可以冒充他人身份参与通信。</div></pre></td></tr></table></figure>
<p>SSL/TLS协议是为了解决这三大风险而设计的，希望达到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">（1） 所有信息都是加密传播，第三方无法窃听。</div><div class="line">（2） 具有校验机制，一旦被篡改，通信双方会立刻发现。</div><div class="line">（3） 配备身份证书，防止身份被冒充。</div></pre></td></tr></table></figure>
<p>互联网是开放环境，通信双方都是未知身份，这为协议的设计带来了很大的难度。而且，协议还必须能够经受所有匪夷所思的攻击，这使得SSL/TLS协议变得异常复杂。</p>
<h3 id="二、历史"><a href="#二、历史" class="headerlink" title="二、历史"></a><strong>二、历史</strong></h3><p>互联网加密通信协议的历史，几乎与互联网一样长。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1994年，NetScape公司设计了SSL协议（Secure Sockets Layer）的1.0版，但是未发布。</div><div class="line">1995年，NetScape公司发布SSL 2.0版，很快发现有严重漏洞。</div><div class="line">1996年，SSL 3.0版问世，得到大规模应用。</div><div class="line">1999年，互联网标准化组织ISOC接替NetScape公司，发布了SSL的升级版TLS 1.0版。</div><div class="line">2006年和2008年，TLS进行了两次升级，分别为TLS 1.1版和TLS 1.2版。最新的变动是2011年TLS 1.2的修订版。</div></pre></td></tr></table></figure>
<p>目前，应用最广泛的是TLS 1.0，接下来是SSL 3.0。但是，主流浏览器都已经实现了TLS 1.2的支持。</p>
<p>TLS 1.0通常被标示为SSL 3.1，TLS 1.1为SSL 3.2，TLS 1.2为SSL 3.3。</p>
<h3 id="三、基本的运行过程"><a href="#三、基本的运行过程" class="headerlink" title="三、基本的运行过程"></a><strong>三、基本的运行过程</strong></h3><p>SSL/TLS协议的基本思路是采用<a href="http://en.wikipedia.org/wiki/Public-key_cryptography" target="_blank" rel="external">公钥加密法</a>，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。</p>
<p>但是，这里有两个问题。</p>
<p><strong>（1）如何保证公钥不被篡改？</strong></p>
<blockquote>
<p>解决方法：将公钥放在<a href="http://en.wikipedia.org/wiki/Digital_certificate" target="_blank" rel="external">数字证书</a>中。只要证书是可信的，公钥就是可信的。</p>
</blockquote>
<p><strong>（2）公钥加密计算量太大，如何减少耗用的时间？</strong></p>
<blockquote>
<p>解决方法：每一次对话（session），客户端和服务器端都生成一个”对话密钥”（session key），用它来加密信息。由于”对话密钥”是对称加密，所以运算速度非常快，而服务器公钥只用于加密”对话密钥”本身，这样就减少了加密运算的消耗时间。</p>
</blockquote>
<p>因此，SSL/TLS协议的基本过程是这样的：</p>
<blockquote>
<p>（1） 客户端向服务器端索要并验证公钥。</p>
<p>（2） 双方协商生成”对话密钥”。</p>
<p>（3） 双方采用”对话密钥”进行加密通信。</p>
</blockquote>
<p>上面过程的前两步，又称为”握手阶段”（handshake）。</p>
<h3 id="四、握手阶段的详细过程"><a href="#四、握手阶段的详细过程" class="headerlink" title="四、握手阶段的详细过程"></a><strong>四、握手阶段的详细过程</strong></h3><p><img src="http://image.beekka.com/blog/201402/bg2014020502.png" alt="img"></p>
<p>“握手阶段”涉及四次通信，我们一个个来看。需要注意的是，”握手阶段”的所有通信都是明文的。</p>
<h4 id="4-1-客户端发出请求（ClientHello）"><a href="#4-1-客户端发出请求（ClientHello）" class="headerlink" title="4.1 客户端发出请求（ClientHello）"></a><strong>4.1 客户端发出请求（ClientHello）</strong></h4><p>首先，客户端（通常是浏览器）先向服务器发出加密通信的请求，这被叫做<code>ClientHello</code>请求。</p>
<p>在这一步，客户端主要向服务器提供以下信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">（1） 支持的协议版本，比如TLS 1.0版。</div><div class="line">（2） 一个客户端生成的随机数，稍后用于生成&quot;对话密钥&quot;。</div><div class="line">（3） 支持的加密方法，比如RSA公钥加密。</div><div class="line">（4） 支持的压缩方法。</div></pre></td></tr></table></figure>
<p>这里需要注意的是，客户端发送的信息之中不包括服务器的域名。也就是说，理论上服务器只能包含一个网站，否则会分不清应该向客户端提供哪一个网站的数字证书。这就是为什么通常一台服务器只能有一张数字证书的原因。</p>
<p>对于虚拟主机的用户来说，这当然很不方便。2006年，TLS协议加入了一个<a href="http://tools.ietf.org/html/rfc4366" target="_blank" rel="external">Server Name Indication扩展</a>，允许客户端向服务器提供它所请求的域名。</p>
<h4 id="4-2-服务器回应（SeverHello）"><a href="#4-2-服务器回应（SeverHello）" class="headerlink" title="4.2 服务器回应（SeverHello）"></a><strong>4.2 服务器回应（SeverHello）</strong></h4><p>服务器收到客户端请求后，向客户端发出回应，这叫做SeverHello。服务器的回应包含以下内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">（1） 确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。</div><div class="line">（2） 一个服务器生成的随机数，稍后用于生成&quot;对话密钥&quot;。</div><div class="line">（3） 确认使用的加密方法，比如RSA公钥加密。</div><div class="line">（4） 服务器证书。</div></pre></td></tr></table></figure>
<p>除了上面这些信息，<strong>如果服务器需要确认客户端的身份，就会再包含一项请求，要求客户端提供”客户端证书”</strong>。比如，金融机构往往只允许认证客户连入自己的网络，就会向正式客户提供USB密钥，里面就包含了一张客户端证书。</p>
<h4 id="4-3-客户端回应"><a href="#4-3-客户端回应" class="headerlink" title="4.3 客户端回应"></a><strong>4.3 客户端回应</strong></h4><p>客户端收到服务器回应以后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。</p>
<p>如果证书没有问题，客户端就会从证书中取出服务器的公钥。然后，向服务器发送下面三项信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">（1） 一个随机数。该随机数用服务器公钥加密，防止被窃听。</div><div class="line">（2） 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。</div><div class="line">（3） 客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。</div></pre></td></tr></table></figure>
<p>上面第一项的随机数，是整个握手阶段出现的第三个随机数，又称”pre-master key”。有了它以后，客户端和服务器就同时有了三个随机数，接着双方就用事先商定的加密方法，各自生成本次会话所用的<strong>同一把”会话密钥”</strong>。</p>
<p>至于为什么一定要用三个随机数，来生成”会话密钥”，<a href="http://blog.csdn.net/dog250/article/details/5717162" target="_blank" rel="external">dog250</a>解释得很好：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&quot;不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于SSL协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。</div><div class="line">对于RSA密钥交换算法来说，pre-master-key本身就是一个随机数，再加上hello消息中的随机，三个随机数通过一个密钥导出器最终导出一个对称密钥。</div><div class="line">pre master的存在在于SSL协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么pre master secret就有可能被猜出来，那么仅适用pre master secret作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上pre master secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是一。&quot;</div></pre></td></tr></table></figure>
<p><strong>此外，如果前一步，服务器要求客户端证书，客户端会在这一步发送证书及相关信息。</strong></p>
<p>同时需要注意前两个随机数都是明文传输的，窃听者是可以轻易获取到的，只有最后一个<strong>PreMaster Secret 是加密传输的，只有拥有服务器私钥才能解密</strong>，一旦 PreMaster Secret 泄露，那么本次通信就就完全可被破解了。</p>
<ul>
<li><strong>PreMaster Secret 说明</strong></li>
</ul>
<p>PreMaster secret是在客户端使用RSA或者Diffie-Hellman等加密算法生成的。它将用来跟服务端和客户端在Hello阶段产生的随机数结合在一起生成Master secret(包含会话对称密钥)。在客户端使用服务单的公钥对PreMaster secret进行加密之后传送给服务端，服务端将使用私钥进行解密得到PreMaster secret。也就是说服务端和客户端都有一份相同的PreMaster secret和随机数。</p>
<p>premaster_secret 长度为 48 个字节，前 2 个字节是协议版本号，剩下的 46 个字节填充一个随机数。结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Struct &#123;</div><div class="line">	byte Version[2];</div><div class="line">	byte random[46];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>PreMaster secret前两个字节是TLS的版本号，这是一个比较重要的用来核对握手数据的版本号，因为在Client Hello阶段，客户端会发送一份加密套件列表和当前支持的SSL/TLS的版本号给服务端，而且是使用明文传送的，如果握手的数据包被破解之后，攻击者很有可能串改数据包，选择一个安全性较低的加密套件和版本给服务端，从而对数据进行破解。所以，服务端需要对密文中解密出来对的PreMaster版本号跟之前Client Hello阶段的版本号进行对比，如果版本号变低，则说明被串改，则立即停止发送任何消息。</p>
<ul>
<li><strong>Master secret 说明</strong></li>
</ul>
<p>需要注意的是，上面握手过程中存在三个Key(random_1,random_2,PreMaster Secret)，而且服务器和客户端都保留着这三个值，客户端和服务端通过这三个值计算出同样的Master secret。Master secret是由系列的hash值组成的，结构如下：</p>
<p><img src="http://honglu-blog.qiniudn.com/image%2F16%2F01%2F14%2FHTTPS%E6%B5%85%E6%9E%90.png" alt="Master secret 结构"></p>
<p>其中，Client/Server write MAC key 是用来对数据进行验证的，Client/Server write encryption Key 是用来对数据进行加解密的会话密钥(session secret)。</p>
<p>关于Master Secret的计算请参考<a href="http://www.fenesky.com/blog/2014/07/25/how-session-secret.html" target="_blank" rel="external">《Htttps SSL/TLS Session Secret(Key)计算》</a>。</p>
<h4 id="4-4-服务器的最后回应"><a href="#4-4-服务器的最后回应" class="headerlink" title="4.4 服务器的最后回应"></a><strong>4.4 服务器的最后回应</strong></h4><p>服务器收到客户端的第三个随机数pre-master key之后，计算生成本次会话所用的”会话密钥”。然后，向客户端最后发送下面信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">（1）编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。</div><div class="line">（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。</div></pre></td></tr></table></figure>
<p>至此，整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的HTTP协议，只不过用”会话密钥”加密内容。</p>
<p><img src="http://image.beekka.com/blog/201402/bg2014020503.gif" alt="img"></p>
<h3 id="五、应用数据传输"><a href="#五、应用数据传输" class="headerlink" title="五、应用数据传输"></a><strong>五、应用数据传输</strong></h3><p>在所有的握手阶段都完成之后，就可以开始传送应用数据了。应用数据在传输之前，首先要附加上MAC secret，然后再对这个数据包使用write encryption key进行加密。在服务端收到密文之后，使用Client write encryption key进行解密，客户端收到服务端的数据之后使用Server write encryption key进行解密，然后使用各自的write MAC key对数据的完整性包括是否被串改进行验证。</p>
<h3 id="六、对称加密-amp-非对称加密"><a href="#六、对称加密-amp-非对称加密" class="headerlink" title="六、对称加密 &amp; 非对称加密"></a><strong>六、对称加密 &amp; 非对称加密</strong></h3><p>HTTPS 的通信过程中只在握手阶段使用了非对称加密，后面的通信过程均使用的对称加密。尽管非对称加密相比对称加密更加安全，但也存在两个明显缺点：</p>
<ol>
<li>CPU 计算资源消耗非常大。一次完全 TLS 握手，密钥交换时的非对称解密计算量占整个握手过程的 90% 以上。而对称加密的计算量只相当于非对称加密的 0.1%，如果应用层数据也使用非对称加解密，性能开销太大，无法承受。</li>
<li>非对称加密算法对加密内容的长度有限制，不能超过公钥长度。比如现在常用的公钥长度是 2048 位，意味着待加密内容不能超过 256 个字节。</li>
</ol>
<p>所以公钥加密目前只能用来作密钥交换或者内容签名，不适合用来做应用层传输内容的加解密。</p>
<p>非对称密钥交换算法是整个 HTTPS 得以安全的基石，充分理解非对称密钥交换算法是理解 HTTPS 协议和功能的关键。</p>
<h3 id="七、证书"><a href="#七、证书" class="headerlink" title="七、证书"></a><strong>七、证书</strong></h3><p>下面是使用 chrome 访问 Google 时查看的证书详细信息</p>
<p><img src="http://honglu-blog.qiniudn.com/image%2F16%2F01%2F14%2FHTTPS%20%E8%AF%81%E4%B9%A6%E7%BB%93%E6%9E%84.png" alt="Google  HTTPS证书"></p>
<p>数字证书的格式普遍采用的是X.509V3国际标准，一个标准的X.509数字证书包含以下一些内容：</p>
<ul>
<li>证书的版本信息；</li>
<li>证书的序列号，每个证书都有一个唯一的证书序列号；</li>
<li>证书所使用的签名算法；</li>
<li>证书的发行机构名称，命名规则一般采用X.500格式；</li>
<li>证书的有效期，通用的证书一般采用UTC时间格式，它的计时范围为1950-2049；</li>
<li>证书所有人的名称，命名规则一般采用X.500格式；</li>
<li>证书所有人的公钥；</li>
<li>证书发行者对证书的签名。</li>
</ul>
<p>证书以链的形式组织，上级标识该证书的签发机构，验证证书的时候也是顺着这个链向上层层验证的，只有所有证书都是受信的，整个验证结果才是可信的。那么根证书是如何验证的呢？根证书是自信任的，在操作系统或者浏览其中都会默认一些受信任的 CA 机构根证书。</p>
<p>除非对这个根证书有绝对的信任才可以加入信任列表中，因为根证书是有权签发子证书的，如果根证书失信，那么对应的子证书的可信性就无从谈起，那么与使用相应证书的 HTTPS 网站通信的安全性就得不到保障了。当访问12306的时候，网站会提示把其提供的根证书加入到可信任列表里面，这就是为什么许多人反对这种做法的原因了。另外中国互联网信息中心(CNNIC)也曾发布过用于中间人攻击证书，详情可以参考这篇文章：<a href="http://www.williamlong.info/archives/4183.html" target="_blank" rel="external">谷歌称CNNIC发布伪造CA证书</a>。</p>
<p>Mac 用户可以通过 钥匙串-&gt;系统根证书 查看系统默认信任的所有根证书，如果想取消信任(比如 CNNIC证书)，可以双击，改为永不信任</p>
<h3 id="八、安全性"><a href="#八、安全性" class="headerlink" title="八、安全性"></a><strong>八、安全性</strong></h3><p>针对 HTTPS 的攻击最主要的就是 SSL 劫持攻击，其分为两种：</p>
<p><strong>HTTPS 替换为 HTTP</strong></p>
<p>这种方式就是攻击者充当中间人和服务器通信，然后把相应的通信内容通过 HTTP 协议发送给客户端，由于 HTTP 协议是未加密的，于是就可以截获用户的访问数据。</p>
<p>这种攻击方式比较简单，通过代理，可以很容易的把 HTTPS 变成 HTTP，这个一方面需要用户留意网站是否有从 HTTPS 跳转到 HTTP 的行为，另一方面服务器也可以通过配置将所有HTTP的请求强制转移到HTTPS上。</p>
<p><strong>HTTPS 劫持</strong></p>
<p>这种方式攻击者为了获得 HTTPS 的明文传输内容，需要充当中间人，替换服务器发给用户的包含公钥的证书。攻击者既和用户之间建立了 HTTPS 链接，又和服务器建立了 HTTPS 链接。</p>
<p>在上面握手建立的过程中，由于用户的公钥是攻击者生成的，所以攻击者可以轻易获得握手中的数据。也就可以获取到和用户通信过程中的对称加密的密钥，攻击者可以通过密钥获取用户发送的数据，同时在使用和服务器通信的密钥加密后再发送给服务器。</p>
<p>这种攻击方式也有一个明显的问题就是攻击者生成的证书几乎是不可能被用户信任的，在这种情况下，用户浏览器通常会提示该网站的证书不可信，是否继续访问，这已经对用户进行了一个明显的警告了。</p>
<p>另外我们也可以通过这种对基于 HTTPS 的通信进行抓包分析。Mac 平台著名的抓包工具 Charles 就是基于这种方式，首先要求你信任一个它的证书，然后自己充当中间人对你与某个服务器的 HTTPS 通信进行抓包分析。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[mysql 存储引擎]]></title>
      <url>http://zsr.github.io/2016/09/27/mysql-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</url>
      <content type="html"><![CDATA[<h3 id="什么是存储引擎？"><a href="#什么是存储引擎？" class="headerlink" title="什么是存储引擎？"></a><strong>什么是存储引擎？</strong></h3><p>存储引擎说白了就是如何存储数据、如何为存储的数据建立索引和如何更新、查询数据等技术的实现方法。因为在关系数据库中数据的存储是以表的形式存储的，所以存储引擎也可以称为表类型（即存储和操作此表的类型）。</p>
<p>关系数据库表是用于存储和组织信息的数据结构，可以将表理解为由行和列组成的表格，类似于Excel的电子表格的形式。有的表简单，有的表复杂，有的表根本不用来存储任何长期的数据，有的表读取时非常快，但是插入数据时去很差；而我们在实际开发过程中，就可能需要各种各样的表，不同的表，就意味着存储不同类型的数据，数据的处理上也会存在着差异，那么。对于MySQL来说，它提供了很多种类型的存储引擎，我们可以根据对数据处理的需求，选择不同的存储引擎，从而最大限度的利用MySQL强大的功能。</p>
<h3 id="MyISAM存储引擎"><a href="#MyISAM存储引擎" class="headerlink" title="MyISAM存储引擎"></a><strong>MyISAM存储引擎</strong></h3><p>在mysql客户端中，使用以下命令可以查看MySQL支持的引擎。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">show engines;</div></pre></td></tr></table></figure>
<p>MyISAM表是独立于操作系统的，这说明可以轻松地将其从Windows服务器移植到Linux服务器；每当我们建立一个MyISAM引擎的表时，就会在本地磁盘上建立三个文件，文件名就是表名。例如，我建立了一个MyISAM引擎的tb_Demo表，那么就会生成以下三个文件：</p>
<ul>
<li>tb_demo.frm，存储表定义；</li>
<li>tb_demo.MYD，存储数据；</li>
<li>tb_demo.MYI，存储索引。</li>
</ul>
<p>MyISAM表无法处理事务，这就意味着有事务处理需求的表，不能使用MyISAM存储引擎。MyISAM存储引擎特别适合在以下几种情况下使用：</p>
<ul>
<li>选择密集型的表。MyISAM存储引擎在筛选大量数据时非常迅速，这是它最突出的优点。</li>
<li>插入密集型的表。MyISAM的并发插入特性允许同时选择和插入数据。例如：MyISAM存储引擎很适合管理邮件或Web服务器日志数据。</li>
</ul>
<h3 id="InnoDB存储引擎"><a href="#InnoDB存储引擎" class="headerlink" title="InnoDB存储引擎"></a><strong>InnoDB存储引擎</strong></h3><p>InnoDB给Mysql的表提供了 事务、回滚、崩溃修复能力、多版本并发控制的事务安全、间隙锁（可以有效的防止幻读的出现）、支持辅助索引、聚簇索引、自适应hash索引、支持热备、行级锁。还有InnoDB是Mysql上唯一一个提供了外键约束的引擎。</p>
<p>InnoDB存储引擎中，创建的表的表结构是单独存储的并且存储在.frm文件中。数据和索引存储在一起的并且存储在表空间中。但是默认情况下mysql会将数据库的所有InnoDB表存储在一个表空间中的。</p>
<p>InnoDB是一个健壮的事务型存储引擎，<strong>mysql 5.5 之后。InnoDB 被认定为默认的存储引擎</strong>. InnoDB就是作为默认的存储引擎**。InnoDB还引入了行级锁定和外键约束，在以下场合下，使用InnoDB是最理想的选择：</p>
<ol>
<li>更新密集的表。InnoDB存储引擎特别适合处理多重并发的更新请求。</li>
<li>事务。InnoDB存储引擎是支持事务的标准MySQL存储引擎。</li>
<li>自动灾难恢复。与其它存储引擎不同，InnoDB表能够自动从灾难中恢复。</li>
<li>外键约束。MySQL支持外键的存储引擎只有InnoDB。</li>
<li>支持自动增加列AUTO_INCREMENT属性。</li>
</ol>
<p>一般来说，如果需要事务支持，并且有较高的并发读取频率，InnoDB是不错的选择。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[context:annotation-config 与 context:component-scan区别]]></title>
      <url>http://zsr.github.io/2016/09/21/context-annotation-config%E4%B8%8Econtext-component-scan%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<p><code>&lt;context:annotation-config&gt;</code> <strong>是用于激活那些已经在spring容器里注册过的bean</strong>（无论是通过xml的方式还是通过package sanning的方式）上面的注解。</p>
<p><code>&lt;context:component-scan&gt;</code>除了具有<code>&lt;context:annotation-config&gt;</code>的功能之外，<code>&lt;context:component-scan&gt;</code>还可以在指定的package下扫描以及注册javabean 。</p>
<p>下面通过例子来详细查看他们的区别，有三个class   A,B,C,并且B,C的对象被注入到A中.</p>
<h3 id="通过xml的方式"><a href="#通过xml的方式" class="headerlink" title="通过xml的方式"></a><strong>通过xml的方式</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.xxx;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">()</span> </span>&#123;</div><div class="line">    System.out.println(<span class="string">"creating bean B: "</span> + <span class="keyword">this</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">package</span> com.xxx;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">C</span><span class="params">()</span> </span>&#123;</div><div class="line">    System.out.println(<span class="string">"creating bean C: "</span> + <span class="keyword">this</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">package</span> com.yyy;</div><div class="line"><span class="keyword">import</span> com.xxx.B;</div><div class="line"><span class="keyword">import</span> com.xxx.C;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123; </div><div class="line">  <span class="keyword">private</span> B bbb;</div><div class="line">  <span class="keyword">private</span> C ccc;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span> </span>&#123;</div><div class="line">    System.out.println(<span class="string">"creating bean A: "</span> + <span class="keyword">this</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBbb</span><span class="params">(B bbb)</span> </span>&#123;</div><div class="line">    System.out.println(<span class="string">"setting A.bbb with "</span> + bbb);</div><div class="line">    <span class="keyword">this</span>.bbb = bbb;</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCcc</span><span class="params">(C ccc)</span> </span>&#123;</div><div class="line">    System.out.println(<span class="string">"setting A.ccc with "</span> + ccc);</div><div class="line">    <span class="keyword">this</span>.ccc = ccc; </div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在applicationContext.xml中加入下面的配置 :</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;bean id="bBean"class="com.xxx.B"/&gt;</div><div class="line">&lt;bean id="cBean"class="com.xxx.C"/&gt;</div><div class="line">&lt;bean id="aBean"class="com.yyy.A"&gt;</div><div class="line">  &lt;property name="bbb" ref="bBean"/&gt;</div><div class="line">  &lt;property name="ccc" ref="cBean"/&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure>
<p>加载applicationContext.xml配置文件，将得到下面的结果:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">creating bean B: com.xxx.B<span class="meta">@c</span>2ff5</div><div class="line">creating bean C: com.xxx.C@<span class="number">1e8</span>a1f6</div><div class="line">creating bean A: com.yyy.A@<span class="number">1e152</span>c5</div><div class="line">setting A.bbb with com.xxx.B<span class="meta">@c</span>2ff5</div><div class="line">setting A.ccc with com.xxx.C@<span class="number">1e8</span>a1f6</div></pre></td></tr></table></figure>
<h3 id="通过注解的方式"><a href="#通过注解的方式" class="headerlink" title="通过注解的方式"></a><strong>通过注解的方式</strong></h3><p><strong>使用<code>&lt;context:annotation-config&gt;</code>和 <code>&lt;context:component-scan&gt;</code></strong></p>
<a id="more"></a>
<ul>
<li><strong>使用<code>&lt;context:annotation-config&gt;</code></strong></li>
</ul>
<p>首先，我们使用<code>@Autowire</code>的方式将对象bbb和ccc注入到A中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.yyy;</div><div class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</div><div class="line"><span class="keyword">import</span> com.xxx.B;</div><div class="line"><span class="keyword">import</span> com.xxx.C;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123; </div><div class="line">  <span class="keyword">private</span> B bbb;</div><div class="line">  <span class="keyword">private</span> C ccc;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span> </span>&#123;</div><div class="line">    System.out.println(<span class="string">"creating bean A: "</span> + <span class="keyword">this</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="meta">@Autowired</span> </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBbb</span><span class="params">(B bbb)</span> </span>&#123;</div><div class="line">    System.out.println(<span class="string">"setting A.bbb with "</span> + bbb);</div><div class="line">    <span class="keyword">this</span>.bbb = bbb;</div><div class="line">  &#125;</div><div class="line">  <span class="meta">@Autowired</span> </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCcc</span><span class="params">(C ccc)</span> </span>&#123;</div><div class="line">    System.out.println(<span class="string">"setting A.ccc with "</span> + ccc);</div><div class="line">    <span class="keyword">this</span>.ccc = ccc;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后applicationContext.xml配置文件去除属性<code>&lt;property&gt;</code>就简化为下面的样子了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=<span class="string">"bBean"</span><span class="class"><span class="keyword">class</span></span>=<span class="string">"com.xxx.B"</span>/&gt;</div><div class="line">&lt;bean id=<span class="string">"cBean"</span><span class="class"><span class="keyword">class</span></span>=<span class="string">"com.xxx.C"</span>/&gt;</div><div class="line">&lt;bean id=<span class="string">"aBean"</span><span class="class"><span class="keyword">class</span></span>=<span class="string">"com.yyy.A"</span>/&gt;</div></pre></td></tr></table></figure>
<p>当我们加载applicationContext.xml配置文件之后，将得到下面的结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">reating bean B: com.xxx.B@<span class="number">5e5</span>a50</div><div class="line">creating bean C: com.xxx.C@<span class="number">54</span>a328</div><div class="line">creating bean A: com.yyy.A<span class="meta">@a</span>3d4cf</div></pre></td></tr></table></figure>
<p>ClassA中显然没有注入属性，结果是错误的的，为什么我们的属性没有被注入进去呢？</p>
<p>是因为注解本身并不能够做任何事情，它们只是最基本的组成部分，我们需要能够处理这些注解的处理工具来处理这些注解。</p>
<p>这就是<code>&lt;context:annotation-config&gt;</code> 所做的事情，<strong>用于激活那些已经在spring容器里注册过的bean</strong></p>
<p>我们将applicationContext.xml配置文件作如下修改：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;context:annotation-config /&gt;</div><div class="line">&lt;bean id=<span class="string">"bBean"</span><span class="class"><span class="keyword">class</span></span>=<span class="string">"com.xxx.B"</span>/&gt;</div><div class="line">&lt;bean id=<span class="string">"cBean"</span><span class="class"><span class="keyword">class</span></span>=<span class="string">"com.xxx.C"</span>/&gt;</div><div class="line">&lt;bean id=<span class="string">"aBean"</span><span class="class"><span class="keyword">class</span></span>=<span class="string">"com.yyy.A"</span>/&gt;</div></pre></td></tr></table></figure>
<p>当我们加载applicationContext.xml配置文件之后，将得到下面的结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">creating bean B: com.xxx.B@<span class="number">15663</span>a2</div><div class="line">creating bean C: com.xxx.C<span class="meta">@cd</span>5f8b</div><div class="line">creating bean A: com.yyy.A@<span class="number">157</span>aa53</div><div class="line">setting A.bbb with com.xxx.B@<span class="number">15663</span>a2</div><div class="line">setting A.ccc with com.xxx.C<span class="meta">@cd</span>5f8b</div></pre></td></tr></table></figure>
<p> 结果正确了</p>
<ul>
<li><strong>使用<code>&lt;context:component-scan&gt;</code></strong></li>
</ul>
<p>但是如果我们将代码作如下修改：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.xxx;</div><div class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</div><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">()</span> </span>&#123;</div><div class="line">    System.out.println(<span class="string">"creating bean B: "</span> + <span class="keyword">this</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">package</span> com.xxx;</div><div class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</div><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">C</span><span class="params">()</span> </span>&#123;</div><div class="line">    System.out.println(<span class="string">"creating bean C: "</span> + <span class="keyword">this</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">package</span> com.yyy;</div><div class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</div><div class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</div><div class="line"><span class="keyword">import</span> com.xxx.B;</div><div class="line"><span class="keyword">import</span> com.xxx.C;</div><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123; </div><div class="line">  <span class="keyword">private</span> B bbb;</div><div class="line">  <span class="keyword">private</span> C ccc;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span> </span>&#123;</div><div class="line">    System.out.println(<span class="string">"creating bean A: "</span> + <span class="keyword">this</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="meta">@Autowired</span> </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBbb</span><span class="params">(B bbb)</span> </span>&#123;</div><div class="line">    System.out.println(<span class="string">"setting A.bbb with "</span> + bbb);</div><div class="line">    <span class="keyword">this</span>.bbb = bbb;</div><div class="line">  &#125;</div><div class="line">  <span class="meta">@Autowired</span> </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCcc</span><span class="params">(C ccc)</span> </span>&#123;</div><div class="line">    System.out.println(<span class="string">"setting A.ccc with "</span> + ccc);</div><div class="line">    <span class="keyword">this</span>.ccc = ccc;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>applicationContext.xml配置文件修改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;context:annotation-config /&gt;</div></pre></td></tr></table></figure>
<p>当我们加载applicationContext.xml配置文件之后，却没有任何输出，这是因为<code>&lt;context:annotation-config /&gt;</code><strong>仅能够在已经在已经注册过的bean上面起作用</strong>。对于没有在spring容器中注册的bean，它并不能执行任何操作。</p>
<p>但是不用担心，<code>&lt;context:component-scan&gt;</code>除了具有<code>&lt;context:annotation-config /&gt;</code>的功能之外，还具有<strong>自动将带有@component,@service,@Repository等注解的对象注册到spring容器中的功能</strong>。</p>
<p>我们将applicationContext.xml配置文件作如下修改：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;context:component-scan base-<span class="keyword">package</span>=<span class="string">"com.xxx"</span>/&gt;</div></pre></td></tr></table></figure>
<p>当我们加载applicationContext.xml的时候，会得到下面的结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">creating bean B: com.xxx.B@<span class="number">1</span>be0f0a</div><div class="line">creating bean C: com.xxx.C@<span class="number">80</span>d1ff</div></pre></td></tr></table></figure>
<p>这是因为我们仅仅扫描了<code>com.xxx</code>包及其子包的类，而class  A是在<code>com.yyy</code>包下，所以就扫描不到了</p>
<p>下面我们在applicationContext.xml中把<code>com.yyy</code>也加入进来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;context:component-scan base-<span class="keyword">package</span>=<span class="string">"com.xxx"</span>/&gt;</div><div class="line">&lt;context:component-scan base-<span class="keyword">package</span>=<span class="string">"com.xxx,com.yyy"</span>/&gt;</div></pre></td></tr></table></figure>
<p>然后加载applicationContext.xml就会得到下面的结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">creating bean B: com.xxx.B<span class="meta">@cd</span>5f8b</div><div class="line">creating bean C: com.xxx.C@<span class="number">15</span>ac3c9</div><div class="line">creating bean A: com.yyy.A<span class="meta">@ec</span>4a87</div><div class="line">setting A.bbb with com.xxx.B<span class="meta">@cd</span>5f8b</div><div class="line">setting A.ccc with com.xxx.C@<span class="number">15</span>ac3c9</div></pre></td></tr></table></figure>
<p>看下applicationContext.xml文件，已经简化为两行<code>context:component-scan</code>了.</p>
<p>如果在applicationContext.xml手动加上下面的配置，也就是说既在applicationContext.xml中手动的注册了A的实例对象，同时，通过component-scan去扫描并注册B,C的对象，如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;context:component-scan base-<span class="keyword">package</span>=<span class="string">"com.xxx"</span>/&gt;</div><div class="line">&lt;bean id=<span class="string">"aBean"</span><span class="class"><span class="keyword">class</span></span>=<span class="string">"com.yyy.A"</span>/&gt;</div></pre></td></tr></table></figure>
<p>结果仍是正确的:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">creating bean B: com.xxx.B@<span class="number">157</span>aa53</div><div class="line">creating bean C: com.xxx.C<span class="meta">@ec</span>4a87</div><div class="line">creating bean A: com.yyy.A@<span class="number">1</span>d64c37</div><div class="line">setting A.bbb with com.xxx.B@<span class="number">157</span>aa53</div><div class="line">setting A.ccc with com.xxx.C<span class="meta">@ec</span>4a87</div></pre></td></tr></table></figure>
<p>虽然class A并不是通过扫描的方式注册到容器中的 ，但是<code>&lt;context:component-scan&gt;</code>所产生的的处理那些注解的处理器工具，会处理所有绑定到容器上面的bean，不管是通过xml手动注册的还是通过scanning扫描注册的。 </p>
<p>那么，如果我们既配置了<code>&lt;context:annotation-config /&gt;</code>，又配置了<code>&lt;context:component-scan base-package=&quot;com.xxx&quot;/&gt;</code>，它们都具有处理在容器中注册的bean里面的注解的功能。会不会出现重复注入的情况呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;context:annotation-config /&gt;</div><div class="line">&lt;context:component-scan base-<span class="keyword">package</span>=<span class="string">"com.xxx"</span>/&gt;</div><div class="line">&lt;bean id=<span class="string">"aBean"</span><span class="class"><span class="keyword">class</span></span>=<span class="string">"com.yyy.A"</span>/&gt;</div></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">creating bean B: com.xxx.B@<span class="number">157</span>aa53</div><div class="line">creating bean C: com.xxx.C<span class="meta">@ec</span>4a87</div><div class="line">creating bean A: com.yyy.A@<span class="number">1</span>d64c37</div><div class="line">setting A.bbb with com.xxx.B@<span class="number">157</span>aa53</div><div class="line">setting A.ccc with com.xxx.C<span class="meta">@ec</span>4a87</div></pre></td></tr></table></figure>
<p>因为<code>&lt;context:annotation-config /&gt;</code>和 <code>&lt;context:component-scan&gt;</code>同时存在的时候，前者会被忽略。</p>
<p>也就是那些@autowire，@resource等注入注解只会被注入一次</p>
<p>哪怕是手动的注册了多个处理器，spring仍然只会处理一次：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;context:annotation-config /&gt;</div><div class="line">&lt;context:component-scan base-<span class="keyword">package</span>=<span class="string">"com.xxx"</span> /&gt;</div><div class="line">&lt;bean id=<span class="string">"aBean"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.yyy.A"</span> /&gt;</div><div class="line">&lt;bean id=<span class="string">"bla"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor"</span> /&gt;</div><div class="line">&lt;bean id=<span class="string">"bla1"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor"</span> /&gt;</div><div class="line">&lt;bean id=<span class="string">"bla2"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor"</span> /&gt;</div><div class="line">&lt;bean id=<span class="string">"bla3"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor"</span> /&gt;</div></pre></td></tr></table></figure>
<p>结果仍是正确的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">creating bean B: com.xxx.B@<span class="number">157</span>aa53</div><div class="line">creating bean C: com.xxx.C<span class="meta">@ec</span>4a87</div><div class="line">creating bean A: com.yyy.A@<span class="number">25</span>d2b2</div><div class="line">setting A.bbb with com.xxx.B@<span class="number">157</span>aa53</div><div class="line">setting A.ccc with com.xxx.C<span class="meta">@ec</span>4a87</div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[context:annotation-config 作用]]></title>
      <url>http://zsr.github.io/2016/09/21/context-annotation-config-%E4%BD%9C%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>在基于注解方式配置Spring的配置文件中，可能会见到<code>&lt;context:annotation-config/&gt;</code>这样一条配置，他的作用是隐式地向 Spring 容器注册</p>
<ul>
<li>AutowiredAnnotationBeanPostProcessor</li>
<li>CommonAnnotationBeanPostProcessor</li>
<li>PersistenceAnnotationBeanPostProcessor</li>
<li>RequiredAnnotationBeanPostProcessor 这 4 个BeanPostProcessor。</li>
</ul>
<p>注册这4个BeanPostProcessor的作用，就是为了你的系统能够识别相应的注解。</p>
<p>例如：</p>
<ol>
<li>如果你想使用<code>@Autowired</code>注解，那么就必须事先在 Spring 容器中声明 <code>AutowiredAnnotationBeanPostProcessor</code>Bean。传统声明方式如下</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;bean <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor "</span>/&gt;</div></pre></td></tr></table></figure>
<ol>
<li>如果想使用@ Resource 、@ PostConstruct、@ PreDestroy等注解就必须声明CommonAnnotationBeanPostProcessor</li>
<li>如果想使用@PersistenceContext注解，就必须声明PersistenceAnnotationBeanPostProcessor的Bean。</li>
<li>如果想使用 @Required的注解，就必须声明RequiredAnnotationBeanPostProcessor的Bean。同样，传统的声明方式如下：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;bean <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor"</span>/&gt;</div></pre></td></tr></table></figure>
<p>一般来说，这些注解我们还是比较常用，尤其是<code>@Autowired</code>的注解，在自动注入的时候更是经常使用，所以如果总是需要按照传统的方式一条一条配置显得有些繁琐和没有必要，于是spring给我们提供<code>&lt;context:annotation-config/&gt;</code>的简化配置方式，自动帮你完成声明。</p>
<p>不过，我们使用注解一般都会配置扫描包路径选项</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;context:component-scan base-<span class="keyword">package</span>=<span class="string">"XX.XX"</span>/&gt;</div></pre></td></tr></table></figure>
<p>该配置项其实也包含了自动注入上述processor的功能，因此当使用<code>&lt;context:component-scan/&gt;</code>后，就可以将 <code>&lt;context:annotation-config/&gt;</code>移除了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Spring的@Autowired注入规则]]></title>
      <url>http://zsr.github.io/2016/09/21/spring-Autowired/</url>
      <content type="html"><![CDATA[<p>Spring 2.5引入了<code>@Autowired</code>注解，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。通过<code>@Autowired</code>的使用来消除set，get方法。</p>
<p><code>@Autowired</code>默认是按照byType进行注入的，但是当byType方式找到了多个符合的bean，又是怎么处理的？</p>
<p><strong>Autowired默认先按byType，如果发现找到多个bean，则，又按照byName方式比对，如果还有多个，则报出异常</strong>。</p>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Autowired</span></div><div class="line"><span class="keyword">private</span> ExamUserMapper examUserMapper;  - ExamUserMapper是一个接口</div></pre></td></tr></table></figure>
<ul>
<li>spring先找类型为ExamUserMapper的bean</li>
<li>如果存在且唯一，则OK；</li>
<li>如果不唯一，在结果集里，寻找name为examUserMapper的bean。因为bean的name有唯一性，所以，到这里应该能确定是否存在满足要求的bean了</li>
</ul>
<p><code>@Autowired也可以手动指定按照byName方式注入，使用@Qualifier标签，例如：</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Autowired</span></div><div class="line"><span class="meta">@Qualifier</span> ( <span class="string">"baseDao"</span> )</div></pre></td></tr></table></figure>
<p>因为bean的name具有唯一性，理论上是byName会快一点，但spring默认使用byType的方式注入</p>
<p>要使用@Autowired实现要精简程序的目的，需要这样来处理： </p>
<p>在applicationContext.xml中加入： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 该 BeanPostProcessor 将自动对标注 <span class="meta">@Autowired</span> 的 Bean 进行注入 --&gt;   </div><div class="line">&lt;bean <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor"</span>/&gt;</div></pre></td></tr></table></figure>
<p>Spring通过一个BeanPostProcessor对@Autowired进行解析，所以要让@Autowired起作用必须事先在Spring容器中声明<code>AutowiredAnnotationBeanPostProcessor</code> Bean。   </p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Comparable 和 Comparator比较]]></title>
      <url>http://zsr.github.io/2016/09/20/Comparable%E5%92%8CComparator%E6%AF%94%E8%BE%83/</url>
      <content type="html"><![CDATA[<p>有两种方式可以进行集合排序 ：</p>
<ul>
<li>集合中对象的所属类实现了 java.lang.Comparable 接口</li>
<li>给集合指定比较器 java.lang.Comparator 的实现类</li>
</ul>
<h3 id="1-java-lang-Comparable"><a href="#1-java-lang-Comparable" class="headerlink" title="1. java.lang.Comparable"></a><strong>1. java.lang.Comparable</strong></h3><p>public interface Comparable 接口强行对实现它的每个类的对象进行整体排序。 – 自然排序。类的compareTo称为自然比较方法。</p>
<p><strong>接口的作用</strong></p>
<p>若一个类实现了Comparable 接口，实现 Comparable 接口的类对象的 List 列表 ( 或数组)可以通过 Collections.sort（或 Arrays.sort）进行排序。</p>
<p>此外，实现 Comparable 接口的类的对象 可以用作 “有序映射 ( 如 TreeMap)” 中的键或 “有序集合 (TreeSet)” 中的元素，而不需要指定比较器。</p>
<p><strong>实现的方式</strong></p>
<p>利用Comparable接口创建自己的类的排序顺序，只是实现comparaTo方法的问题。<br>通常就是依赖几个数据成员的自然排序。同时类也应该覆盖equals()和hashCode() 以确保两个相等的对象返回同一个哈希码。</p>
<p>Comparable接口只有一个方法，compareTo(Object obj),定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T o)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通常需要覆写 compareTo 方法实现排序规则的应用 ：<strong>int compareTo(Object o): 比较当前实例对象与对象 o ，如果位于对象 o 之前，返回负值，如果两个对象在排序中位置相同，则返回 0 ，如果位于对象 o 后面，则返回正值.</strong></p>
<p>下表展示了几种基本类型的自然排序。虽然一些类共享同一种自然排序，但只有相互可比的类才能排序。</p>
<table>
<thead>
<tr>
<th style="text-align:center">类</th>
<th style="text-align:center">排序(越大排在后面)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Integer</td>
<td style="text-align:center">按数字大小排序</td>
</tr>
<tr>
<td style="text-align:center">Long</td>
<td style="text-align:center">按数字大小排序</td>
</tr>
<tr>
<td style="text-align:center">Byte</td>
<td style="text-align:center">按数字大小排序</td>
</tr>
<tr>
<td style="text-align:center">Double</td>
<td style="text-align:center">按数字大小排序</td>
</tr>
<tr>
<td style="text-align:center">Character</td>
<td style="text-align:center">按 <code>Unicode</code> 值的数字大小排序</td>
</tr>
<tr>
<td style="text-align:center">String</td>
<td style="text-align:center">按字符串中字符 <code>Unicode</code> 值排序</td>
</tr>
</tbody>
</table>
<p>举个例子：一种商品(商品名，销售量，生产日期)，根据<strong>生产日期降序 销售量升序 商品名称降序</strong></p>
<p><strong>思路：首先按照日期降序，如果日期相同 按照销售量升序，如果销售量相同，按周商品的名称降序</strong></p>
<ul>
<li><strong>创建需要比较的对象的java bean</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComparableExample</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">ComparableExample</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> String title; <span class="comment">// 名称</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">int</span> hits; <span class="comment">// 销售量</span></div><div class="line">  <span class="keyword">private</span> Date pubTime; <span class="comment">// 日期</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ComparableExample</span><span class="params">()</span> </span>&#123;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ComparableExample</span><span class="params">(String title, <span class="keyword">int</span> hits, Date pubTime)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>();</div><div class="line">    <span class="keyword">this</span>.title = title;</div><div class="line">    <span class="keyword">this</span>.hits = hits;</div><div class="line">    <span class="keyword">this</span>.pubTime = pubTime;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getTitle</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> title;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTitle</span><span class="params">(String title)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.title = title;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHits</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> hits;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHits</span><span class="params">(<span class="keyword">int</span> hits)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.hits = hits;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> Date <span class="title">getPubTime</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> pubTime;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPubTime</span><span class="params">(Date pubTime)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.pubTime = pubTime;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 时间降序(越大排在前面) 点击量升序(越大排在后面) 标题降序</span></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(ComparableExample o)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">    <span class="comment">// 按照生产时间降序</span></div><div class="line">    result = -<span class="keyword">this</span>.pubTime.compareTo(o.pubTime);</div><div class="line">    <span class="keyword">if</span> (<span class="number">0</span> == result) &#123;<span class="comment">// 如果生产时间相同 就按照销售量升序排列</span></div><div class="line">      result = <span class="keyword">this</span>.hits - o.hits;</div><div class="line">      <span class="keyword">if</span> (<span class="number">0</span> == result) &#123;<span class="comment">// 如果销售量相同 按照名字降序排列</span></div><div class="line">        result = -<span class="keyword">this</span>.title.compareTo(o.title);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">    sb.append(<span class="string">"商品名称"</span>).append(<span class="keyword">this</span>.title);</div><div class="line">    sb.append(<span class="string">"销售量"</span>).append(<span class="keyword">this</span>.hits);</div><div class="line">    sb.append(<span class="string">"生产时间"</span>).append(<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>).format(<span class="keyword">this</span>.pubTime)).append(<span class="string">"\n"</span>);</div><div class="line">    <span class="keyword">return</span> sb.toString();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>测试，比较</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 时间降序， 销售量升序， 标题降序</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">  List&lt;ComparableExample&gt; item = <span class="keyword">new</span> ArrayList&lt;ComparableExample&gt;();</div><div class="line">  item.add(<span class="keyword">new</span> ComparableExample(<span class="string">"abcitems"</span>, <span class="number">30</span>, <span class="keyword">new</span> Date(System.currentTimeMillis() - <span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span>)));</div><div class="line">  item.add(<span class="keyword">new</span> ComparableExample(<span class="string">"abcfgitems"</span>, <span class="number">30</span>, <span class="keyword">new</span> Date(System.currentTimeMillis() - <span class="number">1000</span> * <span class="number">60</span> * <span class="number">50</span>)));</div><div class="line">  item.add(<span class="keyword">new</span> ComparableExample(<span class="string">"abcditems"</span>, <span class="number">100</span>, <span class="keyword">new</span> Date()));</div><div class="line">  item.add(<span class="keyword">new</span> ComparableExample(<span class="string">"abefNews"</span>, <span class="number">50</span>, <span class="keyword">new</span> Date(System.currentTimeMillis() - <span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span>)));</div><div class="line">  System.out.println(<span class="string">"----------排序前----------"</span>);</div><div class="line">  System.out.println(item);</div><div class="line">  System.out.println(<span class="string">"----------排序后----------"</span>);</div><div class="line">  Collections.sort(item);</div><div class="line">  System.out.println(item);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>运行结果</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">----------排序前----------</div><div class="line">[商品名称abcitems销售量30生产时间2016-09-20 15:04:37</div><div class="line">, 商品名称abcfgitems销售量30生产时间2016-09-20 15:14:37</div><div class="line">, 商品名称abcditems销售量100生产时间2016-09-20 16:04:37</div><div class="line">, 商品名称abefNews销售量50生产时间2016-09-20 15:04:37</div><div class="line">]</div><div class="line">----------排序后----------</div><div class="line">[商品名称abcditems销售量100生产时间2016-09-20 16:04:37</div><div class="line">, 商品名称abcfgitems销售量30生产时间2016-09-20 15:14:37</div><div class="line">, 商品名称abcitems销售量30生产时间2016-09-20 15:04:37</div><div class="line">, 商品名称abefNews销售量50生产时间2016-09-20 15:04:37</div><div class="line">]</div></pre></td></tr></table></figure>
<h3 id="2-Comparator-比较器接口"><a href="#2-Comparator-比较器接口" class="headerlink" title="2. Comparator 比较器接口"></a><strong>2. Comparator 比较器接口</strong></h3><p>如果需要控制某个类的次序，而<strong>该类本身不支持排序</strong>（即没有实现Comparable接口）；那么可以建立一个该类的比较器来排序，这个比较器只需要实现Comparator接口即可。 换句话说, <strong>通过实现Comparator类来新建一个比较器，然后通过该比较器来对类进行排序</strong>。Comparator 接口其实就是一种策略模式的实践</p>
<p><strong>接口作用</strong></p>
<ol>
<li>如果一个类已经开放完成，但是在此类建立的初期并没有实现 Comparable 接口，此时肯定是无法进行对象排序操作的，所以为了解决这一的问题，java 又定义了另一个比较器的操作接口 Comparator 此接口定义在 java.util 包中</li>
<li>为了使用不同的排序标准做准备，比如升序，降序或者其他什么序列</li>
</ol>
<p>接口仅仅包括两个函数:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1, T o2)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>若一个类要实现Comparator接口：它一定要实现compare(T o1， T o2)函数，<strong>但是可以不实现equals函数。 因为任何类，默认都是已经实现了 equals(Object obj) </strong>。 Java 中的一切类都是继承于 java.lang.Object，在 Object.java 中实现了 equals(Object obj) 函数；所以，其它所有的类也相当于都实现了该函数。</li>
<li>int compare(T o1, T o2) 是 “比较 o1 和 o2 的大小”。返回 “负数”，意味着 “o1 比 o2 小”；返回 “零”，意味着 “o1 等于 o2”；返回 “正数”，意味着 “o1 大于 o2”。</li>
</ol>
<p>比如 商品,我需要按照价格的降序排列,代码如下:</p>
<ul>
<li><strong>商品类</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.zsr.test.compare;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> String title;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">int</span> price;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Product</span><span class="params">()</span> </span>&#123;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Product</span><span class="params">(String title, <span class="keyword">int</span> price)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>();</div><div class="line">    <span class="keyword">this</span>.title = title;</div><div class="line">    <span class="keyword">this</span>.price = price;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getTitle</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> title;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTitle</span><span class="params">(String title)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.title = title;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> price;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">int</span> price)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.price = price;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"title="</span> + title + <span class="string">",price="</span> + price + <span class="string">"\n"</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>定义比较规则:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.zsr.test.compare;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.Comparator;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductCompare</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Product</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Product o1, Product o2)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> -(o1.getPrice() - o2.getPrice() &gt; <span class="number">0</span> ? <span class="number">1</span> : (o1.getPrice() == o2.getPrice() ? <span class="number">0</span> : -<span class="number">1</span>));</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>测试, 比较</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    List&lt;Product&gt; product = <span class="keyword">new</span> ArrayList&lt;Product&gt;();</div><div class="line">    product.add(<span class="keyword">new</span> Product(<span class="string">"a"</span>, <span class="number">120</span>));</div><div class="line">    product.add(<span class="keyword">new</span> Product(<span class="string">"b"</span>, <span class="number">143432</span>));</div><div class="line">    product.add(<span class="keyword">new</span> Product(<span class="string">"c"</span>, <span class="number">1892</span>));</div><div class="line">    product.add(<span class="keyword">new</span> Product(<span class="string">"d"</span>, <span class="number">11092</span>));</div><div class="line">    Collections.sort(product, <span class="keyword">new</span> ProductCompare());</div><div class="line">    System.out.println(product);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>运行结果</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[title=b,price=143432</div><div class="line">, title=d,price=11092</div><div class="line">, title=c,price=1892</div><div class="line">, title=a,price=120</div><div class="line">]</div></pre></td></tr></table></figure>
<h3 id="3-Comparable-和-Comparator比较"><a href="#3-Comparable-和-Comparator比较" class="headerlink" title="3. Comparable 和 Comparator比较"></a><strong>3. Comparable 和 Comparator比较</strong></h3><p>Comparable 是排序接口；若一个类实现了 Comparable 接口，就意味着 “该类支持排序”。 而 Comparator 是比较器；我们若需要控制某个类的次序，可以建立一个 “该类的比较器” 来进行排序。</p>
<p>前者应该比较固定，和一个具体类相绑定，而后者比较灵活，它可以被用于各个需要比较功能的类使用。可以说前者属于 “静态绑定”，而后者可以 “动态绑定”。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[mvc:annotation-driven]]></title>
      <url>http://zsr.github.io/2016/09/13/mvc-annotation-driven/</url>
      <content type="html"><![CDATA[<p><strong><code>&lt;mvc:annotation-driven /&gt;</code>这个标签注册了Spring MVC分发请求到Controller控制器所必须的HandlerMapping和HandlerAdapter实例。</strong></p>
<p><strong>Spring 3.1 之前:</strong></p>
<ol>
<li>DefaultAnnotationHandlerMapping</li>
<li>AnnotationMethodHandlerAdapter</li>
<li>AnnotationMethodHandlerExceptionResolver</li>
</ol>
<p><strong>Spring 3.1+ ：</strong></p>
<ol>
<li>RequestMappingHandlerMapping</li>
<li>RequestMappingHandlerAdapter</li>
<li>ExceptionHandlerExceptionResolver  </li>
</ol>
<p><code>DefaultAnnotationHandlerMapping</code> 根据url决定使用哪个<code>controller</code>，<code>AnnotationMethodHandlerAdapter</code> 选择处理请求的实际方法。<code>RequestMappingHandlerMapping</code>包涵上面2个作用，所以将请求直接映射到方法。</p>
<a id="more"></a>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p><code>DispatcherServlet</code>初始化的时候，会调用一个方法如下： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initStrategies</span><span class="params">(ApplicationContext context)</span> </span>&#123;  </div><div class="line">        initMultipartResolver(context);  </div><div class="line">        initLocaleResolver(context);  </div><div class="line">        initThemeResolver(context);  </div><div class="line">        <span class="comment">//初始化一些HandlerMapping  </span></div><div class="line">        initHandlerMappings(context);  </div><div class="line">        <span class="comment">//初始化一些HandlerAdapter  </span></div><div class="line">        initHandlerAdapters(context);  </div><div class="line">        initHandlerExceptionResolvers(context);  </div><div class="line">        initRequestToViewNameTranslator(context);  </div><div class="line">        initViewResolvers(context);  </div><div class="line">        initFlashMapManager(context);  </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>它会初始化一些<code>HandlerMapping</code>和<code>HandlerAdapter</code>，这两个方法非常重要</p>
<ul>
<li>初始化<code>HandlerMapping</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initHandlerMappings</span><span class="params">(ApplicationContext context)</span> </span>&#123;  </div><div class="line">        <span class="keyword">this</span>.handlerMappings = <span class="keyword">null</span>;  </div><div class="line">  </div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.detectAllHandlerMappings) &#123;  </div><div class="line">            <span class="comment">// Find all HandlerMappings in the ApplicationContext, including ancestor contexts.  </span></div><div class="line">            Map&lt;String, HandlerMapping&gt; matchingBeans =  </div><div class="line">                    BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerMapping.class, <span class="keyword">true</span>, <span class="keyword">false</span>);  </div><div class="line">            <span class="keyword">if</span> (!matchingBeans.isEmpty()) &#123;  </div><div class="line">                <span class="keyword">this</span>.handlerMappings = <span class="keyword">new</span> ArrayList&lt;HandlerMapping&gt;(matchingBeans.values());  </div><div class="line">                <span class="comment">// We keep HandlerMappings in sorted order.  </span></div><div class="line">                OrderComparator.sort(<span class="keyword">this</span>.handlerMappings);  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">else</span> &#123;  </div><div class="line">            <span class="keyword">try</span> &#123;  </div><div class="line">                HandlerMapping hm = context.getBean(HANDLER_MAPPING_BEAN_NAME, HandlerMapping.class);  </div><div class="line">                <span class="keyword">this</span>.handlerMappings = Collections.singletonList(hm);  </div><div class="line">            &#125;  </div><div class="line">            <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;  </div><div class="line">                <span class="comment">// Ignore, we'll add a default HandlerMapping later.  </span></div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        <span class="comment">// Ensure we have at least one HandlerMapping, by registering  </span></div><div class="line">        <span class="comment">// a default HandlerMapping if no other mappings are found.  </span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.handlerMappings == <span class="keyword">null</span>) &#123;  </div><div class="line">            <span class="keyword">this</span>.handlerMappings = getDefaultStrategies(context, HandlerMapping.class);  </div><div class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;  </div><div class="line">                logger.debug(<span class="string">"No HandlerMappings found in servlet '"</span> + getServletName() + <span class="string">"': using default"</span>);  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><code>detectAllHandlerMappings</code>是<code>DispatcherServlet</code>的一个属性，可以在<code>web.xml</code>中配置，<strong>默认是true</strong>，如果为true,则会去从本工程<code>mvc-servlet.xml</code>文件中去探测所有实现了<code>HandlerMapping</code>的bean，如果有，则加入<code>DispatcherServlet</code>的<code>handlerMappings</code>中。如果<code>detectAllHandlerMappings</code>为false,则直接去容器中找<code>id=&quot;handlerMapping&quot;</code>且实现了<code>HandlerMapping</code>的bean.如果以上都没找到，则会去加载默认的<code>HandlerMapping</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** Detect all HandlerMappings or just expect "handlerMapping" bean? */</span>  </div><div class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> detectAllHandlerMappings = <span class="keyword">true</span>;</div></pre></td></tr></table></figure>
<p>如果没有配置<code>HandlerMapping</code>,所以它会去加载默认的，默认的配置如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">getDefaultStrategies</span><span class="params">(ApplicationContext context, Class&lt;T&gt; strategyInterface)</span> </span>&#123;  </div><div class="line">        String key = strategyInterface.getName();  </div><div class="line">        <span class="comment">//defaultStrategies存储了默认的配置  </span></div><div class="line">        String value = defaultStrategies.getProperty(key);  </div><div class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;  </div><div class="line">            String[] classNames = StringUtils.commaDelimitedListToStringArray(value);  </div><div class="line">            List&lt;T&gt; strategies = <span class="keyword">new</span> ArrayList&lt;T&gt;(classNames.length);  </div><div class="line">            <span class="keyword">for</span> (String className : classNames) &#123;  </div><div class="line">                <span class="keyword">try</span> &#123;  </div><div class="line">                    Class&lt;?&gt; clazz = ClassUtils.forName(className, DispatcherServlet.class.getClassLoader());  </div><div class="line">                    Object strategy = createDefaultStrategy(context, clazz);  </div><div class="line">                    strategies.add((T) strategy);  </div><div class="line">                &#125;  </div><div class="line">                <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;  </div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanInitializationException(  </div><div class="line">                            <span class="string">"Could not find DispatcherServlet's default strategy class ["</span> + className +  </div><div class="line">                                    <span class="string">"] for interface ["</span> + key + <span class="string">"]"</span>, ex);  </div><div class="line">                &#125;  </div><div class="line">                <span class="keyword">catch</span> (LinkageError err) &#123;  </div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanInitializationException(  </div><div class="line">                            <span class="string">"Error loading DispatcherServlet's default strategy class ["</span> + className +  </div><div class="line">                                    <span class="string">"] for interface ["</span> + key + <span class="string">"]: problem with class file or dependent class"</span>, err);  </div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">            <span class="keyword">return</span> strategies;  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">else</span> &#123;  </div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> LinkedList&lt;T&gt;();  </div><div class="line">        &#125;  </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>看看<code>defaultStrategies</code>是如何初始化的： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Properties defaultStrategies;  </div><div class="line">  </div><div class="line">    <span class="keyword">static</span> &#123;  </div><div class="line">        <span class="comment">// Load default strategy implementations from properties file.  </span></div><div class="line">        <span class="comment">// This is currently strictly internal and not meant to be customized  </span></div><div class="line">        <span class="comment">// by application developers.  </span></div><div class="line">        <span class="keyword">try</span> &#123;  </div><div class="line">            <span class="comment">//这里的DEFAULT_STRATEGIES_PATH就是DispatcherServlet.properties  </span></div><div class="line">            ClassPathResource resource = <span class="keyword">new</span> ClassPathResource(DEFAULT_STRATEGIES_PATH, DispatcherServlet.class);  </div><div class="line">            defaultStrategies = PropertiesLoaderUtils.loadProperties(resource);  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">catch</span> (IOException ex) &#123;  </div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Could not load 'DispatcherServlet.properties': "</span> + ex.getMessage());  </div><div class="line">        &#125;  </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这里使用静态代码块来加载配置文件<code>DispatcherServlet.properties</code>，它所在位置就是和<code>DispatcherServlet</code>同一目录下面。默认的配置文件的内容如下： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#这里就是默认的HandlerMapping的配置  </div><div class="line">org.springframework.web.servlet.HandlerMapping=org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\  </div><div class="line">    org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping  </div><div class="line">#这里就是默认的HandlerAdapter的配置  </div><div class="line">org.springframework.web.servlet.HandlerAdapter=org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,\  </div><div class="line">    org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,\  </div><div class="line">    org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter  </div><div class="line">  </div><div class="line">org.springframework.web.servlet.HandlerExceptionResolver=org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerExceptionResolver,\  </div><div class="line">    org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver,\  </div><div class="line">    org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver</div></pre></td></tr></table></figure>
<p>也就是说，当你什么都没有配置时，默认会加载以上的配置</p>
<p>默认<code>HandlerMapping</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">BeanNameUrlHandlerMapping</div><div class="line">DefaultAnnotationHandlerMapping</div></pre></td></tr></table></figure>
<p>默认<code>HandlerAdapter</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">HttpRequestHandlerAdapter</div><div class="line">SimpleControllerHandlerAdapter</div><div class="line">AnnotationMethodHandlerAdapter</div></pre></td></tr></table></figure>
<p>参考：</p>
<p><a href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/mvc.html" target="_blank" rel="external">http://docs.spring.io/spring/docs/current/spring-framework-reference/html/mvc.html</a></p>
<p><a href="http://shouce.jb51.net/spring/mvc.html" target="_blank" rel="external">http://shouce.jb51.net/spring/mvc.html</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Spring MVC 适配器模式]]></title>
      <url>http://zsr.github.io/2016/09/13/Spring-MVC-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<pre><code>找到DispatcherServlet类中的`doDispatch`体，我们可以看到，它的作用是相当于在Servlet的 doService调用的。 也就是用来传递request给我们编写的Controller并执行相应的方法、返回ModeView对象。 

 执行的代码片段： 
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">...  </div><div class="line">HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());  </div><div class="line">mv = ha.handle(processedRequest, response, mappedHandler.getHandler());  </div><div class="line">...</div></pre></td></tr></table></figure>
<p><code>mappedHandler.getHandler()</code>得到的是Controller对象<br>而此处并非采用直接 调用.handlerRequest或者MultiActionController中编写的自定义方法，而采用了一个<code>HandlerAdapter</code>的接口。 </p>
<p>此处采用了适配器模式， 由于Controller的类型不同，有多重实现方式，那么调用方式就不是确定的，如果需要直接调用Controller方法，需要在代码中写成如下形式： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(mappedHandler.getHandler() <span class="keyword">instanceof</span> MultiActionController)&#123;  </div><div class="line">   ((MultiActionController)mappedHandler.getHandler()).xxx  </div><div class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(mappedHandler.getHandler() <span class="keyword">instanceof</span> XXX)&#123;  </div><div class="line">    ...  </div><div class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(...)&#123;  </div><div class="line">   ...  </div><div class="line">&#125;  </div><div class="line">...</div></pre></td></tr></table></figure>
<p>这样假设如果我们增加一个HardController,就要在代码中加入一行 if(mappedHandler.getHandler() instanceof  HardController) , 这种形式就使得程序难以维护，也违反了设计模式中的<code>开闭原则</code> –  对扩展开放，对修改关闭。 </p>
<p>因此Spring定义了一个适配接口，使得每一种Controller有一种对应的适配器实现类， 让适配器代替controller执行相应的方法。这样在扩展Controller 时，只需要增加一个适配器类就完成了SpringMVC的扩展了.</p>
<p>​    实现一套代码来模拟springMVC:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//定义一个Adapter接口  </span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerAdapter</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span></span>;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Object handler)</span></span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//以下是三种Controller实现  </span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Controller</span> </span>&#123;  </div><div class="line">  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpController</span> <span class="keyword">implements</span> <span class="title">Controller</span></span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doHttpHandler</span><span class="params">()</span></span>&#123;  </div><div class="line">        System.out.println(<span class="string">"http..."</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleController</span> <span class="keyword">implements</span> <span class="title">Controller</span></span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSimplerHandler</span><span class="params">()</span></span>&#123;  </div><div class="line">        System.out.println(<span class="string">"simple..."</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationController</span> <span class="keyword">implements</span> <span class="title">Controller</span></span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAnnotationHandler</span><span class="params">()</span></span>&#123;  </div><div class="line">        System.out.println(<span class="string">"annotation..."</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//下面编写适配器类  </span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleHandlerAdapter</span> <span class="keyword">implements</span> <span class="title">HandlerAdapter</span> </span>&#123;  </div><div class="line">  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Object handler)</span> </span>&#123;  </div><div class="line">        ((SimpleController)handler).doSimplerHandler();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> (handler <span class="keyword">instanceof</span> SimpleController);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpHandlerAdapter</span> <span class="keyword">implements</span> <span class="title">HandlerAdapter</span> </span>&#123;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Object handler)</span> </span>&#123;  </div><div class="line">        ((HttpController)handler).doHttpHandler();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> (handler <span class="keyword">instanceof</span> HttpController);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">  </div><div class="line">  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationHandlerAdapter</span> <span class="keyword">implements</span> <span class="title">HandlerAdapter</span> </span>&#123;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Object handler)</span> </span>&#123;  </div><div class="line">        ((AnnotationController)handler).doAnnotationHandler();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span> </span>&#123;  </div><div class="line">          </div><div class="line">        <span class="keyword">return</span> (handler <span class="keyword">instanceof</span> AnnotationController);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//模拟一个DispatcherServlet  </span></div><div class="line"><span class="keyword">import</span> java.util.ArrayList;  </div><div class="line"><span class="keyword">import</span> java.util.List;  </div><div class="line">  </div><div class="line">  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DispatchServlet</span> </span>&#123;  </div><div class="line">      </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;HandlerAdapter&gt; handlerAdapters = <span class="keyword">new</span> ArrayList&lt;HandlerAdapter&gt;();   </div><div class="line">      </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DispatchServlet</span><span class="params">()</span></span>&#123;  </div><div class="line">        handlerAdapters.add(<span class="keyword">new</span> AnnotationHandlerAdapter());  </div><div class="line">        handlerAdapters.add(<span class="keyword">new</span> HttpHandlerAdapter());  </div><div class="line">        handlerAdapters.add(<span class="keyword">new</span> SimpleHandlerAdapter());  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">      </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">()</span></span>&#123;  </div><div class="line">          </div><div class="line">        <span class="comment">//此处模拟SpringMVC从request取handler的对象，仅仅new出.               </span></div><div class="line">        <span class="comment">//不论实现何种Controller，适配器总能经过适配以后得到想要的结果  </span></div><div class="line"><span class="comment">//      HttpController controller = new HttpController();  </span></div><div class="line"><span class="comment">//      AnnotationController controller = new AnnotationController();  </span></div><div class="line">        SimpleController controller = <span class="keyword">new</span> SimpleController();  </div><div class="line">        <span class="comment">//得到对应适配器  </span></div><div class="line">        HandlerAdapter adapter = getHandler(controller);  </div><div class="line">        <span class="comment">//通过适配器执行对应的controller对应方法  </span></div><div class="line">        adapter.handle(controller);  </div><div class="line">          </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    <span class="function"><span class="keyword">public</span> HandlerAdapter <span class="title">getHandler</span><span class="params">(Controller controller)</span></span>&#123;  </div><div class="line">        <span class="keyword">for</span>(HandlerAdapter adapter: <span class="keyword">this</span>.handlerAdapters)&#123;  </div><div class="line">            <span class="keyword">if</span>(adapter.supports(controller))&#123;  </div><div class="line">                <span class="keyword">return</span> adapter;  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </div><div class="line">        <span class="keyword">new</span> DispatchServlet().doDispatch();  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Spring MVC HandlerAdapter ,有下面几个子类：</p>
<p><img src="http://www.ityuedu.com/myimages/2/593936406071.png" alt="img"></p>
<p>这几个子类，分别用于适配不同的Handler（我们写的请求处理代码）。</p>
<p>如果Handler是一个简单的Servlet（这是在web.xml配置自定义的Servlet时的方式），那么就使用<code>SimpleServletHandlerAdapter</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span>  ModelAndView <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> </span></div><div class="line"></div><div class="line">        <span class="keyword">throws</span>  Exception &#123; </div><div class="line">        </div><div class="line">      ((Servlet) handler).service(request, response); </div><div class="line"></div><div class="line">      <span class="keyword">return</span> <span class="keyword">null</span> ; </div><div class="line"></div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>如果Handler是一个简单的Controller的实例，就是用<code>SimpleControllerHandlerAdapter</code>来适配（在Spring2.5时，一般会采用这种方式）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123; </div><div class="line">  <span class="keyword">return</span> ((Controller) handler).handleRequest(request, response); </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果使用了注解方式，就使用<code>AnnotationMethodHandlerAdapter</code>.</p>
<p>从上面的可以采用的几种处理HttpRequest的写法上来看，这几种Handler分别属于不同的类，也就是处理的接口是不同的。然而在DispatcherServlet中，只用了一个接口，采用了适配器模式，来屏蔽掉这种差异，在适配器的内部，进行接口的转换工作。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[HTTP协议详解]]></title>
      <url>http://zsr.github.io/2016/09/11/HTTP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h3 id="Http"><a href="#Http" class="headerlink" title="Http:"></a><strong>Http:</strong></h3><ul>
<li>全称：超文本传输协议<code>(HyperText Transfer Protocol)</code></li>
<li>作用：设计之初是为了将<strong>超文本标记语言</strong><code>(HTML)</code>文档从Web服务器传送到客户端的浏览器。现在<code>http</code>的作用已不局限于<code>HTML</code>的传输。</li>
<li>版本：<code>http/1.0</code> <code>http/1.1*</code> <code>http/2.0</code></li>
</ul>
<h3 id="URL详解"><a href="#URL详解" class="headerlink" title="URL详解"></a><strong>URL详解</strong></h3><p>一个示例URL</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">http://www.mywebsite.com/sj/test;id=8079?name=sviergn&amp;x=true#stuff</div><div class="line"></div><div class="line">Schema: http</div><div class="line">host: www.mywebsite.com</div><div class="line">path: /sj/test</div><div class="line">URL params: id=8079</div><div class="line">Query String: name=sviergn&amp;x=true</div><div class="line">Anchor: stuff</div></pre></td></tr></table></figure>
<ul>
<li><code>scheme</code>：指定低层使用的协议(例如：<code>http</code>, <code>https</code>, <code>ftp</code>)</li>
<li><code>host</code>：<code>HTTP</code>服务器的<code>IP</code>地址或者域名</li>
<li><code>port#</code>：<code>HTTP</code>服务器的默认端口是<code>80</code>，这种情况下端口号可以省略。如果使用了别的端口，必须指明，例如<code>http://www.mywebsite.com:8080/</code></li>
<li><code>path</code>：访问资源的路径</li>
<li><code>url-params</code></li>
<li><code>query-string</code>：发送给<code>http</code>服务器的数据</li>
<li><code>anchor</code>：锚</li>
</ul>
<h3 id="无状态的协议"><a href="#无状态的协议" class="headerlink" title="无状态的协议"></a><strong>无状态的协议</strong></h3><p><code>http</code>协议是<strong>无状态</strong>的：</p>
<blockquote>
<p><strong>同一个客户端的这次请求和上次请求是没有对应关系，对http服务器来说，它并不知道这两个请求来自同一个客户端。</strong></p>
</blockquote>
<p>解决方法：<code>Cookie</code>机制来维护状态</p>
<p><strong>既然Http协议是无状态的，那么Connection:keep-alive 又是怎样一回事？</strong></p>
<blockquote>
<p>无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。从另一方面讲，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系。</p>
</blockquote>
<h3 id="http消息结构"><a href="#http消息结构" class="headerlink" title="http消息结构"></a><strong>http消息结构</strong></h3><ol>
<li><p><strong>Request 消息的结构</strong>：<strong>三部分</strong></p>
<blockquote>
<p>第一部分叫<code>Request line</code>（请求行）， 第二部分叫<code>http header</code>, 第三部分是<code>body</code></p>
<ul>
<li><p><strong>请求行</strong>：包括<code>http</code>请求的种类，请求资源的路径，<code>http</code>协议版本</p>
</li>
<li><p><strong>http header</strong>：<code>http</code>头部信息</p>
</li>
<li><p><strong>body</strong>：发送给服务器的<code>query</code>信息<br>当使用的是”<code>GET</code>“ 方法的时候，<code>body</code>是为空的（<strong>GET只能读取服务器上的信息</strong>，<strong>post能写入</strong>） </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&gt;   GET /hope/ HTTP/1.1   //---请求行</div><div class="line">&gt;   Host: ce.sysu.edu.cn</div><div class="line">&gt;   Accept: */*</div><div class="line">&gt;   Accept-Encoding: gzip, deflate, sdch</div><div class="line">&gt;   Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.6</div><div class="line">&gt;   Cache-Control: max-age=0</div><div class="line">&gt;   Cookie:.........</div><div class="line">&gt;   Referer: http://ce.sysu.edu.cn/hope/</div><div class="line">&gt;   User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/44.0.2403.130 Safari/537.36</div><div class="line">&gt;   ---分割线---</div><div class="line">&gt;   POST /hope/ HTTP/1.1   //---请求行</div><div class="line">&gt;   Host: ce.sysu.edu.cn</div><div class="line">&gt;   Accept: */*</div><div class="line">&gt;   Accept-Encoding: gzip, deflate, sdch</div><div class="line">&gt;   Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.6</div><div class="line">&gt;   Cache-Control: max-age=0</div><div class="line">&gt;   Cookie:.........</div><div class="line">&gt;   Referer: http://ce.sysu.edu.cn/hope/</div><div class="line">&gt;   User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/44.0.2403.130 Safari/537.36</div><div class="line">&gt;   ...body...</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>  ​</p>
</blockquote>
</li>
<li><p><strong>Response消息的结构</strong></p>
<blockquote>
<p>也分为三部分，第一部分叫request line, 第二部分叫request header，第三部分是body</p>
<ul>
<li><p><strong>request line</strong>：协议版本、状态码、<code>message</code></p>
</li>
<li><p><strong>request header</strong>：<code>request</code>头信息</p>
</li>
<li><p><strong>body</strong>：返回的请求资源主体 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&gt;   HTTP/1.1 200 OK</div><div class="line">&gt;   Accept-Ranges: bytes</div><div class="line">&gt;   Content-Encoding: gzip</div><div class="line">&gt;   Content-Length: 4533</div><div class="line">&gt;   Content-Type: text/html</div><div class="line">&gt;   Date: Sun, 06 Sep 2015 07:56:07 GMT</div><div class="line">&gt;   ETag: &quot;2788e6e716e7d01:0&quot;</div><div class="line">&gt;   Last-Modified: Fri, 04 Sep 2015 13:37:55 GMT</div><div class="line">&gt;   Server: Microsoft-IIS/7.5</div><div class="line">&gt;   Vary: Accept-Encoding</div><div class="line">&gt;   X-Powered-By: ASP.NET</div><div class="line">&gt;   &lt;!DOCTYPE html&gt;</div><div class="line">&gt;   ...</div><div class="line">&gt;   &lt;&gt;</div><div class="line">&gt;   ...</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
</li>
</ol>
<h3 id="get-和-post-区别"><a href="#get-和-post-区别" class="headerlink" title="get 和 post 区别"></a><strong>get 和 post 区别</strong></h3><p><code>http</code>协议定义了很多与服务器交互的方法，最基本的有4种，分别是<code>GET</code>,<code>POST</code>,<code>PUT</code>,<code>DELETE</code>。 一个<code>URL</code>地址用于描述一个网络上的资源，而<code>HTTP</code>中的<code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code> 就对应着对这个资源的查，改，增，删4个操作。 我们最常见的就是<code>GET</code>和<code>POST</code>了。<code>GET</code>一般用于获取/查询资源信息，而POST一般用于更新资源信息.</p>
<ol>
<li><code>GET</code> 提交的数据会放在<code>URL</code>之后，以<code>?</code>分割<code>URL</code>和传输数据，参数之间以<code>&amp;</code>相连，如<code>EditPosts.aspx?name=test1&amp;id=123456</code>。<code>POST</code> 方法是把提交的数据放在<code>HTTP</code>包的<code>Body</code>中。</li>
<li><code>GET</code> 提交的数据大小有限制（因为<strong>浏览器对URL的长度有限制</strong>），而<code>POST</code>方法提交的数据没有限制.</li>
<li><code>GET</code> 方式需要使用<code>Request.QueryString</code> 来取得变量的值，而<code>POST</code>方式通过<code>Request.Form</code>来获取变量的值。</li>
<li><code>GET</code> 方式提交数据，会带来<strong>安全问题</strong>，比如一个登录页面，通过<code>GET</code>方式提交数据时，用户名和密码将出现在<code>URL</code>上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码. </li>
</ol>
<p><strong><a href="https://www.zybuluo.com/yangfch3/note/123476" target="_blank" rel="external">HTTP请求的Get与Post</a></strong></p>
<h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a><strong>状态码</strong></h3><p><code>Response</code> 消息中的第一行叫做<strong>状态行</strong>，由<code>HTTP</code>协议版本号， <strong>状态码</strong>， <strong>状态消息</strong> 三部分组成。</p>
<p>状态码用来告诉<code>HTTP</code>客户端，<code>HTTP</code>服务器是否产生了预期的<code>Response</code>.</p>
<p><code>HTTP/1.1</code>中定义了 5 类状态码。</p>
<p>状态码由三位数字组成，第一个数字定义了响应的类别</p>
<ul>
<li><code>1XX</code> 提示信息 - 表示请求已被成功接收，继续处理</li>
<li><code>2XX</code> 成功 - 表示请求已被成功接收，理解，接受</li>
<li><code>3XX</code> 重定向 - 要完成请求必须进行更进一步的处理</li>
<li><code>4XX</code> 客户端错误 - 请求有语法错误或请求无法实现</li>
<li><code>5XX</code> 服务器端错误 - 服务器未能实现合法的请求<ol>
<li><strong>200 OK</strong><br>请求被成功地完成，所请求的资源发送回客户端</li>
<li><strong>302 Found</strong><br>重定向，新的<code>URL</code>会在<code>response</code>中的<code>Location</code>中返回，浏览器将会使用新的<code>URL</code>发出新的<code>Request</code></li>
<li><strong>304 Not Modified</strong><br>文档已经被缓存，直接从缓存调用</li>
<li><strong>400 Bad Request</strong><br>客户端请求与语法错误，不能被服务器所理解<br><strong>403 Forbidden</strong><br>服务器收到请求，但是拒绝提供服务<br><strong>404 Not Found</strong><br>请求资源不存在</li>
<li><strong>500 Internal Server Error</strong><br>服务器发生了不可预期的错误<br><strong>503 Server Unavailable</strong><br>服务器当前不能处理客户端的请求，一段时间后可能恢复正常</li>
</ol>
</li>
</ul>
<h3 id="http-reauest-header"><a href="#http-reauest-header" class="headerlink" title="http reauest header"></a><strong>http reauest header</strong></h3><p><code>http</code> 请求头包括很多键值对，这些键值对有什么意义与作用？如何根据功能为他们分一下组呢？</p>
<ol>
<li><p><strong>cache 头域</strong></p>
<ul>
<li><p><code>If-Modified-Since</code><br>用法：<code>If-Modified-Since: Thu, 09 Feb 2012 09:07:57 GMT</code></p>
<p>把浏览器端缓存页面的最后修改时间发送到服务器去，服务器会把这个时间与服务器上实际文件的最后修改时间进行对比。如果时间一致，那么返回304，客户端就直接使用本地缓存文件。如果时间不一致，就会返回200和新的文件内容。客户端接到之后，会丢弃旧文件，把新文件缓存起来，并显示在浏览器中。 </p>
</li>
<li><p><code>If-None-Match</code><br>用法：<code>If-None-Match: &quot;03f2b33c0bfcc1:0&quot;</code></p>
<p><code>If-None-Match</code>和<code>ETag</code>一起工作，<strong>工作原理是在HTTP Response中添加ETag信息</strong>。 当用户再次请求该资源时，将在<code>HTTP Request</code> 中加入<code>If-None-Match</code>信息(<code>ETag</code>的值)。如果服务器验证资源的<code>ETag</code>没有改变（该资源没有更新），将返回一个<code>304</code>状态告诉客户端使用本地缓存文件。<strong>否则将返回200状态和新的资源和Etag</strong>. 使用这样的机制将提高网站的性能 </p>
</li>
<li><p><code>Pragma</code>：<code>Pragma: no-cache</code><br><code>Pargma</code>只有一个用法， 例如： <code>Pragma: no-cache</code></p>
<p>作用： 防止页面被缓存， 在<code>HTTP/1.1</code>版本中，它和<code>Cache-Control:no-cache</code>作用一模一样 </p>
</li>
<li><p><code>Cache-Control</code><br>用法：</p>
<ul>
<li><code>Cache-Control:Public</code> 可以被任何缓存所缓存（）</li>
<li><code>Cache-Control:Private</code> 内容只缓存到私有缓存中</li>
<li><code>Cache-Control:no-cache</code> 所有内容都不会被缓存</li>
</ul>
<p>作用：用来指定<code>Response-Request</code>遵循的缓存机制</p>
</li>
</ul>
</li>
<li><p><strong>Client 头域</strong></p>
<ul>
<li><p><code>Accept</code><br>用法：<code>Accept: */*</code>，<code>Accept: text/html</code></p>
<p>作用： 浏览器端可以接受的媒体类型；<br><code>Accept: */*</code> 代表浏览器可以处理所有回发的类型，(<strong>一般浏览器发给服务器都是发这个</strong>）<br><code>Accept: text/html</code> 代表浏览器可以接受服务器回发的类型为 <code>text/html</code> ；如果服务器无法返回<code>text/html</code>类型的数据，服务器应该返回一个<code>406</code>错误(<code>non acceptable</code>) </p>
</li>
<li><p><code>Accept-Encoding</code><br>用法：<code>Accept-Encoding: gzip, deflate</code></p>
<p>作用： 浏览器申明自己接收的<strong>文件</strong>编码方法，通常指定<strong>压缩方法</strong>，是否支持压缩，支持什么压缩方法（<code>gzip</code>，<code>deflate</code>），（注意：这不是指字符编码） </p>
</li>
<li><p><code>Accept-Language</code><br>用法：<code>Accept-Language: en-us</code></p>
<p>作用： 浏览器申明自己接收的语言。<br><strong>语言跟字符集的区别</strong>：中文是语言，中文有多种字符集，比如<code>big5</code>，<code>gb2312</code>，<code>gbk</code>等等； </p>
</li>
<li><p><code>User-Agent</code><br>用法： <code>User-Agent: Mozilla/4.0......</code></p>
<p>作用：告诉<code>HTTP</code>服务器， 客户端使用的操作系统和浏览器的名称和版本. </p>
</li>
<li><p><code>Accept-Charset</code><br>用法：<code>Accept-Charset：utf-8</code></p>
<p>作用：浏览器申明自己接收的字符集，这就是本文前面介绍的各种字符集和字符编码，如gb2312，utf-8（通常我们说Charset包括了相应的字符编码方案） </p>
</li>
</ul>
</li>
<li><p><strong>Cookie/Login 头域</strong></p>
<ul>
<li><p><code>Cookie</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Cookie: bdshare_firstime=1439081296143; ASP.NET_SessionId=rcqayd4ufldcke0wkbm1vhxb; pgv_pvi=7361416192; pgv_si=s6686106624; ce.sysu.edu.cn80.ASPXAUTH=9E099592DD5A414BEECD8CF43CFC71664</div></pre></td></tr></table></figure>
<p>作用： <strong>最重要</strong>的<strong>header</strong>, 将<code>cookie</code>的值发送给<code>HTTP</code> 服务器</p>
</li>
</ul>
</li>
<li><p><strong>Entity 头域</strong></p>
<ul>
<li><p><code>Content-Length</code><br>用法：<code>Content-Length: 38</code></p>
<p>作用：发送给HTTP服务器数据的长度。 </p>
</li>
<li><p><code>Content-Type</code><br>用法：<code>Content-Type: application/x-www-form-urlencoded</code></p>
<p>不常出现，一般出现在<code>response</code>头部，用于指定数据文件类型 </p>
</li>
</ul>
</li>
<li><p><strong>Miscellaneous 头域</strong></p>
<ul>
<li><p><code>Referer</code><br>用法：<code>Referer: http://ce.sysu.edu.cn/hope/</code></p>
<p>作用：提供了<code>Request</code>的<strong>上下文信息</strong>的服务器，告诉服务器我是从哪个链接过来的，比如从我主页上链接到一个朋友那里，他的服务器就能够从<code>HTTP Referer</code>中统计出每天有多少用户点击我主页上的链接访问他的网站。 </p>
</li>
</ul>
</li>
<li><p><strong>Transport 头域</strong></p>
<ul>
<li><p><code>Connection</code><br><code>Connection: keep-alive</code>： 当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接</p>
<p><code>Connection: close</code>： 代表一个<code>Request</code>完成后，客户端和服务器之间用于传输<code>HTTP</code>数据的<code>TCP</code>连接会关闭， 当客户端再次发送<code>Request</code>，需要重新建立<code>TCP</code>连接 </p>
</li>
<li><p><code>Host</code><br>用法：<code>Host: ce.sysu.edu.cn</code></p>
<p>作用: 请求报头域主要用于指定被请求资源的<code>Internet</code><strong>主机和端口号</strong>（默认80），它通常从<code>HTTP URL</code>中提取出来的</p>
</li>
</ul>
</li>
</ol>
<h3 id="HTTP-Response-header"><a href="#HTTP-Response-header" class="headerlink" title="HTTP Response header"></a><strong>HTTP Response header</strong></h3><ol>
<li><p><strong><code>Cache</code> 头域</strong></p>
<ul>
<li><p><code>Date</code><br>用法：<code>Date: Sat, 11 Feb 2012 11:35:14 GMT</code></p>
<p>作用: 生成消息的具体时间和日期 </p>
</li>
<li><p><code>Expires</code><br>用法：<code>Expires: Tue, 08 Feb 2022 11:35:14 GMT</code><br>作用: 浏览器会在指定过期时间内使用本地缓存 </p>
</li>
<li><p><code>Vary</code><br>用法：Vary: Accept-Encoding </p>
</li>
</ul>
</li>
<li><p><strong><code>Cookie/Login</code> 头域</strong></p>
<ul>
<li><p><code>P3P</code><br>用法：<br><code>P3P: CP=CURa ADMa DEVa PSAo PSDo OUR BUS UNI PUR INT DEM STA PRE COM NAV OTC NOI DSP COR</code></p>
<p>作用: 用于<strong>跨域</strong>设置<strong>Cookie</strong>, 这样可以解决<code>iframe</code>跨域访问<code>cookie</code>的问题 </p>
</li>
<li><p><code>Set-Cookie</code><br>用法：<br><code>Set-Cookie: sc=4c31523a; path=/; domain=.acookie.taobao.com</code></p>
<p>作用：非常重要的<code>header</code>, 用于把<code>cookie</code> 发送到客户端浏览器， 每一个写入<code>cookie</code>都会生成一个<code>Set-Cookie</code>.</p>
</li>
</ul>
</li>
<li><p><strong><code>Entity</code> 头域</strong></p>
<ul>
<li><p><code>ETag</code><br>用法：<code>ETag: &quot;03f2b33c0bfcc1:0&quot;</code></p>
<p>作用: 和<code>request header</code>的<code>If-None-Match</code> 配合使用 </p>
</li>
<li><p><code>Last-Modified</code><br>用法：<code>Last-Modified: Wed, 21 Dec 2011 09:09:10 GMT</code></p>
<p>作用：用于指示资源的最后修改日期和时间。（实例请看上节的<code>If-Modified-Since</code>的实例） </p>
</li>
<li><p><code>Content-Type</code><br>用法：</p>
<ul>
<li>Content-Type: text/html; charset=utf-8</li>
<li>Content-Type:text/html;charset=GB2312</li>
<li>Content-Type: image/jpeg</li>
</ul>
<p>作用：WEB服务器告诉浏览器自己响应的对象的类型和字符集 </p>
</li>
<li><p>Content-Encoding<br>用法：<code>Content-Encoding：gzip</code></p>
<p>作用：WEB服务器表明自己使用了什么压缩方法（<code>gzip</code>，<code>deflate</code>）压缩响应中的对象。 </p>
</li>
<li><p><code>Content-Language</code><br>用法： <code>Content-Language:da</code></p>
<p>WEB服务器告诉浏览器自己响应的对象的语言</p>
</li>
</ul>
</li>
<li><p><strong><code>Miscellaneous</code> 头域</strong></p>
<ul>
<li><p><code>Server</code><br>用法：<code>Server: Microsoft-IIS/7.5</code></p>
<p>作用：指明HTTP服务器的软件信息 </p>
</li>
<li><p><code>X-AspNet-Version</code><br>用法：<code>X-AspNet-Version: 4.0.30319</code></p>
<p>作用：如果网站是用<code>ASP.NET</code>开发的，这个<code>header</code>用来表示<code>ASP.NET</code>的版本 </p>
</li>
<li><p>X-Powered-By<br>用法：<code>X-Powered-By: ASP.NET</code></p>
<p>作用：表示网站是用什么技术开发的 </p>
</li>
</ul>
</li>
<li><p><strong><code>Transport</code>头域</strong></p>
<ul>
<li><code>Connection</code><br>用法与作用：<br><code>Connection: keep-alive</code>：当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接<code>Connection: close</code>：代表一个Request完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭， 当客户端再次发送Request，需要重新建立TCP连接</li>
</ul>
</li>
<li><p><strong><code>Location</code>头域</strong></p>
<ul>
<li>Location<br>用法：<code>Location：http://ce.sysu.edu.cn/hope/</code><br>作用： 用于重定向一个新的位置， 包含新的<code>URL</code>地址</li>
</ul>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Http请求过程]]></title>
      <url>http://zsr.github.io/2016/09/10/http%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>浏览器 http请求过程</p>
<h3 id="1-首先是输入网址"><a href="#1-首先是输入网址" class="headerlink" title="1. 首先是输入网址"></a><strong>1. 首先是输入网址</strong></h3><p>以www.facebook.com为例.</p>
<h3 id="2-浏览器查找域名对应IP"><a href="#2-浏览器查找域名对应IP" class="headerlink" title="2. 浏览器查找域名对应IP"></a><strong>2. 浏览器查找域名对应IP</strong></h3><h4 id="2-1-DNS查找过程："><a href="#2-1-DNS查找过程：" class="headerlink" title="2.1 DNS查找过程："></a><strong>2.1 DNS查找过程：</strong></h4><ol>
<li><strong>浏览器缓存</strong>——浏览器会记录DNS一段时间（2-30分钟不等，视浏览器而定）</li>
<li><strong>系统缓存</strong>——浏览器里没找到DNS缓存，此事浏览器做一个系统调用（window下是gethostbyname）。如发现匹配则采用。（与此对应有host恶意劫持更改攻击）</li>
<li><strong>路由器缓存</strong>——路由器也会有DNS缓存（缓存你上过的网站，所以有时路由器需要进行DNS刷新）</li>
<li><strong>ISP DNS缓存</strong>——接下来是在ISP（互联网服务提供商）的DNS服务器的<strong>缓存</strong>上查找。**</li>
<li><strong>递归查找</strong>——DNS缓存里没有的话，ISP DNS服务器会先后从<strong>根域名服务器（root）</strong>、<strong>.com顶级域名服务器</strong>、<strong>Facebook域名服务器</strong>获取IP（一般缓存内都会有，所以这一步一般不会发生）</li>
</ol>
<p>DNS递归查找如下图所示：</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/KovAgJ2aWyaMiajaQydgJ5rUpib6cuhTpJ8RvkQs1icO3m8PUqSRHvhq6qbWyXr1keDtg9wNE9SlJpicDq8dHspuVA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="img"></p>
<p>DNS有一点令人担忧，这就是像wikipedia.org 或者 facebook.com这样的整个域名看上去只是对应一个单独的IP地址。还好，有几种方法可以消除这个瓶颈：</p>
<h4 id="2-2-多IP域名DNS查询解决方案"><a href="#2-2-多IP域名DNS查询解决方案" class="headerlink" title="2.2 多IP域名DNS查询解决方案"></a><strong>2.2 多IP域名DNS查询解决方案</strong></h4><ol>
<li><strong>循环DNS</strong>——单个域名、多个IP列表循环应对DNS查询</li>
<li><strong>负载均衡器</strong>——一个特定IP的负载均衡服务器（例如：反向代理服务器）负责监听请求并转发给后面的多个服务器集群的某一个，实现多个服务器负载均衡</li>
<li><strong>地理DNS</strong>——根据用户所处地理位置，返回不同的IP（应用：CDN）</li>
<li><strong>anycast</strong>——一个IP地址映射多个物理主机的路由技术</li>
</ol>
<p>大多数DNS服务器使用Anycast来获得高效低延迟的DNS查找。</p>
<h3 id="3-发送请求"><a href="#3-发送请求" class="headerlink" title="3. 发送请求"></a><strong>3. 发送请求</strong></h3><p>得到域名对应的IP后，就开始发送HTTP(S)请求了.</p>
<p>浏览器将把请求发送到Facebook所在的服务器, 请求头详解：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">GET http://facebook.com/ HTTP/1.1</div><div class="line">Accept: application/x-ms-application, image/jpeg, application/xaml+xml, [...]</div><div class="line">User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; [...]</div><div class="line">Accept-Encoding: gzip, deflate</div><div class="line">Connection: Keep-Alive</div><div class="line">Host: facebook.com</div><div class="line">Cookie: datr=1265876274-[...]; locale=en_US; lsd=WW[...]; c_user=2101[...]</div></pre></td></tr></table></figure>
<p>请求告诉服务器： </p>
<ol>
<li>我要获取（GET） <a href="http://facebook.com/" target="_blank" rel="external">http://facebook.com/</a>（GET的URL）这个页面 </li>
<li>Accept：我能接受这些类型的文件 </li>
<li>我使用的是何种操作系统上的哪个类型那个版本的浏览器 </li>
<li>接受何种方式的压缩文件 </li>
<li>连接类型：短连接？长连接？ </li>
<li>主机域名 </li>
<li>发送存储在本机的cookies信息给服务器</li>
</ol>
<p>除了获取请求，还有一种是发送请求，它常在提交表单用到。（如：搜索时要把搜索的内容一并发给服务器进行处理（在请求URL后面增加特定的用户参数），以获取特定的内容）</p>
<p>注意：<strong>URL后面加斜杠与不加斜杠的区别</strong>(文件夹与单个文件的区别)<br><a href="http://www.facebook.com/" target="_blank" rel="external">http://www.facebook.com</a><br><a href="http://www.facebook.com/" target="_blank" rel="external">http://www.facebook.com/</a></p>
<p>当我们输入<a href="http://www.facebook.com/" target="_blank" rel="external">http://www.facebook.com</a>时，浏览器会自动添加斜杠，保证URL的严谨。<br>当我们输入：<a href="http://www.facebook.com/folderOrFile" target="_blank" rel="external">http://www.facebook.com/folderOrFile</a> 时，因为<strong>浏览器不清楚folderOrFile到底是文件夹还是文件</strong>，所以<strong>不能自动添加 斜杠</strong>。这时，浏览器就不加斜杠直接访问地址，服务器会<strong>响应一个重定向</strong>，结果造成一次<strong>不必要的握手</strong>。</p>
<h3 id="4-重定向"><a href="#4-重定向" class="headerlink" title="4. 重定向"></a><strong>4. 重定向</strong></h3><p>当我们输入不完整的网址（<a href="http://facebook.com/" target="_blank" rel="external">http://facebook.com</a>）时，或者网站迁移做了重定向设置时，服务器会进行一次重定向响应。<br>下面是重定向之后返回的响应头：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 301 Moved Permanently  </div><div class="line">Cache-Control: private, no-store, no-cache, must-revalidate, post-check=0,</div><div class="line">pre-check=0</div><div class="line">Expires: Sat, 01 Jan 2000 00:00:00 GMT</div><div class="line">Location: http://www.facebook.com/</div><div class="line">P3P: CP=&quot;DSP LAW&quot;</div><div class="line">Pragma: no-cache</div><div class="line">Set-Cookie: made_write_conn=deleted; expires=Thu, 12-Feb-2009 05:09:50 GMT;</div><div class="line">path=/; domain=.facebook.com; httponly</div><div class="line">Content-Type: text/html; charset=utf-8</div><div class="line">X-Cnection: close</div><div class="line">Date: Fri, 12 Feb 2010 05:09:51 GMT</div><div class="line">Content-Length: 0</div></pre></td></tr></table></figure>
<ol>
<li>301 永久重定向 </li>
<li>新的Location：……</li>
</ol>
<p><strong>为什么要重定向，而不直接返回用户想看的内容呢？（既然服务器已经经过重定向知道了用户需要什么）</strong><br>答：原因之一：与搜索引擎排名有关。你看，如果一个页面有两个地址，就像<a href="http://www.igoro.com/" target="_blank" rel="external">http://www.igoro.com/</a> 和<a href="http://igoro.com/" target="_blank" rel="external">http://igoro.com/</a>，搜索引擎会认为它们是两个网站，结果造成每一个的搜索链接都减少从而降低排名。而搜索引擎知道301永久重定向是 什么意思，这样就会把访问带www的和不带www的地址归到同一个网站排名下。还有一个是用不同的地址会造成缓存友好性变差。当一个页面有好几个名字时，它可能会在缓存里出现好几次。</p>
<h3 id="5-新的请求"><a href="#5-新的请求" class="headerlink" title="5. 新的请求"></a><strong>5. 新的请求</strong></h3><p>重定向之后会发布一个新的获取请求</p>
<h3 id="6-服务器处理请求"><a href="#6-服务器处理请求" class="headerlink" title="6. 服务器处理请求"></a><strong>6. 服务器处理请求</strong></h3><h4 id="6-1-web服务器软件"><a href="#6-1-web服务器软件" class="headerlink" title="6.1 web服务器软件"></a><strong>6.1 web服务器软件</strong></h4><ul>
<li>服务器操作系统种类：Linux（一般是厂家根据开源定制）、windows server系列（微软）</li>
<li>主要的服务器软件：IIS、Apache、Tomcat、JBOSS、Nginx、lighttpd、Tetty</li>
<li>服务器软件的作用：接收、处理与响应请求（了解CGI的作用）</li>
</ul>
<h4 id="6-2-处理流程："><a href="#6-2-处理流程：" class="headerlink" title="6.2 处理流程："></a><strong>6.2 处理流程：</strong></h4><ol>
<li>web服务器软件（如IIS或者Apache）接收到HTTP请求</li>
<li>确定执行那个<strong>请求处理程序</strong>（一个能<strong>读懂请求</strong>并且<strong>能生成HTML</strong>来进行响应的程序）（例如：java）来处理它</li>
<li>请求处理器<strong>阅读请求头的参数和cookies信息</strong></li>
<li>更新服务器上的信息：例如更新数据库信息</li>
<li>生成HTML，压缩（gzip或其他），响应请求发送给用户</li>
</ol>
<h3 id="7-服务器发回一个HTML响应"><a href="#7-服务器发回一个HTML响应" class="headerlink" title="7. 服务器发回一个HTML响应"></a><strong>7. 服务器发回一个HTML响应</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 200 OK</div><div class="line">Cache-Control: private, no-store, no-cache, must-revalidate, post-check=0,</div><div class="line">pre-check=0</div><div class="line">Expires: Sat, 01 Jan 2000 00:00:00 GMT</div><div class="line">P3P: CP=&quot;DSP LAW&quot;</div><div class="line">Pragma: no-cache</div><div class="line">Content-Encoding: gzip</div><div class="line">Content-Type: text/html; charset=utf-8</div><div class="line">X-Cnection: close</div><div class="line">Transfer-Encoding: chunked</div><div class="line">Date: Fri, 12 Feb 2010 09:05:55 GMT</div><div class="line"></div><div class="line">2b3Tn@[...]</div></pre></td></tr></table></figure>
<p>响应包括响应头（响应参数与信息）、响应body（主体文件）</p>
<p>响应包采用特定方法压缩，整个响应以blob类型传输，响应头指示响应包以何种方式压缩</p>
<p>这个响应头与重定向的响应头不太一样，这个响应头还包含着<strong>缓存选项</strong>，<strong>cookies设置</strong>和<strong>隐私信息</strong>等</p>
<p><strong>注意: 报头中把Content-type设置为“text/html”。报头让浏览器将该响应内容以HTML形式呈现，而不是以文件形式下载它。浏览器会根据报头信息决定如何解释该响应，不过同时也会考虑像URL扩展内容等其他因素。</strong></p>
<h3 id="8-浏览器开始显示HTML"><a href="#8-浏览器开始显示HTML" class="headerlink" title="8. 浏览器开始显示HTML"></a><strong>8. 浏览器开始显示HTML</strong></h3><p>浏览器在没有完整接收全部HTML文件，就已经开始显示页面了</p>
<h3 id="9-浏览器获取其他文件"><a href="#9-浏览器获取其他文件" class="headerlink" title="9. 浏览器获取其他文件"></a><strong>9. 浏览器获取其他文件</strong></h3><p>浏览器解析HTML遇到需要下载的文件时，便再次向服务器（CDN）发送获取文件的请求。</p>
<p>下面是几个访问facebook.com时需要重获取的几个URL：</p>
<p>图片</p>
<p><a href="http://static.ak.fbcdn.net/rsrc.php/z12E0/hash/8q2anwu7.gif" target="_blank" rel="external">http://static.ak.fbcdn.net/rsrc.php/z12E0/hash/8q2anwu7.gif</a></p>
<p><a href="http://static.ak.fbcdn.net/rsrc.php/zBS5C/hash/7hwy7at6.gif" target="_blank" rel="external">http://static.ak.fbcdn.net/rsrc.php/zBS5C/hash/7hwy7at6.gif</a></p>
<p>…</p>
<p>CSS 式样表</p>
<p><a href="http://static.ak.fbcdn.net/rsrc.php/z448Z/hash/2plh8s4n.css" target="_blank" rel="external">http://static.ak.fbcdn.net/rsrc.php/z448Z/hash/2plh8s4n.css</a></p>
<p><a href="http://static.ak.fbcdn.net/rsrc.php/zANE1/hash/cvtutcee.css" target="_blank" rel="external">http://static.ak.fbcdn.net/rsrc.php/zANE1/hash/cvtutcee.css</a></p>
<p>…</p>
<p>JavaScript 文件</p>
<p><a href="http://static.ak.fbcdn.net/rsrc.php/zEMOA/hash/c8yzb6ub.js" target="_blank" rel="external">http://static.ak.fbcdn.net/rsrc.php/zEMOA/hash/c8yzb6ub.js</a></p>
<p><a href="http://static.ak.fbcdn.net/rsrc.php/z6R9L/hash/cq2lgbs8.js" target="_blank" rel="external">http://static.ak.fbcdn.net/rsrc.php/z6R9L/hash/cq2lgbs8.js</a></p>
<p>…</p>
<p>这些地址都要经历一个和HTML读取类似的过程。所以浏览器会在DNS中查找这些域名，发送请求，重定向等等…</p>
<p>但 不像动态页面那样，静态文件会允许浏览器对其进行缓存。有的文件可能会不需要与服务器通讯，而从缓存中直接读取。服务器的响应中包含了静态文件保存的期限 信息，所以浏览器知道要把它们缓存多长时间。还有，每个响应都可能包含像版本号一样工作的ETag头（被请求变量的实体值），如果浏览器观察到文件的版本 ETag信息已经存在，就马上停止这个文件的传输。</p>
<p>试着猜猜看“fbcdn.net”在地址中代表什么？聪明的答案是”Facebook内容分发网络”。Facebook利用内容分发网络（CDN）分发像图片，CSS表和JavaScript文件这些静态文件。所以，这些文件会在全球很多CDN的数据中心中留下备份。</p>
<p>静态内容往往代表站点的带宽大小，也能通过CDN轻松的复制。通常网站会使用第三方的CDN。例如，Facebook的静态文件由最大的CDN提供商Akamai来托管。</p>
<p>举例来讲，当你试着ping static.ak.fbcdn.net的时候，可能会从某个akamai.net服务器上获得响应。有意思的是，当你同样再ping一次的时候，响应的服务器可能就不一样，这说明幕后的负载平衡开始起作用了。</p>
<p><strong>注意： </strong></p>
<ol>
<li>动态页面无法缓存，静态文件允许浏览器进行缓存。 </li>
<li>静态文件本地有缓存时直接从本地读取 </li>
<li>请求响应头内包含着<strong>静态文件保存的期限</strong>，浏览器知道下载的静态文件要静默保留多久。 </li>
<li>响应头还会有静态文件的ETag（相当于版本号），当浏览器发现请求的静态文件的响应头的ETag与现有的缓存文件不符时，便会再次向服务器获取静态文件。</li>
</ol>
<h3 id="10-浏览器发送异步（AJAX）请求"><a href="#10-浏览器发送异步（AJAX）请求" class="headerlink" title="10. 浏览器发送异步（AJAX）请求"></a><strong>10. 浏览器发送异步（AJAX）请求</strong></h3><p>以 Facebook聊天功能为例，它会持续与服务器保持联系来及时更新你那些亮亮灰灰的好友状态。为了更新这些头像亮着的好友状态，在浏览器中执行的 JavaScript代码会给服务器发送异步请求。这个异步请求发送给特定的地址，它是一个按照程式构造的获取或发送请求。还是在Facebook这个例子中，客户端发送给<a href="http://www.facebook.com/ajax/chat/buddy_list.php一个发布请求来获取你好友里哪个在线的状态信息。" target="_blank" rel="external">http://www.facebook.com/ajax/chat/buddy_list.php一个发布请求来获取你好友里哪个在线的状态信息。</a></p>
<p>Facebook聊天功能提供了关于AJAX一个有意思的问题案例：把数据从服务器端推送到客户端。因为HTTP是一个请求-响应协议，所以聊天服务器不能把新消息发给客户。取而代之的是客户端不得不隔几秒就轮询下服务器端看自己有没有新消息。</p>
<p>这些情况发生时长轮询是个减轻服务器负载挺有趣的技术。如果当被轮询时服务器没有新消息，它就不理这个客户端。而当尚未超时的情况下收到了该客户的新消息，服务器就会找到未完成的请求，把新消息做为响应返回给客户端。</p>
<p><strong>总结：</strong></p>
<ul>
<li>web 2.0的一大特征就是页面显示完全后客户端仍旧与服务器端保持联系（keep-alive）</li>
<li>浏览器执行特定的JS代码会给服务器发送<strong>异步请求</strong>，获取最新的动态消息，使得页面能保持较新的状态。</li>
<li>HTTP是一个<strong>请求-响应协议</strong>，只有在客户端发送请求，服务器端才能做出响应，而不能主动把消息或者文档发给客户</li>
<li>所以，要想保持页面处于最新的状态，需要<strong>定时进行轮询</strong>（定时发送AJAX请求以更新页面内容）</li>
<li>AJAX请求十分容易更改，且用户十分容易自己制造和发送AJAX请求，所以没有验证码的没有IP限制条件的投票就是一个小游戏了（参照工作室两次刷票：自己定义IP，自己定时发送AJAX请求，然后票就哗哗的上了）。</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[gitlab-ci]]></title>
      <url>http://zsr.github.io/2016/09/08/gitlab-ci/</url>
      <content type="html"><![CDATA[<h3 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a><strong>1. 背景</strong></h3><p>团队开发项目遇到的问题：</p>
<ul>
<li>版本更新较为频繁的问题。</li>
<li>测试覆盖不到位的问题。</li>
</ul>
<h3 id="2-Jenkins和Gitlab-CI的简单比较"><a href="#2-Jenkins和Gitlab-CI的简单比较" class="headerlink" title="2. Jenkins和Gitlab CI的简单比较"></a><strong>2. Jenkins和Gitlab CI的简单比较</strong></h3><p>Jenkins是老牌持续集成开源平台：</p>
<ul>
<li>优点：现在已经发展到2.0，各种功能插件非常丰富，支持groovy编写脚本，尤其支持LDAP等与企业集成的功能，基本上是CI的不二之选。</li>
<li>缺点：界面丑陋，配置相对复杂，一般需要专门的IT运维人员维护，与代码管理平台结合度相对较低，对Docker支持需要安装额外的插件。</li>
</ul>
<p>Gitlab CI，新锐CI平台：</p>
<ul>
<li>优点：界面美观，原生支持docker及多种机制，与代码管理工具结合度非常高，配置简单，使用YAML语言，程序员即可编写自动编译脚本。</li>
<li>缺点：控制性不够好，生态还不够齐全，YAML有一定的局限性，复杂任务需要些shell完成。</li>
</ul>
<p><strong>Jenkins适合复杂集成任务，而Gitlab CI适合相对简单的持续集成。</strong></p>
<p>企业中一般会2个同时使用，而两者的分工可以为：</p>
<ul>
<li>develop环境，直接使用Gitlab CI做持续的编译、测试、开发环境部署、API测试、客户端打包等工作</li>
<li>staging和production环境，使用Gitlab CI+Jenkins辅助配合的方式，或者直接由jenkins全包，因为上线会涉及到不同版本的资源更改、根据参数调整编译和打包等相对复杂的任务，这时Gitlab CI就会相形见肘了，虽然可以自己写Shell来支持，但控制性（如鸡肋的trigger）差强人意</li>
</ul>
<h3 id="3-项目中的使用"><a href="#3-项目中的使用" class="headerlink" title="3. 项目中的使用"></a><strong>3. 项目中的使用</strong></h3><p>项目中会使用J2EE, 大致阶段分为：代码检视、编译、测试、打包、部署。</p>
<p>dev环境，均使用Gitlab CI，比较简单，可以直接查询Gitlab CI文档，如果用过Travis CI，对于Gitlab CI就更不会有问题了。</p>
<p>staging和production环境，选用Gitlab CI+Jenkins混合的模式，具体阶段分工为：</p>
<ul>
<li>Gitlab CI负责：代码检视、编译、打包、测试</li>
<li>Jenkins负责：打包（主要是资源替换）、部署</li>
</ul>
<p><strong>在gitlab中完成持续集成CI包括两个操作：</strong></p>
<ul>
<li>配置一个Runner(用来编译、测试、打包的服务器节点)。</li>
<li>在项目根目录增加<a href="https://en.wikipedia.org/wiki/YAML" target="_blank" rel="external">YAML</a>格式的CI脚本文件<code>.gitlab-ci.yml</code>。</li>
</ul>
<h4 id="3-1-install-configue-gitlab-ci-multi-runner"><a href="#3-1-install-configue-gitlab-ci-multi-runner" class="headerlink" title="3.1 install configue gitlab-ci-multi-runner"></a><strong>3.1 install configue <code>gitlab-ci-multi-runner</code></strong></h4><ul>
<li><p><strong>GitLab 部署 CI 的第一步就是安装 gitlab-ci-multi-runner，你可以把它理解为：跑 CI 的服务。</strong></p>
<p>将一台mac计算机配置成我们的一个Runner，基本原理就是在Mac上安装一个代理程序gitlab-ci-multi-runner，然后将mac注册到gitlab服务器端，然后这台mac机器就能接收到gitlab服务器下发的CI任务，完成相应的编译、测试、打包等工作，然后将结果反馈给gitlab服务器。</p>
</li>
</ul>
<p>在一台Mac机器上执行如下命令安装gitlab-ci-multi-runner:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo curl --output /usr/local/bin/gitlab-ci-multi-runner https://gitlab-ci-multi-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-ci-multi-runner-darwin-amd64</div><div class="line"></div><div class="line">sudo chmod +x /usr/local/bin/gitlab-ci-multi-runner</div></pre></td></tr></table></figure>
<ul>
<li><strong>进入项目的Runner配置页面，如下图所示：</strong></li>
</ul>
<p><img src="http://img.blog.csdn.net/20160805110318437" alt="gitlab_config_runner"></p>
<ul>
<li><strong>在Mac机器上执行如下命令，将这台Mac注册到gitlab并绑定到我们示例项目。</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">gitlab-ci-multi-runner register</div><div class="line">#Please enter the gitlab-ci coordinator URL (e.g. https://gitlab.com/ci):</div><div class="line">##输入上图中的URL.</div><div class="line">#Please enter the gitlab-ci token for this runner:</div><div class="line">##输入上图中的token.</div><div class="line">#Please enter the gitlab-ci description for this runner:</div><div class="line">##输入一个描述信息，这里我们输入mac_runner</div><div class="line">#Please enter the gitlab-ci tags for this runner (comma separated):</div><div class="line">##输入一些标签，这里我们输入&quot;mac,xcode7.1&quot;</div><div class="line"># Registering runner... succeeded runner=euasz2j9 </div><div class="line">#Please enter the executor: docker-ssh+machine, docker, docker-ssh, parallels, shell, ssh, virtualbox, docker+machine:</div><div class="line">##这里我们输入shell，因为ios项目的编译、测试、打包我们都采用脚本来执行。</div><div class="line">#Runner registered successfully. Feel free to start it, but if it&apos;s running already the config should be automatically reloaded!</div><div class="line"></div><div class="line">#注册成功，接下来启动它</div><div class="line">gitlab-ci-multi-runner install </div><div class="line">gitlab-ci-multi-runner start</div></pre></td></tr></table></figure>
<p>现在我们的Mac机器就注册为一个Runner了，查看项目的Runner页面，如下图所示：</p>
<p><img src="http://img.blog.csdn.net/20160805110339094" alt="gitlab_runner_running"></p>
<p>我们的Runner就成功注册上了。接下来就可以编写CI的脚本了。</p>
<ul>
<li><strong>增加CI脚本文件<code>.gitlab-ci.yml</code></strong></li>
</ul>
<p>在项目根目录创建<code>.gitlab-ci.yml</code>文件，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">before_script:</div><div class="line">  - export JAVA_HOME=/usr/local/jdk1.7.0_79</div><div class="line"></div><div class="line">job:</div><div class="line">  only:</div><div class="line">    - master(每一次提交到master分支触发script)</div><div class="line"></div><div class="line">  script: </div><div class="line">    - mvn clean package -Ptest -q -Dmaven.javadoc.skip=true</div></pre></td></tr></table></figure>
<p><code>before_script</code> 部分将在每一个job前被执行。每个job包含的参数，例如<code>script</code> （shell script）、<code>tags</code> （只有运行这个tag/tags才允许选择这个构建），以及<code>only</code> 或<code>except</code> 参数来定义允许运行构建的分支名称。<code>only</code> 部分优先于 “except”。参见：<a href="http://doc.gitlab.com/ci/builds_configuration/README.html" target="_blank" rel="external">Configuration of your builds with .gitlab-ci.yml</a></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考**"></a>参考**</h3><ul>
<li><a href="http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html" target="_blank" rel="external">持续集成是什么？</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[开闭原则]]></title>
      <url>http://zsr.github.io/2016/09/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99-%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/</url>
      <content type="html"><![CDATA[<p>开闭原则是设计模式六大原则中最重要也是最“虚”的一个原则。为什么说它最重要呢？因为前面五大原则的目的都是为了实现这个开闭原则，开闭原则相当于它们的主旨思想。为什么说它“虚”呢？因为开闭原则只是个指导思想，不像另外五大原则都有具体可行的指导方法。</p>
<h3 id="1、什么是开闭原则"><a href="#1、什么是开闭原则" class="headerlink" title="1、什么是开闭原则"></a><strong>1、什么是开闭原则</strong></h3><p>Software entities like classes, modules and functions shoule be open for extension but closed for modifications.（一个软件实体如类，模块和函数应该对扩展开放，对修改关闭。）</p>
<p>开闭原则的定义很短，就是对扩展开放，对修改关闭。但是为什么要遵守这一个原则呢？</p>
<p>做过实际项目的筒子们应该都会深有体会，一个软件在其生命周期内都会发生很多变化，这几乎是不可避免的。无论是需求的变化、业务逻辑的变化、程序代码的变化等等，这些变化都有可能对整个软件的稳定性造成一定的威胁。</p>
<p>而开闭原则就是应对这些变化的，它告诉我们应该通过扩展来实现变化，而不是通过修改已有的代码。</p>
<h3 id="2、例子"><a href="#2、例子" class="headerlink" title="2、例子"></a><strong>2、例子</strong></h3><p>UML类图：</p>
<p><img src="http://7u2i08.com1.z0.glb.clouddn.com/design-pattern/open-close-principle1.png" alt="img"></p>
<p>程序代码如下：</p>
<ol>
<li>学生类，每个学生都有姓名和成绩：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> String name;</div><div class="line">  <span class="keyword">private</span> String grade;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, String grade)</span> </span>&#123;</div><div class="line">      <span class="keyword">this</span>.name = name;</div><div class="line">      <span class="keyword">this</span>.grade = grade;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> name;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getGrade</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> grade;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>老师类，每个老师管理一群的学生：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> List&lt;Student&gt; students = <span class="keyword">new</span> ArrayList&lt;Student&gt;();</div><div class="line"></div><div class="line">  <span class="keyword">static</span> &#123;</div><div class="line">      students.add(<span class="keyword">new</span> Student(<span class="string">"张三"</span>, <span class="string">"60"</span>));</div><div class="line">      students.add(<span class="keyword">new</span> Student(<span class="string">"李四"</span>, <span class="string">"70"</span>));</div><div class="line">      students.add(<span class="keyword">new</span> Student(<span class="string">"王五"</span>, <span class="string">"80"</span>));</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>场景类：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">      Teacher teacher = <span class="keyword">new</span> Teacher();</div><div class="line">      <span class="keyword">for</span> (Student student : teacher.students) &#123;</div><div class="line">          System.out.println(<span class="string">"姓名："</span> + student.getName() + <span class="string">" 成绩："</span> + student.getGrade());</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">姓名：张三 成绩：60</div><div class="line">姓名：李四 成绩：70</div><div class="line">姓名：王五 成绩：80</div></pre></td></tr></table></figure>
<h4 id="更改需求"><a href="#更改需求" class="headerlink" title="更改需求"></a><strong>更改需求</strong></h4><p>把同学们的成绩按照级别来分，分别有优秀，良好，一般，及格，不及格这几种。</p>
<p>直接修改Student类的getGrade方法不就行了嘛? 可能有很多人在实际项目中都是这么做的，但是这就违背了开闭原则，开闭原则要求我们尽量不要修改已有的代码，尽量通过扩展来实现改变。</p>
<p>可以通过扩展已有的代码来实现改变，可以增加一个LevelStudent来继承Student，并扩展修改getGrade方法。</p>
<p>修改后的UML类图如下所示：</p>
<p><img src="http://7u2i08.com1.z0.glb.clouddn.com/design-pattern/open-close-principle2.png" alt="img"></p>
<p>增加LevelStudent类代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LevelStudent</span> <span class="keyword">extends</span> <span class="title">Student</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">LevelStudent</span><span class="params">(String name, String grade)</span> </span>&#123;</div><div class="line">      <span class="keyword">super</span>(name, grade);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getGrade</span><span class="params">()</span> </span>&#123;</div><div class="line">      String level = <span class="keyword">null</span>;</div><div class="line">      <span class="keyword">int</span> grade_ = Integer.valueOf(<span class="keyword">super</span>.getGrade());</div><div class="line">      <span class="keyword">if</span> (grade_ &gt;= <span class="number">90</span>) &#123;</div><div class="line">          level = <span class="string">"优秀"</span>;</div><div class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (grade_ &gt;= <span class="number">80</span> &amp;&amp; grade_ &lt; <span class="number">90</span>) &#123;</div><div class="line">          level = <span class="string">"良好"</span>;</div><div class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (grade_ &gt;= <span class="number">70</span> &amp;&amp; grade_ &lt; <span class="number">80</span>) &#123;</div><div class="line">          level = <span class="string">"一般"</span>;</div><div class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (grade_ &gt;= <span class="number">60</span> &amp;&amp; grade_ &lt; <span class="number">70</span>) &#123;</div><div class="line">          level = <span class="string">"及格"</span>;</div><div class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (grade_ &lt; <span class="number">60</span>) &#123;</div><div class="line">          level = <span class="string">"不及格"</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> level;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a><strong>3、总结</strong></h3><p>开闭原则是对扩展开放，对修改关闭。</p>
<p>开闭原则的主旨是为了拥抱变化。</p>
<p>在六大原则中，开闭原则只是一个思想，没有具体实际操作方法。其他五大原则都是为了实现这个开闭思想的一些方法和工具。</p>
<p>想要遵守开闭原则，就需要一个设计合理的系统。可以说在做系统设计的时候就要考虑到未来的扩展和改变。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[迪米特法则]]></title>
      <url>http://zsr.github.io/2016/09/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99-%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99/</url>
      <content type="html"><![CDATA[<p>迪米特法则有很多种说法，比如：一个类应该应该对其他类尽可能了解得最少；类只与直接的朋友通信等等。但是其最终目的只有一个，就是让类间解耦。</p>
<h3 id="1、什么是迪米特法则"><a href="#1、什么是迪米特法则" class="headerlink" title="1、什么是迪米特法则"></a><strong>1、什么是迪米特法则</strong></h3><p>迪米特法则：Law Of Demeter，LoD。</p>
<p>也被称为最少知识原则，Least Knowledge Principle，LKP。</p>
<p>就是说一个对象应该对其他对象保持最少的了解。正如最少知识原则这个定义一样，一个类应该对其耦合的其他类或所调用的类知道得最少。所耦合的类内部无论如何复杂，怎么实现的我都不需要知道，我只调用你public出来的这些方法，其他都不用知道。</p>
<p>另外可以解释一下开头提到的只与直接的朋友通信，什么叫直接的朋友呢？</p>
<h3 id="2、例子"><a href="#2、例子" class="headerlink" title="2、例子"></a><strong>2、例子</strong></h3><p>光看定义可能无法完全理解它所表达的含义，以及在什么场景下才需要使用这个迪米特法则。现在就来举个例子。</p>
<p>现在市面上各种人脉书上很多都会提到“六度人脉”这个理论，这个理论说的是你与世界上任何一个人中间只隔了六个人。也就是说你想找任何一个人，无论这个人是政界要人，还是商界巨鳄，抑或是明星名人，你最多只通过六个人就可以联系到他。</p>
<p>我们暂且不论这个理论是对是错，在现实生活中我们也经常遇到这样的情况。比如你想办一件事情，但是凭借你的能力是做不到的，而你周围的朋友也无法帮你办到。但是恰好你有一个朋友认识有另外一个朋友可以办得成此事，那么你只有拜托你这位朋友中间牵线搭桥，让他的朋友帮你办好此事。</p>
<p>在这个例子中，我们就暂且定义你为A，你的朋友为B，你朋友的朋友为C好了。</p>
<ul>
<li><strong>反面教材</strong></li>
</ul>
<p>我们先来看看表达此种关系的UML类图：</p>
<p><img src="http://7u2i08.com1.z0.glb.clouddn.com/design-pattern/law-of-demeter1.png" alt="img"></p>
<p>实现代码如下：</p>
<ol>
<li>类A和类B是好朋友，能找到类B来帮忙：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">public</span> String name;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">      <span class="keyword">this</span>.name = name;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> B <span class="title">getB</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> B(name);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</div><div class="line">      B b = getB(<span class="string">"李四"</span>);</div><div class="line">      C c = b.getC(<span class="string">"王五"</span>);</div><div class="line">      c.work();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>类B和类C是好朋友，能知道类C来帮忙：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> String name;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">      <span class="keyword">this</span>.name = name;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> C <span class="title">getC</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> C(name);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>类C能够办成此事：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">public</span> String name;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">C</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">      <span class="keyword">this</span>.name = name;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</div><div class="line">      System.out.println(name + <span class="string">"把这件事做好了"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>场景类</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">      A a = <span class="keyword">new</span> A(<span class="string">"张三"</span>);</div><div class="line">      a.work();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">王五把这件事做好了</div></pre></td></tr></table></figure>
<p>上面的输出虽然是把事情成功办好了，但是仔细看业务逻辑明显是不对的。A和C又不是好朋友，为什么在类A中会出现类C呢？他们又互相不认识。</p>
<p>看到这里很多人都会明白，这种场景在实际开发中是非常常见的一种情况。对象A需要调用对象B的方法，对象B有需要调用对象C的方法……就是常见的getXXX().getXXX().getXXX()……类似于这种代码。如果你发现你的代码中也有这样的代码，那就考虑下是不是违反迪米特法则，是不是要重构一下了。</p>
<ul>
<li><strong>正确例子</strong></li>
</ul>
<p>为了符合迪米特法则，也为了让业务逻辑能够说得通，我们把上面的例子稍微修改一下。</p>
<p>UML类图如下：</p>
<p><img src="http://7u2i08.com1.z0.glb.clouddn.com/design-pattern/law-of-demeter2.png" alt="img"></p>
<p>代码如下：</p>
<ol>
<li>类A和类B是好朋友，能找到类B来帮忙：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">public</span> String name;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">      <span class="keyword">this</span>.name = name;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> B <span class="title">getB</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> B(name);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</div><div class="line">      B b = getB(<span class="string">"李四"</span>);</div><div class="line">      b.work();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>类B和类C是好朋友，能知道类C来帮忙：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> String name;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">      <span class="keyword">this</span>.name = name;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> C <span class="title">getC</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> C(name);</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</div><div class="line">      C c = getC(<span class="string">"王五"</span>);</div><div class="line">      c.work();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>类C能够办成此事：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">public</span> String name;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">C</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">      <span class="keyword">this</span>.name = name;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</div><div class="line">      System.out.println(name + <span class="string">"把这件事做好了"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>场景类</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">      A a = <span class="keyword">new</span> A(<span class="string">"张三"</span>);</div><div class="line">      a.work();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">王五把这件事做好了</div></pre></td></tr></table></figure>
<p>上面代码只是修改了下类A和B的work方法，使之符合了迪米特法则：</p>
<ul>
<li>类A只与最直接的朋友类B通信，不与类C通信；</li>
<li>类A只调用类B提供的方法即可，不用关心类B内部是如何实现的（至于B是怎么调用的C，这些A都不用关心）。</li>
</ul>
<h3 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a><strong>3、总结</strong></h3><p>迪米特法则的目的是让类之间解耦，降低耦合度。只有这样，类的可复用性才能提高。</p>
<p>但是迪米特法则也有弊端，它会产生大量的中转类或跳转类，导致系统的复杂度提高。</p>
<p>所以我们不要太死板的遵守这个迪米特法则，在系统设计的时候，在弱耦合和结构清晰之间反复权衡。尽量保证系统结构清晰，又能做到低耦合。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[接口隔离原则]]></title>
      <url>http://zsr.github.io/2016/09/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99-%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99/</url>
      <content type="html"><![CDATA[<p><strong>1、问题由来</strong></p>
<p>　　类A通过接口I依赖类B，类C通过接口I依赖类D，如果接口I对于类B和类D来说不是最小接口，则类B和类D必须去实现他们不需要的方法。</p>
<p><strong>2、什么是接口隔离原则</strong></p>
<p>　　接口隔离原则比较简单，有两种定义：</p>
<ul>
<li>Clients should not be forced to depend upon interfaces that they don’t use.（客户端不应该强行依赖它不需要的接口）</li>
<li>The dependency of one class to another one should depend on the smallest possible interface.（类间的依赖关系应该建立在最小的接口上）</li>
</ul>
<p>　　其实上述两种定义说的是同一种意思。客户端不应该依赖它不需要的接口，意思就是说客户端只要依赖它需要的接口，它需要什么接口，就提供什么接口，不提供多余的接口。“类间的依赖关系应该建立在最小的接口上”也表达这一层意思。通俗的讲就是：接口中的方法应该尽量少，不要使接口过于臃肿，不要有很多不相关的逻辑方法。</p>
<p>　　通过简单的代码还原开篇的问题，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">I</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">I</span></span>&#123;</div><div class="line"> </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"类B实现了接口I的方法1"</span>);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"类B实现了接口I的方法2"</span>);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;<span class="comment">//类B并不需要接口I的方法3功能，但是由于实现接口I，所以不得不实现方法3</span></div><div class="line">        <span class="comment">//在这里写一个空方法</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">I</span></span>&#123;</div><div class="line"> </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"类D实现了接口I的方法2"</span>);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"类D实现了接口I的方法3"</span>);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;<span class="comment">//类D并不需要接口I的方法1功能，但是由于实现接口I，所以不得不实现方法1</span></div><div class="line">        <span class="comment">//在这里写一个空方法</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//类A通过接口I依赖类B</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(I i)</span></span>&#123;</div><div class="line">        i.method1();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//类C通过接口I依赖类D</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(I i)</span></span>&#123;</div><div class="line">        i.method3();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        A a = <span class="keyword">new</span> A();</div><div class="line">        I i1 = <span class="keyword">new</span> B();</div><div class="line">        a.depend1(i1);</div><div class="line">         </div><div class="line">        C c = <span class="keyword">new</span> C();</div><div class="line">        I i2 = <span class="keyword">new</span> D();</div><div class="line">        c.depend1(i2);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">类B实现了接口I的方法<span class="number">1</span></div><div class="line">类D实现了接口I的方法<span class="number">3</span></div></pre></td></tr></table></figure>
<p>　　从以上代码可以看出，如果接口过于臃肿，不同业务逻辑的抽象方法都放在一个接口内，则会造成它的实现类必须实现自己并不需要的方法，这种设计方式显然是不妥当的。所以我们要修改上述设计方法，把接口I拆分成3个接口，使得实现类只需要实现自己需要的接口即可。只贴出修改后的接口和实现类的代码，修改代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">I1</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">I2</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">I3</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">I1</span>,<span class="title">I2</span></span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"类B实现了接口I的方法1"</span>);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"类B实现了接口I的方法2"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">I2</span>,<span class="title">I3</span></span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"类D实现了接口I的方法2"</span>);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"类D实现了接口I的方法3"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>3、与单一职责原则的区别</strong></p>
<p>　　到了这里，有些人可能觉得接口隔离原则与单一职责原则很相似，其实不然。</p>
<ul>
<li>第一，单一职责原则注重的是职责；而接口隔离原则注重对接口依赖的隔离。</li>
<li>第二，单一职责原则主要是约束类，其次才是接口和方法，它针对的是程序中的实现和细节；而接口隔离原则主要约束接口，主要针对抽象，针对程序整体框架的构建。</li>
</ul>
<p><strong>4、注意事项</strong></p>
<p>　　原则是前人经验的总结，在软件设计中具有一定的指导作用，但是不能完全照搬这些原则。对于接口隔离原则来说，接口尽量小，但是也要有限度。对接口进行细化可以提高程序设计灵活性是不争的事实，但是如果过小，则会造成接口数量过多，使设计复杂化，所以一定要适度。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[依赖倒置原则]]></title>
      <url>http://zsr.github.io/2016/09/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99-%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99/</url>
      <content type="html"><![CDATA[<p><strong>1、问题由来</strong></p>
<p>　　类A直接依赖于类B，假如要将类A修改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑。类B和C是底层模块，负责基本的原子操作。假如修改类A，将会给程序带来不必要的风险。而遵循依赖倒置原则的程序设计可以解决这一问题。</p>
<p><strong>2、什么是依赖倒置原则</strong></p>
<p>　　英文缩写DIP（Dependence Inversion Principle）。</p>
<p>　　原始定义：High level modules should not depend upon low level modules. Both should depend upon abstractions. Abstractions should not depend upon details. Details should depend upon abstractions.</p>
<p>　　翻译过来就三层含义：</p>
<ul>
<li>高层模块不应该依赖低层模块，两者都应该依赖其抽象；</li>
<li>抽象不应该依赖细节；</li>
<li>细节应该依赖抽象。</li>
</ul>
<p>　　抽象：即抽象类或接口，两者是不能够实例化的。</p>
<p>　　细节：即具体的实现类，实现接口或者继承抽象类所产生的类，两者可以通过关键字new直接被实例化。</p>
<p>　　现在我们来通过实例还原开篇问题的场景，以便更好的来理解。下面代码描述了一个简单的场景，Jim作为人有吃的方法，苹果有取得自己名字的方法，然后实现Jim去吃苹果。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//具体Jim人类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Jim</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(Apple apple)</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"Jim eat "</span> + apple.getName());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//具体苹果类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"apple"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Jim jim = <span class="keyword">new</span> Jim();</div><div class="line">        Apple apple = <span class="keyword">new</span> Apple();</div><div class="line">        jim.eat(apple);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Jim eat apple</div></pre></td></tr></table></figure>
<p>　　上面代码看起来比较简单，但其实是一个非常脆弱的设计。现在Jim可以吃苹果了，但是不能只吃苹果而不吃别的水果啊，这样下去肯定会造成营养失衡。现在想让Jim吃香蕉了（好像香蕉里含钾元素比较多，吃点比较有益），突然发现Jim是吃不了香蕉的，那怎么办呢？看来只有修改代码了啊，由于上面代码中Jim类依赖于Apple类，所以导致不得不去改动Jim类里面的代码。那如果下次Jim又要吃别的水果了呢？继续修改代码？这种处理方式显然是不可取的，频繁修改会带来很大的系统风险，改着改着可能就发现Jim不会吃水果了。</p>
<p>　　上面的代码之所以会出现上述难堪的问题，就是因为Jim类依赖于Apple类，两者是紧耦合的关系，其导致的结果就是系统的可维护性大大降低。要增加香蕉类却要去修改Jim类代码，这是不可忍受的，你改你的代码为什么要动我的啊，显然Jim不乐意了。我们常说要设计一个健壮稳定的系统，而这里只是增加了一个香蕉类，就要去修改Jim类，健壮和稳定还从何谈起。</p>
<p>　　而根据依赖倒置原则，我们可以对上述代码做些修改，提取抽象的部分。首先我们提取出两个接口：People和Fruit，都提供各自必需的抽象方法，这样以后无论是增加Jim人类，还是增加Apple、Banana等各种水果，都只需要增加自己的实现类就可以了。由于遵循依赖倒置原则，只依赖于抽象，而不依赖于细节，所以增加类无需修改其他类。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//人接口</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">People</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(Fruit fruit)</span></span>;<span class="comment">//人都有吃的方法，不然都饿死了</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//水果接口</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Fruit</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>;<span class="comment">//水果都是有名字的</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//具体Jim人类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Jim</span> <span class="keyword">implements</span> <span class="title">People</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(Fruit fruit)</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"Jim eat "</span> + fruit.getName());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//具体苹果类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">implements</span> <span class="title">Fruit</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"apple"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//具体香蕉类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Banana</span> <span class="keyword">implements</span> <span class="title">Fruit</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"banana"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        People jim = <span class="keyword">new</span> Jim();</div><div class="line">        Fruit apple = <span class="keyword">new</span> Apple();</div><div class="line">        Fruit Banana = <span class="keyword">new</span> Banana();<span class="comment">//这里符合了里氏替换原则</span></div><div class="line">        jim.eat(apple);</div><div class="line">        jim.eat(Banana);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Jim eat apple</div><div class="line">Jim eat banana</div></pre></td></tr></table></figure>
<ul>
<li>People类是复杂的业务逻辑，属于高层模块，而Fruit是原子模块，属于低层模块。People依赖于抽象的Fruit接口，这就做到了：高层模块不应该依赖低层模块，两者都应该依赖于抽象（抽象类或接口）。</li>
<li>People和Fruit接口与各自的实现类没有关系，增加实现类不会影响接口，这就做到了：抽象（抽象类或接口）不应该依赖于细节（具体实现类）。</li>
<li>Jim、Apple、Banana实现类都要去实现各自的接口所定义的抽象方法，所以是依赖于接口的。这就做到了：细节（具体实现类）应该依赖抽象。</li>
</ul>
<p><strong>3、什么是倒置</strong></p>
<p>　　到了这里，我们对依赖倒置原则的“依赖”就很好理解了，但是什么是“倒置”呢。是这样子的，刚开始按照正常人的一般思维方式，我想吃香蕉就是吃香蕉，想吃苹果就吃苹果，编程也是这样，都是按照面向实现的思维方式来设计。而现在要倒置思维，提取公共的抽象，面向接口（抽象类）编程。不再依赖于具体实现了，而是依赖于接口或抽象类，这就是依赖的思维方式“倒置”了。</p>
<p><strong>4、依赖的三种实现方式</strong></p>
<p>　　对象的依赖关系有三种方式来传递：</p>
<ul>
<li>接口方法中声明依赖对象。就是我们上面代码所展示的那样。</li>
<li>构造方法传递依赖对象。在构造函数中的需要传递的参数是抽象类或接口的方式实现。代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//具体Jim人类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Jim</span> <span class="keyword">implements</span> <span class="title">People</span></span>&#123;</div><div class="line">     </div><div class="line">    <span class="keyword">private</span> Fruit fruit;</div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Jim</span><span class="params">(Fruit fruit)</span></span>&#123;<span class="comment">//构造方法传递依赖对象</span></div><div class="line">        <span class="keyword">this</span>.fruit = fruit;</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(Fruit fruit)</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"Jim eat "</span> + <span class="keyword">this</span>.fruit.getName());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>Setter方法传递依赖对象。在我们设置的setXXX方法中的参数为抽象类或接口，来实现传递依赖对象。代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//具体Jim人类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Jim</span> <span class="keyword">implements</span> <span class="title">People</span></span>&#123;</div><div class="line">     </div><div class="line">    <span class="keyword">private</span> Fruit fruit;</div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFruit</span><span class="params">(Fruit fruit)</span></span>&#123;<span class="comment">//setter方式传递依赖对象</span></div><div class="line">        <span class="keyword">this</span>.fruit = fruit;</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"Jim eat "</span> + <span class="keyword">this</span>.fruit.getName());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>5、优点</strong></p>
<p>　　从上面的代码修改过程中，我们可以看到由于类之间松耦合的设计，面向接口编程依赖抽象而不依赖细节，所以在修改某个类的代码时，不会牵涉到其他类的修改，显著降低系统风险，提高系统健壮性。</p>
<p>　　还有一个优点是，在我们实际项目开发中，都是多人团队协作，每人负责某一模块。比如一个人负责开发People模块，一人负责开发Fruit模块，如果未采用依赖倒置原则，没有提取抽象，那么开发People模块的人必须等Fruit模块开发完成后自己才能开发，否则编译都无法通过，这就是单线程的开发。为了能够两人并行开发，设计时遵循依赖倒置原则，提取抽象，就可以大大提高开发进度。</p>
<p><strong>6、总结</strong></p>
<p>　　说到底，依赖倒置原则的核心就是面向接口编程的思想，尽量对每个实现类都提取抽象和公共接口形成接口或抽象类，依赖于抽象而不要依赖于具体实现。依赖倒置原则的本质其实就是通过抽象（抽象类或接口）使各个类或模块的实现彼此独立，不相互影响，实现模块间的松耦合。但是这个原则也是6个设计原则中最难以实现的了，如果没有实现这个原则，那么也就意味着开闭原则（对扩展开放，对修改关闭）也无法实现。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[里氏替换原则]]></title>
      <url>http://zsr.github.io/2016/09/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99-%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99/</url>
      <content type="html"><![CDATA[<p><strong>1、问题的由来</strong></p>
<p>　　我们都知道面向对象有三大特性：封装、继承、多态。所以我们在实际开发过程中，子类在继承父类后，根据多态的特性，可能是图一时方便，经常任意重写父类的方法，那么这种方式会大大增加代码出问题的几率。比如下面场景：类C实现了某项功能F1。现在需要对功能F1作修改扩展，将功能F1扩展为F，其中F由原有的功能F1和新功能F2组成。新功能F由类C的子类C1来完成，则子类C1在完成功能F的同时，有可能会导致类C的原功能F1发生故障。这时候里氏替换原则就闪亮登场了。</p>
<p><strong>2、什么是里氏替换原则</strong></p>
<p>　　前面说过的单一职责原则，从字面意思就很好理解，但是里氏替换原则就有点让人摸不着头脑。查过资料后发现原来这项原则最早是在1988年，由麻省理工学院一位姓里的女士（Liskov）提出来的。</p>
<p>　　英文缩写：LSP (Liskov Substitution Principle)。</p>
<p>　　严格的定义：如果对每一个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都换成o2时，程序P的行为没有变化，那么类型T2是类型T1的子类型。 </p>
<p>　　通俗的定义：所有引用基类的地方必须能透明地使用其子类的对象。</p>
<p>　　更通俗的定义：子类可以扩展父类的功能，但不能改变父类原有的功能。</p>
<p>代码示例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//抽象父类电脑</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">IBM</span> <span class="keyword">extends</span> <span class="title">Computer</span></span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"use IBM Computer."</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HP</span> <span class="keyword">extends</span> <span class="title">Computer</span></span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"use HP Computer."</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Computer ibm = <span class="keyword">new</span> IBM();</div><div class="line">        Computer hp = <span class="keyword">new</span> HP();<span class="comment">//引用基类的地方能透明地使用其子类的对象。</span></div><div class="line">         </div><div class="line">        ibm.use();</div><div class="line">        hp.use();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>3、四层含义</strong></p>
<p>　　里氏替换原则包含以下4层含义：</p>
<ul>
<li>子类可以实现父类的抽象方法，但是不能覆盖父类的非抽象方法。</li>
<li>子类中可以增加自己特有的方法。</li>
<li>当子类覆盖或实现父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。</li>
<li>当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。</li>
</ul>
<p>　　现在我们可以对以上四层含义逐个讲解。</p>
<p>　　<strong>子类可以实现父类的抽象方法，但是不能覆盖父类的非抽象方法</strong></p>
<p>　　在我们做系统设计时，经常会设计接口或抽象类，然后由子类来实现抽象方法，这里使用的其实就是里氏替换原则。子类可以实现父类的抽象方法很好理解，事实上，子类也必须完全实现父类的抽象方法，哪怕写一个空方法，否则会编译报错。</p>
<p>　　里氏替换原则的关键点在于不能覆盖父类的非抽象方法。父类中凡是已经实现好的方法，实际上是在设定一系列的规范和契约，虽然它不强制要求所有的子类必须遵从这些规范，但是如果子类对这些非抽象方法任意修改，就会对整个继承体系造成破坏。而里氏替换原则就是表达了这一层含义。</p>
<p>　　在面向对象的设计思想中，继承这一特性为系统的设计带来了极大的便利性，但是由之而来的也潜在着一些风险。就像开篇所提到的那一场景一样，对于那种情况最好遵循里氏替换原则，类C1继承类C时，可以添加新方法完成新增功能，尽量不要重写父类C的方法。否则可能带来难以预料的风险，比如下面一个简单的例子还原开篇的场景：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> a+b;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C1</span> <span class="keyword">extends</span> <span class="title">C</span></span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> a-b;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        C c = <span class="keyword">new</span> C1();</div><div class="line">        System.out.println(<span class="string">"2+1="</span> + c.func(<span class="number">2</span>, <span class="number">1</span>));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">2</span>+<span class="number">1</span>=<span class="number">1</span></div></pre></td></tr></table></figure>
<p>　　上面的运行结果明显是错误的。类C1继承C，后来需要增加新功能，类C1并没有新写一个方法，而是直接重写了父类C的func方法，违背里氏替换原则，引用父类的地方并不能透明的使用子类的对象，导致运行结果出错。</p>
<p>　　<strong>子类中可以增加自己特有的方法</strong></p>
<p>　　在继承父类属性和方法的同时，每个子类也都可以有自己的个性，在父类的基础上扩展自己的功能。前面其实已经提到，当功能扩展时，子类尽量不要重写父类的方法，而是另写一个方法，所以对上面的代码加以更改，使其符合里氏替换原则，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> a+b;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C1</span> <span class="keyword">extends</span> <span class="title">C</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> a-b;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        C1 c = <span class="keyword">new</span> C1();</div><div class="line">        System.out.println(<span class="string">"2-1="</span> + c.func2(<span class="number">2</span>, <span class="number">1</span>));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">2</span>-<span class="number">1</span>=<span class="number">1</span></div></pre></td></tr></table></figure>
<p>　　<strong>当子类覆盖或实现父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松</strong></p>
<p>代码示例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.HashMap;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(HashMap m)</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"执行父类..."</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">import</span> java.util.Map;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(Map m)</span></span>&#123;<span class="comment">//方法的形参比父类的更宽松</span></div><div class="line">        System.out.println(<span class="string">"执行子类..."</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">import</span> java.util.HashMap;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Father f = <span class="keyword">new</span> Son();<span class="comment">//引用基类的地方能透明地使用其子类的对象。</span></div><div class="line">        HashMap h = <span class="keyword">new</span> HashMap();</div><div class="line">        f.func(h);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">执行父类...</div></pre></td></tr></table></figure>
<p>　　注意Son类的func方法前面是不能加@Override注解的，因为否则会编译提示报错，因为这并不是重写（Override），而是重载（Overload），因为方法的输入参数不同。重写和重载的区别在<a href="http://www.cnblogs.com/hellojava/archive/2013/02/27/2935450.html" target="_blank" rel="external">Java面向对象详解</a>一文中已作解释，此处不再赘述。</p>
<p>　　<strong>当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格</strong></p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Map;</div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Map <span class="title">func</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">import</span> java.util.HashMap;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</div><div class="line">     </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> HashMap <span class="title">func</span><span class="params">()</span></span>&#123;<span class="comment">//方法的返回值比父类的更严格</span></div><div class="line">        HashMap h = <span class="keyword">new</span> HashMap();</div><div class="line">        h.put(<span class="string">"h"</span>, <span class="string">"执行子类..."</span>);</div><div class="line">        <span class="keyword">return</span> h;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Father f = <span class="keyword">new</span> Son();<span class="comment">//引用基类的地方能透明地使用其子类的对象。</span></div><div class="line">        System.out.println(f.func());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;h=执行子类...&#125;</div></pre></td></tr></table></figure>
<p><strong>4、总结</strong></p>
<p>　　继承作为面向对象三大特性之一，在给程序设计带来巨大便利的同时，也带来了一些弊端，它增加了对象之间的耦合性。因此在系统设计时，遵循里氏替换原则，尽量避免子类重写父类的方法，可以有效降低代码出错的可能性。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[单一职责原则]]></title>
      <url>http://zsr.github.io/2016/09/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99-%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99/</url>
      <content type="html"><![CDATA[<p>　　前言：据说设计模式是区别程序员与软件设计师的标准之一。其实在编程学习初期就接触过设计模式，但是都没有写过多少代码是领悟不到设计模式真正的威力和必要性的。现在自认为也实践过不少段时间了，是时候总结一下设计模式。不知谁说过没有写过十万行以上代码别谈设计模式，虽然略显夸张，但是还是很有道理的。只有自己亲身经历过一些编写设计垃圾代码，才会深刻理解设计模式真正的意义所在。设计模式都是前辈大牛们在无数次实践中总结出来的，我辈自然要站在巨人肩膀上，实行拿来主义并消化使用之。</p>
<p><strong>1、问题的由来</strong></p>
<p>　　初学者在编程的时候可能一开始会有这样的经历，使用一个类来实现很多的功能，新添加的甚至不相关的功能都放在一个类里来实现，煮成了一锅大杂烩，往往使得某个类包罗万象，无所不能。可能刚开始实现功能比较简单，这样做不会引发什么特别大的问题。但是随着项目复杂度的提升，各种不相关的实现代码耦合在一起，一旦有功能的更改或增删，修改的代码很可能会导致其他功能的正常运行。这种编程方式显然是不可取的，也就是违背了所谓的单一职责原则。</p>
<p><strong>2、什么是单一职责原则？</strong></p>
<p>　　单一职责原则的英文名称是Single Responsibility Principle，简称是SRP。SRP原则的解释是：There should never be more than one reason for a class to change。定义很简单，即不能存在多于一个导致类变更的原因。简单的说就是一个类只负责一项职责。</p>
<p>　　在软件设计中，秉承着“高内聚，低耦合”的思想，让一个类仅负责一项职责，如果一个类有多于一项的职责，那么就代表这个类耦合性变高了，这些职责耦合在了一起，这是比较脆弱的设计。因为一旦某一项职责发生了改变，需要去更改代码，那么有可能会引起其他职责改变。所谓牵一发而动全身，这显然是我们所不愿意看到的，所以我们会把这个类分拆开来，由两个类来分别维护这两个职责，这样当一个职责发生改变，需要修改时，不会影响到另一个职责。</p>
<p>　　需要说明的是单一职责原则不只是面向对象编程思想所特有的，只要是模块化的程序设计，都适用单一职责原则。</p>
<p><strong>3、关于职责</strong></p>
<p>　　看到上面所述，或许有人会说这么简单谁不知道。的确，很多程序员即使没有学过设计模式，不知道单一职责原则，在编程的时候，在设计软件时也会有意识的遵循这一原则。因为谁都不希望修改一个地方会引发另外一个地方出现问题，而避免这种问题的最好处理方式就是设计时遵循单一职责原则。但是，我认为单一职责原则的难点是在于职责范围的认定。关于职责的认定是一个仁者见仁智者见智的话题，在实际开发中也会引起程序员之间的争论。有的人认为这些功能方法的实现目的很相似，必须要放在一个类中，有的人认为方法差别很大，必须要分拆成多个类，在多个类里面来实现。</p>
<p>　　还有职责的扩散问题。软件一开发完上线后并不是一成不变的，随着社会的进步，需求的变更，软件的功能可能要做些维护更改，有时候会遇到职责扩散。所谓的职责扩散就是因为某种原因，职责R被分化为粒度更细的R1和R2。</p>
<p>　　比如类C只负责一个职责R，这是符合单一职责原则的。但是后来需要把职责R拆分为职责R1和职责R2，那么这时候是否需要死守着单一职责原则，把类C也拆开为C1和C2。接着如果R1又需要细化为R11和R12呢……</p>
<p>　　我们必须要意识到，一味的遵守单一职责原则，不停的分拆类所付出的开销是很大的。这时候就涉及到平衡的问题，平衡单一职责原则与修改造成的开销。我的观点是如果一个方法逻辑不复杂的情况下，可以修改方法实现，否则要拆分为两个方法，遵循方法级别的单一职责原则；如果一个类方法不多的情况下，可以只增加方法，而不用分拆为多个类，否则要拆分为多个类，遵循类级别的单一职责原则。</p>
<p><strong>4、遵循单一职责原则的优点</strong></p>
<ul>
<li>降低了类的复杂度。一个类只负责一项职责比负责多项职责要简单得多。</li>
<li>提高了代码的可读性。一个类简单了，可读性自然就提高了。</li>
<li>提高了系统的可维护性。代码的可读性高了，并且修改一项职责对其他职责影响降低了，可维护性自然就提高了。</li>
<li>变更引起的风险变低了。单一职责最大的优点就是修改一个功能，对其他功能的影响显著降低。</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Servlet Listener]]></title>
      <url>http://zsr.github.io/2016/09/06/Servlet-Listener/</url>
      <content type="html"><![CDATA[<h2 id="Listener-监听器"><a href="#Listener-监听器" class="headerlink" title="Listener 监听器"></a><strong>Listener 监听器</strong></h2><h3 id="1、Listener的定义与作用"><a href="#1、Listener的定义与作用" class="headerlink" title="1、Listener的定义与作用"></a><strong>1、Listener的定义与作用</strong></h3><p>监听器Listener就是在application,session,request三个对象创建、销毁或者往其中添加修改删除属性时自动执行代码的功能组件。</p>
<p>Listener是Servlet的监听器，可以监听客户端的请求，服务端的操作等。</p>
<h3 id="2、Listener的分类与使用"><a href="#2、Listener的分类与使用" class="headerlink" title="2、Listener的分类与使用"></a><strong>2、Listener的分类与使用</strong></h3><p>主要有以下三类：</p>
<h4 id="2-1、ServletContext监听"><a href="#2-1、ServletContext监听" class="headerlink" title="2.1、ServletContext监听"></a>2.1、<strong>ServletContext监听</strong></h4><ul>
<li><strong>ServletContextListener</strong>：用于对Servlet整个上下文进行监听（创建、销毁）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent sce)</span></span>;<span class="comment">//上下文初始化</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent sce)</span></span>;<span class="comment">//上下文销毁</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> ServletContext <span class="title">getServletContext</span><span class="params">()</span></span>;<span class="comment">//ServletContextEvent事件：取得一个ServletContext（application）对象</span></div></pre></td></tr></table></figure>
<ul>
<li><strong>ServletContextAttributeListener</strong>：对Servlet上下文属性的监听（增删改属性）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeAdded</span><span class="params">(ServletContextAttributeEvent scab)</span></span>;<span class="comment">//增加属性</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeRemoved</span><span class="params">(ServletContextAttributeEvent scab)</span></span>;<span class="comment">//属性删除</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeRepalced</span><span class="params">(ServletContextAttributeEvent scab)</span></span>;<span class="comment">//属性替换（第二次设置同一属性）</span></div><div class="line"></div><div class="line"><span class="comment">//ServletContextAttributeEvent事件：能取得设置属性的名称与内容</span></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>;<span class="comment">//得到属性名称</span></div><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">()</span></span>;<span class="comment">//取得属性的值</span></div></pre></td></tr></table></figure>
<h4 id="2-2、Session监听"><a href="#2-2、Session监听" class="headerlink" title="2.2、Session监听"></a>2.2、<strong>Session监听</strong></h4><p>Session属于http协议下的内容，接口位于javax.servlet.http.*包下。</p>
<ul>
<li><strong>HttpSessionListener接口</strong>：对Session的整体状态的监听。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionCreated</span><span class="params">(HttpSessionEvent se)</span></span>;<span class="comment">//session创建</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionDestroyed</span><span class="params">(HttpSessionEvent se)</span></span>;<span class="comment">//session销毁</span></div><div class="line"></div><div class="line"><span class="comment">//HttpSessionEvent事件：</span></div><div class="line"><span class="function"><span class="keyword">public</span> HttpSession <span class="title">getSession</span><span class="params">()</span></span>;<span class="comment">//取得当前操作的session</span></div></pre></td></tr></table></figure>
<ul>
<li><strong>HttpSessionAttributeListener接口</strong>：对session的属性监听。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeAdded</span><span class="params">(HttpSessionBindingEvent se)</span></span>;<span class="comment">//增加属性</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeRemoved</span><span class="params">(HttpSessionBindingEvent se)</span></span>;<span class="comment">//删除属性</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeReplaced</span><span class="params">(HttpSessionBindingEvent se)</span></span>;<span class="comment">//替换属性</span></div><div class="line"></div><div class="line"><span class="comment">//HttpSessionBindingEvent事件：</span></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>;<span class="comment">//取得属性的名称</span></div><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">()</span></span>;<span class="comment">//取得属性的值</span></div><div class="line"><span class="function"><span class="keyword">public</span> HttpSession <span class="title">getSession</span><span class="params">()</span></span>;<span class="comment">//取得当前的session</span></div></pre></td></tr></table></figure>
<p>session的销毁有两种情况：</p>
<ul>
<li>session超时，web.xml配置：</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;session-config&gt;</div><div class="line">    &lt;session-timeout&gt;120&lt;/session-timeout&gt;&lt;!--session120分钟后超时销毁--&gt;</div><div class="line">&lt;/session-config&gt;</div></pre></td></tr></table></figure>
<ul>
<li>手工使session失效</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//使session失效方法。session.invalidate();</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invalidate</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure>
<h4 id="2-3、Request监听"><a href="#2-3、Request监听" class="headerlink" title="2.3、Request监听"></a><strong>2.3、Request监听</strong></h4><ul>
<li>ServletRequestListener：用于对Request请求进行监听（创建、销毁）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestInitialized</span><span class="params">(ServletRequestEvent sre)</span></span>;<span class="comment">//request初始化</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestDestroyed</span><span class="params">(ServletRequestEvent sre)</span></span>;<span class="comment">//request销毁</span></div><div class="line"></div><div class="line"><span class="comment">//ServletRequestEvent事件：</span></div><div class="line"><span class="function"><span class="keyword">public</span> ServletRequest <span class="title">getServletRequest</span><span class="params">()</span></span>;<span class="comment">//取得一个ServletRequest对象</span></div><div class="line"><span class="function"><span class="keyword">public</span> ServletContext <span class="title">getServletContext</span><span class="params">()</span></span>;<span class="comment">//取得一个ServletContext（application）对象</span></div></pre></td></tr></table></figure>
<ul>
<li>ServletRequestAttributeListener：对Request属性的监听（增删改属性）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeAdded</span><span class="params">(ServletRequestAttributeEvent srae)</span></span>;<span class="comment">//增加属性</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeRemoved</span><span class="params">(ServletRequestAttributeEvent srae)</span></span>;<span class="comment">//属性删除</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeReplaced</span><span class="params">(ServletRequestAttributeEvent srae)</span></span>;<span class="comment">//属性替换（第二次设置同一属性）</span></div><div class="line"></div><div class="line"><span class="comment">//ServletRequestAttributeEvent事件：能取得设置属性的名称与内容</span></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>;<span class="comment">//得到属性名称</span></div><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">()</span></span>;<span class="comment">//取得属性的值</span></div></pre></td></tr></table></figure>
<h3 id="3、在web-xml中配置"><a href="#3、在web-xml中配置" class="headerlink" title="3、在web.xml中配置"></a><strong>3、在web.xml中配置</strong></h3><p>Listener配置信息必须在Filter和Servlet配置之前，Listener的初始化（ServletContentListener初始化）比Servlet和Filter都优先，而销毁比Servlet和Filter都慢。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;listener&gt;</div><div class="line">    &lt;listener-<span class="class"><span class="keyword">class</span>&gt;<span class="title">com</span>.<span class="title">listener</span>.<span class="title">class</span>&lt;/<span class="title">listener</span>-<span class="title">class</span>&gt;</span></div><div class="line">&lt;/<span class="title">listener</span>&gt;</div></pre></td></tr></table></figure>
<h3 id="4、Listener应用实例"><a href="#4、Listener应用实例" class="headerlink" title="4、Listener应用实例"></a><strong>4、Listener应用实例</strong></h3><h4 id="4-1、Spring使用ContextLoaderListener加载ApplicationContext配置信息"><a href="#4-1、Spring使用ContextLoaderListener加载ApplicationContext配置信息" class="headerlink" title="4.1、Spring使用ContextLoaderListener加载ApplicationContext配置信息"></a><strong>4.1、Spring使用ContextLoaderListener加载ApplicationContext配置信息</strong></h4><p>ContextLoaderListener的作用就是启动Web容器时，自动装配ApplicationContext的配置信息。因为它实现了ServletContextListener这个接口，在web.xml配置这个监听器，启动容器时，就会默认执行它实现的方法。</p>
<p>ContextLoaderListener如何查找ApplicationContext.xml的配置位置以及配置多个xml：如果在web.xml中不写任何参数配置信息，默认的路径是”/WEB-INF/applicationContext.xml”，在WEB-INF目录下创建的xml文件的名称必须是applicationContext.xml（在MyEclipse中把xml文件放置在src目录下）。如果是要自定义文件名可以在web.xml里加入contextConfigLocation这个context参数。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;context-param&gt;</div><div class="line">    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</div><div class="line">    &lt;param-value&gt;classpath:spring/applicationContext-*.xml&lt;/param-value&gt;&lt;!-- 采用的是通配符方式，查找WEB-INF/spring目录下xml文件。如有多个xml文件，以“,”分隔。 --&gt;</div><div class="line">&lt;/context-param&gt;</div><div class="line">&lt;listener&gt;</div><div class="line">    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;</div><div class="line">&lt;/listener&gt;</div></pre></td></tr></table></figure>
<h4 id="4-2、Spring使用Log4jConfigListener配置Log4j日志"><a href="#4-2、Spring使用Log4jConfigListener配置Log4j日志" class="headerlink" title="4.2、Spring使用Log4jConfigListener配置Log4j日志"></a><strong>4.2、Spring使用Log4jConfigListener配置Log4j日志</strong></h4><p>Spring使用Log4jConfigListener(实现了ServletContextListener接口)的好处：</p>
<ul>
<li>动态的改变记录级别和策略，不需要重启Web应用。</li>
<li>把log文件定在 /WEB-INF/logs/ 而不需要写绝对路径。因为系统把web目录的路径压入一个叫webapp.root的系统变量。这样写log文件路径时不用写绝对路径了。</li>
<li>可以把log4j.properties和其他properties一起放在/WEB-INF/ ，而不是Class-Path。</li>
<li>设置log4jRefreshInterval时间，开一条watchdog线程每隔段时间扫描一下配置文件的变化。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;context-param&gt;</div><div class="line">    &lt;param-name&gt;webAppRootKey&lt;/param-name&gt;</div><div class="line">    &lt;param-value&gt;project.root&lt;/param-value&gt;&lt;!-- 用于定位log文件输出位置在web应用根目录下，log4j配置文件中写输出位置：log4j.appender.FILE.File=$&#123;project.root&#125;/logs/project.log --&gt;</div><div class="line">&lt;/context-param&gt;</div><div class="line">&lt;context-param&gt;</div><div class="line">    &lt;param-name&gt;log4jConfigLocation&lt;/param-name&gt;</div><div class="line">    &lt;param-value&gt;classpath:log4j.properties&lt;/param-value&gt;&lt;!-- 载入log4j配置文件 --&gt;</div><div class="line">&lt;/context-param&gt;</div><div class="line">&lt;context-param&gt;</div><div class="line">    &lt;param-name&gt;log4jRefreshInterval&lt;/param-name&gt;</div><div class="line">    &lt;param-value&gt;60000&lt;/param-value&gt;&lt;!--Spring刷新Log4j配置文件的间隔60秒,单位为millisecond--&gt;</div><div class="line">&lt;/context-param&gt;</div><div class="line">&lt;listener&gt;</div><div class="line">    &lt;listener-class&gt;org.springframework.web.util.Log4jConfigListener&lt;/listener-class&gt;</div><div class="line">&lt;/listener&gt;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Servlet Filter]]></title>
      <url>http://zsr.github.io/2016/09/06/Servlet-Filter/</url>
      <content type="html"><![CDATA[<h2 id="Filter-过滤器"><a href="#Filter-过滤器" class="headerlink" title="Filter 过滤器"></a><strong>Filter 过滤器</strong></h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. <strong>简介</strong></h3><p>Filter也称之为过滤器，它是Servlet技术中最实用的技术，WEB开发人员通过Filter技术，对web服务器管理的所有web资源：例如Jsp, Servlet, 静态图片文件或静态 html 文件等进行拦截，从而实现一些特殊的功能。例如实现URL级别的权限访问控制、过滤敏感词汇、压缩响应信息等一些高级功能。</p>
<p>它主要用于对用户请求进行预处理，也可以对HttpServletResponse 进行后处理。使用Filter 的完整流程：Filter 对用户请求进行预处理，接着将请求交给Servlet 进行处理并生成响应，最后Filter 再对服务器响应进行后处理。</p>
<p>　　Filter功能：</p>
<ul>
<li>在HttpServletRequest 到达 Servlet 之前，拦截客户的 HttpServletRequest 。 根据需要检查 HttpServletRequest ，也可以修改HttpServletRequest 头和数据。</li>
<li>在HttpServletResponse 到达客户端之前，拦截HttpServletResponse 。 根据需要检查 HttpServletResponse ，也可以修改HttpServletResponse头和数据。</li>
</ul>
<h3 id="2-如何实现拦截"><a href="#2-如何实现拦截" class="headerlink" title="2. 如何实现拦截"></a>2. <strong>如何实现拦截</strong></h3><p>Filter接口中有一个doFilter方法，当开发人员编写好Filter，并配置对哪个web资源进行拦截后，WEB服务器每次在调用web资源的service方法之前，都会先调用一下filter的doFilter方法，因此，在该方法内编写代码可达到如下目的：</p>
<ul>
<li>调用目标资源之前，让一段代码执行。</li>
<li>是否调用目标资源（即是否让用户访问web资源）。</li>
</ul>
<p>web服务器在调用doFilter方法时，会传递一个filterChain对象进来，<strong>filterChain对象是filter接口中最重要的一个对象</strong>，它也提供了一个doFilter方法，开发人员可以根据需求决定是否调用此方法，调用该方法，则web服务器就会调用web资源的service方法，即web资源就会被访问，否则web资源不会被访问。 </p>
<h3 id="3-Filter开发两步走"><a href="#3-Filter开发两步走" class="headerlink" title="3. Filter开发两步走"></a>3. <strong>Filter开发两步走</strong></h3><ul>
<li><ol>
<li>编写java类实现Filter接口，并实现其doFilter方法。 </li>
</ol>
</li>
<li><ol>
<li>在 web.xml 文件中使用<filter>和<filter-mapping>元素对编写的filter类进行注册，并设置它所能拦截的资源。</filter-mapping></filter></li>
</ol>
</li>
</ul>
<p>web.xml配置各节点介绍：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;filter-name&gt;用于为过滤器指定一个名字，该元素的内容不能为空。 </div><div class="line">&lt;filter-<span class="class"><span class="keyword">class</span>&gt;元素用于指定过滤器的完整的限定类名。 </span></div><div class="line">&lt;<span class="title">init</span>-<span class="title">param</span>&gt;元素用于为过滤器指定初始化参数，它的子元素&lt;<span class="title">param</span>-<span class="title">name</span>&gt;指定参数的名字，&lt;<span class="title">param</span>-<span class="title">value</span>&gt;指定参数的值。</div><div class="line">在过滤器中，可以使用<span class="title">FilterConfig</span>接口对象来访问初始化参数。</div><div class="line"></div><div class="line">&lt;<span class="title">filter</span>-<span class="title">mapping</span>&gt;元素用于设置一个 <span class="title">Filter</span> 所负责拦截的资源。一个<span class="title">Filter</span>拦截的资源可通过两种方式来指定：<span class="title">Servlet</span> 名称和资源访问的请求路径 </div><div class="line">&lt;<span class="title">filter</span>-<span class="title">name</span>&gt;子元素用于设置<span class="title">filter</span>的注册名称。该值必须是在&lt;<span class="title">filter</span>&gt;元素中声明过的过滤器的名字 </div><div class="line">&lt;<span class="title">url</span>-<span class="title">pattern</span>&gt;设置 <span class="title">filter</span> 所拦截的请求路径(过滤器关联的<span class="title">URL</span>样式) </div><div class="line">&lt;<span class="title">servlet</span>-<span class="title">name</span>&gt;指定过滤器所拦截的<span class="title">Servlet</span>名称。 </div><div class="line">&lt;<span class="title">dispatcher</span>&gt;指定过滤器所拦截的资源被 <span class="title">Servlet</span> 容器调用的方式，可以是<span class="title">REQUEST</span>,<span class="title">INCLUDE</span>,<span class="title">FORWARD</span>和<span class="title">ERROR</span>之一，默认<span class="title">REQUEST</span>。用户可以设置多个&lt;<span class="title">dispatcher</span>&gt; 子元素用来指定 <span class="title">Filter</span> 对资源的多种调用方式进行拦截。 </div><div class="line"></div><div class="line">&lt;<span class="title">dispatcher</span>&gt; 子元素可以设置的值及其意义： </div><div class="line"><span class="title">REQUEST</span>：当用户直接访问页面时，<span class="title">Web</span>容器将会调用过滤器。如果目标资源是通过<span class="title">RequestDispatcher</span>的<span class="title">include</span>()或<span class="title">forward</span>()方法访问时，那么该过滤器就不会被调用。 </div><div class="line"><span class="title">INCLUDE</span>：如果目标资源是通过<span class="title">RequestDispatcher</span>的<span class="title">include</span>()方法访问时，那么该过滤器将被调用。除此之外，该过滤器不会被调用。 </div><div class="line"><span class="title">FORWARD</span>：如果目标资源是通过<span class="title">RequestDispatcher</span>的<span class="title">forward</span>()方法访问时，那么该过滤器将被调用，除此之外，该过滤器不会被调用。 </div><div class="line"><span class="title">ERROR</span>：如果目标资源是通过声明式异常处理机制调用时，那么该过滤器将被调用。除此之外，过滤器不会被调用。</div></pre></td></tr></table></figure>
<h3 id="4-Filter链"><a href="#4-Filter链" class="headerlink" title="4. Filter链"></a>4. <strong>Filter链</strong></h3><p>在一个web应用中，可以开发编写多个Filter，这些Filter组合起来称之为一个Filter链。</p>
<p><strong>web服务器根据Filter在web.xml文件中的注册顺序，决定先调用哪个Filter</strong>，当第一个Filter的doFilter方法被调用时，web服务器会创建一个代表Filter链的FilterChain对象传递给该方法。在doFilter方法中，开发人员如果调用了FilterChain对象的doFilter方法，则web服务器会检查FilterChain对象中是否还有filter，如果有，则调用第2个filter，如果没有，则调用目标资源。</p>
<h3 id="5-Filter的生命周期"><a href="#5-Filter的生命周期" class="headerlink" title="5. Filter的生命周期"></a>5. <strong>Filter的生命周期</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException</span>;<span class="comment">//初始化</span></div></pre></td></tr></table></figure>
<p>和编写的Servlet程序一样，Filter的创建和销毁由WEB服务器负责。 web 应用程序启动时，web 服务器将创建Filter 的实例对象，并调用其init方法，读取web.xml配置，完成对象的初始化功能，从而为后续的用户请求作好拦截的准备工作<strong>（filter对象只会创建一次，init方法也只会执行一次）</strong>。开发人员通过init方法的参数，可获得代表当前filter配置信息的FilterConfig对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException</span>;<span class="comment">//拦截请求</span></div></pre></td></tr></table></figure>
<p>这个方法完成实际的过滤操作。当客户请求访问与过滤器关联的URL的时候，Servlet过滤器将先执行doFilter方法。FilterChain参数用于访问后续过滤器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;<span class="comment">//销毁</span></div></pre></td></tr></table></figure>
<p>Filter对象创建后会驻留在内存，当web应用移除或服务器停止时才销毁。在Web容器卸载 Filter 对象之前该方法被调用。该方法在Filter的生命周期中仅执行一次，在这个方法中，可以释放过滤器使用的资源。</p>
<h3 id="6-FilterConfig接口"><a href="#6-FilterConfig接口" class="headerlink" title="6. FilterConfig接口"></a>6. <strong>FilterConfig接口</strong></h3><p>用户在配置filter时，可以使用<init-param>为filter配置一些初始化参数，当web容器实例化Filter对象，调用其init方法时，会把封装了filter初始化参数的filterConfig对象传递进来。因此开发人员在编写filter时，通过filterConfig对象的方法，就可获得以下内容：</init-param></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function">String <span class="title">getFilterName</span><span class="params">()</span></span>;<span class="comment">//得到filter的名称。 </span></div><div class="line"><span class="function">String <span class="title">getInitParameter</span><span class="params">(String name)</span></span>;<span class="comment">//返回在部署描述中指定名称的初始化参数的值。如果不存在返回null. </span></div><div class="line"><span class="function">Enumeration <span class="title">getInitParameterNames</span><span class="params">()</span></span>;<span class="comment">//返回过滤器的所有初始化参数的名字的枚举集合。 </span></div><div class="line"><span class="function"><span class="keyword">public</span> ServletContext <span class="title">getServletContext</span><span class="params">()</span></span>;<span class="comment">//返回Servlet上下文对象的引用。</span></div></pre></td></tr></table></figure>
<h3 id="7-Filter使用案例"><a href="#7-Filter使用案例" class="headerlink" title="7. Filter使用案例"></a>7. <strong>Filter使用案例</strong></h3><h4 id="1、使用Filter验证用户登录安全控制"><a href="#1、使用Filter验证用户登录安全控制" class="headerlink" title="1、使用Filter验证用户登录安全控制"></a><strong>1、使用Filter验证用户登录安全控制</strong></h4><p>先在web.xml配置</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">&lt;filter&gt;</div><div class="line">    &lt;filter-name&gt;SessionFilter&lt;/filter-name&gt;</div><div class="line">    &lt;filter-class&gt;com.action.login.SessionFilter&lt;/filter-class&gt;</div><div class="line">    &lt;init-param&gt;</div><div class="line">        &lt;param-name&gt;logonStrings&lt;/param-name&gt;&lt;!-- 对登录页面不进行过滤 --&gt;</div><div class="line">        &lt;param-value&gt;/project/index.jsp;login.do&lt;/param-value&gt;</div><div class="line">    &lt;/init-param&gt;</div><div class="line">    &lt;init-param&gt;</div><div class="line">        &lt;param-name&gt;includeStrings&lt;/param-name&gt;&lt;!-- 只对指定过滤参数后缀进行过滤 --&gt;</div><div class="line">        &lt;param-value&gt;.do;.jsp&lt;/param-value&gt;</div><div class="line">    &lt;/init-param&gt;</div><div class="line">    &lt;init-param&gt;</div><div class="line">        &lt;param-name&gt;redirectPath&lt;/param-name&gt;&lt;!-- 未通过跳转到登录界面 --&gt;</div><div class="line">        &lt;param-value&gt;/index.jsp&lt;/param-value&gt;</div><div class="line">    &lt;/init-param&gt;</div><div class="line">    &lt;init-param&gt;</div><div class="line">        &lt;param-name&gt;disabletestfilter&lt;/param-name&gt;&lt;!-- Y:过滤无效 --&gt;</div><div class="line">        &lt;param-value&gt;N&lt;/param-value&gt;</div><div class="line">    &lt;/init-param&gt;</div><div class="line">&lt;/filter&gt;</div><div class="line">&lt;filter-mapping&gt;</div><div class="line">    &lt;filter-name&gt;SessionFilter&lt;/filter-name&gt;</div><div class="line">    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</div><div class="line">&lt;/filter-mapping&gt;</div></pre></td></tr></table></figure>
<p>接着编写FilterServlet：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"></div><div class="line"><span class="keyword">import</span> javax.servlet.Filter;</div><div class="line"><span class="keyword">import</span> javax.servlet.FilterChain;</div><div class="line"><span class="keyword">import</span> javax.servlet.FilterConfig;</div><div class="line"><span class="keyword">import</span> javax.servlet.ServletException;</div><div class="line"><span class="keyword">import</span> javax.servlet.ServletRequest;</div><div class="line"><span class="keyword">import</span> javax.servlet.ServletResponse;</div><div class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</div><div class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</div><div class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponseWrapper;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> *    判断用户是否登录,未登录则退出系统</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> FilterConfig config;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.config = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isContains</span><span class="params">(String container, String[] regx)</span> </span>&#123;</div><div class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; regx.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (container.indexOf(regx[i]) != -<span class="number">1</span>) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</div><div class="line">        HttpServletRequest hrequest = (HttpServletRequest)request;</div><div class="line">        HttpServletResponseWrapper wrapper = <span class="keyword">new</span> HttpServletResponseWrapper((HttpServletResponse) response);</div><div class="line">        </div><div class="line">        String logonStrings = config.getInitParameter(<span class="string">"logonStrings"</span>);        <span class="comment">// 登录登陆页面</span></div><div class="line">        String includeStrings = config.getInitParameter(<span class="string">"includeStrings"</span>);    <span class="comment">// 过滤资源后缀参数</span></div><div class="line">        String redirectPath = hrequest.getContextPath() + config.getInitParameter(<span class="string">"redirectPath"</span>);<span class="comment">// 没有登陆转向页面</span></div><div class="line">        String disabletestfilter = config.getInitParameter(<span class="string">"disabletestfilter"</span>);<span class="comment">// 过滤器是否有效</span></div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (disabletestfilter.toUpperCase().equals(<span class="string">"Y"</span>)) &#123;    <span class="comment">// 过滤无效</span></div><div class="line">            chain.doFilter(request, response);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        String[] logonList = logonStrings.split(<span class="string">";"</span>);</div><div class="line">        String[] includeList = includeStrings.split(<span class="string">";"</span>);</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.isContains(hrequest.getRequestURI(), includeList)) &#123;<span class="comment">// 只对指定过滤参数后缀进行过滤</span></div><div class="line">            chain.doFilter(request, response);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isContains(hrequest.getRequestURI(), logonList)) &#123;<span class="comment">// 对登录页面不进行过滤</span></div><div class="line">            chain.doFilter(request, response);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        String user = ( String ) hrequest.getSession().getAttribute(<span class="string">"useronly"</span>);<span class="comment">//判断用户是否登录</span></div><div class="line">        <span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</div><div class="line">            wrapper.sendRedirect(redirectPath);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">            chain.doFilter(request, response);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</div><div class="line">        config = filterConfig;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样既可完成对用户所有请求，均要经过这个Filter进行验证用户登录。</p>
<h4 id="2、防止中文乱码过滤器"><a href="#2、防止中文乱码过滤器" class="headerlink" title="2、防止中文乱码过滤器"></a><strong>2、防止中文乱码过滤器</strong></h4><p>项目使用spring框架时。当前台JSP页面和JAVA代码中使用了不同的字符集进行编码的时候就会出现表单提交的数据或者上传/下载中文名称文件出现乱码的问题，那就可以使用这个过滤器。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;filter&gt;</div><div class="line">    &lt;filter-name&gt;Spring character encoding filter&lt;/filter-name&gt;</div><div class="line">    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;</div><div class="line">    &lt;init-param&gt;</div><div class="line">      &lt;param-name&gt;encoding&lt;/param-name&gt;&lt;!--用来指定一个具体的字符集--&gt;</div><div class="line">      &lt;param-value&gt;UTF-8&lt;/param-value&gt;</div><div class="line">    &lt;/init-param&gt;</div><div class="line">    &lt;init-param&gt;</div><div class="line">      &lt;param-name&gt;forceEncoding&lt;/param-name&gt;&lt;!--true：无论request是否指定了字符集，都是encoding；   false：如果request已指定一个字符集，则不使用encoding--&gt;</div><div class="line">      &lt;param-value&gt;false&lt;/param-value&gt;</div><div class="line">    &lt;/init-param&gt;</div><div class="line">  &lt;/filter&gt;</div><div class="line"></div><div class="line">  &lt;filter-mapping&gt;</div><div class="line">    &lt;filter-name&gt;Spring character encoding filter&lt;/filter-name&gt;</div><div class="line">    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</div><div class="line">  &lt;/filter-mapping&gt;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Storm]]></title>
      <url>http://zsr.github.io/2016/08/30/Storm/</url>
      <content type="html"><![CDATA[<h2 id="Storm-入门教程"><a href="#Storm-入门教程" class="headerlink" title="Storm 入门教程"></a>Storm 入门教程</h2><p><strong>topologies topology</strong>: 由用户编写的Storm集群中的业务处理逻辑<br><strong>deamon</strong>: 守护进程<br><strong>worker process</strong>: 工作进程<br><strong>stream</strong>: 指Storm中的数据流<br><strong>tuple</strong>: 指stream中的最小单元数据<br><strong>primitive</strong>: 基件 指storm topology 的组成部分，比如 bolt(螺栓) 和 spout(喷嘴)</p>
<h3 id="Storm-集群里的各种组件"><a href="#Storm-集群里的各种组件" class="headerlink" title="Storm 集群里的各种组件"></a>Storm 集群里的各种组件</h3><p>从表面上看一个 Storm 集群 与 一个 Hadoop 集群相似，然而在 Hadoop 上运行 “MapReduce jobs”, 在 Storm 上运行 “topologies”, 但是 “jobs” 和 “topologies” 是非常不同的– <strong>一个关键的不同是 MapReduce job 最终会结束，而一个 topology 是永远在等待消息并处理（直到你杀掉它）</strong>。</p>
<p>一个 Storm 集群中有两种节点(node)：主节点和工作节点(指Storm集群中不同角色的服务器节点)，主节点运行一个叫 “Nimbus” 的守护进程（daemon）跟 Hadoop 的 “任务跟踪器”（Jobtracker）类似。Nimbus 负责向集群中分发代码， 向各机器分配任务，以及监测故障。</p>
<p>每一个工作节点运行一个名叫 “Supervisor” 的守护进程。Supervisor 监听 Nimbus 指派到这个这台机器的任务，根据 Numbus 的指派信息来停止或启动工作进程(worker process) ，每一个 worker process 执行一个topology的子集，一个运行中的topology由跨越多个主机的多个 worker process 组成。</p>
<p><img src="http://storm.apache.org/releases/current/images/storm-cluster.png" alt="Storm cluster"></p>
<p>在 Nimbus 和 Supervisors 之间的所有协调调度通过一个 <a href="http://zookeeper.apache.org/" target="_blank" rel="external">Zookeeper</a> 集群来完成。另外，Nimbus 守护进程和 Supervisor 守护进程都是快速失败 （fail-fast）和无状态的；所有的状态保存在 Zookeeper 或者本地磁盘中。这意味着你可以 <code>kill -9</code> Nimbus 或者 Supervisors 他们会自动恢复，就像什么都没发生过一样。这种设计让 Storm 集群变的不可思议的稳定。</p>
<h3 id="Topologies"><a href="#Topologies" class="headerlink" title="Topologies"></a>Topologies</h3><p>在Strom上做实时计算， 需要创建 “Topology”，一个 topology 是一个计算过程的描述，一个 topology 中的每一个节点包含处理逻辑，节点之间的连接表明了数据在节点之间是如何传递的。</p>
<p>运行一个topology是很简单的。首先，将你所有的代码和依赖都打包到一个单独的jar包中，然后运行像下面这样的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">storm jar all-my-code.jar backtype.storm.MyTopology arg1 arg2</div></pre></td></tr></table></figure>
<p>这样会传递<code>arg1</code>和 <code>arg2</code>参数给<code>backtype.storm.MyTopology</code>类，这个类的 <code>main</code> 方法定义topology 并将它提交到 Nimbus。<code>Strom jar</code> 负责连接 Nimbus 并上传jar包.</p>
<p>由于 topology 的定义本来就是 Thrift 结构，并且 Nimbus 是一个 Thrift 服务， 所以可以使用任何编程语言来创建和提交 topology。上面的方法是使用基于 JVM 的编程语言来完成的最简单的方法，参考<a href="http://storm.apache.org/documentation/Running-topologies-on-a-production-cluster.html" target="_blank" rel="external">Running topologies on a production cluster</a> 来获取更多的关于开启和停止 topology 的方法。</p>
<a id="more"></a>
<h3 id="Streams"><a href="#Streams" class="headerlink" title="Streams"></a>Streams</h3><p>Strom 的核心抽象概念是 “流” （stream），一个 stream 相当于一个无限的元组(tuple) 序列，Storm 提供了以可靠且分布式的方法来将一个 stream 转换成一个新 stream 的基件 (primitive) ，例如：你可以将twitter流转换为热门话题流。</p>
<p>Storm提供基本的用来做流转换的的基件是 “spout” 和 “bolts” ，spout 和 bolt 提供了接口，你可以实现这些接口来处理的你自己的应用程序相关的逻辑。</p>
<p>spout 是流的来源， 例如 spout 可以从一个 <a href="http://github.com/nathanmarz/storm-kestrel" target="_blank" rel="external">Kestrel</a> 队列来读 tuple 并且发射(emit)他们形成一个流，或者 spout 可以连接到 Twitter api，来发射一个推文的流。</p>
<p>一个 bolt 消费任意数量的流， 做一些处理，然后可能会发射出新的流，复杂的流转换，例如从一个推文的流计算出一个热门话题的流，需要多个步骤，多个 bolt 。bolt可以通过运行函数（functions）来做任何事，例如过滤元组，做流聚合，做流连接，跟数据库交互等等。</p>
<p>所有的 spout 和 bolt 被打包到了一个 “topology” 中 ，topology 是你提交给 Storm 集群来执行的计算过程的最高抽象，一个 topology 类似一个流转换的图表，它现显示了哪些 bolt 是绑定(subscribe)哪些 stream 上的 。当一个 spout 或者 bolt 发射出一个 tuple 到 stream 中，它会发送 tuple 到所有绑定了这个 stream 的 bolt 中。</p>
<p><img src="http://www.dahouduan.com/2015/11/10/storm-tutorial/topology.png" alt="[spout和bolt的关系图]"></p>
<p>topology 中节点(<strong>指 topology 中的 spout 或者 bolt </strong>)之间的连接表明了 tuple 是如何在他们之间传递的。例如如果在 spout A 和 bolt B 之间有一个连接，从 spout A 到 bolt C 之间有一个连接，从 boltB 到 boltC 有一个连接，tuple 会发到 bolt B 和 bolt C 中， 所有 bolt B 的输出 tuple 也会流到 bolt C 中。</p>
<p>topology中的每一个节点都是并行执行的。在topology中，你可以指定每个节点的并行数量n，然后 Storm会启动 n 个线程在集群中运行</p>
<p>一个 topology 是永远运行的，直到你杀掉它，Storm 会自动重新分配失败的任务。另外，Storm 保证没有数据丢失， 即使主机挂掉消息丢失。</p>
<h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p>Storm 使用 tuple 做数据模型，一个 tuple 是被命名过的值列表(A tuple is a named list of values)，一个 tuple 中的字段可以是任何类型的对象。它是开箱即用的，Storm 支持所有的简单数据类型，如字符串，字节数组作为 tuple 的字段值。如果要使用另一种类型的对象，只需要为这个类型实现一个 <a href="http://storm.apache.org/documentation/Serialization.html" target="_blank" rel="external">serializer</a>.</p>
<p>topology 中的每一个节点都应该为它要发射的元组声明输出字段， 例如， 下面这个bolt声明了它发射字段为 “double” 和 “triple” 字段的元组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleAndTripleBolt</span> <span class="keyword">extends</span> <span class="title">BaseRichBolt</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> OutputCollectorBase _collector;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(Map conf, TopologyContext context, OutputCollectorBase collector)</span> </span>&#123;</div><div class="line">        _collector = collector;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Tuple input)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> val = input.getInteger(<span class="number">0</span>);        </div><div class="line">        _collector.emit(input, <span class="keyword">new</span> Values(val*<span class="number">2</span>, val*<span class="number">3</span>));</div><div class="line">        _collector.ack(input);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">declareOutputFields</span><span class="params">(OutputFieldsDeclarer declarer)</span> </span>&#123;</div><div class="line">        declarer.declare(<span class="keyword">new</span> Fields(<span class="string">"double"</span>, <span class="string">"triple"</span>));</div><div class="line">    &#125;    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>declareOutputFields</code> 方法声明了输出字段为<code>[&quot;double&quot;, &quot;triple&quot;]</code>.</p>
<h3 id="简单的topology例子"><a href="#简单的topology例子" class="headerlink" title="简单的topology例子"></a>简单的topology例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * This is a basic example of a Storm topology.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExclamationTopology</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ExclamationBolt</span> <span class="keyword">extends</span> <span class="title">BaseRichBolt</span> </span>&#123;</div><div class="line">    OutputCollector _collector;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(Map conf, TopologyContext context, OutputCollector collector)</span> </span>&#123;</div><div class="line">      _collector = collector;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Tuple tuple)</span> </span>&#123;</div><div class="line">      _collector.emit(tuple, <span class="keyword">new</span> Values(tuple.getString(<span class="number">0</span>) + <span class="string">"!!!"</span>));</div><div class="line">      _collector.ack(tuple);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">declareOutputFields</span><span class="params">(OutputFieldsDeclarer declarer)</span> </span>&#123;</div><div class="line">      declarer.declare(<span class="keyword">new</span> Fields(<span class="string">"word"</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    TopologyBuilder builder = <span class="keyword">new</span> TopologyBuilder();</div><div class="line"></div><div class="line">    builder.setSpout(<span class="string">"word"</span>, <span class="keyword">new</span> TestWordSpout(), <span class="number">10</span>);</div><div class="line">    builder.setBolt(<span class="string">"exclaim1"</span>, <span class="keyword">new</span> ExclamationBolt(), <span class="number">3</span>).shuffleGrouping(<span class="string">"word"</span>);</div><div class="line">    builder.setBolt(<span class="string">"exclaim2"</span>, <span class="keyword">new</span> ExclamationBolt(), <span class="number">2</span>).shuffleGrouping(<span class="string">"exclaim1"</span>);</div><div class="line"></div><div class="line">    Config conf = <span class="keyword">new</span> Config();</div><div class="line">    conf.setDebug(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (args != <span class="keyword">null</span> &amp;&amp; args.length &gt; <span class="number">0</span>) &#123;</div><div class="line">      conf.setNumWorkers(<span class="number">3</span>);</div><div class="line"></div><div class="line">      StormSubmitter.submitTopologyWithProgressBar(args[<span class="number">0</span>], conf, builder.createTopology());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">      LocalCluster cluster = <span class="keyword">new</span> LocalCluster();</div><div class="line">      cluster.submitTopology(<span class="string">"test"</span>, conf, builder.createTopology());</div><div class="line">      Utils.sleep(<span class="number">10000</span>);</div><div class="line">      cluster.killTopology(<span class="string">"test"</span>);</div><div class="line">      cluster.shutdown();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个 topology 包含一个 spout 和两个 bolt，spout 发送单词，每一个 bolt 附加 “!!!” 到它的输入数据中。这些节点排练成一条线：spout 先发射 tuple 到第一个 bolt，然后第一个 bolt 发送到第二个 bolt。如果 spout 发送 [“bob”] 和 [“john”] 元组，然后第二个bolt会发送 [“bob!!!!!!”] 和 [“john!!!!!!”] 元组.</p>
<p>代码中使用 <code>setSpout</code> 和 <code>setBolt</code> 方法来定义节点.这些方法需要传入: 一个用户指定的id，一个包含处理逻辑的对象，以及你希望这个节点运行的并行数量。在这个例子中，spout 被指定了id “words”, bolt 被指定了id “exclaim1” 和 “exclaim2”.</p>
<p><strong>传入的 Spout 对象实现了 <a href="http://storm.apache.org/javadoc/apidocs/backtype/storm/topology/IRichSpout.html" target="_blank" rel="external">IRichSpout</a> 接口并包含业务逻辑, Bolt 对象实现了 <a href="http://storm.apache.org/javadoc/apidocs/backtype/storm/topology/IRichBolt.html" target="_blank" rel="external">IRichBolt</a> 接口并包含业务逻辑</strong>.</p>
<p>最后一个参数，设置这个节点的并行数量是几，这个参数是可选的，它表明有多少线程应该在集群中运行该组件 ，如果你忽略了它，Storm 会给这个节点（<strong>即 spout 或者 bolt</strong>）只分配一个线程。</p>
<p><code>setBolt</code> 返回一个 <a href="http://storm.apache.org/javadoc/apidocs/backtype/storm/topology/InputDeclarer.html" target="_blank" rel="external">InputDeclarer</a> 对象用来给 bolt 定义输入。这 “exclaim1”组件 声明了它要想读入所有 “words” 组件的发射的打乱分组过的所有 tuple. “exclaim2” 组件声明了它要读入所有 “exclaim1” 发射的打乱分组过的 tuple，”打乱分组”（shuffile group）意味着 tuple 必须从输入中随机分发到 bolt 的任务中。有许多在组件之间将数据分组的方法，打乱只是其中一种。</p>
<p>如果你希望 “exclaim2” 组件，既读取 “words” 又读取 “exclaim1” 发射的 tuple ， 你可以像如下这样实现 “excliam2” ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">builder.setBolt(<span class="string">"exclaim2"</span>, <span class="keyword">new</span> ExclamationBolt(), <span class="number">5</span>)</div><div class="line">            .shuffleGrouping(<span class="string">"words"</span>)</div><div class="line">            .shuffleGrouping(<span class="string">"exclaim1"</span>);</div></pre></td></tr></table></figure>
<p><strong>可以给 bolt 链式的指定多个数据源。</strong></p>
<p>Spouts 负责发射新的消息到 topology中。 在这个 topology 中 <code>TestWordSpouts</code>方法 从 [“nathan”, “mike”, “jackson”, “golda”, “bertels”] 中每 100毫秒 发射一个随机的字符， TestWordSpout 中 <code>nextTuple()</code>方法 的实现是这样的:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextTuple</span><span class="params">()</span> </span>&#123;</div><div class="line">    Utils.sleep(<span class="number">100</span>);</div><div class="line">    <span class="keyword">final</span> String[] words = <span class="keyword">new</span> String[] &#123;<span class="string">"nathan"</span>, <span class="string">"mike"</span>, <span class="string">"jackson"</span>, <span class="string">"golda"</span>, <span class="string">"bertels"</span>&#125;;</div><div class="line">    <span class="keyword">final</span> Random rand = <span class="keyword">new</span> Random();</div><div class="line">    <span class="keyword">final</span> String word = words[rand.nextInt(words.length)];</div><div class="line">    _collector.emit(<span class="keyword">new</span> Values(word));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ExclamationBolt类的 <code>prepare</code> 方法给 bolt 提供了一个 <code>OutputCollector</code> 对象用来从这个 bolt 中发射 tuple 。 在这个 bolt 中的任何位置都可以发射 tuples —在 <code>prepare</code>, <code>execute</code>, <code>cleanup</code> 方法中， 甚至在异步的其他线程中。</p>
<ul>
<li><p><code>prepare</code> 方法仅仅保持一个 <code>OutputCollector</code> 对象实例以便在后面<code>execute</code> 方法中调用。</p>
</li>
<li><p><code>execute</code> 方法从输入中接收一个 tuple。<code>ExclamationBolt</code> 从元组中取到第一个字段，然后在后面附加 “!!!” 。 如果你实现的 bolt 订阅了多个输入源， 你可以使用<code>Tuple#getSourceComponent</code> 方法查到当前的 tuple 是来自哪个组件.</p>
<p><code>execute</code> 方法里还可以做一些其他操作，即将输入的 tuple 作为 emit 的第一个参数传入，这样这个 tuple 会被确认。这是 Storm 可靠api一部分它能保证，不会丢失数据，这些在本教程后面的章节中还会阐述。</p>
</li>
<li><p><code>cleanup</code> 方法会在 Bolt 停止时被调用，用来关闭清理所有打开的资源。不能保证这个方法一定会在集群中被调用，如果正在运行的机器发生了爆炸（作者在搞笑），这样就没办法调用这个方法了。<code>cleanup</code>方法其实是专门为你在<a href="http://storm.apache.org/documentation/Local-mode.html" target="_blank" rel="external">本地模式</a>(将Storm集群在一个进程中模拟出来)下运行 topology ，你希望运行和杀掉 topology 而不必担心资源泄露。</p>
</li>
</ul>
<p><code>declareOutputFields</code> 方法声明 <code>ExclamationBolt</code> 发射包含一个 word 字段的 tuple</p>
<p><code>getComponentConfiguration</code> 方法允许你配置影响这个 bolt 如何运行的各种参数，关于配置的更多内容 <a href="http://storm.apache.org/documentation/Configuration.html" target="_blank" rel="external">Configuration</a>.</p>
<p>像<code>cleanup</code> 和 <code>getComponentConfiguration</code> 方法通常并不是必须的， 你可以通过继承一个提供了默认实现的基类来更简洁的定义 bolt。 通过继承 <code>BaseRichBolt</code>类 ，<code>ExclamationBolt</code>可以被实现的更简洁，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ExclamationBolt</span> <span class="keyword">extends</span> <span class="title">BaseRichBolt</span> </span>&#123;</div><div class="line">    OutputCollector _collector;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(Map conf, TopologyContext context, OutputCollector collector)</span> </span>&#123;</div><div class="line">        _collector = collector;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Tuple tuple)</span> </span>&#123;</div><div class="line">        _collector.emit(tuple, <span class="keyword">new</span> Values(tuple.getString(<span class="number">0</span>) + <span class="string">"!!!"</span>));</div><div class="line">        _collector.ack(tuple);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">declareOutputFields</span><span class="params">(OutputFieldsDeclarer declarer)</span> </span>&#123;</div><div class="line">        declarer.declare(<span class="keyword">new</span> Fields(<span class="string">"word"</span>));</div><div class="line">    &#125;    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="在本地模式下运行-ExclamationTopology"><a href="#在本地模式下运行-ExclamationTopology" class="headerlink" title="在本地模式下运行 ExclamationTopology"></a>在本地模式下运行 ExclamationTopology</h3><p>Storm 有两种运行模式：<code>本地模式</code>和<code>分布式模式</code>。</p>
<ul>
<li>在本地模式中，Storm 完全在一个进程中运行，用线程来模拟各个工作节点。本地模式对与开发和测试topology是非常有用的，当你运行 storm-starter 中的 topology时，它会运行在本地模式下，可以看到每一个组件发射的消息.</li>
<li>在分布式模式下，Storm 运行在一组机器上，当你提交一个 topology 到 master上，就会同时提交所有必要的代码来运行这个 topology，master会负责分发你的代码，并分配工作进程来运行你的 topology，如果工作进程挂掉了，master会在某处重新分配他们.</li>
</ul>
<p>下面是在本地模式运行 <code>ExclamationTopology</code> 的代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Config conf = <span class="keyword">new</span> Config();</div><div class="line">conf.setDebug(<span class="keyword">true</span>);</div><div class="line">conf.setNumWorkers(<span class="number">2</span>);</div><div class="line"></div><div class="line">LocalCluster cluster = <span class="keyword">new</span> LocalCluster();</div><div class="line">cluster.submitTopology(<span class="string">"test"</span>, conf, builder.createTopology());</div><div class="line">Utils.sleep(<span class="number">10000</span>);</div><div class="line">cluster.killTopology(<span class="string">"test"</span>);</div><div class="line">cluster.shutdown();</div></pre></td></tr></table></figure>
<p>这段代码通过创建 <code>LocalCluster</code> 对象定义了一个进程内的集群。提交 topology 到虚拟集群和提交到分布式集群是一样的，通过调用 <code>submitTopology</code> 来向 <code>LocalCluster</code> 中提交 topology，它接受三个参数: topology的名字，topology的配置，topology本身。</p>
<p>名字是用来识别这个 topology，以便日后杀掉它。。topology会一直运行直到你杀掉它。</p>
<p>配置是用来调优运行 topology 的各个方面，下面是两个常见的配置：</p>
<ol>
<li>TOPOLOGY_WORKERS (用 <code>setNumWorkers</code>来设置) 指定你将在集群分配几个进程来运行这个这个topology，topology中的每一个组件会被当做多个线程来运行。一个组件被分配线程的数量通过 <code>setBolt</code> 和 <code>setSpout</code> 方法来配置，这些线程存在于工作进程中。每个工作进程包含一些组件中的一些线程，例如，你分配了 300 个线程给所有的组件，在配置中设置了50个工作进程，那么每个工作进程会运行6个线程，每一个线程可能属于不同的组件。通过调整每个元件的并行度和运行这些线程的工作进程的数量来对 storm 的并行性能调优。</li>
<li>TOPOLOGY_DEBUG （通过 setDebug 设置）,当被设为 true 时，storm 将记录元件发射的每个消息，在本地模式测试topology时这是很有用的，但是在线上模式运行时，你更愿意将它关闭</li>
</ol>
<h3 id="流分组-Stream-groupings"><a href="#流分组-Stream-groupings" class="headerlink" title="流分组 Stream groupings"></a>流分组 Stream groupings</h3><p>流分组让 topology 知道在组件之间如何发送 tuple，记住 spouts 和 bolts 是被当成很多 tasks （<strong>这里的task 就是setBolt和 setSpout 中产生的工作线程，如果设置了数量，就是线程组或者任务组即 set of tasks</strong>）并行运行在整个集群中的，如果想看看 topology 是如何在 task 层级运行的，如下图:</p>
<p><img src="http://storm.apache.org/releases/current/images/topology-tasks.png" alt="Tasks in a topology"></p>
<p>当一个运行 Bolt A 的 task 发射了一个 tuple 到 Bolt B，那么它应该发射到哪个 task（当然是运行Bolt B 的task） 呢？</p>
<p>流分组 （Stream grouping）答了这个问题，它告诉 Storm 如何在 set of task（任务组）之间发送 tuple，在我们深入不同种类的流分组以前，让我们看看 <a href="http://github.com/apache/storm/blob/master/examples/storm-starter" target="_blank" rel="external">storm-start</a> 里的另一个 topology ，<a href="https://github.com/apache/storm/blob/master/examples/storm-starter/src/jvm/storm/starter/WordCountTopology.java" target="_blank" rel="external">WordCountTopology</a>从一个 spout 中读取句子并且从 <code>WordCountBolt</code> 中获取某个单词出现的次数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">TopologyBuilder builder = <span class="keyword">new</span> TopologyBuilder();</div><div class="line"></div><div class="line">builder.setSpout(<span class="string">"sentences"</span>, <span class="keyword">new</span> RandomSentenceSpout(), <span class="number">5</span>);        </div><div class="line">builder.setBolt(<span class="string">"split"</span>, <span class="keyword">new</span> SplitSentence(), <span class="number">8</span>)</div><div class="line">        .shuffleGrouping(<span class="string">"sentences"</span>);</div><div class="line">builder.setBolt(<span class="string">"count"</span>, <span class="keyword">new</span> WordCount(), <span class="number">12</span>)</div><div class="line">        .fieldsGrouping(<span class="string">"split"</span>, <span class="keyword">new</span> Fields(<span class="string">"word"</span>));</div></pre></td></tr></table></figure>
<p><code>SplitSentence</code> 把它接收到的每一个句子中的每一个单词当做 tuple 发送出去，<code>WordCount</code>在内存中维护了一个单词和数量的映射关系，每次 <code>WordCount</code> 接收到一个单词，它就更新单词的数量，然后发送新的单词数量。</p>
<p>还有一些不同种类的流分组:</p>
<ul>
<li><p>基本的分组类型叫做 “乱序分组(shuffle grouping)” ，它将使 tuple 被随机发个一个 task，<code>WordCountTopology</code>中 使用了乱序分组来从 <code>RandomSentenceSpout</code> 向<code>SplitSentence</code> 发送 tuple， 这样所有的处理任务就能够被平均的分配到所有运行<code>SplitSentence</code> Bolt的 task 上。</p>
</li>
<li><p>一个更有趣的分组类型是 <code>字段分组(fields grouping)</code> ，<code>SplitSentence</code> 和 <code>WordCount</code>之间使用了一个字段分组，<code>WordCount</code>能够运作的一个极为重要的要求是相同的单词必须被发到同一个 task中，否则会有一个以上的 task 会接收到相同的单词，然后他们会发射错误的计数。字段分组使我们可以用字段将一个流分组，这使得相同字段的内容总是被分到同一个task中。由于<code>WordCount</code> 在 <code>word</code> 字段上使用字段分组订阅了 <code>SplitSentence</code>‘s 的输出流，这样相同的单词总是会进入到相同的task.</p>
<p>字段分组是流连接和流聚合以及许多其他用力的基本实现，究其原理，字段分组是通过 mod hashing（哈希的一种） 来实现的.</p>
</li>
</ul>
<p>还有一些其他类型的分组，可以在<a href="http://storm.apache.org/documentation/Concepts.html" target="_blank" rel="external">概念</a>里查看更多。</p>
<h3 id="保证消息处理的可靠性"><a href="#保证消息处理的可靠性" class="headerlink" title="保证消息处理的可靠性"></a>保证消息处理的可靠性</h3><p>storm保证从spout发出的每个tuple都会被完全处理。</p>
<p><code>Storm</code> 提供了几个不同层次的保证消息处理的方式,例如最佳努力,至少一次,只有一次三种方式。下文基于“至少一次”方式.</p>
<p><strong>消息被”完整处理”的含义?</strong></p>
<p>从spout发射的一个tuple可以引起其它成千上万个tuple因它而产生 。举例：统计每个单词出现次数的Topology.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">TopologyBuilder builder = <span class="keyword">new</span> TopologyBuilder();</div><div class="line">builder.setSpout(<span class="string">"sentences"</span>, <span class="keyword">new</span> KestrelSpout(<span class="string">"kestrel.backtype.com"</span>,</div><div class="line">                                               <span class="number">22133</span>,</div><div class="line">                                               <span class="string">"sentence_queue"</span>,</div><div class="line">                                               <span class="keyword">new</span> StringScheme()));</div><div class="line">builder.setBolt(<span class="string">"split"</span>, <span class="keyword">new</span> SplitSentence(), <span class="number">10</span>)</div><div class="line">        .shuffleGrouping(<span class="string">"sentences"</span>);</div><div class="line">builder.setBolt(<span class="string">"count"</span>, <span class="keyword">new</span> WordCount(), <span class="number">20</span>)</div><div class="line">        .fieldsGrouping(<span class="string">"split"</span>, <span class="keyword">new</span> Fields(<span class="string">"word"</span>));</div></pre></td></tr></table></figure>
<p>这个topology从Kestrel队列中读取句子，并将句子分割成一个个的单词，最后发送的是各个单词出现的次数。从spout发出的tuple将会在下游触发生成更多的tuple：句子中的每个单词会形成一个tuple以及后面每个单词的计数会形成新的tuple。以下是tuple构成的消息树或者说tuple树:</p>
<p><img src="http://storm.apache.org/releases/current/images/tuple_tree.png" alt="Tuple tree"></p>
<p>当这棵tuple树被完全使用并且这棵树中的所有的消息都被完全的处理过了，storm就认为spout发出的tuple（这个tuple是树中的根节点）被”完全处理”了。而当这棵树中的所有消息在特定的时间内没有被完全的处理，storm就认为该tuple就是未被完全处理的。其中，处理的时限可以通过<a href="http://storm.apache.org/javadoc/apidocs/backtype/storm/Config.html#TOPOLOGY_MESSAGE_TIMEOUT_SECS" target="_blank" rel="external">Config.TOPOLOGY_MESSAGE_TIMEOUT_SECS</a> 进行设置，默认是30秒。</p>
<p><strong>消息被完全处理或者未被完全处理分别会发生什么？</strong></p>
<p>为了理解这个问题，我们首先来看看spout发出的tuple的生命周期。这里给出了spouts需要实现的接口作为参考：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ISpout</span> <span class="keyword">extends</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">(Map conf, TopologyContext context, SpoutOutputCollector collector)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextTuple</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ack</span><span class="params">(Object msgId)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fail</span><span class="params">(Object msgId)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先，Storm通过调用Spout中的nextTuple方法来请求一个tuple。Spout使用open方法中提供的SpoutOutputCollector的实例来向它的输出流中发送tuple（collector.emit()）。当发送一个tuple时，Spout会提供一个”message id”，后面将会用这个”message id”来标识相应的tuple。例如:KestrelSpout从kestrel队列中读取一条消息并以Kestrel中消息的id作为tuple的”message id”来发送该tuple。通过SpoutOutputCollector的实例_collector来发送方式如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">_collector.emit(<span class="keyword">new</span> Values(<span class="string">"field1"</span>, <span class="string">"field2"</span>, <span class="number">3</span>) , msgId);</div></pre></td></tr></table></figure>
<p>接下来，该tuple被发送至消费bolts，Storm来跟踪以该tuple为根节点生成的消息树。如果Storm检测到一个tuple被”完全处理”了，Storm将会根据message id调用起始时<code>Spout</code> task（这里设计到并发，一个spout可能产生多个spout task，各个task都会产生tuple）中的<code>ack</code>方法。同样的，如果tuple在规定时间内未被”完全处理”,Storm就会调用fail方法。调用ack或者fail在生成该tuple的Spout task上进行的。因此，一个Spout在执行时产生了多个tasks，一个tuple的ack或fail不会又非生成该tuple的task来完成。</p>
<p>用KestrelSpout来看看Spout在消息处理保证机制中做了些什么。当KestrelSpout从Kestrel队列中获取一条消息时，它会”opens”(打开)这个消息。这意味着该消息还并没有从队列中提取出来，而是处于一种”pending”（待处理）的状态，等待确定这条消息被确实的处理完成。处于”pending”状态的消息不会被发送到该队列的其他消费者中。另外，如果客户端断开了连接，所有”pending”状态下的消息都将回归队列中的正常状态。当一个消息被”opend”(打开)，Kestrel将会提供该消息的数据以及该消息的唯一的id给相应的客户端。KestrelSpout就使用这个id作为tuple的”message id”。当KestrelSpout中的ack或者fail被调用时，KestrelSpout将会发送ack或者fail消息并附上message id给Kestrel，以便Kestrel将该消息从队列中踢出或者让该消息回归正常状态等待下次”open”。</p>
<p><strong>Storm的可靠性API</strong></p>
<p>作为一个用户，我们使用storm的可靠性能力时需要做两件事。1.当我们在消息树中建立了新的连接的时候，我们需要告诉Storm。2.当我们处理完了单个的tuple（这里tuple是整个过程中产生的tuple不单单只根节点的那个tuple）也需要告诉Storm。通过以上两点，Storm就可以检测tuple树是否处理完成，并调用相应的ack或者fail。Storm API提供了简洁的方案来完成上述任务。</p>
<p>确定tuple树中的一个连接叫做”anchoring”（锚定）。Anchoring将在发送一个新tuple的时候就完成。我们看下面这个bolt例子。这个bolt将一个包含一个句子的tuple分割成多个单词tuple：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SplitSentence</span> <span class="keyword">extends</span> <span class="title">BaseRichBolt</span> </span>&#123;</div><div class="line">        OutputCollector _collector;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(Map conf, TopologyContext context, OutputCollector collector)</span> </span>&#123;</div><div class="line">            _collector = collector;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Tuple tuple)</span> </span>&#123;</div><div class="line">            String sentence = tuple.getString(<span class="number">0</span>);</div><div class="line">            <span class="keyword">for</span>(String word: sentence.split(<span class="string">" "</span>)) &#123;</div><div class="line">                _collector.emit(tuple, <span class="keyword">new</span> Values(word));</div><div class="line">            &#125;</div><div class="line">            _collector.ack(tuple);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">declareOutputFields</span><span class="params">(OutputFieldsDeclarer declarer)</span> </span>&#123;</div><div class="line">            declarer.declare(<span class="keyword">new</span> Fields(<span class="string">"word"</span>));</div><div class="line">        &#125;        </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>每个单词tuple通过<code>_collector.emit(tuple,new Values(word))</code>中的第一个参数（本例中的tuple）来anchored（锚定）。因为单词tuple已经被锚定了，如果下游的tuple出现处理失败的情况，处于树根节点的spout tuple就会进行重发。如果我们以<code>_collector.emit(new Values(word))</code>的方式发送tuple，显然这种方式发送的tuple是没有被锚定的。如果下游处理失败，也不会重发。我们可以根据具体的容错需要来选择相应的方式。一个输出的tuple可以被多个输入tuple锚定。当需要进行流连接（join）或者汇聚（aggregation）时，这个功能非常有用。一个多锚定的（multi-anchored）tuple处理失败将可能会引起spouts的多个tuple的重发。通过以下方式可以完成多锚定（multi-anchored）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">List&lt;Tuple&gt; anchors = <span class="keyword">new</span> ArrayList&lt;Tuple&gt;();</div><div class="line">anchors.add(tuple1);</div><div class="line">anchors.add(tuple2);</div><div class="line">_collector.emit(anchors, <span class="keyword">new</span> Values(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</div></pre></td></tr></table></figure>
<p>多锚定将输出的tuple加入了一个多tuple树（其实已然不是一个树结构，而是一个有向无环图DAG，其实树就是一个特殊的DAG嘛）可以称为tuple-DAG：</p>
<p><img src="http://storm.apache.org/releases/current/images/tuple-dag.png" alt="Tuple DAG"></p>
<p><code>Anchoring</code>使得我们能够使tuple树具体化。如何来确定单个tuple的处理是否完成: 这是通过OutputCollector中的ack以及fail来实现的。例如，上面的SplitSentence例子，它在发送完所有的单词tuples后进行了ack。</p>
<p>可以通过OutputCollector中的fail方法来迅速通知位于根节点的spout tuple。这样，我们就无需等到超出时限才发送fail消息。</p>
<p>每个tuple都必须进行ack或者fail。Storm使用内存来跟踪每个tuple，所以如果不对每个tuple进行ack或者fail，负责跟踪tuple的任务将一直运行，直到内存用光。</p>
<p>大多数bolts都以种通用的模式来读取输入的tuple，发送tuple，以及在execute方法的结尾处来ack这个tuple。这种的bolts被归到了过滤器或者说简单函数这一类。Storm中有一个BasicBolt接口包含了这一模式。将SplitSentence改成BasicBolt的形式:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SplitSentence</span> <span class="keyword">extends</span> <span class="title">BaseBasicBolt</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Tuple tuple, BasicOutputCollector collector)</span> </span>&#123;</div><div class="line">            String sentence = tuple.getString(<span class="number">0</span>);</div><div class="line">            <span class="keyword">for</span>(String word: sentence.split(<span class="string">" "</span>)) &#123;</div><div class="line">                collector.emit(<span class="keyword">new</span> Values(word));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">declareOutputFields</span><span class="params">(OutputFieldsDeclarer declarer)</span> </span>&#123;</div><div class="line">            declarer.declare(<span class="keyword">new</span> Fields(<span class="string">"word"</span>));</div><div class="line">        &#125;        </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这个实现比以前的更加简洁,但是功能上是一样的。Tuples在BasicOutputCollector中是自动与输入的tuple锚定的（不需要我们填tuple参数）。并且当execute方法完成时输入tuple也是自动的进行ack。相反，bolts进行aggregations（汇聚）或者joins（连接）时，将会推迟ack直到在批量的tuples的基础上计算出了结果之后。Aggregations以及joins将会对他们的output tuples进行多锚定,这些东西超出IBasicBolt的简单模式。</p>
<p><strong>Storm如何有效的实现可靠性</strong></p>
<p>在Storm topology中有一系列特殊的”acker”它们会为每个spout tuple追踪DAG中的tuples。当一个acker检测到一个DAG完成了，它将会发送一条消息给生成了该spout tuple的task来进行确认。（这里，大家肯定会有疑惑，每次tuple发送时都进行了ack，为什么还有acker。answer：每次的ack是告知acker本次的处理完了。而acker要进行汇总告诉根节点task所有的tuple都处理完成了）。可以通过<a href="http://storm.apache.org/javadoc/apidocs/backtype/storm/Config.html#TOPOLOGY_ACKER_EXECUTORS" target="_blank" rel="external">Config.TOPOLOGY_ACKER_EXECUTORS</a>来设置acker的个数。Storm默认acker的个数与worker的个数一样。–当我们需要处理大量的消息时，我们可能就需要提高这个acker的量了。</p>
<p>理解Storm的可靠性的最好方式是研究tuples以及tuple DAG的生命周期。当tuple在topology中生成时，无论是spout还是bolt生成的tuple，都将被赋予一个64bit的随机id。这些id就被ackers用来跟踪这个tuple DAG中的每个spout tuple。</p>
<p>每个tuple都知道所有与其位于同个DAG的spout tuples的id。当我们发送一个新的tuple时，spout tuple的id将会通过锚定这个方式拷贝到新的tuple中。当该tuple进行ack，它会发送一条消息给相应的acker task告诉其tupel DAG的变化情况。白话一点：该tuple说：我已经完成了该id号的spout tuple来的计算，然后这些是锚定了我的新的tuple。</p>
<p>举个例子，如果tuples D与E是在C的基础上生成的，那么下面就是当C ack以后，tuple DAG的变化（打红叉说明就是ack了）：</p>
<p><img src="http://img.blog.csdn.net/20151012163509158" alt="img"></p>
<p>由于C被ack时，D与E又被加入到了DAG中，故这个DAG还没有被完全处理。</p>
<p>这里有些细节需要说明，上面已经提过，你可以自己设置任意数量的acker tasks。这就会导致出现问题：当一个tuple被ack了，它如何知道它该向哪个acker task发消息？</p>
<p>Storm使用mod hashing的方式将spout tuple id映射给相应的acker task。因为每一个tuple知道它所有的spout的tuple id， 所以它自然可以算出要通知哪个acker（这里注意因为一个tuple可能存在于多个tuple树）。</p>
<p>另一个细节是acker task如何知道向哪个spout task发送消息？</p>
<p>当spout task发出一个新的tuple时，它会简单的发一个消息给一个合适的acker,并且告诉acker它自己的id(taskid),这样storm就有了taskid-tupleid的对应关系。因此acker task可以根据spout task id来确定当tuple完成后向相应的spout task发消息。</p>
<p>Acker tasks并不是显式的追踪tuple DAG（这会使得单单运行acker task就耗光内存），而是acker用了一种不同的方式，使得对于每个spout tuple所需要的内存量是恒定的（20 bytes)。这种追踪算法是Storm的关键，也是storm的一个主要突破。</p>
<p>acker task存储了一个spout tuple id到一个值对（value1，value2）的映射 。value1是spout task id用来在完成处理tuple的时候发送消息用的。value2是一个64bit的数字叫做”ack val”（ack变量）:ack val是整个tuple树的状态的一个表示，不管这棵树多大, 它只是简单地把这棵树上的所有创建的tupleid/ack的tupleid一起异或(XOR)。。</p>
<p>当acker task发现ack变量的值为0时，那就说明tuple树已经完全处理了。因为tuple id是随机的64bit数，所以如果因为不同的数异或产生0的概率是特别小的。经数学计算，每秒10k次的ack，也需要50000000年才会出现一次上述错误情况。而且即使出现了上述错误，也仅仅是造成了一次数据的丢失，如果碰巧这次处理是失败的。</p>
<p>现在我们来看看，在各种失败的情况下，storm如何避免数据丢失:</p>
<ul>
<li>由于task died，tuple未进行ack:这种情况下，处理将超时，spout tuple将重发</li>
<li>Acker task dies:这种情况下所有该Acker task跟踪下的spout tuple都将因为超时而重发</li>
<li>Spout task dies:这种情况下Spout的源头将进行消息重发，例如：当与消费客户端失去连接后，Kestrel和RabbitMQ将会把所有的”待处理”消息回复正常。</li>
</ul>
<p>你可以看到，Storm的可靠性机制是完全分布式、可扩展以及容错的。</p>
<p>调整storm的可靠性</p>
<p>Acker tasks是轻量级的，所以我们在topology并不需要部署太多。我们可以通过Storm UI来监控他的性能。如果流量不太对，我们可能就需要加大acker task的量了。</p>
<p>如果可靠性对你来说不太重要，我们就可以不追踪tuple了。这将使消息的传输量下降一半。另外，下游的tuple也不需要拷贝spout tuple id，这也将减少带宽使用。</p>
<p>我们有三种方式来移除可靠性。第一种是设置Config.TOPOLOGY_ACKERS为0 ，这种情况下，Storm将会在spout发送了tuple后就调用spout的ack方法。因此DAG就不会被追踪。</p>
<p>第二种方式是将消息的message id置为null。通过在SpoutOutputcollector.emit参数中设置message id为null，就可以关闭对当前spout tuple的追踪。</p>
<p>第三种方式就是之前提到过的，我们可以不对下游的tuple进行锚定（anchor）。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[zookeeper 分布式锁]]></title>
      <url>http://zsr.github.io/2016/08/29/zookeeper-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
      <content type="html"><![CDATA[<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>分布式的锁全局同步， 这意味着任何一个时间点不会有两个客户端都拥有相同的锁。</p>
<h3 id="可重入锁Shared-Reentrant-Lock"><a href="#可重入锁Shared-Reentrant-Lock" class="headerlink" title="可重入锁Shared Reentrant Lock"></a>可重入锁Shared Reentrant Lock</h3><p>Shared意味着锁是全局可见的， 客户端都可以请求锁。 Reentrant和JDK的ReentrantLock类似， 意味着同一个客户端在拥有锁的同时，可以多次获取，不会被阻塞。它是由类<code>InterProcessMutex</code>来实现。<br>它的构造函数为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">InterProcessMutex</span><span class="params">(CuratorFramework client, String path)</span></span></div></pre></td></tr></table></figure>
<p>通过<code>acquire</code>获得锁，并提供超时机制：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* Acquire the mutex - blocking until it's available. Note: the same thread can call acquire</div><div class="line">* re-entrantly. Each call to acquire must be balanced by a call to release()</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span></span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* Acquire the mutex - blocks until it's available or the given time expires. Note: the same </div><div class="line">* thread can call acquire re-entrantly. Each call to acquire that returns true must be </div><div class="line">* balanced by a call to release()</div><div class="line">* Parameters:</div><div class="line">* time - time to wait</div><div class="line">* unit - time unit</div><div class="line">* Returns:</div><div class="line">* true if the mutex was acquired, false if not</div><div class="line">*/</div><div class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">acquire</span><span class="params">(<span class="keyword">long</span> time,</span></div><div class="line">                       TimeUnit unit)</div></pre></td></tr></table></figure>
<p>通过<code>release()</code>方法释放锁。InterProcessMutex 实例可以重用。</p>
<p><strong>Revoking</strong><br>ZooKeeper recipes wiki定义了可协商的撤销机制。<br>为了撤销mutex, 调用下面的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* 将锁设为可撤销的. 当别的进程或线程想让你释放锁是Listener会被调用。</div><div class="line">* Parameters:</div><div class="line">* listener - the listener</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeRevocable</span><span class="params">(RevocationListener&lt;T&gt; listener)</span></span></div></pre></td></tr></table></figure>
<p>如果请求撤销当前的锁， 调用<code>Revoker</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* Utility to mark a lock for revocation. Assuming that the lock has been registered</div><div class="line">* with a RevocationListener, it will get called and the lock should be released. Note,</div><div class="line">* however, that revocation is cooperative.</div><div class="line">* Parameters:</div><div class="line">* client - the client</div><div class="line">* path - the path of the lock - usually from something like </div><div class="line">* InterProcessMutex.getParticipantNodes()</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">attemptRevoke</span><span class="params">(CuratorFramework client,</span></span></div><div class="line">                                 String path)</div><div class="line">                         <span class="keyword">throws</span> Exception</div></pre></td></tr></table></figure>
<a id="more"></a>
<p><strong>错误处理</strong><br>还是强烈推荐你使用<code>ConnectionStateListener</code>处理连接状态的改变。 当连接LOST时你不再拥有锁。</p>
<p>首先创建一个模拟的共享资源， 这个资源期望只能单线程的访问，否则会有并发问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.zsr.test.curator.lock;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicBoolean;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Simulates some external resource that can only be access by one process at a time</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FakeLimitedResource</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean inUse = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    <span class="comment">// 真实环境中我们会在这里访问/维护一个共享的资源</span></div><div class="line">    <span class="comment">//这个例子在使用锁的情况下不会非法并发异常IllegalStateException</span></div><div class="line">	<span class="comment">//但是在无锁的情况由于sleep了一段时间，很容易抛出异常</span></div><div class="line">    <span class="keyword">if</span> (!inUse.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Needs to be used by one client at a time"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      Thread.sleep((<span class="keyword">long</span>) (<span class="number">3</span> * Math.random()));</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">      inUse.set(<span class="keyword">false</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后创建一个<code>ExampleClientThatLocks</code>类， 它负责请求锁， 使用资源，释放锁这样一个完整的访问过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.zsr.test.curator.lock;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFramework;</div><div class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.locks.InterProcessMutex;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleClientThatLocks</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> InterProcessMutex lock;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> FakeLimitedResource resource;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String clientName;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ExampleClientThatLocks</span><span class="params">(CuratorFramework client, String lockPath, FakeLimitedResource resource,</span></span></div><div class="line">      String clientName) &#123;</div><div class="line">    <span class="keyword">this</span>.resource = resource;</div><div class="line">    <span class="keyword">this</span>.clientName = clientName;</div><div class="line">    lock = <span class="keyword">new</span> InterProcessMutex(client, lockPath);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!lock.acquire(time, unit)) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(clientName + <span class="string">" could not acquire the lock"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      System.out.println(clientName + <span class="string">" has the lock"</span>);</div><div class="line">      resource.use();</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">      System.out.println(clientName + <span class="string">" releasing the lock"</span>);</div><div class="line">      lock.release(); <span class="comment">// always release the lock in a finally block</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后创建主程序来测试。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.zsr.test.curator.lock;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFramework;</div><div class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;</div><div class="line"><span class="keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;</div><div class="line"><span class="keyword">import</span> org.apache.curator.test.TestingServer;</div><div class="line"><span class="keyword">import</span> org.apache.curator.utils.CloseableUtils;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterProcessMutexExample</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> QTY = <span class="number">5</span>;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REPETITIONS = QTY * <span class="number">10</span>;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH = <span class="string">"/examples/locks"</span>;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="keyword">final</span> FakeLimitedResource resource = <span class="keyword">new</span> FakeLimitedResource();</div><div class="line">    ExecutorService service = Executors.newFixedThreadPool(QTY);</div><div class="line">    <span class="keyword">final</span> TestingServer server = <span class="keyword">new</span> TestingServer();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; QTY; ++i) &#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> index = i;</div><div class="line">        Callable&lt;Void&gt; task = <span class="keyword">new</span> Callable&lt;Void&gt;() &#123;</div><div class="line">          <span class="meta">@Override</span></div><div class="line">          <span class="function"><span class="keyword">public</span> Void <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">            CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>));</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">              client.start();</div><div class="line">              <span class="keyword">final</span> ExampleClientThatLocks example = <span class="keyword">new</span> ExampleClientThatLocks(client, PATH, resource, <span class="string">"Client "</span> + index);</div><div class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; REPETITIONS; ++j) &#123;</div><div class="line">                example.doWork(<span class="number">10</span>, TimeUnit.SECONDS);</div><div class="line">              &#125;</div><div class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">              e.printStackTrace();</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">              CloseableUtils.closeQuietly(client);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">          &#125;</div><div class="line">        &#125;;</div><div class="line">        service.submit(task);</div><div class="line">      &#125;</div><div class="line">      service.shutdown();</div><div class="line">      service.awaitTermination(<span class="number">10</span>, TimeUnit.MINUTES);</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">      CloseableUtils.closeQuietly(server);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码也很简单，生成10个client， 每个client重复执行10次 请求锁–访问资源–释放锁的过程。每个client都在独立的线程中。结果可以看到，锁是随机的被每个实例排他性的使用。</p>
<p>既然是可重用的，可以在一个线程中多次调用<code>acquire</code>,在线程拥有锁时它总是返回true。</p>
<p>不应该在多个线程中用同一个InterProcessMutex， 你可以在每个线程中都生成一个InterProcessMutex实例，它们的path都一样，这样它们可以共享同一个锁。</p>
<h3 id="不可重入锁Shared-Lock"><a href="#不可重入锁Shared-Lock" class="headerlink" title="不可重入锁Shared Lock"></a>不可重入锁Shared Lock</h3><p>这个锁和上面的相比，就是少了<code>Reentrant</code>的功能，也就意味着它不能在同一个线程中重入。<br>这个类是<code>InterProcessSemaphoreMutex</code>。<br>使用方法和上面的类类似。</p>
<p>将上面的例子修改一下，测试一下它的重入。修改<code>ExampleClientThatLocks.doWork</code>,连续两次<code>acquire</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">	<span class="keyword">if</span> (!lock.acquire(time, unit)) &#123;</div><div class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(clientName + <span class="string">" could not acquire the lock"</span>);</div><div class="line">	&#125;</div><div class="line">	System.out.println(clientName + <span class="string">" has the lock"</span>);</div><div class="line">	<span class="keyword">if</span> (!lock.acquire(time, unit)) &#123;</div><div class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(clientName + <span class="string">" could not acquire the lock"</span>);</div><div class="line">	&#125;</div><div class="line">	System.out.println(clientName + <span class="string">" has the lock again"</span>);</div><div class="line">	</div><div class="line">	<span class="keyword">try</span> &#123;			</div><div class="line">		resource.use(); <span class="comment">//access resource exclusively</span></div><div class="line">	&#125; <span class="keyword">finally</span> &#123;</div><div class="line">		System.out.println(clientName + <span class="string">" releasing the lock"</span>);</div><div class="line">		lock.release(); <span class="comment">// always release the lock in a finally block</span></div><div class="line">		lock.release(); <span class="comment">// always release the lock in a finally block</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>注意:</strong>我们也需要调用<code>release</code>两次。这和JDK的ReentrantLock用法一致。如果少调用一次<code>release</code>，则此线程依然拥有锁。<br>上面的代码没有问题，我们可以多次调用<code>acquire</code>，后续的<code>acquire</code>也不会阻塞。<br>将上面的<code>InterProcessMutex</code>换成不可重入锁<code>InterProcessSemaphoreMutex</code>,如果再运行上面的代码，结果就会发现线程被阻塞再第二个<code>acquire</code>上。 也就是此锁不是可重入的。</p>
<h3 id="可重入读写锁Shared-Reentrant-Read-Write-Lock"><a href="#可重入读写锁Shared-Reentrant-Read-Write-Lock" class="headerlink" title="可重入读写锁Shared Reentrant Read Write Lock"></a>可重入读写锁Shared Reentrant Read Write Lock</h3><p>类似JDK的<code>ReentrantReadWriteLock</code>.<br>一个读写锁管理一对相关的锁。 一个负责读操作，另外一个负责写操作。 读操作在写锁没被使用时可同时由多个进程使用，而写锁使用时不允许读 (阻塞)。<br>此锁是可重入的。一个拥有写锁的线程可重入读锁，但是读锁却不能进入写锁。<br>这也意味着写锁可以降级成读锁， 比如请求写锁 —&gt;读锁 —-&gt;释放写锁。 从读锁升级成写锁是不成的。</p>
<p>主要由两个类实现：</p>
<ul>
<li>InterProcessReadWriteLock</li>
<li>InterProcessLock</li>
</ul>
<p>使用时首先创建一个<code>InterProcessReadWriteLock</code>实例，然后再根据你的需求得到读锁或者写锁， 读写锁的类型是<code>InterProcessLock</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> InterProcessLock <span class="title">readLock</span><span class="params">()</span></span></div><div class="line"><span class="keyword">public</span> InterProcessLock <span class="title">writeLock</span><span class="params">()</span></div></pre></td></tr></table></figure>
<p>例子和上面的类似。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.zsr.test.curator.lock;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFramework;</div><div class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.locks.InterProcessMutex;</div><div class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.locks.InterProcessReadWriteLock;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleClientReadWriteLocks</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> InterProcessReadWriteLock lock;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> InterProcessMutex readLock;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> InterProcessMutex writeLock;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> FakeLimitedResource resource;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String clientName;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ExampleClientReadWriteLocks</span><span class="params">(CuratorFramework client, String lockPath, FakeLimitedResource resource,</span></span></div><div class="line">      String clientName) &#123;</div><div class="line">    <span class="keyword">this</span>.resource = resource;</div><div class="line">    <span class="keyword">this</span>.clientName = clientName;</div><div class="line">    lock = <span class="keyword">new</span> InterProcessReadWriteLock(client, lockPath);</div><div class="line">    readLock = lock.readLock();</div><div class="line">    writeLock = lock.writeLock();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!writeLock.acquire(time, unit)) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(clientName + <span class="string">" could not acquire the writeLock"</span>);</div><div class="line">    &#125;</div><div class="line">    System.out.println(clientName + <span class="string">" has the writeLock"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!readLock.acquire(time, unit)) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(clientName + <span class="string">" could not acquire the readLock"</span>);</div><div class="line">    &#125;</div><div class="line">    System.out.println(clientName + <span class="string">" has the readLock too"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      resource.use(); <span class="comment">// access resource exclusively</span></div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">      System.out.println(clientName + <span class="string">" releasing the lock"</span>);</div><div class="line">      readLock.release(); <span class="comment">// always release the lock in a finally block</span></div><div class="line">      writeLock.release(); <span class="comment">// always release the lock in a finally block</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个类中我们首先请求了一个写锁， 然后降级成读锁。 执行业务处理，然后释放读写锁。</p>
<h3 id="信号量Shared-Semaphore"><a href="#信号量Shared-Semaphore" class="headerlink" title="信号量Shared Semaphore"></a>信号量Shared Semaphore</h3><p>一个计数的信号量类似JDK的Semaphore。 JDK中Semaphore维护的一组许可(permits)，而Curator中称之为租约(Lease)。<br>有两种方式可以决定semaphore的最大租约数。第一种方式是有用户给定的path决定。第二种方式使用<code>SharedCountReader</code>类。<br>如果不使用SharedCountReader, 没有内部代码检查进程是否假定有10个租约而进程B假定有20个租约。 所以所有的实例必须使用相同的numberOfLeases值.</p>
<p>这次调用<code>acquire</code>会返回一个租约对象。 客户端必须在finally中close这些租约对象，否则这些租约会丢失掉。 但是， 但是，如果客户端session由于某种原因比如crash丢掉， 那么这些客户端持有的租约会自动close， 这样其它客户端可以继续使用这些租约。<br>租约还可以通过下面的方式返还：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnAll</span><span class="params">(Collection&lt;Lease&gt; leases)</span></span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnLease</span><span class="params">(Lease lease)</span></div></pre></td></tr></table></figure>
<p><strong>注意:</strong>一次你可以请求多个租约，如果Semaphore当前的租约不够，则请求线程会被阻塞。 同时还提供了超时的重载方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Lease <span class="title">acquire</span><span class="params">()</span></span></div><div class="line"><span class="keyword">public</span> Collection&lt;Lease&gt; <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> qty)</span></div><div class="line"><span class="keyword">public</span> Lease <span class="title">acquire</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span></div><div class="line"><span class="keyword">public</span> Collection&lt;Lease&gt; <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> qty, <span class="keyword">long</span> time, TimeUnit unit)</span></div></pre></td></tr></table></figure>
<p>主要类有:</p>
<ul>
<li>InterProcessSemaphoreV2</li>
<li>Lease</li>
<li>SharedCountReader</li>
</ul>
<p>下面是使用的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.zsr.test.curator.lock;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.Collection;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFramework;</div><div class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;</div><div class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.locks.InterProcessSemaphoreV2;</div><div class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.locks.Lease;</div><div class="line"><span class="keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;</div><div class="line"><span class="keyword">import</span> org.apache.curator.test.TestingServer;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterProcessSemaphoreExample</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_LEASE = <span class="number">10</span>;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH = <span class="string">"/examples/locks"</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    FakeLimitedResource resource = <span class="keyword">new</span> FakeLimitedResource();</div><div class="line">    <span class="keyword">try</span> (TestingServer server = <span class="keyword">new</span> TestingServer()) &#123;</div><div class="line">      CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(),</div><div class="line">          <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>));</div><div class="line">      client.start();</div><div class="line">      InterProcessSemaphoreV2 semaphore = <span class="keyword">new</span> InterProcessSemaphoreV2(client, PATH, MAX_LEASE);</div><div class="line">      Collection&lt;Lease&gt; leases = semaphore.acquire(<span class="number">5</span>);</div><div class="line">      System.out.println(<span class="string">"get "</span> + leases.size() + <span class="string">" leases"</span>);</div><div class="line">      Lease lease = semaphore.acquire();</div><div class="line">      System.out.println(<span class="string">"get another lease"</span>);</div><div class="line">      resource.use();</div><div class="line">      Collection&lt;Lease&gt; leases2 = semaphore.acquire(<span class="number">5</span>, <span class="number">10</span>, TimeUnit.SECONDS);</div><div class="line">      System.out.println(<span class="string">"Should timeout and acquire return "</span> + leases2);</div><div class="line">      System.out.println(<span class="string">"return one lease"</span>);</div><div class="line">      semaphore.returnLease(lease);</div><div class="line">      System.out.println(<span class="string">"return another 5 leases"</span>);</div><div class="line">      semaphore.returnAll(leases);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先先获得了5个租约， 最后我们把它还给了semaphore。<br>接着请求了一个租约，因为semaphore还有5个租约，所以请求可以满足，返回一个租约，还剩4个租约。<br>然后再请求一个租约，因为租约不够，阻塞到超时，还是没能满足，返回结果为null。</p>
<p>上面所讲的锁都是公平锁(fair)。 从ZooKeeper的角度看， 每个客户端都按照请求的顺序获得锁，相当公平。</p>
<h3 id="多锁对象-Multi-Shared-Lock"><a href="#多锁对象-Multi-Shared-Lock" class="headerlink" title="多锁对象 Multi Shared Lock"></a>多锁对象 Multi Shared Lock</h3><p>Multi Shared Lock是一个锁的容器。 当调用<code>acquire</code>， 所有的锁都会被<code>acquire</code>，如果请求失败，所有的锁都会被release。 同样调用release时所有的锁都被release(失败被忽略)。<br>基本上，它就是组锁的代表，在它上面的请求释放操作都会传递给它包含的所有的锁。</p>
<p>主要涉及两个类：</p>
<ul>
<li>InterProcessMultiLock</li>
<li>InterProcessLock</li>
</ul>
<p>它的构造函数需要包含的锁的集合，或者一组ZooKeeper的path。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">InterProcessMultiLock</span><span class="params">(List&lt;InterProcessLock&gt; locks)</span></span></div><div class="line"><span class="keyword">public</span> <span class="title">InterProcessMultiLock</span><span class="params">(CuratorFramework client, List&lt;String&gt; paths)</span></div></pre></td></tr></table></figure>
<p>用法和Shared Lock相同。</p>
<p>例子如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.zsr.test.curator.lock;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.Arrays;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFramework;</div><div class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;</div><div class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.locks.InterProcessLock;</div><div class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.locks.InterProcessMultiLock;</div><div class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.locks.InterProcessMutex;</div><div class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.locks.InterProcessSemaphoreMutex;</div><div class="line"><span class="keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;</div><div class="line"><span class="keyword">import</span> org.apache.curator.test.TestingServer;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterProcessMultiLockExample</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH1 = <span class="string">"/examples/locks1"</span>;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH2 = <span class="string">"/examples/locks2"</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    FakeLimitedResource resource = <span class="keyword">new</span> FakeLimitedResource();</div><div class="line">    <span class="keyword">try</span> (TestingServer server = <span class="keyword">new</span> TestingServer()) &#123;</div><div class="line">      CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(),</div><div class="line">          <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>));</div><div class="line">      client.start();</div><div class="line"></div><div class="line">      InterProcessLock lock1 = <span class="keyword">new</span> InterProcessMutex(client, PATH1);</div><div class="line">      InterProcessLock lock2 = <span class="keyword">new</span> InterProcessSemaphoreMutex(client, PATH2);</div><div class="line"></div><div class="line">      InterProcessMultiLock lock = <span class="keyword">new</span> InterProcessMultiLock(Arrays.asList(lock1, lock2));</div><div class="line">      <span class="keyword">if</span> (!lock.acquire(<span class="number">10</span>, TimeUnit.SECONDS)) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"could not acquire the lock"</span>);</div><div class="line">      &#125;</div><div class="line">      System.out.println(<span class="string">"has the lock"</span>);</div><div class="line"></div><div class="line">      System.out.println(<span class="string">"has the lock1: "</span> + lock1.isAcquiredInThisProcess());</div><div class="line">      System.out.println(<span class="string">"has the lock2: "</span> + lock2.isAcquiredInThisProcess());</div><div class="line"></div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        resource.use(); <span class="comment">// access resource exclusively</span></div><div class="line">      &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        System.out.println(<span class="string">"releasing the lock"</span>);</div><div class="line">        lock.release(); <span class="comment">// always release the lock in a finally block</span></div><div class="line">      &#125;</div><div class="line">      System.out.println(<span class="string">"has the lock1: "</span> + lock1.isAcquiredInThisProcess());</div><div class="line">      System.out.println(<span class="string">"has the lock2: "</span> + lock2.isAcquiredInThisProcess());</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>新建一个InterProcessMultiLock， 包含一个重入锁和一个非重入锁。<br>调用<code>acquire</code>后可以看到线程同时拥有了这两个锁。<br>调用<code>release</code>看到这两个锁都被释放了。</p>
<p><strong>注意：</strong>强烈推荐使用ConnectionStateListener监控连接的状态。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[zookeeper leader选举]]></title>
      <url>http://zsr.github.io/2016/08/29/zookeeper-leader%E9%80%89%E4%B8%BE/</url>
      <content type="html"><![CDATA[<h2 id="Leader选举"><a href="#Leader选举" class="headerlink" title="Leader选举"></a>Leader选举</h2><p>在实际使用ZooKeeper开发中，我们最常用的是<a href="http://curator.apache.org/index.html" target="_blank" rel="external">Apache Curator</a>。 在使用ZK API开发时会遇到让人头疼的几个问题，ZK连接管理、SESSION失效等一些异常问题的处理，Curator替我们解决了这些问题，通过对ZK连接状态的监控来做出相应的重连等操作，并触发事件。</p>
<p>更好的地方是Curator对ZK的一些应用场景提供了非常好的实现，而且有很多扩充，这些都符合ZK使用规范。<br>它的主要组件为：</p>
<ul>
<li><strong>Recipes</strong>: ZooKeeper的系列recipe实现, 基于 Curator Framework.**</li>
<li><strong>Framework</strong>: 封装了大量ZooKeeper常用API操作，降低了使用难度, 基于Zookeeper增加了一些新特性，对ZooKeeper链接的管理，对链接丢失自动重新链接。**</li>
<li><strong>Utilities</strong>: 一些ZooKeeper操作的工具类包括ZK的集群测试工具路径生成等非常有用，在Curator-Client包下org.apache.curator.utils。</li>
<li><strong>Client</strong>: ZooKeeper的客户端API封装，替代官方 ZooKeeper class，解决了一些繁琐低级的处理，提供一些工具类。</li>
<li><strong>Errors</strong>: 异常处理, 连接异常等</li>
<li><strong>Extensions</strong>: 对curator-recipes的扩展实现，拆分为curator-: stuck_out_tongue_closed_eyes: iscovery和curator-: stuck_out_tongue_closed_eyes: iscovery-server提供基于RESTful的Recipes WEB服务.</li>
</ul>
<p>在分布式计算中， leader election是很重要的一个功能， 这个选举过程是这样子的： 指派一个进程作为组织者，将任务分发给各节点。 在任务开始前， 哪个节点都不知道谁是leader或者coordinator. 当选举算法开始执行后， 每个节点最终会得到一个唯一的节点作为任务leader.<br>除此之外， 选举还经常会发生在leader意外宕机的情况下，新的leader要被选举出来。</p>
<p>Curator 有两种选举recipe， 可以根据需求选择合适的。</p>
<h3 id="Leader-latch"><a href="#Leader-latch" class="headerlink" title="Leader latch"></a>Leader latch</h3><p>使用<code>LeaderLatch</code>类选举的例子.</p>
<p>构造函数如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">LeaderLatch</span><span class="params">(CuratorFramework client, String latchPath)</span></span></div><div class="line"><span class="keyword">public</span> <span class="title">LeaderLatch</span><span class="params">(CuratorFramework client, String latchPath,  String id)</span></div></pre></td></tr></table></figure>
<p>启动LeaderLatch: <code>leaderLatch.start();</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * Add this instance to the leadership election and attempt to acquire leadership.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@throws</span> Exception errors</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span></div><div class="line">    &#123;</div><div class="line">        Preconditions.checkState(state.compareAndSet(State.LATENT, State.STARTED), <span class="string">"Cannot be started more than once"</span>);</div><div class="line"></div><div class="line">        startTask.set(AfterConnectionEstablished.execute(client, <span class="keyword">new</span> Runnable()</div><div class="line">                &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></div><div class="line">                    &#123;</div><div class="line">                        <span class="keyword">try</span></div><div class="line">                        &#123;</div><div class="line">                            internalStart();</div><div class="line">                        &#125;</div><div class="line">                        <span class="keyword">finally</span></div><div class="line">                        &#123;</div><div class="line">                            startTask.set(<span class="keyword">null</span>);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;));</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>一旦启动， LeaderLatch会和其它使用相同latch path的其它LeaderLatch交涉，然后随机的选择其中一个作为leader。 可以随时查看一个给定的实例是否是leader:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasLeadership</span><span class="params">()</span></span></div></pre></td></tr></table></figure>
<p>LeaderLatch在请求成为leadership时有block方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span></span></div><div class="line">     <span class="keyword">throws</span> InterruptedException, EOFException</div><div class="line">   &#123;</div><div class="line">     <span class="keyword">synchronized</span> (<span class="keyword">this</span>)</div><div class="line">     &#123;</div><div class="line">       <span class="keyword">while</span> ((<span class="keyword">this</span>.state.get() == State.STARTED) &amp;&amp; (!<span class="keyword">this</span>.hasLeadership.get()))</div><div class="line">       &#123;</div><div class="line">         wait();</div><div class="line">       &#125;</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">if</span> (<span class="keyword">this</span>.state.get() != State.STARTED)</div><div class="line">     &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> EOFException();</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line">Causes the current thread to wait until <span class="keyword">this</span> instance acquires leadership</div><div class="line">unless the thread is interrupted or closed.</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout,</span></span></div><div class="line">                     TimeUnit unit)</div><div class="line">            <span class="keyword">throws</span> InterruptedException</div></pre></td></tr></table></figure>
<p>一旦不使用LeaderLatch了，必须调用<code>close</code>方法。 如果它是leader,会释放leadership， 其它的参与者将会重新选举一个leader。</p>
<p><strong>异常处理</strong><br>LeaderLatch实例可以增加ConnectionStateListener来监听网络连接问题。 当 SUSPENDED 或 LOST 时, leader不再认为自己还是leader.当LOST 连接重连后 RECONNECTED,LeaderLatch会删除先前的ZNode然后重新创建一个.<br>LeaderLatch用户必须考虑导致leadership丢失的连接问题。 强烈推荐你使用ConnectionStateListener。</p>
<a id="more"></a>
<p><strong>LeaderLatch案例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.zsr.test.curator;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.BufferedReader;</div><div class="line"><span class="keyword">import</span> java.io.InputStreamReader;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFramework;</div><div class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;</div><div class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.leader.LeaderLatch;</div><div class="line"><span class="keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;</div><div class="line"><span class="keyword">import</span> org.apache.curator.utils.CloseableUtils;</div><div class="line"><span class="keyword">import</span> org.apache.curator.test.TestingServer;</div><div class="line"></div><div class="line"><span class="keyword">import</span> com.google.common.collect.Lists;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeaderLatchExample</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CLIENT_QTY = <span class="number">10</span>;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH = <span class="string">"/examples/leader"</span>;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    List&lt;CuratorFramework&gt; clients = Lists.newArrayList();</div><div class="line">    List&lt;LeaderLatch&gt; examples = Lists.newArrayList();</div><div class="line">    TestingServer server = <span class="keyword">new</span> TestingServer();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; CLIENT_QTY; ++i) &#123;</div><div class="line">        CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>));</div><div class="line">        clients.add(client);</div><div class="line">        LeaderLatch example = <span class="keyword">new</span> LeaderLatch(client, PATH, <span class="string">"Client #"</span> + i);</div><div class="line">        examples.add(example);</div><div class="line">        client.start();</div><div class="line">        example.start();</div><div class="line">      &#125;</div><div class="line">      Thread.sleep(<span class="number">2000</span>);</div><div class="line">      LeaderLatch currentLeader = <span class="keyword">null</span>;</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; CLIENT_QTY; ++i) &#123;</div><div class="line">        LeaderLatch example = examples.get(i);</div><div class="line">        <span class="keyword">if</span> (example.hasLeadership())</div><div class="line">          currentLeader = example;</div><div class="line">      &#125;</div><div class="line">      System.out.println(<span class="string">"current leader is "</span> + currentLeader.getId());</div><div class="line">      System.out.println(<span class="string">"release the leader "</span> + currentLeader.getId());</div><div class="line">      currentLeader.close();</div><div class="line">      examples.get(<span class="number">0</span>).await(<span class="number">2</span>, TimeUnit.SECONDS);</div><div class="line">      System.out.println(<span class="string">"Client #0 maybe is elected as the leader or not although it want to be"</span>);</div><div class="line">      System.out.println(<span class="string">"the new leader is "</span> + examples.get(<span class="number">0</span>).getLeader().getId());</div><div class="line">      </div><div class="line">      System.out.println(<span class="string">"Press enter/return to quit\n"</span>);</div><div class="line">      <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in)).readLine();</div><div class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">      e.printStackTrace();</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">      System.out.println(<span class="string">"Shutting down..."</span>);</div><div class="line">      <span class="keyword">for</span> (LeaderLatch exampleClient : examples) &#123;</div><div class="line">        CloseableUtils.closeQuietly(exampleClient);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">for</span> (CuratorFramework client : clients) &#123;</div><div class="line">        CloseableUtils.closeQuietly(client);</div><div class="line">      &#125;</div><div class="line">      CloseableUtils.closeQuietly(server);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先创建了10个LeaderLatch，启动后它们中的一个会被选举为leader。 因为选举会花费一些时间，start后并不能马上就得到leader。<br>通过<code>hasLeadership</code>查看自己是否是leader， 如果是的话返回true。<br>可以通过<code>.getLeader().getId()</code>可以得到当前的leader的ID。<br>只能通过<code>close</code>释放当前的领导权。<br><code>await</code>是一个阻塞方法， 尝试获取leader地位，但是未必能选中。</p>
<h3 id="Leader-Election"><a href="#Leader-Election" class="headerlink" title="Leader Election"></a>Leader Election</h3><p>Curator还提供了另外一种选举方法。<br>主要涉及以下四个类：</p>
<ul>
<li>LeaderSelector</li>
<li>LeaderSelectorListener</li>
<li>LeaderSelectorListenerAdapter</li>
<li>CancelLeadershipException</li>
</ul>
<p>重要的是LeaderSelector类，它的构造函数为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">LeaderSelector</span><span class="params">(CuratorFramework client, String mutexPath,LeaderSelectorListener listener)</span></span></div><div class="line"><span class="keyword">public</span> <span class="title">LeaderSelector</span><span class="params">(CuratorFramework client, String mutexPath, ThreadFactory threadFactory, Executor executor, LeaderSelectorListener listener)</span></div></pre></td></tr></table></figure>
<p>类似LeaderLatch,必须<code>start</code>: <code>leaderSelector.start();</code><br>一旦启动，当实例取得领导权时你的listener的<code>takeLeadership()</code>方法被调用. 而takeLeadership()方法只有领导权被释放时才返回。<br>当你不再使用<code>LeaderSelector</code>实例时，需要调用它的close方法</p>
<p><strong>异常处理</strong><br>LeaderSelectorListener类继承ConnectionStateListener。LeaderSelector必须小心连接状态的改变. 如果实例成为leader, 它应该响应SUSPENDED 或 LOST. 当 SUSPENDED 状态出现时， 实例必须假定在重新连接成功之前它可能不再是leader了。 如果LOST状态出现， 实例不再是leader， takeLeadership方法返回.</p>
<p><strong>注意：</strong>推荐处理方式是当收到SUSPENDED 或 LOST时抛出CancelLeadershipException异常. 这会导致LeaderSelector实例中断并取消执行takeLeadership方法的异常. 这非常重要， 你必须考虑扩展LeaderSelectorListenerAdapter. LeaderSelectorListenerAdapter提供了推荐的处理逻辑。</p>
<p><strong>LeaderSelector案例</strong></p>
<p>首先创建一个ExampleClient类， 它继承LeaderSelectorListenerAdapter， 它实现了takeLeadership方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.zsr.test.curator;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.Closeable;</div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFramework;</div><div class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.leader.LeaderSelector;</div><div class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.leader.LeaderSelectorListenerAdapter;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * An example leader selector client. Note that &#123;<span class="doctag">@link</span> LeaderSelectorListenerAdapter&#125; which has the</div><div class="line"> * recommended handling for connection state issues</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleClient</span> <span class="keyword">extends</span> <span class="title">LeaderSelectorListenerAdapter</span> <span class="keyword">implements</span> <span class="title">Closeable</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String name;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> LeaderSelector leaderSelector;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger leaderCount = <span class="keyword">new</span> AtomicInteger();</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ExampleClient</span><span class="params">(CuratorFramework client, String path, String name)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line"></div><div class="line">    <span class="comment">// create a leader selector using the given path for management</span></div><div class="line">    <span class="comment">// all participants in a given leader selection must use the same path</span></div><div class="line">    <span class="comment">// ExampleClient here is also a LeaderSelectorListener but this isn't required</span></div><div class="line">    leaderSelector = <span class="keyword">new</span> LeaderSelector(client, path, <span class="keyword">this</span>);</div><div class="line"></div><div class="line">    <span class="comment">// for most cases you will want your instance to requeue when it relinquishes leadership</span></div><div class="line">    leaderSelector.autoRequeue();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="comment">// the selection for this instance doesn't start until the leader selector is started</span></div><div class="line">    <span class="comment">// leader selection is done in the background so this call to leaderSelector.start() returns</span></div><div class="line">    <span class="comment">// immediately</span></div><div class="line">    leaderSelector.start();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    leaderSelector.close();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeLeadership</span><span class="params">(CuratorFramework client)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="comment">// we are now the leader. This method should not return until we want to relinquish leadership</span></div><div class="line"></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> waitSeconds = (<span class="keyword">int</span>) (<span class="number">5</span> * Math.random()) + <span class="number">1</span>;</div><div class="line"></div><div class="line">    System.out.println(name + <span class="string">" is now the leader. Waiting "</span> + waitSeconds + <span class="string">" seconds..."</span>);</div><div class="line">    System.out.println(name + <span class="string">" has been leader "</span> + leaderCount.getAndIncrement() + <span class="string">" time(s) before."</span>);</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      Thread.sleep(TimeUnit.SECONDS.toMillis(waitSeconds));</div><div class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">      System.err.println(name + <span class="string">" was interrupted."</span>);</div><div class="line">      Thread.currentThread().interrupt();</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">      System.out.println(name + <span class="string">" relinquishing leadership.\n"</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以在takeLeadership进行任务的分配等等，并且不要返回，如果你想要要此实例一直是leader的话可以加一个死循环。<br><code>leaderSelector.autoRequeue();</code>：保证在此实例释放领导权之后还可能获得领导权。<br>在这里我们使用AtomicInteger来记录此client获得领导权的次数， 它是公平的， 每个client有平等的机会获得领导权。</p>
<p><strong>测试代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.zsr.test.curator;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.BufferedReader;</div><div class="line"><span class="keyword">import</span> java.io.InputStreamReader;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFramework;</div><div class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;</div><div class="line"><span class="keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;</div><div class="line"><span class="keyword">import</span> org.apache.curator.test.TestingServer;</div><div class="line"><span class="keyword">import</span> org.apache.curator.utils.CloseableUtils;</div><div class="line"></div><div class="line"><span class="keyword">import</span> com.google.common.collect.Lists;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeaderSelectorExample</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CLIENT_QTY = <span class="number">10</span>;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH = <span class="string">"/examples/leader"</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="comment">// all of the useful sample code is in ExampleClient.java</span></div><div class="line"></div><div class="line">    System.out.println(<span class="string">"Create "</span> + CLIENT_QTY</div><div class="line">        + <span class="string">" clients, have each negotiate for leadership and then wait a random number of seconds before letting another leader election occur."</span>);</div><div class="line">    System.out.println(</div><div class="line">        <span class="string">"Notice that leader election is fair: all clients will become leader and will do so the same number of times."</span>);</div><div class="line"></div><div class="line">    List&lt;CuratorFramework&gt; clients = Lists.newArrayList();</div><div class="line">    List&lt;ExampleClient&gt; examples = Lists.newArrayList();</div><div class="line">    TestingServer server = <span class="keyword">new</span> TestingServer();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; CLIENT_QTY; ++i) &#123;</div><div class="line">        CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(),</div><div class="line">            <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>));</div><div class="line">        clients.add(client);</div><div class="line"></div><div class="line">        ExampleClient example = <span class="keyword">new</span> ExampleClient(client, PATH, <span class="string">"Client #"</span> + i);</div><div class="line">        examples.add(example);</div><div class="line"></div><div class="line">        client.start();</div><div class="line">        example.start();</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      System.out.println(<span class="string">"Press enter/return to quit\n"</span>);</div><div class="line">      <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in)).readLine();</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">      System.out.println(<span class="string">"Shutting down..."</span>);</div><div class="line"></div><div class="line">      <span class="keyword">for</span> (ExampleClient exampleClient : examples) &#123;</div><div class="line">        CloseableUtils.closeQuietly(exampleClient);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">for</span> (CuratorFramework client : clients) &#123;</div><div class="line">        CloseableUtils.closeQuietly(client);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      CloseableUtils.closeQuietly(server);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>与LeaderLatch相比， 通过<code>LeaderSelectorListener</code>可以对领导权进行控制， 在适当的时候释放领导权，这样每个节点都有可能获得领导权。 而LeaderLatch除非调用close方法，否则它不会释放领导权。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[java mock]]></title>
      <url>http://zsr.github.io/2016/08/26/java-mock/</url>
      <content type="html"><![CDATA[<h3 id="Mock-测试"><a href="#Mock-测试" class="headerlink" title="Mock 测试"></a>Mock 测试</h3><p>Mock 最大的功能是帮你把单元测试的耦合分解开，如果你的代码对另一个类或者接口有依赖，它能够帮你模拟这些依赖，并帮你验证所调用的依赖的行为。</p>
<p>比如一段代码有这样的依赖：</p>
<p><img src="http://media.techtarget.com/tss/static/articles/content/JMockTestDrivenDev/images/image004.jpg" alt="img"></p>
<p>当我们需要测试A类的时候，如果没有 Mock，则我们需要把整个依赖树都构建出来，而使用 Mock 的话就可以将结构分解开，像下面这样：</p>
<p><img src="http://media.techtarget.com/tss/static/articles/content/JMockTestDrivenDev/images/image010.jpg" alt="img"></p>
<p>mock对象就是在调试期间用来作为真实对象的替代品。</p>
<p>mock测试就是在测试过程中，对那些不容易构建的对象用一个虚拟对象来代替测试的方法就叫mock测试。</p>
<h3 id="Mock-对象使用范畴"><a href="#Mock-对象使用范畴" class="headerlink" title="Mock 对象使用范畴"></a>Mock 对象使用范畴</h3><ul>
<li>真实对象具有不可确定的行为，产生不可预测的效果，（如：股票行情，天气预报） </li>
<li>真实对象很难被创建的 </li>
<li>真实对象的某些行为很难被触发 </li>
<li>真实对象实际上还不存在的（和其他开发小组或者和新的硬件打交道）等等</li>
</ul>
<a id="more"></a>
<h3 id="Mockito-使用"><a href="#Mockito-使用" class="headerlink" title="Mockito 使用"></a>Mockito 使用</h3><h4 id="声明-mockito-依赖"><a href="#声明-mockito-依赖" class="headerlink" title="声明 mockito 依赖"></a>声明 mockito 依赖</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.mockito&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;mockito-core&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;2.0.111-beta&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><h4 id="1-验证行为"><a href="#1-验证行为" class="headerlink" title="1. 验证行为"></a>1. 验证行为</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Let's import Mockito statically so that the code looks clearer</span></div><div class="line"> <span class="keyword">import</span> <span class="keyword">static</span> org.mockito.Mockito.*;</div><div class="line"></div><div class="line"> <span class="comment">//mock creation</span></div><div class="line"> List mockedList = mock(List.class);</div><div class="line"></div><div class="line"> <span class="comment">//using mock object</span></div><div class="line"> mockedList.add(<span class="string">"one"</span>);</div><div class="line"> mockedList.clear();</div><div class="line"></div><div class="line"> <span class="comment">//verification</span></div><div class="line"> verify(mockedList).add(<span class="string">"one"</span>);</div><div class="line"> verify(mockedList).clear();</div></pre></td></tr></table></figure>
<p>一旦创建 mock 将会记得所有的交互。你可以选择验证你感兴趣的任何交互</p>
<h4 id="2-stubbing"><a href="#2-stubbing" class="headerlink" title="2. stubbing"></a>2. stubbing</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//You can mock concrete classes, not just interfaces</span></div><div class="line">LinkedList mockedList = mock(LinkedList.class);</div><div class="line"></div><div class="line"><span class="comment">//stubbing</span></div><div class="line">when(mockedList.get(<span class="number">0</span>)).thenReturn(<span class="string">"first"</span>);</div><div class="line">when(mockedList.get(<span class="number">1</span>)).thenThrow(<span class="keyword">new</span> RuntimeException());</div><div class="line"></div><div class="line"><span class="comment">//following prints "first"</span></div><div class="line">System.out.println(mockedList.get(<span class="number">0</span>));</div><div class="line"></div><div class="line"><span class="comment">//following throws runtime exception</span></div><div class="line">System.out.println(mockedList.get(<span class="number">1</span>));</div><div class="line"></div><div class="line"><span class="comment">//following prints "null" because get(999) was not stubbed</span></div><div class="line">System.out.println(mockedList.get(<span class="number">999</span>));</div><div class="line"></div><div class="line"><span class="comment">//Although it is possible to verify a stubbed invocation, usually it's just redundant</span></div><div class="line"><span class="comment">//If your code cares what get(0) returns, then something else breaks (often even before verify() gets executed).</span></div><div class="line"><span class="comment">//If your code doesn't care what get(0) returns, then it should not be stubbed. Not convinced? See here.</span></div><div class="line">verify(mockedList).get(<span class="number">0</span>);</div></pre></td></tr></table></figure>
<ul>
<li>默认情况下，所有方法都会返回值，一个 mock 将返回要么 null，一个原始/基本类型的包装值或适当的空集。例如，对于一个 int/Integer 就是 0，而对于 boolean/Boolean 就是 false。</li>
<li>Stubbing 可以被覆盖。</li>
<li>一旦 stub，该方法将始终返回一个 stub 的值，无论它有多少次被调用。</li>
<li>最后的 stubbing 是很重要的 - 当你使用相同的参数 stub 多次同样的方法。换句话说：stubbing 的顺序是重要的，但它唯一有意义的却很少，例如当 stubbing 完全相同的方法调用，或者有时当参数匹配器的使用，等等。</li>
</ul>
<h4 id="3-参数匹配器"><a href="#3-参数匹配器" class="headerlink" title="3. 参数匹配器"></a>3. 参数匹配器</h4><p>Mockito 验证参数值使用 Java 方式：通过使用 equals() 方法。有时，当需要额外的灵活性，可以使用参数匹配器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//stubbing using built-in anyInt() argument matcher</span></div><div class="line">when(mockedList.get(anyInt())).thenReturn(<span class="string">"element"</span>);</div><div class="line"></div><div class="line"><span class="comment">//stubbing using custom matcher (let's say isValid() returns your own matcher implementation):</span></div><div class="line">when(mockedList.contains(argThat(isValid()))).thenReturn(<span class="string">"element"</span>);</div><div class="line"></div><div class="line"><span class="comment">//following prints "element"</span></div><div class="line">System.out.println(mockedList.get(<span class="number">999</span>));</div><div class="line"></div><div class="line"><span class="comment">//you can also verify using an argument matcher</span></div><div class="line">verify(mockedList).get(anyInt());</div></pre></td></tr></table></figure>
<p>下面的示例演示验证，但同样适用于 stubbing：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">verify(mock).someMethod(anyInt(), anyString(), eq(<span class="string">"third argument"</span>));</div><div class="line"><span class="comment">//above is correct - eq() is also an argument matcher</span></div><div class="line"></div><div class="line">verify(mock).someMethod(anyInt(), anyString(), <span class="string">"third argument"</span>);</div><div class="line"><span class="comment">//above is incorrect - exception will be thrown because third argument is given without an argument matcher.</span></div></pre></td></tr></table></figure>
<h4 id="4-调用额外的调用数字-at-least-never"><a href="#4-调用额外的调用数字-at-least-never" class="headerlink" title="4. 调用额外的调用数字/at least / never"></a>4. 调用额外的调用数字/at least / never</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//using mock</span></div><div class="line">mockedList.add(<span class="string">"once"</span>);</div><div class="line"></div><div class="line">mockedList.add(<span class="string">"twice"</span>);</div><div class="line">mockedList.add(<span class="string">"twice"</span>);</div><div class="line"></div><div class="line">mockedList.add(<span class="string">"three times"</span>);</div><div class="line">mockedList.add(<span class="string">"three times"</span>);</div><div class="line">mockedList.add(<span class="string">"three times"</span>);</div><div class="line"></div><div class="line"><span class="comment">//following two verifications work exactly the same - times(1) is used by default</span></div><div class="line">verify(mockedList).add(<span class="string">"once"</span>);</div><div class="line">verify(mockedList, times(<span class="number">1</span>)).add(<span class="string">"once"</span>);</div><div class="line"></div><div class="line"><span class="comment">//exact number of invocations verification</span></div><div class="line">verify(mockedList, times(<span class="number">2</span>)).add(<span class="string">"twice"</span>);</div><div class="line">verify(mockedList, times(<span class="number">3</span>)).add(<span class="string">"three times"</span>);</div><div class="line"></div><div class="line"><span class="comment">//verification using never(). never() is an alias to times(0)</span></div><div class="line">verify(mockedList, never()).add(<span class="string">"never happened"</span>);</div><div class="line"></div><div class="line"><span class="comment">//verification using atLeast()/atMost()</span></div><div class="line">verify(mockedList, atLeastOnce()).add(<span class="string">"three times"</span>);</div><div class="line">verify(mockedList, atLeast(<span class="number">2</span>)).add(<span class="string">"five times"</span>);</div><div class="line">verify(mockedList, atMost(<span class="number">5</span>)).add(<span class="string">"three times"</span>);</div></pre></td></tr></table></figure>
<p>times(1) 是默认的，因此，使用的 times(1) 可以显示的省略。</p>
<h4 id="5-Stubbing-void-方法处理异常"><a href="#5-Stubbing-void-方法处理异常" class="headerlink" title="5. Stubbing void 方法处理异常"></a>5. Stubbing void 方法处理异常</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">doThrow(<span class="keyword">new</span> RuntimeException()).when(mockedList).clear();</div><div class="line"></div><div class="line"><span class="comment">//following throws RuntimeException:</span></div><div class="line">mockedList.clear();</div></pre></td></tr></table></figure>
<h4 id="6-有序的验证"><a href="#6-有序的验证" class="headerlink" title="6. 有序的验证"></a>6. 有序的验证</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// A. Single mock whose methods must be invoked in a particular order</span></div><div class="line">List singleMock = mock(List.class);</div><div class="line"></div><div class="line"><span class="comment">//using a single mock</span></div><div class="line">singleMock.add(<span class="string">"was added first"</span>);</div><div class="line">singleMock.add(<span class="string">"was added second"</span>);</div><div class="line"></div><div class="line"><span class="comment">//create an inOrder verifier for a single mock</span></div><div class="line">InOrder inOrder = inOrder(singleMock);</div><div class="line"></div><div class="line"><span class="comment">//following will make sure that add is first called with "was added first, then with "was added second"</span></div><div class="line">inOrder.verify(singleMock).add(<span class="string">"was added first"</span>);</div><div class="line">inOrder.verify(singleMock).add(<span class="string">"was added second"</span>);</div><div class="line"></div><div class="line"><span class="comment">// B. Multiple mocks that must be used in a particular order</span></div><div class="line">List firstMock = mock(List.class);</div><div class="line">List secondMock = mock(List.class);</div><div class="line"></div><div class="line"><span class="comment">//using mocks</span></div><div class="line">firstMock.add(<span class="string">"was called first"</span>);</div><div class="line">secondMock.add(<span class="string">"was called second"</span>);</div><div class="line"></div><div class="line"><span class="comment">//create inOrder object passing any mocks that need to be verified in order</span></div><div class="line">InOrder inOrder = inOrder(firstMock, secondMock);</div><div class="line"></div><div class="line"><span class="comment">//following will make sure that firstMock was called before secondMock</span></div><div class="line">inOrder.verify(firstMock).add(<span class="string">"was called first"</span>);</div><div class="line">inOrder.verify(secondMock).add(<span class="string">"was called second"</span>);</div><div class="line"></div><div class="line"><span class="comment">// Oh, and A + B can be mixed together at will</span></div></pre></td></tr></table></figure>
<p>有序验证是为了灵活 - 不必一个接一个验证所有的交互。</p>
<p>此外，还可以通过创建 InOrder 对象传递只与有序验证相关的 mock 。</p>
<h4 id="7-确保-mock-上不会发生交互"><a href="#7-确保-mock-上不会发生交互" class="headerlink" title="7. 确保 mock 上不会发生交互"></a>7. 确保 mock 上不会发生交互</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//using mocks - only mockOne is interacted</span></div><div class="line">mockOne.add(<span class="string">"one"</span>);</div><div class="line"></div><div class="line"><span class="comment">//ordinary verification</span></div><div class="line">verify(mockOne).add(<span class="string">"one"</span>);</div><div class="line"></div><div class="line"><span class="comment">//verify that method was never called on a mock</span></div><div class="line">verify(mockOne, never()).add(<span class="string">"two"</span>);</div><div class="line"></div><div class="line"><span class="comment">//verify that other mocks were not interacted</span></div><div class="line">verifyZeroInteractions(mockTwo, mockThree);</div></pre></td></tr></table></figure>
<h4 id="8-寻找多余的调用"><a href="#8-寻找多余的调用" class="headerlink" title="8. 寻找多余的调用"></a>8. 寻找多余的调用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//using mocks</span></div><div class="line">mockedList.add(<span class="string">"one"</span>);</div><div class="line">mockedList.add(<span class="string">"two"</span>);</div><div class="line"></div><div class="line">verify(mockedList).add(<span class="string">"one"</span>);</div><div class="line"></div><div class="line"><span class="comment">//following verification will fail</span></div><div class="line">verifyNoMoreInteractions(mockedList);</div></pre></td></tr></table></figure>
<p>注意：不建议 verifyNoMoreInteractions() 在每个测试方法中使用。 verifyNoMoreInteractions() 是从交互测试工具包一个方便的断言。只有与它的相关时才使用它。滥用它导致难以维护。</p>
<h4 id="9-标准创建-mock-方式-使用-Mock-注解"><a href="#9-标准创建-mock-方式-使用-Mock-注解" class="headerlink" title="9. 标准创建 mock 方式 - 使用 @Mock 注解"></a>9. 标准创建 mock 方式 - 使用 <code>@Mock</code> 注解</h4><ul>
<li>最小化可重用 mock 创建代码</li>
<li>使测试类更加可读性</li>
<li>使验证错误更加易读，因为字段名称用于唯一识别 mock</li>
</ul>
<p>public class ArticleManagerTest {</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Mock</span> <span class="keyword">private</span> ArticleCalculator calculator;</div><div class="line"><span class="meta">@Mock</span> <span class="keyword">private</span> ArticleDatabase database;</div><div class="line"><span class="meta">@Mock</span> <span class="keyword">private</span> UserProvider userProvider;</div><div class="line"></div><div class="line"><span class="keyword">private</span> ArticleManager manager;</div></pre></td></tr></table></figure>
<p>在基础类或者测试 runner 里面，使用如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">MockitoAnnotations.initMocks(testClass);</div></pre></td></tr></table></figure>
<p>可以使用内建 runner: <a href="http://site.mockito.org/mockito/docs/current/org/mockito/runners/MockitoJUnitRunner.html" target="_blank" rel="external">MockitoJUnitRunner</a> 或者 rule: <a href="http://site.mockito.org/mockito/docs/current/org/mockito/junit/MockitoRule.html" target="_blank" rel="external">MockitoRule</a></p>
<p>更多详见 <a href="http://site.mockito.org/mockito/docs/current/org/mockito/MockitoAnnotations.html" target="_blank" rel="external">MockitoAnnotations</a></p>
<h4 id="10-Stubbing-连续调用（迭代器式的-stubbing）"><a href="#10-Stubbing-连续调用（迭代器式的-stubbing）" class="headerlink" title="10. Stubbing 连续调用（迭代器式的 stubbing）"></a>10. Stubbing 连续调用（迭代器式的 stubbing）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">when(mock.someMethod(<span class="string">"some arg"</span>))</div><div class="line"> .thenThrow(<span class="keyword">new</span> RuntimeException())</div><div class="line"> .thenReturn(<span class="string">"foo"</span>);</div><div class="line"></div><div class="line"><span class="comment">//First call: throws runtime exception:</span></div><div class="line">mock.someMethod(<span class="string">"some arg"</span>);</div><div class="line"></div><div class="line"><span class="comment">//Second call: prints "foo"</span></div><div class="line">System.out.println(mock.someMethod(<span class="string">"some arg"</span>));</div><div class="line"></div><div class="line"><span class="comment">//Any consecutive call: prints "foo" as well (last stubbing wins).</span></div><div class="line">System.out.println(mock.someMethod(<span class="string">"some arg"</span>));</div></pre></td></tr></table></figure>
<p>下面是一个精简版本：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">when(mock.someMethod(<span class="string">"some arg"</span>))</div><div class="line"> .thenReturn(<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>);</div></pre></td></tr></table></figure>
<h4 id="11-回调-Stubbing"><a href="#11-回调-Stubbing" class="headerlink" title="11. 回调 Stubbing"></a>11. 回调 Stubbing</h4><p>允许使用泛型 <a href="http://site.mockito.org/mockito/docs/current/org/mockito/stubbing/Answer.html" target="_blank" rel="external">Answer</a> 接口。</p>
<p>然而，这是不包括在最初的 Mockito 另一个有争议的功能。建议只需用thenReturn() 或 thenThrow() 来 stubbing ，这在测试/测试驱动中应用简洁与简单的代码足够了。但是，如果有一个需要 stub 到泛型 Answer 接口，这里是一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">when(mock.someMethod(anyString())).thenAnswer(<span class="keyword">new</span> Answer() &#123;</div><div class="line">   <span class="function">Object <span class="title">answer</span><span class="params">(InvocationOnMock invocation)</span> </span>&#123;</div><div class="line">       Object[] args = invocation.getArguments();</div><div class="line">       Object mock = invocation.getMock();</div><div class="line">       <span class="keyword">return</span> <span class="string">"called with arguments: "</span> + args;</div><div class="line">   &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">//the following prints "called with arguments: foo"</span></div><div class="line">System.out.println(mock.someMethod(<span class="string">"foo"</span>));</div></pre></td></tr></table></figure>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例:"></a>案例:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SalaryService</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BigDecimal minimumSalary = <span class="keyword">new</span> BigDecimal(<span class="number">20000</span>);</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> EmployeeDAO employeeDAO;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> TaxCalculator taxCalculator;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> BigDecimal <span class="title">getNetSalary</span><span class="params">(<span class="keyword">long</span> employeeId)</span> </span>&#123;</div><div class="line">        BigDecimal netSalary = <span class="keyword">null</span>;</div><div class="line">        BigDecimal grossSalary = employeeDAO.getAnnualSalary(employeeId);</div><div class="line">        BigDecimal taxes = taxCalculator.calculateTaxes(grossSalary);</div><div class="line">        <span class="keyword">if</span> (taxedSalaryIsGreaterThanMinimumSalary(grossSalary)) &#123;</div><div class="line">            netSalary = grossSalary.subtract(taxes);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            netSalary = grossSalary;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> netSalary;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">taxedSalaryIsGreaterThanMinimumSalary</span><span class="params">(BigDecimal taxedSalary)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> taxedSalary.compareTo(minimumSalary) == <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeDAO</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> BigDecimal <span class="title">getAnnualSalary</span><span class="params">(<span class="keyword">long</span> employeeId)</span> </span>&#123;</div><div class="line">        <span class="comment">// conncetTODB</span></div><div class="line">        <span class="comment">// run select for employeeId;</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BigDecimal(<span class="number">70000</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaxCalculator</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> BigDecimal <span class="title">calculateTaxes</span><span class="params">(BigDecimal salary)</span> </span>&#123;</div><div class="line">        BigDecimal result = salary.multiply(<span class="keyword">new</span> BigDecimal(<span class="number">200</span>));</div><div class="line">        <span class="comment">// some other weird calculation ....</span></div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SalaryServiceTest</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> UserId = <span class="number">123l</span>;</div><div class="line"></div><div class="line">  <span class="meta">@InjectMocks</span></div><div class="line">  <span class="keyword">private</span> SalaryService salaryService;</div><div class="line"></div><div class="line">  <span class="meta">@Mock</span></div><div class="line">  <span class="keyword">private</span> EmployeeDAO employeeDAO;</div><div class="line"></div><div class="line">  <span class="meta">@Mock</span></div><div class="line">  <span class="keyword">private</span> TaxCalculator taxCalculator;</div><div class="line"></div><div class="line">  <span class="meta">@Before</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">      MockitoAnnotations.initMocks(<span class="keyword">this</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Test</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMinimumSalary</span><span class="params">()</span> </span>&#123;</div><div class="line">      BigDecimal annualSalary = <span class="keyword">new</span> BigDecimal(<span class="number">10000</span>);</div><div class="line">      Mockito.when(employeeDAO.getAnnualSalary(UserId)).thenReturn(annualSalary);</div><div class="line">      Mockito.when(taxCalculator.calculateTaxes(annualSalary)).thenReturn(<span class="keyword">new</span> BigDecimal(<span class="number">1000</span>));</div><div class="line">      BigDecimal actual = salaryService.getNetSalary(UserId);</div><div class="line">      assertThat(actual.compareTo(<span class="keyword">new</span> BigDecimal(<span class="number">10000</span>)), is(<span class="number">0</span>));</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Test</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMaximumSalary</span><span class="params">()</span> </span>&#123;</div><div class="line">      BigDecimal annualSalary = <span class="keyword">new</span> BigDecimal(<span class="number">80000</span>);</div><div class="line">      Mockito.when(employeeDAO.getAnnualSalary(UserId)).thenReturn(annualSalary);</div><div class="line">      Mockito.when(taxCalculator.calculateTaxes(annualSalary)).thenReturn(<span class="keyword">new</span> BigDecimal(<span class="number">8000</span>));</div><div class="line">      BigDecimal actual = salaryService.getNetSalary(UserId);</div><div class="line">      assertThat(actual.compareTo(<span class="keyword">new</span> BigDecimal(<span class="number">72000</span>)), is(<span class="number">0</span>));</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://www.vogella.com/tutorials/Mockito/article.html#prerequisites" target="_blank" rel="external">Mockito</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[zookeeper 安装]]></title>
      <url>http://zsr.github.io/2016/08/24/zookeeper-%E5%AE%89%E8%A3%85/</url>
      <content type="html"><![CDATA[<h1 id="Zookeeper-安装及配置（Mac）"><a href="#Zookeeper-安装及配置（Mac）" class="headerlink" title="Zookeeper 安装及配置（Mac）"></a>Zookeeper 安装及配置（Mac）</h1><p>Zookeeper 分布式服务框架是 Apache Hadoop 的一个子项目，它主要是用来解决分布式应用中经常遇到的一些数据管理问题，如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等。</p>
<h3 id="Zookeeper-的安装"><a href="#Zookeeper-的安装" class="headerlink" title="Zookeeper 的安装"></a>Zookeeper 的安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">下载地址：http://www.apache.org/dyn/closer.cgi/zookeeper</div></pre></td></tr></table></figure>
<p>首先从官网下载ZooKeeper压缩包，然后解压下载得到的ZooKeeper压缩包，发现有“bin，conf，lib”等目录。“bin目录”中存放有运行脚本；“conf目录”中存放有配置文件；“lib目录”中存放有运行所需要第三方库。<br>解压文件： </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar zxvf zookeeper-3.4.8.tar.gz</div></pre></td></tr></table></figure>
<h3 id="Zookeeper-的配置"><a href="#Zookeeper-的配置" class="headerlink" title="Zookeeper 的配置"></a>Zookeeper 的配置</h3><h4 id="伪分布式部署"><a href="#伪分布式部署" class="headerlink" title="伪分布式部署"></a>伪分布式部署</h4><ol>
<li>在“conf”目录下，新建一个名为“zoo.cfg”的文件，准备部署3个节点，其中内容如下：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">   tickTime=2000</div><div class="line">initLimit=5</div><div class="line">syncLimit=2</div><div class="line">dataDir=/Users/nali/program/zookeeper-3.4.8_1/data</div><div class="line">dataLogDir=/Users/nali/program/zookeeper-3.4.8_1/logs </div><div class="line">clientPort=2181(不同节点注意不同)</div><div class="line">server.1=127.0.0.1:2888:3888</div><div class="line">server.2=127.0.0.1:2889:3889</div><div class="line">server.3=127.0.0.1:2890:3890</div></pre></td></tr></table></figure>
<p><strong>参数说明:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">#tickTime: 客户端和服务端或者服务端多个节点之间维持心跳的时间间隔，单位毫秒。</div><div class="line"></div><div class="line">#initLimit：zookeeper集群中的包含多台server, 其中一台为leader, 集群中其余的server为follower.</div><div class="line">initLimit参数配置初始化连接时, follower和leader之间的最长心跳时间. 此时该参数设置为5, 说明时间限制为5   倍tickTime, 即5*2000=10000ms=10s.</div><div class="line"></div><div class="line">#syncLimit：该参数配置leader和follower之间发送消息, 请求和应答的最大时间长度. 此时该参数设置为2, 说明时间限制为2倍tickTime, 即4000ms.</div><div class="line"></div><div class="line">#dataDir: 数据文件存放目录,可以是任意目录</div><div class="line"></div><div class="line">#dataLogDir: 用来重做数据的事务日志文件存放目录.</div><div class="line"></div><div class="line">#clientPort: 监听client连接的端口号.</div><div class="line"></div><div class="line">#server.1，server.2，server.3: 表示节点编号，后边用冒号隔开的三个数字，分别表示节点的ip，交换数据的端口号，某个节点挂掉之后专门用来选举的端口号。</div></pre></td></tr></table></figure>
<font color="red">注：initLimit，syncLimit在单节点部署模式下，不需要配置。</font>

<ol>
<li>在dataDir目录下创建myid文件，写入该节点的编号 1 。这样一个节点就配置完成了。</li>
<li>复制 zookeeper-3.4.8-1 到 zookeeper-3.4.8-2和 zookeeper-3.4.8-3，要修改的地方是 zoo.cfg里的 dataDir,dataLogDir,clientPort。还有需要在自己的data目录下新建myid文件，写入自己的编号。</li>
</ol>
<table>
<thead>
<tr>
<th>myid</th>
<th>Data目录</th>
<th>Client</th>
<th>Server</th>
<th>Leader</th>
<th>配置文件</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>/zookeeper-3.4.8_1/data</td>
<td>2181</td>
<td>2888</td>
<td>3888</td>
<td>z1.cfg</td>
</tr>
<tr>
<td>2</td>
<td>/zookeeper-3.4.8_2/data</td>
<td>2182</td>
<td>2889</td>
<td>3889</td>
<td>z2.cfg</td>
</tr>
<tr>
<td>3</td>
<td>/zookeeper-3.4.8_3/data</td>
<td>2183</td>
<td>2890</td>
<td>3890</td>
<td>z3.cfg</td>
</tr>
</tbody>
</table>
<ol>
<li>启动和测试</li>
</ol>
<p>分别进入三个节点的bin目录，启动zookeeper，运行./zkServer.sh start。</p>
<p>注：前边节点启动的时候，会抛出一些错误，可忽略。这是因为另外的节点没启动，导致的通信异常。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">nalideMacBook-Pro-4:program nali$ <span class="built_in">cd</span> zookeeper-3.4.8_3/bin/</div><div class="line">nalideMacBook-Pro-4:bin nali$ ./zkServer.sh start</div><div class="line">ZooKeeper JMX enabled by default</div><div class="line">Using config: /Users/nali/program/zookeeper-3.4.8_3/bin/../conf/zoo.cfg</div><div class="line">Starting zookeeper ... STARTED</div></pre></td></tr></table></figure>
<p>​       </p>
<p>可以用自带的基于telnet的客户端测试一下，看看是否启动成功。随便进入一个节点的bin目录，比如节点0</p>
<p>./zkCli.sh -server 127.0.0.1:2180，随便输入一个字符，他会跳出help界面。说明服务端启动成功。  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">nalideMacBook-Pro-4:bin nali$ ./zkCli.sh -server 127.0.0.1:2181</div><div class="line">Connecting to 127.0.0.1:2181</div><div class="line">2016-08-25 21:02:28,712 [myid:] - INFO  [main:Environment@100] - Client environment:zookeeper.version=3.4.8--1, built on 02/06/2016 03:18 GMT</div><div class="line">2016-08-25 21:02:28,715 [myid:] - INFO  [main:Environment@100] - Client environment:host.name=192.168.120.222</div><div class="line">2016-08-25 21:02:28,715 [myid:] - INFO  [main:Environment@100] - Client environment:java.version=1.8.0_91</div><div class="line">2016-08-25 21:02:28,717 [myid:] - INFO  [main:Environment@100] - Client environment:java.vendor=Oracle Corporation</div><div class="line">2016-08-25 21:02:28,717 [myid:] - INFO  [main:Environment@100] - Client environment:java.home=/Library/Java/JavaVirtualMachines/jdk1.8.0_91.jdk/Contents/Home/jre</div><div class="line">2016-08-25 21:02:28,717 [myid:] - INFO  [main:Environment@100] - Client environment:java.class.path=/Users/nali/program/zookeeper-3.4.8_1/bin/../build/classes:/Users/nali/program/zookeeper-3.4.8_1/bin/../build/lib/*.jar:/Users/nali/program/zookeeper-3.4.8_1/bin/../lib/slf4j-log4j12-1.6.1.jar:/Users/nali/program/zookeeper-3.4.8_1/bin/../lib/slf4j-api-1.6.1.jar:/Users/nali/program/zookeeper-3.4.8_1/bin/../lib/netty-3.7.0.Final.jar:/Users/nali/program/zookeeper-3.4.8_1/bin/../lib/<span class="built_in">log</span>4j-1.2.16.jar:/Users/nali/program/zookeeper-3.4.8_1/bin/../lib/jline-0.9.94.jar:/Users/nali/program/zookeeper-3.4.8_1/bin/../zookeeper-3.4.8.jar:/Users/nali/program/zookeeper-3.4.8_1/bin/../src/java/lib/*.jar:/Users/nali/program/zookeeper-3.4.8_1/bin/../conf:</div><div class="line">2016-08-25 21:02:28,718 [myid:] - INFO  [main:Environment@100] - Client environment:java.library.path=/Users/nali/Library/Java/Extensions:/Library/Java/Extensions:/Network/Library/Java/Extensions:/System/Library/Java/Extensions:/usr/lib/java:.</div><div class="line">2016-08-25 21:02:28,718 [myid:] - INFO  [main:Environment@100] - Client environment:java.io.tmpdir=/var/folders/jr/rgnrtr4n13n3d6tbwsch9_qr0000gn/T/</div><div class="line">2016-08-25 21:02:28,718 [myid:] - INFO  [main:Environment@100] - Client environment:java.compiler=&lt;NA&gt;</div><div class="line">2016-08-25 21:02:28,718 [myid:] - INFO  [main:Environment@100] - Client environment:os.name=Mac OS X</div><div class="line">2016-08-25 21:02:28,719 [myid:] - INFO  [main:Environment@100] - Client environment:os.arch=x86_64</div><div class="line">2016-08-25 21:02:28,719 [myid:] - INFO  [main:Environment@100] - Client environment:os.version=10.11.4</div><div class="line">2016-08-25 21:02:28,719 [myid:] - INFO  [main:Environment@100] - Client environment:user.name=nali</div><div class="line">2016-08-25 21:02:28,719 [myid:] - INFO  [main:Environment@100] - Client environment:user.home=/Users/nali</div><div class="line">2016-08-25 21:02:28,719 [myid:] - INFO  [main:Environment@100] - Client environment:user.dir=/Users/nali/program/zookeeper-3.4.8_1/bin</div><div class="line">2016-08-25 21:02:28,721 [myid:] - INFO  [main:ZooKeeper@438] - Initiating client connection, connectString=127.0.0.1:2181 sessionTimeout=30000 watcher=org.apache.zookeeper.ZooKeeperMain<span class="variable">$MyWatcher</span>@531d72ca</div><div class="line">Welcome to ZooKeeper!</div></pre></td></tr></table></figure>
<ol>
<li>Zookeeper常用命令<ul>
<li>ZooKeeper服务端命令:<ul>
<li>启动ZK服务:  bin/zkServer.sh start</li>
<li>查看ZK服务状态: bin/zkServer.sh status</li>
<li>停止ZK服务:  bin/zkServer.sh stop</li>
<li>重启ZK服务:  bin/zkServer.sh restart</li>
</ul>
</li>
<li>zk客户端命令<ul>
<li>显示根目录下、文件： ls / 使用 ls 命令来查看当前 ZooKeeper 中所包含的内容</li>
<li>显示根目录下、文件： ls2 / 查看当前节点数据并能看到更新次数等数据</li>
<li>创建文件，并设置初始内容： create /zk “test” 创建一个新的 znode节点“ zk ”以及与它关联的字符</li>
<li>获取文件内容： get /zk 确认 znode 是否包含我们所创建的字符串</li>
<li>修改文件内容： set /zk “zkbak” 对 zk 所关联的字符串进行设置</li>
<li>删除文件： delete /zk 将刚才创建的 znode 删除</li>
<li>退出客户端： quit</li>
<li>帮助命令： help</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>zookeeper仅仅是维护了一个分布式的树形目录。如下图。它通过<a href="http://baike.baidu.com/view/8438269.htm" target="_blank" rel="external">fast paxos算法</a>保证多个节点上znode的数据一致性。一套zookeeper可以同时给多个应用程序使用，只需要隔离好各自的path~。在生产环境中，多个程序，比如hadoop，hbase，strom共用一套zookeeper也是常事。结构如下图。</p>
<p><img src="http://dl2.iteye.com/upload/attachment/0099/3476/b395cbf0-55aa-387e-af65-b5bcd9fcf234.jpg" alt="img"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Guava cache]]></title>
      <url>http://zsr.github.io/2016/08/24/Guava-cache/</url>
      <content type="html"><![CDATA[<h1 id="Guava-Cache"><a href="#Guava-Cache" class="headerlink" title="Guava Cache"></a>Guava Cache</h1><p>Guava cache是一个应用内缓存(一般作为应用的本地缓存，redis作为集中式分布式缓存)。</p>
<p>一个缓存需要考虑的问题：</p>
<ul>
<li>缓存读取失败如何加载数据</li>
<li>加载策略（同步还是异步）</li>
<li>缓存过期问题</li>
<li>统计缓存命中情况</li>
<li>缓存数据失效时设置监听</li>
<li>缓存满时替换策略（LRU、FIFO）</li>
<li>……</li>
</ul>
<h3 id="Guava简单的示例："><a href="#Guava简单的示例：" class="headerlink" title="Guava简单的示例："></a>Guava简单的示例：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</div><div class="line">    CacheLoader&lt;String, String&gt; loader = <span class="keyword">new</span> CacheLoader&lt;String, String&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">load</span><span class="params">(String key)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">            System.out.println(<span class="string">"call.."</span>);</div><div class="line">            <span class="keyword">return</span> key.toUpperCase();</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">//fluent风格...</span></div><div class="line">    LoadingCache&lt;String, String&gt; cache = CacheBuilder.newBuilder().build(loader);</div><div class="line">    System.out.println(cache.size());</div><div class="line">    System.out.println(cache.getUnchecked(<span class="string">"aaa"</span>));</div><div class="line">    System.out.println(cache.size());</div><div class="line">    System.out.println(cache.getUnchecked(<span class="string">"aaa"</span>));</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        System.out.println(cache.get(<span class="string">"cjp"</span>));</div><div class="line">    &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</div><div class="line">        <span class="comment">// TODO Auto-generated catch block</span></div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该示例中，仅仅将一个类型是字符串作为key，value为它的大写形式。运行的结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">0</div><div class="line">call..</div><div class="line">AAA</div><div class="line">1</div><div class="line">AAA</div><div class="line">call..</div><div class="line">CJP</div></pre></td></tr></table></figure>
<p>Guava的缓存是一个LoadingCache实例，通过CacheBuilder创建该实例，并传入一个CacheLoader，CacheLoader实例注明了在缓存读取失败时如何加载数据，开始时，缓存中没有任何数据，size为0，当取aaa的时候，触发了缓存加载数据，输出call…，虽然缓存的size变成了1。然后再取aaa时，因为缓存中已经有了该key对应的value，就没有触发加载。</p>
<p>需要注意一下getUnchecked方法和get方法的不同，前者不对可能的异常做检查，调用代码不需要显式的捕捉异常，而后者调用代码需要显式的捕获异常。</p>
<p>这是一个非常简单的示例，可以看到使用guava实现一个缓存非常简单，如果将创建CacheLoader实例和build LoadingCache的两行代码合并，使用仅一行代码就可以实现一个缓存，并且Guava的缓存是线程安全的，可以放心的在多线程的环境中使用。</p>
<h3 id="复杂一点的例子"><a href="#复杂一点的例子" class="headerlink" title="复杂一点的例子:"></a>复杂一点的例子:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="comment">//缓存同步删除</span></div><div class="line">    LoadingCache&lt;String, String&gt; cache = CacheBuilder.newBuilder().expireAfterWrite(<span class="number">5</span>, TimeUnit.SECONDS).maximumSize(<span class="number">3</span>).recordStats().removalListener(<span class="keyword">new</span> RemovalListener&lt;String, String&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRemoval</span><span class="params">(RemovalNotification&lt;String, String&gt; notification)</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"remove key["</span> + notification.getKey() + <span class="string">"],value["</span> + notification.getValue() + <span class="string">"],remove reason["</span> + notification.getCause() + <span class="string">"]"</span>);</div><div class="line">            System.out.println(<span class="string">"remove thread name "</span> + Thread.currentThread().getName());</div><div class="line">        &#125;</div><div class="line">    &#125;).build(<span class="keyword">new</span> CacheLoader&lt;String, String&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">load</span><span class="params">(String key)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">            System.out.println(<span class="string">"key["</span> + key + <span class="string">"] to upper case"</span>);</div><div class="line">            <span class="keyword">return</span> key.toUpperCase();</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    System.out.println(cache.getUnchecked(<span class="string">"a"</span>));</div><div class="line">    System.out.println(cache.getUnchecked(<span class="string">"b"</span>));</div><div class="line">    System.out.println(<span class="string">"thread name "</span> + Thread.currentThread().getName());</div><div class="line">    cache.invalidate(<span class="string">"b"</span>);<span class="comment">//删除key为b的值</span></div><div class="line">    System.out.println(cache.getUnchecked(<span class="string">"a"</span>));</div><div class="line">    Thread.sleep(<span class="number">5000</span>);</div><div class="line">    System.out.println(cache.getUnchecked(<span class="string">"c"</span>));</div><div class="line">    System.out.println(cache.getUnchecked(<span class="string">"a"</span>));</div><div class="line">    System.out.println(cache.stats().toString());</div><div class="line">    System.out.println(<span class="string">"end"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">key[a] to upper <span class="keyword">case</span></div><div class="line">A</div><div class="line">key[b] to upper <span class="keyword">case</span></div><div class="line">B</div><div class="line">thread name main</div><div class="line">remove key[b],value[B],remove reason[EXPLICIT]</div><div class="line">remove thread name main A</div><div class="line">remove key[a],value[A],remove reason[EXPIRED]</div><div class="line">remove thread name main key[c] to upper <span class="keyword">case</span></div><div class="line">C</div><div class="line">key[a] to upper <span class="keyword">case</span></div><div class="line">A</div><div class="line">CacheStats&#123;hitCount=1, missCount=4, loadSuccessCount=4, loadExceptionCount=0, totalLoadTime=3460000, evictionCount=1&#125;</div><div class="line">end</div></pre></td></tr></table></figure>
<p>创建了一个稍复杂的LoadingCache实例。各方法意义如下：</p>
<p><strong>expireAfterWrite</strong>：写入缓存后的过期时间<br><strong>maximumSize</strong>：缓存的最多存放元素个数<br><strong>recordStats</strong>：对缓存命中情况进行统计<br><strong>removalListener</strong>：设置缓存数据失效时监听器</p>
<p>Guava中很多地方都是这种fluent的方式.</p>
<p>在删除的监听器中打印线程的名字是为了显示该监听器是同步的还是异步的。可以看到删除监听是同步的，因为和主线程的名字是一样的，其实可以理解，因为我们并没有指定额外的线程池。删除监听器中可以看到删除的key、value、cause。主线程sleep 5s后，缓存中key为a的元素就过期了，可以看到监听器被调用，最后通过cache.stats()取得缓存命中的情况统计。可以看到命中1次，miss了4次（load了4次），事实上的确如此。</p>
<p>可以通过RemovalListeners.asynchronous方法就可以创建一个异步的listener对象。如下方式创建LoadingCache：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">LoadingCache&lt;String, String&gt; cache = CacheBuilder.newBuilder().expireAfterWrite(<span class="number">5</span>, TimeUnit.SECONDS).maximumSize(<span class="number">3</span>).recordStats().removalListener(RemovalListeners.asynchronous(<span class="keyword">new</span> RemovalListener&lt;String, String&gt;() &#123;</div><div class="line">    <span class="comment">//删除缓存监听器异步删除</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRemoval</span><span class="params">(RemovalNotification&lt;String, String&gt; notification)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"remove key["</span> + notification.getKey() + <span class="string">"],value["</span> + notification.getValue() + <span class="string">"],remove reason["</span> + notification.getCause() + <span class="string">"]"</span>);</div><div class="line">        System.out.println(<span class="string">"remove thread name "</span> + Thread.currentThread().getName());</div><div class="line">    &#125;</div><div class="line">&#125;, Executors.newCachedThreadPool())).build(<span class="keyword">new</span> CacheLoader&lt;String, String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">load</span><span class="params">(String key)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        System.out.println(<span class="string">"key["</span> + key + <span class="string">"] to upper case"</span>);</div><div class="line">        <span class="keyword">return</span> key.toUpperCase();</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>RemovalListeners.asynchronous方法接受两个参数，第一个参数是RemovalListener对象，第二个参数接收一个线程池，这样就可以异步的设置删除监听器了。运行可以看到主线程的线程名和监听器中的线程名是不同的。</p>
<p>上面创建缓存的方式是通过expireAfterWrite指定元素的过期时间，达到重新加载的。也就是说当过期后，这个元素就不存在了，再获取的时候就要通过load重新加载，当加载的时候，获取value的主线程必须同步的等缓存加载完获得数据后才能继续执行。这在一定程度上限制了访问速度。</p>
<p>如果数据量不大的情况下，就不必使用过期时间这种方式，而使用刷新，使用refreshAfterWrite指定刷新的时间间隔。看如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    LoadingCache&lt;String, String&gt; cache = CacheBuilder.newBuilder().recordStats().refreshAfterWrite(<span class="number">3</span>, TimeUnit.SECONDS).build(<span class="keyword">new</span> CacheLoader&lt;String, String&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">load</span><span class="params">(String key)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">            System.out.println(<span class="string">"load key["</span> + key + <span class="string">"]"</span>);</div><div class="line">            <span class="keyword">return</span> key.toUpperCase();</div><div class="line">        &#125;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> ListenableFuture&lt;String&gt; <span class="title">reload</span><span class="params">(String key, String oldValue)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">            System.out.println(<span class="string">"reload key["</span> + key + <span class="string">"],oldValue["</span> + oldValue + <span class="string">"]"</span>);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.reload(key, oldValue);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    System.out.println(cache.getUnchecked(<span class="string">"a"</span>));</div><div class="line">    System.out.println(cache.getUnchecked(<span class="string">"b"</span>));</div><div class="line">    cache.refresh(<span class="string">"a"</span>);</div><div class="line">    Thread.sleep(<span class="number">3000</span>);</div><div class="line">    System.out.println(cache.getUnchecked(<span class="string">"a"</span>));</div><div class="line">    System.out.println(cache.getUnchecked(<span class="string">"c"</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是一个非常简单的refresh示例，如果使用refreshAfterWrite，需要实现CacheLoader的reload方法，如果不实现，他有一个默认的实现，就是本示例展示的代码，直接调用load方法。代码的运行结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">load key[a]</div><div class="line">A</div><div class="line">load key[b] B</div><div class="line">reload key[a],oldValue[A]</div><div class="line">load key[a] reload key[a],oldValue[A]</div><div class="line">load key[a] A</div><div class="line">load key[c] C</div></pre></td></tr></table></figure>
<p>本例中刷新的时间设置为3s，再第一次显式的调用<code>cache.refresh(&quot;a&quot;)</code>的时候，可以看到reload方法被调用了。但是reload直接走默认的实现，调用了load方法，所以接着就输出了<code>load key[a]</code>当主线程sleep 3s后，再取a的值时因为超过刷新间隔，又会调用reload方法。可以想象这里的reload肯定是以同步的方式进行的，因为我们并没有指定额外的线程池用来执行reload方法，也就是说当到达刷新时间间隔后，取value的主线程还是要等refresh结束，才能拿到数据后执行，这和刚才的expireAfterWrite方式差不多。Guava提供了异步刷新的方式,看代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 缓存失效时异步重现加载，缓存调用者永远不用阻塞等</div><div class="line"> *</div><div class="line"> * <span class="doctag">@throws</span> InterruptedException</div><div class="line"> */</div><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    LoadingCache&lt;String, String&gt; cache = CacheBuilder.newBuilder().recordStats().refreshAfterWrite(<span class="number">3</span>, TimeUnit.SECONDS).build(<span class="keyword">new</span> CacheLoader&lt;String, String&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">load</span><span class="params">(String key)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">            System.out.println(<span class="string">"load key["</span> + key + <span class="string">"]"</span>);</div><div class="line">            <span class="keyword">return</span> key.toUpperCase();</div><div class="line">        &#125;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> ListenableFuture&lt;String&gt; <span class="title">reload</span><span class="params">(<span class="keyword">final</span> String key, String oldValue)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">            ListenableFutureTask&lt;String&gt; task = ListenableFutureTask.create(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                    System.out.println(<span class="string">"reload key["</span> + key + <span class="string">"] synchronize at thread["</span> + Thread.currentThread().getName() + <span class="string">"],this will take 1 second..."</span>);</div><div class="line">                    Thread.sleep(<span class="number">1000</span>);</div><div class="line">                    System.out.println(<span class="string">"reload end..."</span>);</div><div class="line">                    <span class="keyword">return</span> key.toUpperCase();</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">            Executors.newCachedThreadPool().execute(task);</div><div class="line">            System.out.println(<span class="string">"reload key["</span> + key + <span class="string">"],oldValue["</span> + oldValue + <span class="string">"]"</span>);</div><div class="line">            <span class="keyword">return</span> task;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    <span class="comment">//注意：如果重来没有被get过，在缓存中完全没有，第一次调用会执行load，然后加入到cache中，只有被加入到其中的</span></div><div class="line">    <span class="comment">//到达失效时间后，再被加载的时候才会触发reload</span></div><div class="line">    System.out.println(cache.getUnchecked(<span class="string">"a"</span>));</div><div class="line">    System.out.println(cache.getUnchecked(<span class="string">"b"</span>));</div><div class="line">    cache.refresh(<span class="string">"a"</span>);</div><div class="line">    Thread.sleep(<span class="number">3000</span>);</div><div class="line">    <span class="comment">//这里的取a 不会触发reload，因为上面refresh需要耗1s才能结束，而主线程这里只需要等3s</span></div><div class="line">    <span class="comment">//所以这里的a还有1s的存活时间</span></div><div class="line">    System.out.println(cache.getUnchecked(<span class="string">"a"</span>));</div><div class="line">    <span class="comment">//但是这里的b 就必须reload了，但是reload的过程需要注意下：先调用load方法，然后发现失效了，但是还会返回之前</span></div><div class="line">    <span class="comment">//缓存中的值，同时会加载reload，因为是异步reload，主线程这里不用等reload结束，继续向下运行获取c的值</span></div><div class="line">    System.out.println(cache.getUnchecked(<span class="string">"b"</span>));</div><div class="line">    System.out.println(cache.getUnchecked(<span class="string">"c"</span>));</div><div class="line">    <span class="comment">//这里再暂停5s是为了看清楚上面reload b的结束</span></div><div class="line">    Thread.sleep(<span class="number">5000</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>本示例依然设置refresh时间为3s。重点是reload方法，先打印出reload执行所在的线程名，为了能清楚的看到主线程不需要等refresh完，这里sleep了1s。其他代码跟之前的差不多，运行结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">load key[a]</div><div class="line">A</div><div class="line">load key[b] B</div><div class="line">reload key[a],oldValue[A]</div><div class="line">reload key[a] synchronize at thread[pool-1-thread-1],this will take 1 second...</div><div class="line">reload end...</div><div class="line">A</div><div class="line">reload key[b],oldValue[B]</div><div class="line">B</div><div class="line">load key[c] C</div><div class="line">reload key[b] synchronize at thread[pool-2-thread-1],this will take 1 second...</div><div class="line">reload end...</div></pre></td></tr></table></figure>
<p>当执行<code>cache.refresh(&quot;a&quot;)</code>代码的时候，调用了reload方法，可以看到reload所在线程名是线程池中的。这句代码紧接着主线程sleep了3s，然后又去取a的值，按理说这时候a应该到达了刷新的时间间隔了，但是因为之前的reload方法执行就需要1s，所以对于a来说，还有1s的刷新时间剩余，所以这时取a的值，并不会触发reload。而紧接着取b的值就不同了，因为b没有被refresh过，这时候取b的值达到了刷新的时间间隔，所以会触发reload b。但是因为是异步的刷新，主线程根本不用等刷新完，所以立即输出了原来旧的值B，并立即输出了load c的结果，然后才看到 reload b的过程在继续进行，直到结束。</p>
<p>异步刷新，主线程永远不用等缓存的加载！现在在工作中所有使用Guava cahe的地方全部采用这种方式。</p>
<p><strong>注意如下几点：</strong></p>
<ul>
<li>refreshAfterWrite和expireAfterWrite的区别<ul>
<li>refreshAfterWrite只不过在刷新时间间隔到的时候，调用reload方法获取对于的key对于的value后替换当前内存中的key值。原来内存中的key对于的value是一直存在的。</li>
<li>expireAfterWrite方式当达到过期时间后，内存中的对应的key-value就被删除了（应该是被动删除方式，其实还在内存中，获取key的瞬间被删除）。只能通过load方法重新加载key对于的value。</li>
</ul>
</li>
<li>refresh方式并不是达到时间间隔后就立即刷新，而是在get数据的时候，发现超过刷新时间间隔了才会刷新，是被动的方式。</li>
<li>只有缓存中存在的key，在到达刷新时间时，才会通过reload刷新，如果缓存中没有对应key的value，第一次永远是调用load加载数据。</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Guava future]]></title>
      <url>http://zsr.github.io/2016/08/24/Guava-future/</url>
      <content type="html"><![CDATA[<h2 id="Guava-Future"><a href="#Guava-Future" class="headerlink" title="Guava Future"></a>Guava Future</h2><h3 id="同步、异步、阻塞、非阻塞"><a href="#同步、异步、阻塞、非阻塞" class="headerlink" title="同步、异步、阻塞、非阻塞"></a>同步、异步、阻塞、非阻塞</h3><ul>
<li><p>同步：所谓同步，就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。也就是必须一件一件事做,等前一件做完了才能做下一件事。</p>
</li>
<li><p>异步：异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。</p>
</li>
<li><p>阻塞：阻塞调用是指调用结果返回之前，当前线程会被挂起（线程进入非可执行状态，在这个状态下，cpu不会给线程分配时间片，即线程暂停运行）。函数只有在得到结果之后才会返回。</p>
</li>
<li><p>非阻塞：非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。</p>
</li>
</ul>
<h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>线程的并发方式一般有两种：</p>
<ul>
<li>异步执行一个任务，不需要返回结果</li>
<li>需要异步执行返回结果</li>
</ul>
<p>第一种，直接往线程池中仍Runnable对象，代码大概如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Executors.newCachedThreadPool().execute(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//do something</span></div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>第二种，一般有两种情况：</p>
<ul>
<li>主线程block到数据</li>
<li>设置回调</li>
</ul>
<p>JDK提供的方式就是主线程block到数据，类似如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Future&lt;Object&gt; future = Executors.newCachedThreadPool().submit(<span class="keyword">new</span> Callable&lt;Object&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">Object data = future.get();<span class="comment">//block直到拿到数据</span></div></pre></td></tr></table></figure>
<p>这种方式缺点很显然，主线程阻塞。而JDK对Future设置回调没有相应的方法，Guava扩展了这一点，引入ListenableFuture，可以对ListenableFuture设置回调。</p>
<a id="more"></a>
<h2 id="ListenableFuture"><a href="#ListenableFuture" class="headerlink" title="ListenableFuture"></a>ListenableFuture</h2><p>Guava为Java并行编程Future提供了很多有用扩展，其主要接口为ListenableFuture，并借助于Futures静态扩展。获得ListenableFuture实例有两种方法：</p>
<ul>
<li>向装饰后的线程池中提交callable</li>
<li>将普通的future转换为listenableFuture</li>
</ul>
<p>继承至Future的ListenableFuture，允许我们添加回调函数在线程运算完成时返回值或者方法执行完成立即返回。</p>
<p>对ListenableFuture添加回调函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Futures.addCallback(ListenableFuture&lt;V&gt;, FutureCallback&lt;V&gt;, Executor)</div></pre></td></tr></table></figure>
<p>其中 FutureCallback是一个包含onSuccess(V),onFailure(Throwable)的接口。</p>
<p>使用如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Futures.addCallback(ListenableFuture, <span class="keyword">new</span> FutureCallback&lt;Object&gt;() &#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(Object result)</span> </span>&#123;</div><div class="line">        System.out.printf(<span class="string">"onSuccess with: %s%n"</span>, result);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Throwable thrown)</span> </span>&#123;</div><div class="line">        System.out.printf(<span class="string">"onFailure %s%n"</span>, thrown.getMessage());</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>同时Guava中Futures对于Future扩展还有：</p>
<ul>
<li>transform：对于ListenableFuture的返回值进行转换。</li>
<li>allAsList：对多个ListenableFuture的合并，返回一个当所有Future成功时返回多个Future返回值组成的List对象。注：当其中一个Future失败或者取消的时候，将会进入失败或者取消。</li>
<li>successfulAsList：和allAsList相似，唯一差别是对于失败或取消的Future返回值用null代替。不会进入失败或者取消流程。</li>
<li>immediateFuture/immediateCancelledFuture： 立即返回一个待返回值的ListenableFuture。</li>
<li>makeChecked: 将ListenableFuture 转换成CheckedFuture。CheckedFuture 是一个ListenableFuture ，其中包含了多个版本的get 方法，方法声明抛出检查异常.这样使得创建一个在执行逻辑中可以抛出异常的Future更加容易</li>
<li>JdkFutureAdapters.listenInPoolThread(future): guava同时提供了将JDK Future转换为ListenableFuture的接口函数。</li>
</ul>
<h3 id="装饰线程池"><a href="#装饰线程池" class="headerlink" title="装饰线程池"></a>装饰线程池</h3><p>Guava提供了方法将JDK的线程池装饰成一个“可监听的线程池”。看如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">3</span>, <span class="keyword">new</span> ThreadFactory() &#123;</div><div class="line">        <span class="keyword">private</span> AtomicLong index = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable runnable)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Thread(runnable, <span class="string">"commons-thread-"</span> + index.incrementAndGet());</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    ListeningExecutorService listeningExecutorService = MoreExecutors.listeningDecorator(threadPool);</div><div class="line">    ListenableFuture&lt;String&gt; listenableFuture = listeningExecutorService.submit(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">            Thread.sleep(<span class="number">3000</span>);</div><div class="line">            <span class="comment">//System.out.println(1 / 0);</span></div><div class="line">            <span class="keyword">return</span> <span class="string">"world"</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"> 	<span class="comment">//1)监听</span></div><div class="line">    listenableFuture.addListener(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"can't get return value"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;, MoreExecutors.directExecutor());</div><div class="line"></div><div class="line">    <span class="comment">//2)回调</span></div><div class="line">    Futures.addCallback(listenableFuture, <span class="keyword">new</span> FutureCallback&lt;String&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(String result)</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"the result of future is: "</span> + result);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Throwable t)</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"exception:"</span> + t.getMessage());</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    Thread.sleep(<span class="number">5000</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码先定义了普通的线程池，Guava通过<code>MoreExecutors.listeningDecorator(threadPool)</code>将普通的线程池装饰成一个可监听的线程池，向装饰后的线程池中提交callable，就可以获得listenableFuture实例了。</p>
<p>可以对listenableFuture设置listener(方法：addListener )，同时指定listen执行的线程池，也可以设置回调(方法：Futures.addCallback )，获取listenableFuture的结果。</p>
<ul>
<li><p>方法一：通过ListenableFuture的addListener方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">listenableFuture.addListener(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    System.out.println(<span class="string">"get listenable future's result "</span> + listenableFuture.get());</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;, executorService);</div></pre></td></tr></table></figure>
</li>
<li><p>方法二：通过Futures的静态方法addCallback给ListenableFuture添加回调函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Futures.addCallback(listenableFuture, <span class="keyword">new</span> FutureCallback&lt;Integer&gt;() &#123;</div><div class="line">              <span class="meta">@Override</span></div><div class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(Integer result)</span> </span>&#123;</div><div class="line">                  System.out.println(<span class="string">"get listenable future's result with callback "</span> + result);</div><div class="line">              &#125;</div><div class="line"></div><div class="line">              <span class="meta">@Override</span></div><div class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Throwable t)</span> </span>&#123;</div><div class="line">                  t.printStackTrace();</div><div class="line">              &#125;</div><div class="line">          &#125;);</div></pre></td></tr></table></figure>
</li>
</ul>
<p>推荐使用第二种方法，因为第二种方法可以直接得到Future的返回值，或者处理错误情况。本质上第二种方法是通过调动第一种方法实现的，做了进一步的封装。</p>
<p>另外ListenableFuture接口还有其他几种内置具体实现：</p>
<ul>
<li>SettableFuture：不需要实现一个方法来计算返回值，而只需要返回一个固定值来做为返回值，可以通过程序设置此Future的返回值或者异常信息</li>
<li>CheckedFuture： 这是一个继承自ListenableFuture接口，他提供了checkedGet()方法，此方法在Future执行发生异常时，可以抛出指定类型的异常。</li>
</ul>
<p>可以在callable内部捕获异常，也可以抛出，在回调的onFailure中处理异常。</p>
<p>上面演示的是对JDK普通的线程池，当然也可以对时间调度的线程池进行装饰。示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 演示定时调度线程池装饰成listen的效果</div><div class="line"> *</div><div class="line"> * <span class="doctag">@throws</span> InterruptedException</div><div class="line"> */</div><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    ListeningScheduledExecutorService listeningScheduledExecutorService = MoreExecutors.listeningDecorator(Executors.newScheduledThreadPool(<span class="number">3</span>));</div><div class="line">    <span class="comment">//只有callable才对应有future</span></div><div class="line">    ListenableScheduledFuture&lt;?&gt; listenableScheduledFuture = listeningScheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"hello world"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;, <span class="number">5</span>, <span class="number">3</span>, TimeUnit.SECONDS);</div><div class="line"></div><div class="line">    <span class="comment">//因为上面的传的是runnable，所以没有返回值，没有返回值就不会触发future的callBack</span></div><div class="line">    Futures.addCallback(listenableScheduledFuture, <span class="keyword">new</span> FutureCallback&lt;Object&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(Object result)</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"not result: "</span> + result);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Throwable t)</span> </span>&#123;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    Thread.sleep(<span class="number">12000</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>装饰后的可监听的时间调度线程池使用方式和原来一样。这里调度了一个runnable对象。延迟5s后，每3s执行一次。因为runnable没有返回值，所以下面的回调不会被调用。当然可以向装饰后的线程池中提交callable，这样回调就会执行。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    ListeningScheduledExecutorService listeningScheduledExecutorService = MoreExecutors.listeningDecorator(Executors.newScheduledThreadPool(<span class="number">3</span>));</div><div class="line">    ListenableScheduledFuture&lt;String&gt; schedule = listeningScheduledExecutorService.schedule(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">"world"</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;, <span class="number">3</span>, TimeUnit.SECONDS);</div><div class="line">    Futures.addCallback(schedule, <span class="keyword">new</span> FutureCallback&lt;String&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(String result)</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"hello "</span> + result);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Throwable t)</span> </span>&#123;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    Thread.sleep(<span class="number">4000</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="将Future转换为ListenerableFuture"><a href="#将Future转换为ListenerableFuture" class="headerlink" title="将Future转换为ListenerableFuture"></a>将Future转换为ListenerableFuture</h3><p>Guava提供了方法将普通的future转换为listenerableFuture，以便于添加回调。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 演示将jdk的future转换为ListenableFuture</div><div class="line"> */</div><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</div><div class="line">    ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">3</span>);</div><div class="line">    System.out.println(Thread.currentThread().getName());</div><div class="line">    Future&lt;String&gt; future = threadPool.submit(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">            System.out.println(Thread.currentThread().getName());</div><div class="line">            <span class="keyword">return</span> <span class="string">"world"</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    ListenableFuture&lt;String&gt; listenableFuture = JdkFutureAdapters.listenInPoolThread(future);</div><div class="line">    Futures.addCallback(listenableFuture, <span class="keyword">new</span> FutureCallback&lt;String&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(String result)</span> </span>&#123;</div><div class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">": hello "</span> + result);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Throwable t)</span> </span>&#123;</div><div class="line">        &#125;</div><div class="line">    &#125;, threadPool);<span class="comment">//MoreExecutors.directExecutor();这种方式拿到的线程池还是当前的现场环境，还是同步的。</span></div><div class="line">  System.out.println(<span class="string">"end."</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过<code>JdkFutureAdapters.listenInPoolThread(future)</code>转换一个普通的future。设置回调时，可以指定回调执行的线程池。</p>
<p>Guava提供的listenerableFuture处理可以设置回调，还能通过function进行变换。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[java future]]></title>
      <url>http://zsr.github.io/2016/08/23/java-future/</url>
      <content type="html"><![CDATA[<h2 id="Callable、Future和FutureTask"><a href="#Callable、Future和FutureTask" class="headerlink" title="Callable、Future和FutureTask"></a>Callable、Future和FutureTask</h2><p>创建线程的2种方式，一种是直接继承Thread，另外一种就是实现Runnable接口。这2种方式都有一个缺陷就是：在执行完任务之后无法获取执行结果。</p>
<p>如果需要获取执行结果，就必须通过共享变量或者使用线程通信的方式来达到效果，这样使用起来就比较麻烦。而自从Java 1.5开始，就提供了Callable和Future，通过它们可以在任务执行完毕之后得到任务执行结果。</p>
<h3 id="Callable与Runnable"><a href="#Callable与Runnable" class="headerlink" title="Callable与Runnable"></a>Callable与Runnable</h3><p>java.lang.Runnable:它是一个接口，在它里面只声明了一个run()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于run()方法返回值为void类型，所以在执行完任务之后无法返回任何结果。</p>
<p>Callable位于java.util.concurrent包下，它也是一个接口，在它里面也只声明了一个方法call()：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Computes a result, or throws an exception if unable to do so.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@return</span> computed result</div><div class="line">     * <span class="doctag">@throws</span> Exception if unable to compute a result</div><div class="line">     */</div><div class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是一个泛型接口，call()函数返回的类型就是传递进来的V类型。<br>一般情况下是配合ExecutorService来使用的，在ExecutorService接口中声明了若干个submit方法的重载版本：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</div><div class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</div><div class="line">Future&lt;?&gt; submit(Runnable task);</div></pre></td></tr></table></figure>
<p>第一个submit方法里面的参数类型就是Callable。<br>一般情况下使用第一个submit方法和第三个submit方法，第二个submit方法很少使用。</p>
<h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><p>Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果。</p>
<p>Future类位于java.util.concurrent包下，它是一个接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</div><div class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</div><div class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></div><div class="line">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在Future接口中声明了5个方法，下面依次解释每个方法的作用：</p>
<ul>
<li>cancel方法用来取消任务，如果取消任务成功则返回true，如果取消任务失败则返回false。参数mayInterruptIfRunning表示是否允许取消正在执行却没有执行完毕的任务，如果设置true，则表示可以取消正在执行过程中的任务。如果任务已经完成，则无论mayInterruptIfRunning为true还是false，此方法肯定返回false，即如果取消已经完成的任务会返回false；如果任务正在执行，若mayInterruptIfRunning设置为true，则返回true，若mayInterruptIfRunning设置为false，则返回false；如果任务还没有执行，则无论mayInterruptIfRunning为true还是false，肯定返回true。</li>
<li>isCancelled方法表示任务是否被取消成功，如果在任务正常完成前被取消成功，则返回 true。</li>
<li>isDone方法表示任务是否已经完成，若任务完成，则返回true；</li>
<li>get()方法用来获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回；</li>
<li>get(long timeout, TimeUnit unit)用来获取执行结果，如果在指定时间内，还没获取到结果，就直接返回null。</li>
</ul>
<p>也就是说Future提供了三种功能：</p>
<ul>
<li>1)判断任务是否完成；</li>
<li>2)能够中断任务；</li>
<li>3)能够获取任务执行结果。</li>
</ul>
<p>因为Future只是一个接口，所以是无法直接用来创建对象使用的，因此就有了FutureTask。</p>
<a id="more"></a>
<h4 id="Callable-Future-获取执行结果"><a href="#Callable-Future-获取执行结果" class="headerlink" title="Callable+Future 获取执行结果"></a>Callable+Future 获取执行结果</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.Date;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.Future;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        Thread.sleep(<span class="number">1000</span>);</div><div class="line">        <span class="comment">//return the thread name executing this callable task</span></div><div class="line">        <span class="keyword">return</span> Thread.currentThread().getName();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">        <span class="comment">//Get ExecutorService from Executors utility class, thread pool size is 10</span></div><div class="line">        ExecutorService executor = Executors.newFixedThreadPool(<span class="number">10</span>);</div><div class="line">        <span class="comment">//create a list to hold the Future object associated with Callable</span></div><div class="line">        List&lt;Future&lt;String&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;Future&lt;String&gt;&gt;();</div><div class="line">        <span class="comment">//Create MyCallable instance</span></div><div class="line">        Callable&lt;String&gt; callable = <span class="keyword">new</span> MyCallable();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; <span class="number">100</span>; i++)&#123;</div><div class="line">            <span class="comment">//submit Callable tasks to be executed by thread pool</span></div><div class="line">            Future&lt;String&gt; future = executor.submit(callable);</div><div class="line">            <span class="comment">//add Future to the list, we can get return value using Future</span></div><div class="line">            list.add(future);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(Future&lt;String&gt; fut : list)&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">//print the return value of Future, notice the output delay in console</span></div><div class="line">                <span class="comment">// because Future.get() waits for task to get completed</span></div><div class="line">                System.out.println(<span class="keyword">new</span> Date()+ <span class="string">"::"</span>+fut.get());</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//shut down the executor service now</span></div><div class="line">        executor.shutdown();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">Tue Aug 23 12:02:44 CST 2016::pool-1-thread-1</div><div class="line">Tue Aug 23 12:02:45 CST 2016::pool-1-thread-2</div><div class="line">Tue Aug 23 12:02:45 CST 2016::pool-1-thread-3</div><div class="line">Tue Aug 23 12:02:45 CST 2016::pool-1-thread-4</div><div class="line">Tue Aug 23 12:02:45 CST 2016::pool-1-thread-5</div><div class="line">Tue Aug 23 12:02:45 CST 2016::pool-1-thread-6</div><div class="line">Tue Aug 23 12:02:45 CST 2016::pool-1-thread-7</div><div class="line">Tue Aug 23 12:02:45 CST 2016::pool-1-thread-8</div><div class="line">Tue Aug 23 12:02:45 CST 2016::pool-1-thread-9</div><div class="line">Tue Aug 23 12:02:45 CST 2016::pool-1-thread-10</div><div class="line">Tue Aug 23 12:02:45 CST 2016::pool-1-thread-8</div><div class="line">Tue Aug 23 12:02:46 CST 2016::pool-1-thread-4</div><div class="line">Tue Aug 23 12:02:46 CST 2016::pool-1-thread-7</div><div class="line">Tue Aug 23 12:02:46 CST 2016::pool-1-thread-9</div><div class="line">Tue Aug 23 12:02:46 CST 2016::pool-1-thread-1</div><div class="line">Tue Aug 23 12:02:46 CST 2016::pool-1-thread-5</div><div class="line">Tue Aug 23 12:02:46 CST 2016::pool-1-thread-3</div><div class="line">Tue Aug 23 12:02:46 CST 2016::pool-1-thread-6</div><div class="line">Tue Aug 23 12:02:46 CST 2016::pool-1-thread-2</div><div class="line">Tue Aug 23 12:02:46 CST 2016::pool-1-thread-10</div><div class="line">........I</div></pre></td></tr></table></figure>
<h3 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h3><p>我们先来看一下FutureTask的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt;</span></div></pre></td></tr></table></figure>
<p>FutureTask类实现了RunnableFuture接口，RunnableFuture接口的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>RunnableFuture继承了Runnable接口和Future接口，而FutureTask实现了RunnableFuture接口。所以它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值。</p>
<p>FutureTask提供了2个构造器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Callable-FutureTask获取执行结果"><a href="#Callable-FutureTask获取执行结果" class="headerlink" title="Callable+FutureTask获取执行结果"></a>Callable+FutureTask获取执行结果</h4><ul>
<li>Callable 实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">long</span> waitTime;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyCallable</span><span class="params">(<span class="keyword">int</span> timeInMillis)</span></span>&#123;</div><div class="line">		<span class="keyword">this</span>.waitTime=timeInMillis;</div><div class="line">	&#125;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">		Thread.sleep(waitTime);</div><div class="line">        <span class="comment">//return the thread name executing this callable task</span></div><div class="line">        <span class="keyword">return</span> Thread.currentThread().getName();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>FutureTask 实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTaskExample</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		MyCallable callable1 = <span class="keyword">new</span> MyCallable(<span class="number">1000</span>);</div><div class="line">		MyCallable callable2 = <span class="keyword">new</span> MyCallable(<span class="number">2000</span>);</div><div class="line"></div><div class="line">		FutureTask&lt;String&gt; futureTask1 = <span class="keyword">new</span> FutureTask&lt;String&gt;(callable1);</div><div class="line">		FutureTask&lt;String&gt; futureTask2 = <span class="keyword">new</span> FutureTask&lt;String&gt;(callable2);</div><div class="line"></div><div class="line">		ExecutorService executor = Executors.newFixedThreadPool(<span class="number">2</span>);</div><div class="line">		executor.execute(futureTask1);</div><div class="line">		executor.execute(futureTask2);</div><div class="line">		</div><div class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				<span class="keyword">if</span>(futureTask1.isDone() &amp;&amp; futureTask2.isDone())&#123;</div><div class="line">					System.out.println(<span class="string">"Done"</span>);</div><div class="line">					<span class="comment">//shut down executor service</span></div><div class="line">					executor.shutdown();</div><div class="line">					<span class="keyword">return</span>;</div><div class="line">				&#125;</div><div class="line">				</div><div class="line">				<span class="keyword">if</span>(!futureTask1.isDone())&#123;</div><div class="line">				<span class="comment">//wait indefinitely for future task to complete</span></div><div class="line">				System.out.println(<span class="string">"FutureTask1 output="</span>+futureTask1.get());</div><div class="line">				&#125;</div><div class="line">				</div><div class="line">				System.out.println(<span class="string">"Waiting for FutureTask2 to complete"</span>);</div><div class="line">				String s = futureTask2.get(<span class="number">200L</span>, TimeUnit.MILLISECONDS);</div><div class="line">				<span class="keyword">if</span>(s !=<span class="keyword">null</span>)&#123;</div><div class="line">					System.out.println(<span class="string">"FutureTask2 output="</span>+s);</div><div class="line">				&#125;</div><div class="line">			&#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;<span class="keyword">catch</span>(TimeoutException e)&#123;</div><div class="line">				<span class="comment">//do nothing</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">FutureTask1 output=pool-1-thread-1</div><div class="line">Waiting <span class="keyword">for</span> FutureTask2 to complete</div><div class="line">Waiting <span class="keyword">for</span> FutureTask2 to complete</div><div class="line">Waiting <span class="keyword">for</span> FutureTask2 to complete</div><div class="line">Waiting <span class="keyword">for</span> FutureTask2 to complete</div><div class="line">Waiting <span class="keyword">for</span> FutureTask2 to complete</div><div class="line">FutureTask2 output=pool-1-thread-2</div><div class="line">Done</div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Spring 自定义标签]]></title>
      <url>http://zsr.github.io/2016/08/22/Spring-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%87%E7%AD%BE/</url>
      <content type="html"><![CDATA[<h2 id="Spring-自定义标签"><a href="#Spring-自定义标签" class="headerlink" title="Spring 自定义标签"></a>Spring 自定义标签</h2><p>步骤:</p>
<ol>
<li><p>编写java bean</p>
</li>
<li><p>编写xsd配置文件</p>
</li>
<li><p>编写spring.handlers和spring.schmas</p>
</li>
<li><p>编写applicationContext.xml</p>
</li>
<li><p>编写NamespaceHandler和BeanDefinitionParser</p>
</li>
</ol>
<h3 id="项目目录结构"><a href="#项目目录结构" class="headerlink" title="项目目录结构"></a>项目目录结构</h3><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><h4 id="1-编写java-bean"><a href="#1-编写java-bean" class="headerlink" title="1. 编写java bean"></a>1. 编写java bean</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">package com.zsr.spring.schema;</div><div class="line"></div><div class="line">public class User &#123;</div><div class="line"></div><div class="line">  private String id;</div><div class="line">  private String name;</div><div class="line">  private String sex;</div><div class="line">  private int age;</div><div class="line"></div><div class="line">  public String getId() &#123;</div><div class="line">    return id;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public void setId(String id) &#123;</div><div class="line">    this.id = id;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public String getName() &#123;</div><div class="line">    return name;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public void setName(String name) &#123;</div><div class="line">    this.name = name;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public String getSex() &#123;</div><div class="line">    return sex;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public void setSex(String sex) &#123;</div><div class="line">    this.sex = sex;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public int getAge() &#123;</div><div class="line">    return age;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public void setAge(int age) &#123;</div><div class="line">    this.age = age;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-定义一个XSD文件"><a href="#2-定义一个XSD文件" class="headerlink" title="2. 定义一个XSD文件"></a>2. 定义一个XSD文件</h4><p>META-INF/user-1.0.xsd文件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</div><div class="line">&lt;xsd:schema xmlns=&quot;http://zsr.github.io/schema/test&quot;</div><div class="line">  xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</div><div class="line">  xmlns:tool=&quot;http://www.springframework.org/schema/tool&quot; xmlns:beans=&quot;http://www.springframework.org/schema/beans&quot;</div><div class="line">  targetNamespace=&quot;http://zsr.github.io/schema/test&quot;&gt;</div><div class="line"></div><div class="line">  &lt;xsd:import namespace=&quot;http://www.springframework.org/schema/beans&quot; /&gt;</div><div class="line">  &lt;xsd:import namespace=&quot;http://www.springframework.org/schema/tool&quot; /&gt;</div><div class="line"></div><div class="line">  &lt;xsd:annotation&gt;</div><div class="line">    &lt;xsd:documentation&gt;&lt;![CDATA[ Namespace support for the test]]&gt;&lt;/xsd:documentation&gt;</div><div class="line">  &lt;/xsd:annotation&gt;</div><div class="line"></div><div class="line">  &lt;xsd:element name=&quot;user&quot;&gt;</div><div class="line">    &lt;xsd:complexType&gt;</div><div class="line">      &lt;xsd:attribute name=&quot;id&quot; type=&quot;xsd:string&quot; use=&quot;required&quot;&gt;</div><div class="line">        &lt;xsd:annotation&gt;</div><div class="line">          &lt;xsd:documentation&gt;</div><div class="line">            &lt;![CDATA[</div><div class="line">              Unique id</div><div class="line">            ]]&gt;</div><div class="line">          &lt;/xsd:documentation&gt;</div><div class="line">        &lt;/xsd:annotation&gt;</div><div class="line">      &lt;/xsd:attribute&gt;</div><div class="line"></div><div class="line">      &lt;xsd:attribute name=&quot;name&quot; type=&quot;xsd:string&quot;&gt;</div><div class="line">        &lt;xsd:annotation&gt;</div><div class="line">          &lt;xsd:documentation&gt;姓名&lt;/xsd:documentation&gt;</div><div class="line">        &lt;/xsd:annotation&gt;</div><div class="line">      &lt;/xsd:attribute&gt;</div><div class="line"></div><div class="line">      &lt;xsd:attribute name=&quot;sex&quot; type=&quot;xsd:string&quot;&gt;</div><div class="line">        &lt;xsd:annotation&gt;</div><div class="line">          &lt;xsd:documentation&gt;性别&lt;/xsd:documentation&gt;</div><div class="line">        &lt;/xsd:annotation&gt;</div><div class="line">      &lt;/xsd:attribute&gt;</div><div class="line"></div><div class="line">      &lt;xsd:attribute name=&quot;age&quot; type=&quot;xsd:int&quot;&gt;</div><div class="line">        &lt;xsd:annotation&gt;</div><div class="line">          &lt;xsd:documentation&gt;年龄&lt;/xsd:documentation&gt;</div><div class="line">        &lt;/xsd:annotation&gt;</div><div class="line">      &lt;/xsd:attribute&gt;</div><div class="line">    &lt;/xsd:complexType&gt;</div><div class="line">  &lt;/xsd:element&gt;</div><div class="line"></div><div class="line">&lt;/xsd:schema&gt;</div></pre></td></tr></table></figure>
<h4 id="3-新建spring-handlers，-spring-shcemas"><a href="#3-新建spring-handlers，-spring-shcemas" class="headerlink" title="3. 新建spring.handlers， spring.shcemas"></a>3. 新建spring.handlers， spring.shcemas</h4><p>在项目的META-INF目录下新建两个文件spring.handlers，和spring.shcemas.</p>
<ul>
<li>Spring.handlers</li>
</ul>
<p>在类org.springframework.beans.factory.xml.DefaultNamespaceHandlerResolver中已经写死了要取mapping的handlerMappingsLocation的路径:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public static finalString DEFAULT_HANDLER_MAPPINGS_LOCATION =&quot;META-INF/spring.handlers&quot;;</div></pre></td></tr></table></figure>
<p>spring.handlers内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http\://www.zsr.com/schema/test=com.zsr.spring.schema.MyNamespaceHandler</div></pre></td></tr></table></figure>
<ul>
<li>Spring.Schemas </li>
</ul>
<p>在org.springframework.beans.factory.xml.PluggableSchemaResolver这个类中<br>同样写死了位置:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public static finalString DEFAULT_SCHEMA_MAPPINGS_LOCATION = &quot;META-INF/spring.schemas&quot;;</div></pre></td></tr></table></figure>
<p>spring.schemas内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http\://www.zsr.com/schema/test/user-1.0.xsd=META-INF/user-1.0.xsd</div></pre></td></tr></table></figure>
<p>初始化的时候第一次调用的时候会调用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">PropertiesLoaderUtils.loadAllProperties(this.schemaMappingsLocation,this.classLoader)</div></pre></td></tr></table></figure>
<p>把所有的文件名包含的取出来放入map中。</p>
<h4 id="4-编写applicationContext-xml"><a href="#4-编写applicationContext-xml" class="headerlink" title="4. 编写applicationContext.xml"></a>4. 编写applicationContext.xml</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</div><div class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</div><div class="line">  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:test=&quot;http://www.zsr.com/schema/test&quot;</div><div class="line">  xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans </div><div class="line">    http://www.springframework.org/schema/beans/spring-beans-3.1.xsd    </div><div class="line">    http://www.zsr.com/schema/test </div><div class="line">    http://www.zsr.com/schema/test/user-1.0.xsd&quot;&gt;</div><div class="line"></div><div class="line">  &lt;test:user id=&quot;zsr&quot; name=&quot;zsr&quot; sex=&quot;male&quot; age=&quot;24&quot; /&gt;</div><div class="line"></div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure>
<h4 id="5-编写NamespaceHandler和BeanDefinitionParser"><a href="#5-编写NamespaceHandler和BeanDefinitionParser" class="headerlink" title="5. 编写NamespaceHandler和BeanDefinitionParser"></a>5. 编写NamespaceHandler和BeanDefinitionParser</h4><ul>
<li>NamespaceHandler</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">package com.zsr.spring.schema;</div><div class="line"></div><div class="line">import org.springframework.beans.factory.xml.NamespaceHandlerSupport;</div><div class="line"></div><div class="line">public class MyNamespaceHandler extends NamespaceHandlerSupport &#123;</div><div class="line"></div><div class="line">  @Override</div><div class="line">  public void init() &#123;</div><div class="line">    registerBeanDefinitionParser(&quot;user&quot;, new UserBeanDefinitionParser());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>BeanDefinitionParser</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">package com.zsr.spring.schema;</div><div class="line"></div><div class="line">import org.springframework.beans.factory.support.BeanDefinitionBuilder;</div><div class="line">import org.springframework.beans.factory.xml.AbstractSingleBeanDefinitionParser;</div><div class="line">import org.w3c.dom.Element;</div><div class="line"></div><div class="line">public class UserBeanDefinitionParser extends AbstractSingleBeanDefinitionParser &#123;</div><div class="line"></div><div class="line">  protected static final String USER_ID = &quot;id&quot;;</div><div class="line">  protected static final String USER_NAME = &quot;name&quot;;</div><div class="line">  protected static final String USER_AGE = &quot;age&quot;;</div><div class="line">  protected static final String USER_SEX = &quot;sex&quot;;</div><div class="line"></div><div class="line">  @Override</div><div class="line">  protected Class&lt;?&gt; getBeanClass(Element element) &#123;</div><div class="line">    return User.class;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  @Override</div><div class="line">  protected void doParse(Element element, BeanDefinitionBuilder builder) &#123;</div><div class="line">    String id = element.getAttribute(USER_ID);</div><div class="line">    String name = element.getAttribute(USER_NAME);</div><div class="line">    String sex = element.getAttribute(USER_SEX);</div><div class="line">    int age = Integer.parseInt(element.getAttribute(USER_AGE));</div><div class="line"></div><div class="line">    builder.addPropertyValue(USER_ID, id);</div><div class="line">    builder.addPropertyValue(USER_NAME, name);</div><div class="line">    builder.addPropertyValue(USER_SEX, sex);</div><div class="line">    builder.addPropertyValue(USER_AGE, age);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Google MapReduce中文版]]></title>
      <url>http://zsr.github.io/2016/08/19/Google-MapReduce/</url>
      <content type="html"><![CDATA[<h2 id="Google-MapReduce中文版"><a href="#Google-MapReduce中文版" class="headerlink" title="Google MapReduce中文版"></a>Google MapReduce中文版</h2><pre><code>译者: alex
</code></pre><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>MapReduce是一个编程模型，也是一个处理和生成超大数据集的算法模型的相关实现。用户首先创建一个Map函数处理一个基于 key/value pair的数据集合，输出中间的基于key/value pair的数据集合；然后再创建一个Reduce函数用来合并所有的具有相同中间key值的中间value值。现实世界中有很多满足上述处理模型的例子，本论文将详细描述这个模型。</p>
<p>MapReduce架构的程序能够在大量的普通配置的计算机上实现并行化处理。这个系统在运行时只关心：如何分割输入数据，在大量计算机组成的 集群上的调度，集群中计算机的错误处理，管理集群中计算机之间必要的通信。采用MapReduce架构可以使那些没有并行计算和分布式处理系统开发经验的 程序员有效利用分布式系统的丰富资源。</p>
<p>我们的MapReduce实现运行在规模可以灵活调整的由普通机器组成的集群上：一个典型的MapReduce计算往往由几千台机器组成、处理 以TB计算的数据。程序员发现这个系统非常好用：已经实现了数以百计的MapReduce程序，在Google的集群上，每天都有1000多个 MapReduce程序在执行。</p>
<h3 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h3><p>在过去的5年里，包括本文作者在内的Google的很多程序员，为了处理海量的原始数据，已经实现了数以百计的、专用的计算方法。这些计算方法 用来处理大量的原始数据，比如，文档抓取（类似网络爬虫的程序）、Web请求日志等等；也为了计算处理各种类型的衍生数据，比如倒排索引、Web文档的图 结构的各种表示形势、每台主机上网络爬虫抓取的页面数量的汇总、每天被请求的最多的查询的集合等等。大多数这样的数据处理运算在概念上很容易理解。然而由 于输入的数据量巨大，因此要想在可接受的时间内完成运算，只有将这些计算分布在成百上千的主机上。如何处理并行计算、如何分发数据、如何处理错误？所有这 些问题综合在一起，需要大量的代码处理，因此也使得原本简单的运算变得难以处理。</p>
<p>为了解决上述复杂的问题，我们设计一个新的抽象模型，使用这个抽象模型，我们只要表述我们想要执行的简单运算即可，而不必关心并行计算、容错、 数据分布、负载均衡等复杂的细节，这些问题都被封装在了一个库里面。设计这个抽象模型的灵感来自Lisp和许多其他函数式语言的Map和Reduce的原 语。我们意识到我们大多数的运算都包含这样的操作：在输入数据的“逻辑”记录上应用Map操作得出一个中间key/value pair集合，然后在所有具有相同key值的value值上应用Reduce操作，从而达到合并中间的数据，得到一个想要的结果的目的。使用 MapReduce模型，再结合用户实现的Map和Reduce函数，我们就可以非常容易的实现大规模并行化计算；通过MapReduce模型自带的“再 次执行”（re-execution）功能，也提供了初级的容灾实现方案。</p>
<p>这个工作(实现一个MapReduce框架模型)的主要贡献是通过简单的接口来实现自动的并行化和大规模的分布式计算，通过使用MapReduce模型接口实现在大量普通的PC机上高性能计算。</p>
<p>第二部分描述基本的编程模型和一些使用案例。第三部分描述了一个经过裁剪的、适合我们的基于集群的计算环境的MapReduce实现。第四部分 描述我们认为在MapReduce编程模型中一些实用的技巧。第五部分对于各种不同的任务，测量我们MapReduce实现的性能。第六部分揭示了在 Google内部如何使用MapReduce作为基础重写我们的索引系统产品，包括其它一些使用MapReduce的经验。第七部分讨论相关的和未来的工作。</p>
<h3 id="2、编程模型"><a href="#2、编程模型" class="headerlink" title="2、编程模型"></a>2、编程模型</h3><p>MapReduce编程模型的原理是：利用一个输入key/value pair集合来产生一个输出的key/value pair集合。MapReduce库的用户用两个函数表达这个计算：Map和Reduce。</p>
<p>用户自定义的Map函数接受一个输入的key/value pair值，然后产生一个中间key/value pair值的集合。MapReduce库把所有具有相同中间key值I的中间value值集合在一起后传递给reduce函数。</p>
<p>用户自定义的Reduce函数接受一个中间key的值I和相关的一个value值的集合。Reduce函数合并这些value值，形成一个较小 的value值的集合。一般的，每次Reduce函数调用只产生0或1个输出value值。通常我们通过一个迭代器把中间value值提供给Reduce 函数，这样我们就可以处理无法全部放入内存中的大量的value值的集合。</p>
<h4 id="2-1、例子"><a href="#2-1、例子" class="headerlink" title="2.1、例子"></a>2.1、例子</h4><p>例如，计算一个大的文档集合中每个单词出现的次数，下面是伪代码段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">map(String key, String value):</div><div class="line">    // key: document name</div><div class="line">    // value: document contents</div><div class="line">    for each word w in value:</div><div class="line">        EmitIntermediate(w, “1″);</div><div class="line">        </div><div class="line">reduce(String key, Iterator values):</div><div class="line">    // key: a word</div><div class="line">    // values: a list of counts</div><div class="line">    int result = 0;</div><div class="line">    for each v in values:</div><div class="line">        result += ParseInt(v);</div><div class="line">    Emit(AsString(result));</div></pre></td></tr></table></figure>
<p>Map函数输出文档中的每个词、以及这个词的出现次数(在这个简单的例子里就是1)。Reduce函数把Map函数产生的每一个特定的词的计数累加起来。</p>
<p>另外，用户编写代码，使用输入和输出文件的名字、可选的调节参数来完成一个符合MapReduce模型规范的对象，然后调用MapReduce 函数，并把这个规范对象传递给它。用户的代码和MapReduce库链接在一起(用C++实现)。附录A包含了这个实例的全部程序代码。</p>
<h4 id="2-2、类型"><a href="#2-2、类型" class="headerlink" title="2.2、类型"></a>2.2、类型</h4><p>尽管在前面例子的伪代码中使用了以字符串表示的输入输出值，但是在概念上，用户定义的Map和Reduce函数都有相关联的类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">map(k1,v1) -&gt;list(k2,v2)</div><div class="line"></div><div class="line">reduce(k2,list(v2)) -&gt;list(v2)</div></pre></td></tr></table></figure>
<p>比如，输入的key和value值与输出的key和value值在类型上推导的域不同。此外，中间key和value值与输出key和value值在类型上推导的域相同。<br><strong>（alex注：原文中这个domain的含义不是很清楚，我参考Hadoop、KFS等实现，map和reduce都使用了泛型，因此，我把domain翻译成类型推导的域）</strong>。<br>我们的C++中使用字符串类型作为用户自定义函数的输入输出，用户在自己的代码中对字符串进行适当的类型转换。</p>
<h4 id="2-3、更多的例子"><a href="#2-3、更多的例子" class="headerlink" title="2.3、更多的例子"></a>2.3、更多的例子</h4><p>这里还有一些有趣的简单例子，可以很容易的使用MapReduce模型来表示：</p>
<ul>
<li>分布式的Grep：Map函数输出匹配某个模式的一行，Reduce函数是一个恒等函数，即把中间数据复制到输出。</li>
<li>计算URL访问频率：Map函数处理日志中web页面请求的记录，然后输出(URL,1)。Reduce函数把相同URL的value值都累加起来，产生(URL,记录总数)结果。</li>
<li>倒转网络链接图：Map函数在源页面（source）中搜索所有的链接目标（target）并输出为(target,source)。Reduce函数把给定链接目标（target）的链接组合成一个列表，输出(target,list(source))。</li>
<li>每个主机的检索词向量：检索词向量用一个(词,频率)列表来概述出现在文档或文档集中的最重要的一些词。Map函数为每一个输入文档输出(主机 名,检索词向量)，其中主机名来自文档的URL。Reduce函数接收给定主机的所有文档的检索词向量，并把这些检索词向量加在一起，丢弃掉低频的检索 词，输出一个最终的(主机名,检索词向量)。</li>
<li>倒排索引：Map函数分析每个文档输出一个(词,文档号)的列表，Reduce函数的输入是一个给定词的所有（词，文档号），排序所有的文档号，输出(词,list（文档号）)。所有的输出集合形成一个简单的倒排索引，它以一种简单的算法跟踪词在文档中的位置。</li>
<li>分布式排序：Map函数从每个记录提取key，输出(key,record)。Reduce函数不改变任何的值。这个运算依赖分区机制(在4.1描述)和排序属性(在4.2描述)。</li>
</ul>
<h3 id="3、实现"><a href="#3、实现" class="headerlink" title="3、实现"></a>3、实现</h3><p>MapReduce模型可以有多种不同的实现方式。如何正确选择取决于具体的环境。例如，一种实现方式适用于小型的共享内存方式的机器，另外一种实现方式则适用于大型NUMA架构的多处理器的主机，而有的实现方式更适合大型的网络连接集群。</p>
<p>本章节描述一个适用于Google内部广泛使用的运算环境的实现：用以太网交换机连接、由普通PC机组成的大型集群。在我们的环境里包括：</p>
<ul>
<li>1.x86架构、运行Linux操作系统、双处理器、2-4GB内存的机器。 </li>
<li>2.普通的网络硬件设备，每个机器的带宽为百兆或者千兆，但是远小于网络的平均带宽的一半。 （alex注：这里需要网络专家解释一下了） </li>
<li>3.集群中包含成百上千的机器，因此，机器故障是常态。 </li>
<li>4.存储为廉价的内置IDE硬盘。一个内部分布式文件系统用来管理存储在这些磁盘上的数据。文件系统通过数据复制来在不可靠的硬件上保证数据的可靠性和有效性。 </li>
<li>5.用户提交工作（job）给调度系统。每个工作（job）都包含一系列的任务（task），调度系统将这些任务调度到集群中多台可用的机器上。</li>
</ul>
<h4 id="3-1、执行概括"><a href="#3-1、执行概括" class="headerlink" title="3.1、执行概括"></a>3.1、执行概括</h4><p>通过将Map调用的输入数据自动分割为M个数据片段的集合，Map调用被分布到多台机器上执行。输入的数据片段能够在不同的机器上并行处理。使 用分区函数将Map调用产生的中间key值分成R个不同分区（例如，hash(key) mod R），Reduce调用也被分布到多台机器上执行。分区数量（R）和分区函数由用户来指定。</p>
<p><img src="/images/GoogleMR3-1.jpg"></p>
<p>图1展示了我们的MapReduce实现中操作的全部流程。当用户调用MapReduce函数时，将发生下面的一系列动作（下面的序号和图1中的序号一一对应）： </p>
<ul>
<li><p>1.用户程序首先调用的MapReduce库将输入文件分成M个数据片度，每个数据片段的大小一般从 16MB到64MB(可以通过可选的参数来控制每个数据片段的大小)。然后用户程序在机群中创建大量的程序副本。 </p>
</li>
<li><p>2.这些程序副本中的有一个特殊的程序–master。副本中其它的程序都是worker程序，由master分配任务。有M个Map任务和R个Reduce任务将被分配，master将一个Map任务或Reduce任务分配给一个空闲的worker。 </p>
</li>
<li><p>3.被分配了map任务的worker程序读取相关的输入数据片段，从输入的数据片段中解析出key/value pair，然后把key/value pair传递给用户自定义的Map函数，由Map函数生成并输出的中间key/value pair，并缓存在内存中。 </p>
</li>
<li><p>4.缓存中的key/value pair通过分区函数分成R个区域，之后周期性的写入到本地磁盘上。缓存的key/value pair在本地磁盘上的存储位置将被回传给master，由master负责把这些存储位置再传送给Reduce worker。</p>
</li>
<li><p>5.当Reduce worker程序接收到master程序发来的数据存储位置信息后，使用RPC从Map worker所在主机的磁盘上读取这些缓存数据。当Reduce worker读取了所有的中间数据后，通过对key进行排序后使得具有相同key值的数据聚合在一起。由于许多不同的key值会映射到相同的Reduce 任务上，因此必须进行排序。如果中间数据太大无法在内存中完成排序，那么就要在外部进行排序。 </p>
</li>
<li><p>6.Reduce worker程序遍历排序后的中间数据，对于每一个唯一的中间key值，Reduce worker程序将这个key值和它相关的中间value值的集合传递给用户自定义的Reduce函数。Reduce函数的输出被追加到所属分区的输出文件。</p>
</li>
<li><p>7.当所有的Map和Reduce任务都完成之后，master唤醒用户程序。在这个时候，在用户程序里的对MapReduce调用才返回。</p>
</li>
</ul>
<p>在成功完成任务之后，MapReduce的输出存放在R个输出文件中（对应每个Reduce任务产生一个输出文件，文件名由用户指定）。一般情况 下，用户不需要将这R个输出文件合并成一个文件–他们经常把这些文件作为另外一个MapReduce的输入，或者在另外一个可以处理多个分割文件的分布式 应用中使用。</p>
<h4 id="3-2、Master数据结构"><a href="#3-2、Master数据结构" class="headerlink" title="3.2、Master数据结构"></a>3.2、Master数据结构</h4><p>Master持有一些数据结构，它存储每一个Map和Reduce任务的状态（空闲、工作中或完成)，以及Worker机器(非空闲任务的机器)的标识。</p>
<p>Master就像一个数据管道，中间文件存储区域的位置信息通过这个管道从Map传递到Reduce。因此，对于每个已经完成的Map任 务，master存储了Map任务产生的R个中间文件存储区域的大小和位置。当Map任务完成时，Master接收到位置和大小的更新信息，这些信息被逐 步递增的推送给那些正在工作的Reduce任务。</p>
<h4 id="3-3、容错"><a href="#3-3、容错" class="headerlink" title="3.3、容错"></a>3.3、容错</h4><p>因为MapReduce库的设计初衷是使用由成百上千的机器组成的集群来处理超大规模的数据，所以，这个库必须要能很好的处理机器故障。</p>
<ul>
<li><strong>worker故障:</strong></li>
</ul>
<p>master周期性的ping每个worker。如果在一个约定的时间范围内没有收到worker返回的信息，master将把这个 worker标记为失效。所有由这个失效的worker完成的Map任务被重设为初始的空闲状态，之后这些任务就可以被安排给其他的worker。同样 的，worker失效时正在运行的Map或Reduce任务也将被重新置为空闲状态，等待重新调度。</p>
<p>当worker故障时，由于已经完成的Map任务的输出存储在这台机器上，Map任务的输出已不可访问了，因此必须重新执行。而已经完成的Reduce任务的输出存储在全局文件系统上，因此不需要再次执行。</p>
<p>当一个Map任务首先被worker A执行，之后由于worker A失效了又被调度到worker B执行，这个“重新执行”的动作会被通知给所有执行Reduce任务的worker。任何还没有从worker A读取数据的Reduce任务将从worker B读取数据。</p>
<p>MapReduce可以处理大规模worker失效的情况。比如，在一个MapReduce操作执行期间，在正在运行的集群上进行网络维护引起 80台机器在几分钟内不可访问了，MapReduce master只需要简单的再次执行那些不可访问的worker完成的工作，之后继续执行未完成的任务，直到最终完成这个MapReduce操作。</p>
<ul>
<li><strong>master失败 </strong></li>
</ul>
<p>一个简单的解决办法是让master周期性的将上面描述的数据结构 （alex注：指3.2节）的 写入磁盘，即检查点（checkpoint）。如果这个master任务失效了，可以从最后一个检查点（checkpoint）开始启动另一个 master进程。然而，由于只有一个master进程，master失效后再恢复是比较麻烦的，因此我们现在的实现是如果master失效，就中止 MapReduce运算。客户可以检查到这个状态，并且可以根据需要重新执行MapReduce操作。</p>
<ul>
<li><strong>在失效方面的处理机制</strong></li>
</ul>
<p>当用户提供的Map和Reduce操作是输入确定性函数（即相同的输入产生相同的输出）时，我们的分布式实现在任何情况下的输出都和所有程序没有出现任何错误、顺序的执行产生的输出是一样的。</p>
<p>我们依赖对Map和Reduce任务的输出是原子提交的来完成这个特性。每个工作中的任务把它的输出写到私有的临时文件中。每个Reduce任 务生成一个这样的文件，而每个Map任务则生成R个这样的文件（一个Reduce任务对应一个文件）。当一个Map任务完成的时，worker发送一个包 含R个临时文件名的完成消息给master。如果master从一个已经完成的Map任务再次接收到到一个完成消息，master将忽略这个消息；否 则，master将这R个文件的名字记录在数据结构里。</p>
<p>当Reduce任务完成时，Reduce worker进程以原子的方式把临时文件重命名为最终的输出文件。如果同一个Reduce任务在多台机器上执行，针对同一个最终的输出文件将有多个重命名 操作执行。我们依赖底层文件系统提供的重命名操作的原子性来保证最终的文件系统状态仅仅包含一个Reduce任务产生的数据。</p>
<p>使用MapReduce模型的程序员可以很容易的理解他们程序的行为，因为我们绝大多数的Map和Reduce操作是确定性的，而且存在这样的一个 事实：我们的失效处理机制等价于一个顺序的执行的操作。当Map或/和Reduce操作是不确定性的时候，我们提供虽然较弱但是依然合理的处理机制。当使 用非确定操作的时候，一个Reduce任务R1的输出等价于一个非确定性程序顺序执行产生时的输出。但是，另一个Reduce任务R2的输出也许符合一个 不同的非确定顺序程序执行产生的R2的输出。</p>
<p>考虑Map任务M和Reduce任务R1、R2的情况。我们设定e(Ri)是Ri已经提交的执行过程（有且仅有一个这样的执行过程）。当e(R1)读取了由M一次执行产生的输出，而e(R2)读取了由M的另一次执行产生的输出，导致了较弱的失效处理。</p>
<h4 id="3-4、存储位置"><a href="#3-4、存储位置" class="headerlink" title="3.4、存储位置"></a>3.4、存储位置</h4><p>在我们的计算运行环境中，网络带宽是一个相当匮乏的资源。我们通过尽量把输入数据(由GFS管理)存储在集群中机器的本地磁盘上来节省网络带 宽。GFS把每个文件按64MB一个Block分隔，每个Block保存在多台机器上，环境中就存放了多份拷贝(一般是3个拷贝)。MapReduce的 master在调度Map任务时会考虑输入文件的位置信息，尽量将一个Map任务调度在包含相关输入数据拷贝的机器上执行；如果上述努力失败 了，master将尝试在保存有输入数据拷贝的机器附近的机器上执行Map任务(例如，分配到一个和包含输入数据的机器在一个switch里的 worker机器上执行)。当在一个足够大的cluster集群上运行大型MapReduce操作的时候，大部分的输入数据都能从本地机器读取，因此消耗 非常少的网络带宽。</p>
<h4 id="3-5、任务粒度"><a href="#3-5、任务粒度" class="headerlink" title="3.5、任务粒度"></a>3.5、任务粒度</h4><p>如前所述，我们把Map拆分成了M个片段、把Reduce拆分成R个片段执行。理想情况下，M和R应当比集群中worker的机器数量要多得 多。在每台worker机器都执行大量的不同任务能够提高集群的动态的负载均衡能力，并且能够加快故障恢复的速度：失效机器上执行的大量Map任务都可以 分布到所有其他的worker机器上去执行。</p>
<p>但是实际上，在我们的具体实现中对M和R的取值都有一定的客观限制，因为master必须执行O(M+R)次调度，并且在内存中保存O(M <em> R)个状态（对影响内存使用的因素还是比较小的：O(M </em> R)块状态，大概每对Map任务/Reduce任务1个字节就可以了）。</p>
<p>更进一步，R值通常是由用户指定的，因为每个Reduce任务最终都会生成一个独立的输出文件。实际使用时我们也倾向于选择合适的M值，以使得 每一个独立任务都是处理大约16M到64M的输入数据（这样，上面描写的输入数据本地存储优化策略才最有效），另外，我们把R值设置为我们想使用的 worker机器数量的小的倍数。我们通常会用这样的比例来执行MapReduce：M=200000，R=5000，使用2000台worker机器。</p>
<h4 id="3-6、备用任务"><a href="#3-6、备用任务" class="headerlink" title="3.6、备用任务"></a>3.6、备用任务</h4><p>影响一个MapReduce的总执行时间最通常的因素是“落伍者”：在运算过程中，如果有一台机器花了很长的时间才完成最后几个Map或Reduce任务，导致MapReduce操作总的执行时间超过预期。出现“落伍者”的原因非常多。比如：如果一个机器的硬盘出了问题，在读取的时候要经 常的进行读取纠错操作，导致读取数据的速度从30M/s降低到1M/s。如果cluster的调度系统在这台机器上又调度了其他的任务，由于CPU、内存、本地硬盘和网络带宽等竞争因素的存在，导致执行MapReduce代码的执行效率更加缓慢。我们最近遇到的一个问题是由于机器的初始化代码有bug，导致关闭了的处理器的缓存：在这些机器上执行任务的性能和正常情况相差上百倍。</p>
<p>我们有一个通用的机制来减少“落伍者”出现的情况。当一个MapReduce操作接近完成的时候，master调度备用（backup）任务进 程来执行剩下的、处于处理中状态（in-progress）的任务。无论是最初的执行进程、还是备用（backup）任务进程完成了任务，我们都把这个任 务标记成为已经完成。我们调优了这个机制，通常只会占用比正常操作多几个百分点的计算资源。我们发现采用这样的机制对于减少超大MapReduce操作的 总处理时间效果显著。例如，在5.3节描述的排序任务，在关闭掉备用任务的情况下要多花44%的时间完成排序任务。</p>
<h3 id="4、技巧"><a href="#4、技巧" class="headerlink" title="4、技巧"></a>4、技巧</h3><p>虽然简单的Map和Reduce函数提供的基本功能已经能够满足大部分的计算需要，我们还是发掘出了一些有价值的扩展功能。本节将描述这些扩展功能。</p>
<h4 id="4-1、分区函数"><a href="#4-1、分区函数" class="headerlink" title="4.1、分区函数"></a>4.1、分区函数</h4><p>MapReduce的使用者通常会指定Reduce任务和Reduce任务输出文件的数量（R）。我们在中间key上使用分区函数来对数据进行 分区，之后再输入到后续任务执行进程。一个缺省的分区函数是使用hash方法(比如，hash(key) mod R)进行分区。hash方法能产生非常平衡的分区。然而，有的时候，其它的一些分区函数对key值进行的分区将非常有用。比如，输出的key值是URLs，我们希望每个主机的所有条目保持在同一个输出文件中。为了支持类似的情况，MapReduce库的用户需要提供专门的分区函数。例如，使用 “hash(Hostname(urlkey)) mod R”作为分区函数就可以把所有来自同一个主机的URLs保存在同一个输出文件中。</p>
<h4 id="4-2、顺序保证"><a href="#4-2、顺序保证" class="headerlink" title="4.2、顺序保证"></a>4.2、顺序保证</h4><p>我们确保在给定的分区中，中间key/value pair数据的处理顺序是按照key值增量顺序处理的。这样的顺序保证对每个分成生成一个有序的输出文件，这对于需要对输出文件按key值随机存取的应用非常有意义，对在排序输出的数据集也很有帮助。</p>
<h4 id="4-3、Combiner函数"><a href="#4-3、Combiner函数" class="headerlink" title="4.3、Combiner函数"></a>4.3、Combiner函数</h4><p>在某些情况下，Map函数产生的中间key值的重复数据会占很大的比重，并且，用户自定义的Reduce函数满足结合律和交换律。在2.1节的 词数统计程序是个很好的例子。由于词频率倾向于一个zipf分布(齐夫分布)，每个Map任务将产生成千上万个这样的记录。所 有的这些记录将通过网络被发送到一个单独的Reduce任务，然后由这个Reduce任务把所有这些记录累加起来产生一个数字。我们允许用户指定一个可选 的combiner函数，combiner函数首先在本地将这些记录进行一次合并，然后将合并的结果再通过网络发送出去。</p>
<p>Combiner函数在每台执行Map任务的机器上都会被执行一次。一般情况下，Combiner和Reduce函数是一样的。 Combiner函数和Reduce函数之间唯一的区别是MapReduce库怎样控制函数的输出。Reduce函数的输出被保存在最终的输出文件里，而 Combiner函数的输出被写到中间文件里，然后被发送给Reduce任务。</p>
<p>部分的合并中间结果可以显著的提高一些MapReduce操作的速度。附录A包含一个使用combiner函数的例子。</p>
<h4 id="4-4、输入和输出的类型"><a href="#4-4、输入和输出的类型" class="headerlink" title="4.4、输入和输出的类型"></a>4.4、输入和输出的类型</h4><p>MapReduce库支持几种不同的格式的输入数据。比如，文本模式的输入数据的每一行被视为是一个key/value pair。key是文件的偏移量，value是那一行的内容。另外一种常见的格式是以key进行排序来存储的key/value pair的序列。每种输入类型的实现都必须能够把输入数据分割成数据片段，该数据片段能够由单独的Map任务来进行后续处理(例如，文本模式的范围分割必 须确保仅仅在每行的边界进行范围分割)。虽然大多数MapReduce的使用者仅仅使用很少的预定义输入类型就满足要求了，但是使用者依然可以通过提供一 个简单的Reader接口实现就能够支持一个新的输入类型。</p>
<p>Reader并非一定要从文件中读取数据，比如，我们可以很容易的实现一个从数据库里读记录的Reader，或者从内存中的数据结构读取数据的Reader。</p>
<p>类似的，我们提供了一些预定义的输出数据的类型，通过这些预定义类型能够产生不同格式的数据。用户采用类似添加新的输入数据类型的方式增加新的输出类型。</p>
<h4 id="4-5、副作用"><a href="#4-5、副作用" class="headerlink" title="4.5、副作用"></a>4.5、副作用</h4><p>在某些情况下，MapReduce的使用者发现，如果在Map和/或Reduce操作过程中增加辅助的输出文件会比较省事。我们依靠程序writer把这种“副作用”变成原子的和幂等的 <strong>（alex注：幂等的指一个总是产生相同结果的数学运算）</strong>。通常应用程序首先把输出结果写到一个临时文件中，在输出全部数据之后，在使用系统级的原子操作rename重新命名这个临时文件。</p>
<p>如果一个任务产生了多个输出文件，我们没有提供类似两阶段提交的原子操作支持这种情况。因此，对于会产生多个输出文件、并且对于跨文件有一致性要求的任务，都必须是确定性的任务。但是在实际应用过程中，这个限制还没有给我们带来过麻烦。</p>
<h4 id="4-6、跳过损坏的记录"><a href="#4-6、跳过损坏的记录" class="headerlink" title="4.6、跳过损坏的记录"></a>4.6、跳过损坏的记录</h4><p>有时候，用户程序中的bug导致Map或者Reduce函数在处理某些记录的时候crash掉，MapReduce操作无法顺利完成。惯常的做 法是修复bug后再次执行MapReduce操作，但是，有时候找出这些bug并修复它们不是一件容易的事情；这些bug也许是在第三方库里边，而我们手 头没有这些库的源代码。而且在很多时候，忽略一些有问题的记录也是可以接受的，比如在一个巨大的数据集上进行统计分析的时候。我们提供了一种执行模式，在 这种模式下，为了保证保证整个处理能继续进行，MapReduce会检测哪些记录导致确定性的crash，并且跳过这些记录不处理。</p>
<p>每个worker进程都设置了信号处理函数捕获内存段异常（segmentation violation）和总线错误（bus error）。在执行Map或者Reduce操作之前，MapReduce库通过全局变量保存记录序号。如果用户程序触发了一个系统信号，消息处理函数将 用“最后一口气”通过UDP包向master发送处理的最后一条记录的序号。当master看到在处理某条特定记录不止失败一次时，master就标志着 条记录需要被跳过，并且在下次重新执行相关的Map或者Reduce任务的时候跳过这条记录。</p>
<h4 id="4-7、本地执行"><a href="#4-7、本地执行" class="headerlink" title="4.7、本地执行"></a>4.7、本地执行</h4><p>调试Map和Reduce函数的bug是非常困难的，因为实际执行操作时不但是分布在系统中执行的，而且通常是在好几千台计算机上执行，具体的 执行位置是由master进行动态调度的，这又大大增加了调试的难度。为了简化调试、profile和小规模测试，我们开发了一套MapReduce库的 本地实现版本，通过使用本地版本的MapReduce库，MapReduce操作在本地计算机上顺序的执行。用户可以控制MapReduce操作的执行， 可以把操作限制到特定的Map任务上。用户通过设定特别的标志来在本地执行他们的程序，之后就可以很容易的使用本地调试和测试工具（比如gdb）。</p>
<h4 id="4-8、状态信息"><a href="#4-8、状态信息" class="headerlink" title="4.8、状态信息"></a>4.8、状态信息</h4><p>master使用嵌入式的HTTP服务器（如Jetty）显示一组状态信息页面，用户可以监控各种执行状态。状态信息页面显示了包括计算执行的 进度，比如已经完成了多少任务、有多少任务正在处理、输入的字节数、中间数据的字节数、输出的字节数、处理百分比等等。页面还包含了指向每个任务的 stderr和stdout文件的链接。用户根据这些数据预测计算需要执行大约多长时间、是否需要增加额外的计算资源。这些页面也可以用来分析什么时候计 算执行的比预期的要慢。</p>
<p>另外，处于最顶层的状态页面显示了哪些worker失效了，以及他们失效的时候正在运行的Map和Reduce任务。这些信息对于调试用户代码中的bug很有帮助。</p>
<h4 id="4-9、计数器"><a href="#4-9、计数器" class="headerlink" title="4.9、计数器"></a>4.9、计数器</h4><p>MapReduce库使用计数器统计不同事件发生次数。比如，用户可能想统计已经处理了多少个单词、已经索引的多少篇German文档等等。</p>
<p>为了使用这个特性，用户在程序中创建一个命名的计数器对象，在Map和Reduce函数中相应的增加计数器的值。例如： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Counter* uppercase;</div><div class="line">uppercase = GetCounter(“uppercase”);</div><div class="line">map(String name, String contents):</div><div class="line"> for each word w in contents:</div><div class="line">  if (IsCapitalized(w)):</div><div class="line">   uppercase-&gt;Increment();</div><div class="line">  EmitIntermediate(w, “1″);</div></pre></td></tr></table></figure>
<p>这些计数器的值周期性的从各个单独的worker机器上传递给master（附加在ping的应答包中传递）。master把执行成功的Map和Reduce任务的计数器值进行累计，当MapReduce操作完成之后，返回给用户代码。</p>
<p>计数器当前的值也会显示在master的状态页面上，这样用户就可以看到当前计算的进度。当累加计数器的值的时候，master要检查重复运行的Map或者Reduce任务，避免重复累加（之前提到的备用任务和失效后重新执行任务这两种情况会导致相同的任务被多次执行）。</p>
<p>有些计数器的值是由MapReduce库自动维持的，比如已经处理的输入的key/value pair的数量、输出的key/value pair的数量等等。</p>
<p>计数器机制对于MapReduce操作的完整性检查非常有用。比如，在某些MapReduce操作中，用户需要确保输出的key value pair精确的等于输入的key value pair，或者处理的German文档数量在处理的整个文档数量中属于合理范围。</p>
<h3 id="5、性能"><a href="#5、性能" class="headerlink" title="5、性能"></a>5、性能</h3><p>本节我们用在一个大型集群上运行的两个计算来衡量MapReduce的性能。一个计算在大约1TB的数据中进行特定的模式匹配，另一个计算对大约1TB的数据进行排序。</p>
<p>这两个程序在大量的使用MapReduce的实际应用中是非常典型的 — 一类是对数据格式进行转换，从一种表现形式转换为另外一种表现形式；另一类是从海量数据中抽取少部分的用户感兴趣的数据。</p>
<h4 id="5-1、集群配置"><a href="#5-1、集群配置" class="headerlink" title="5.1、集群配置"></a>5.1、集群配置</h4><p>所有这些程序都运行在一个大约由1800台机器构成的集群上。每台机器配置2个2G主频、支持超线程的Intel Xeon处理器，4GB的物理内存，两个160GB的IDE硬盘和一个千兆以太网卡。这些机器部署在一个两层的树形交换网络中，在root节点大概有 100-200GBPS的传输带宽。所有这些机器都采用相同的部署（对等部署），因此任意两点之间的网络来回时间小于1毫秒。</p>
<p>在4GB内存里，大概有1-1.5G用于运行在集群上的其他任务。测试程序在周末下午开始执行，这时主机的CPU、磁盘和网络基本上处于空闲状态。</p>
<h4 id="5-2、GREP"><a href="#5-2、GREP" class="headerlink" title="5.2、GREP"></a>5.2、GREP</h4><p>这个分布式的grep程序需要扫描大概10的10次方个由100个字节组成的记录，查找出现概率较小的3个字符的模式（这个模式在92337个记录中出现）。输入数据被拆分成大约64M的Block（M=15000），整个输出数据存放在一个文件中（R=1）。</p>
<p><img src="/images/GoogleMR5-2.jpg"></p>
<p>图2显示了这个运算随时间的处理过程。其中Y轴表示输入数据的处理速度。处理速度随着参与MapReduce计算的机器数量的增加而增加，当 1764台worker参与计算的时，处理速度达到了30GB/s。当Map任务结束的时候，即在计算开始后80秒，输入的处理速度降到0。整个计算过程 从开始到结束一共花了大概150秒。这包括了大约一分钟的初始启动阶段。初始启动阶段消耗的时间包括了是把这个程序传送到各个worker机器上的时间、 等待GFS文件系统打开1000个输入文件集合的时间、获取相关的文件本地位置优化信息的时间。</p>
<h4 id="5-3、排序"><a href="#5-3、排序" class="headerlink" title="5.3、排序"></a>5.3、排序</h4><p>排序程序处理10的10次方个100个字节组成的记录（大概1TB的数据）。这个程序模仿TeraSort benchmark[10]。</p>
<p>排序程序由不到50行代码组成。只有三行的Map函数从文本行中解析出10个字节的key值作为排序的key，并且把这个key和原始文本行作 为中间的key/value pair值输出。我们使用了一个内置的恒等函数作为Reduce操作函数。这个函数把中间的key/value pair值不作任何改变输出。最终排序结果输出到两路复制的GFS文件系统（也就是说，程序输出2TB的数据）。</p>
<p>如前所述，输入数据被分成64MB的Block（M=15000）。我们把排序后的输出结果分区后存储到4000个文件（R=4000）。分区函数使用key的原始字节来把数据分区到R个片段中。</p>
<p>在这个benchmark测试中，我们使用的分区函数知道key的分区情况。通常对于排序程序来说，我们会增加一个预处理的MapReduce操作用于采样key值的分布情况，通过采样的数据来计算对最终排序处理的分区点。</p>
<p><img src="/images/GoogleMR5-3.jpg"></p>
<p>图三（a）显示了这个排序程序的正常执行过程。左上的图显示了输入数据读取的速度。数据读取速度峰值会达到13GB/s，并且所有Map任务完 成之后，即大约200秒之后迅速滑落到0。值得注意的是，排序程序输入数据读取速度小于分布式grep程序。这是因为排序程序的Map任务花了大约一半的 处理时间和I/O带宽把中间输出结果写到本地硬盘。相应的分布式grep程序的中间结果输出几乎可以忽略不计。</p>
<p>左边中间的图显示了中间数据从Map任务发送到Reduce任务的网络速度。这个过程从第一个Map任务完成之后就开始缓慢启动了。图示的第一 个高峰是启动了第一批大概1700个Reduce任务（整个MapReduce分布到大概1700台机器上，每台机器1次最多执行1个Reduce任 务）。排序程序运行大约300秒后，第一批启动的Reduce任务有些完成了，我们开始执行剩下的Reduce任务。所有的处理在大约600秒后结束。</p>
<p>左下图表示Reduce任务把排序后的数据写到最终的输出文件的速度。在第一个排序阶段结束和数据开始写入磁盘之间有一个小的延时，这是因为 worker机器正在忙于排序中间数据。磁盘写入速度在2-4GB/s持续一段时间。输出数据写入磁盘大约持续850秒。计入初始启动部分的时间，整个运 算消耗了891秒。这个速度和TeraSort benchmark[18]的最高纪录1057秒相差不多。</p>
<p>还有一些值得注意的现象：输入数据的读取速度比排序速度和输出数据写入磁盘速度要高不少，这是因为我们的输入数据本地化优化策略起了作用 — 绝大部分数据都是从本地硬盘读取的，从而节省了网络带宽。排序速度比输出数据写入到磁盘的速度快，这是因为输出数据写了两份（我们使用了2路的GFS文件 系统，写入复制节点的原因是为了保证数据可靠性和可用性）。我们把输出数据写入到两个复制节点的原因是因为这是底层文件系统的保证数据可靠性和可用性的实 现机制。如果底层文件系统使用类似容错编码<a href="erasure coding">14</a>的方式而不是复制的方式保证数据的可靠性和可用性，那么在输出数据写入磁盘的时候，就可以降低网络带宽的使用。</p>
<h4 id="5-4、高效的backup任务"><a href="#5-4、高效的backup任务" class="headerlink" title="5.4、高效的backup任务"></a>5.4、高效的backup任务</h4><p>图三（b）显示了关闭了备用任务后排序程序执行情况。执行的过程和图3（a）很相似，除了输出数据写磁盘的动作在时间上拖了一个很长的尾巴，而 且在这段时间里，几乎没有什么写入动作。在960秒后，只有5个Reduce任务没有完成。这些拖后腿的任务又执行了300秒才完成。整个计算消耗了 1283秒，多了44%的执行时间。</p>
<h4 id="5-5、失效的机器"><a href="#5-5、失效的机器" class="headerlink" title="5.5、失效的机器"></a>5.5、失效的机器</h4><p>在图三（c）中演示的排序程序执行的过程中，我们在程序开始后几分钟有意的kill了1746个worker中的200个。集群底层的调度立刻在这些机器上重新开始新的worker处理进程（因为只是worker机器上的处理进程被kill了，机器本身还在工作）。</p>
<p>图三（c）显示出了一个“负”的输入数据读取速度，这是因为一些已经完成的Map任务丢失了（由于相应的执行Map任务的worker进程被 kill了），需要重新执行这些任务。相关Map任务很快就被重新执行了。整个运算在933秒内完成，包括了初始启动时间（只比正常执行多消耗了5%的时间）。</p>
<h3 id="6、经验"><a href="#6、经验" class="headerlink" title="6、经验"></a>6、经验</h3><p>我们在2003年1月完成了第一个版本的MapReduce库，在2003年8月的版本有了显著的增强，这包括了输入数据本地优化、 worker机器之间的动态负载均衡等等。从那以后，我们惊喜的发现，MapReduce库能广泛应用于我们日常工作中遇到的各类问题。它现在在 Google内部各个领域得到广泛应用，包括：</p>
<ul>
<li>大规模机器学习问题</li>
<li>Google News和Froogle产品的集群问题</li>
<li>从公众查询产品（比如Google的Zeitgeist）的报告中抽取数据。</li>
<li>从大量的新应用和新产品的网页中提取有用信息（比如，从大量的位置搜索网页中抽取地理位置信息）。</li>
<li>大规模的图形计算。</li>
</ul>
<p><img src="/images/GoogleMR6.jpg"></p>
<p>图四显示了在我们的源代码管理系统中，随着时间推移，独立的MapReduce程序数量的显著增加。从2003年早些时候的0个增长到2004 年9月份的差不多900个不同的程序。MapReduce的成功取决于采用MapReduce库能够在不到半个小时时间内写出一个简单的程序，这个简单的 程序能够在上千台机器的组成的集群上做大规模并发处理，这极大的加快了开发和原形设计的周期。另外，采用MapReduce库，可以让完全没有分布式和/ 或并行系统开发经验的程序员很容易的利用大量的资源，开发出分布式和/或并行处理的应用。</p>
<p><img src="/images/GoogleMR6-2.jpg"></p>
<p>在每个任务结束的时候，MapReduce库统计计算资源的使用状况。在表1，我们列出了2004年8月份MapReduce运行的任务所占用的相关资源。</p>
<h4 id="6-1、大规模索引"><a href="#6-1、大规模索引" class="headerlink" title="6.1、大规模索引"></a>6.1、大规模索引</h4><p>到目前为止，MapReduce最成功的应用就是重写了Google网络搜索服务所使用到的index系统。索引系统的输入数据是网络爬虫抓取回来的海量的文档，这些文档数据都保存在GFS文件系统里。这些文档原始内容 （alex注：raw contents，我认为就是网页中的剔除html标记后的内容、pdf和word等有格式文档中提取的文本内容等）的大小超过了20TB。索引程序是通过一系列的MapReduce操作（大约5到10次）来建立索引。使用MapReduce（替换上一个特别设计的、分布式处理的索引程序）带来这些好处：</p>
<ul>
<li><p>实现索引部分的代码简单、小巧、容易理解，因为对于容错、分布式以及并行计算的处理都是MapReduce库提供的。比如，使用MapReduce库，计算的代码行数从原来的3800行C++代码减少到大概700行代码。</p>
</li>
<li><p>MapReduce库的性能已经足够好了，因此我们可以把在概念上不相关的计算步骤分开处理，而不是混在一起以期减少数据传递的额外消耗。概念 上不相关的计算步骤的隔离也使得我们可以很容易改变索引处理方式。比如，对之前的索引系统的一个小更改可能要耗费好几个月的时间，但是在使用 MapReduce的新系统上，这样的更改只需要花几天时间就可以了。</p>
</li>
<li><p>索引系统的操作管理更容易了。因为由机器失效、机器处理速度缓慢、以及网络的瞬间阻塞等引起的绝大部分问题都已经由MapReduce库解决了，不再需要操作人员的介入了。另外，我们可以通过在索引系统集群中增加机器的简单方法提高整体处理性能。</p>
</li>
</ul>
<h3 id="7、相关工作"><a href="#7、相关工作" class="headerlink" title="7、相关工作"></a>7、相关工作</h3><p>很多系统都提供了严格的编程模式，并且通过对编程的严格限制来实现并行计算。例如，一个结合函数可以通过把N个元素的数组的前缀在N个处理器上使用并行前缀算法，在log N的时间内计算完[6，9，13]。MapReduce可以看作是我们结合在真实环境下处理海量数据的经验，对这些经典模型进行简化和萃取的成果。更加值得骄傲的是，我们还实现了基于上千台处理器的集群的容错处理。相比而言，大部分并发处理系统都只在小规模的集群上实现，并且把容错处理交给了程序员。</p>
<p>Bulk Synchronous Programming[17]和一些MPI原语[11]提供了更高级别的并行处理抽象，可以更容易写出并行处理的程序。MapReduce和这些系统的 关键不同之处在于，MapReduce利用限制性编程模式实现了用户程序的自动并发处理，并且提供了透明的容错处理。</p>
<p>我们数据本地优化策略的灵感来源于active disks[12,15]等技术，在active disks中，计算任务是尽量推送到数据存储的节点处理 <strong>（alex注：即靠近数据源处理）</strong>，这样就减少了网络和IO子系统的吞吐量。我们在挂载几个硬盘的普通机器上执行我们的运算，而不是在磁盘处理器上执行我们的工作，但是达到的目的一样的。</p>
<p>我们的备用任务机制和Charlotte System[3]提出的eager调度机制比较类似。Eager调度机制的一个缺点是如果一个任务反复失效，那么整个计算就不能完成。我们通过忽略引起故障的记录的方式在某种程度上解决了这个问题。</p>
<p>MapReduce的实现依赖于一个内部的集群管理系统，这个集群管理系统负责在一个超大的、共享机器的集群上分布和运行用户任务。虽然这个不是本论文的重点，但是有必要提一下，这个集群管理系统在理念上和其它系统，如Condor[16]是一样。</p>
<p>MapReduce库的排序机制和NOW-Sort[1]的操作上很类似。读取输入源的机器（map workers）把待排序的数据进行分区后，发送到R个Reduce worker中的一个进行处理。每个Reduce worker在本地对数据进行排序（尽可能在内存中排序）。当然，NOW-Sort没有给用户自定义的Map和Reduce函数的机会，因此不具备 MapReduce库广泛的实用性。</p>
<p>River[2]提供了一个编程模型：处理进程通过分布式队列传送数据的方式进行互相通讯。和MapReduce类似，River系统尝试在不 对等的硬件环境下，或者在系统颠簸的情况下也能提供近似平均的性能。River是通过精心调度硬盘和网络的通讯来平衡任务的完成时间。MapReduce 库采用了其它的方法。通过对编程模型进行限制，MapReduce框架把问题分解成为大量的“小”任务。这些任务在可用的worker集群上动态的调度， 这样快速的worker就可以执行更多的任务。通过对编程模型进行限制，我们可用在工作接近完成的时候调度备用任务，缩短在硬件配置不均衡的情况下缩小整 个操作完成的时间（比如有的机器性能差、或者机器被某些操作阻塞了）。</p>
<p>BAD-FS[5]采用了和MapReduce完全不同的编程模式，它是面向广域网的。不过，这两个系统有两个基础功能很类似。</p>
<ul>
<li><p>（1）两个系统采用重新执行的方式来防止由于失效导致的数据丢失。</p>
</li>
<li><p>（2）两个都使用数据本地化调度策略，减少网络通讯的数据量。</p>
</li>
</ul>
<p>TACC[7]是一个用于简化构造高可用性网络服务的系统。和MapReduce一样，它也依靠重新执行机制来实现的容错处理。</p>
<h3 id="8、结束语"><a href="#8、结束语" class="headerlink" title="8、结束语"></a>8、结束语</h3><p>MapReduce编程模型在Google内部成功应用于多个领域。我们把这种成功归结为几个方面：首先，由于MapReduce封装了并行处 理、容错处理、数据本地化优化、负载均衡等等技术难点的细节，这使得MapReduce库易于使用。即便对于完全没有并行或者分布式系统开发经验的程序员 而言；其次，大量不同类型的问题都可以通过MapReduce简单的解决。比如，MapReduce用于生成Google的网络搜索服务所需要的数据、用 来排序、用来数据挖掘、用于机器学习，以及很多其它的系统；第三，我们实现了一个在数千台计算机组成的大型集群上灵活部署运行的MapReduce。这个 实现使得有效利用这些丰富的计算资源变得非常简单，因此也适合用来解决Google遇到的其他很多需要大量计算的问题。</p>
<p>我们也从MapReduce开发过程中学到了不少东西。首先，约束编程模式使得并行和分布式计算非常容易，也易于构造容错的计算环境；其次，网络带 宽是稀有资源。大量的系统优化是针对减少网络传输量为目的的：本地优化策略使大量的数据从本地磁盘读取，中间文件写入本地磁盘、并且只写一份中间文件也节 约了网络带宽；第三，多次执行相同的任务可以减少性能缓慢的机器带来的负面影响<strong>（alex注：即硬件配置的不平衡）</strong>，同时解决了由于机器失效导致的数据丢失问题。</p>
<h3 id="9、参考资料"><a href="#9、参考资料" class="headerlink" title="9、参考资料"></a>9、参考资料</h3><p>[1] Andrea C. Arpaci-Dusseau, Remzi H. Arpaci-Dusseau,David E. Culler, Joseph M. Hellerstein, and David A. Patterson.High-performance sorting on networks of workstations.In Proceedings of the 1997 ACM SIGMOD InternationalConference on Management of Data, Tucson,Arizona, May 1997.<br>[2] Remzi H. Arpaci-Dusseau, Eric Anderson, NoahTreuhaft, David E. Culler, Joseph M. Hellerstein, David Patterson, and Kathy Yelick. Cluster I/O with River:Making the fast case common. In Proceedings of the Sixth Workshop on Input/Output in Parallel and Distributed Systems (IOPADS ’99), pages 10.22, Atlanta, Georgia, May 1999.<br>[3] Arash Baratloo, Mehmet Karaul, Zvi Kedem, and Peter Wyckoff. Charlotte: Metacomputing on the web. In Proceedings of the 9th International Conference on Parallel and Distributed Computing Systems, 1996. [4] Luiz A. Barroso, Jeffrey Dean, and Urs H¨olzle. Web search for a planet: The Google cluster architecture. IEEE Micro, 23(2):22.28, April 2003.<br>[5] John Bent, Douglas Thain, Andrea C.Arpaci-Dusseau, Remzi H. Arpaci-Dusseau, and Miron Livny. Explicit control in a batch-aware distributed file system. In Proceedings of the 1st USENIX Symposium on Networked Systems Design and Implementation NSDI, March 2004.<br>[6] Guy E. Blelloch. Scans as primitive parallel operations.IEEE Transactions on Computers, C-38(11), November 1989.<br>[7] Armando Fox, Steven D. Gribble, Yatin Chawathe, Eric A. Brewer, and Paul Gauthier. Cluster-based scalable network services. In Proceedings of the 16th ACM Symposium on Operating System Principles, pages 78. 91, Saint-Malo, France, 1997.<br>[8] Sanjay Ghemawat, Howard Gobioff, and Shun-Tak Leung. The Google file system. In 19th Symposium on Operating Systems Principles, pages 29.43, Lake George, New York, 2003. To appear in OSDI 2004 12<br>[9] S. Gorlatch. Systematic efficient parallelization of scan and other list homomorphisms. In L. Bouge, P. Fraigniaud, A. Mignotte, and Y. Robert, editors, Euro-Par’96. Parallel Processing, Lecture Notes in Computer Science 1124, pages 401.408. Springer-Verlag, 1996.<br>[10] Jim Gray. Sort benchmark home page. <a href="http://research.microsoft.com/barc/SortBenchmark/" target="_blank" rel="external">http://research.microsoft.com/barc/SortBenchmark/</a>.<br>[11] William Gropp, Ewing Lusk, and Anthony Skjellum. Using MPI: Portable Parallel Programming with the Message-Passing Interface. MIT Press, Cambridge, MA, 1999.<br>[12] L. Huston, R. Sukthankar, R.Wickremesinghe, M. Satyanarayanan, G. R. Ganger, E. Riedel, and A. Ailamaki. Diamond: A storage architecture for early discard in interactive search. In Proceedings of the 2004 USENIX File and Storage Technologies FAST Conference, April 2004.<br>[13] Richard E. Ladner and Michael J. Fischer. Parallel prefix computation. Journal of the ACM, 27(4):831.838, 1980.<br>[14] Michael O. Rabin. Efficient dispersal of information for security, load balancing and fault tolerance. Journal of the ACM, 36(2):335.348, 1989.<br>[15] Erik Riedel, Christos Faloutsos, Garth A. Gibson, and David Nagle. Active disks for large-scale data processing. IEEE Computer, pages 68.74, June 2001.<br>[16] Douglas Thain, Todd Tannenbaum, and Miron Livny. Distributed computing in practice: The Condor experience. Concurrency and Computation: Practice and Experience, 2004.<br>[17] L. G. Valiant. A bridging model for parallel computation. Communications of the ACM, 33(8):103.111, 1997.<br>[18] Jim Wyllie. Spsort: How to sort a terabyte quickly. <a href="http://alme1.almaden.ibm.com/cs/spsort.pdf" target="_blank" rel="external">http://alme1.almaden.ibm.com/cs/spsort.pdf</a>.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Google GFS文件系统]]></title>
      <url>http://zsr.github.io/2016/08/19/Google-GFS%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
      <content type="html"><![CDATA[<h1 id="The-Google-File-System中文版"><a href="#The-Google-File-System中文版" class="headerlink" title="The Google File System中文版"></a>The Google File System中文版</h1><p>译者：alex</p>
<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>我们设计并实现了Google GFS文件系统，一个面向大规模数据密集型应用的、可伸缩的分布式文件系统。GFS虽然运行在廉价的普遍硬件设备上，但是它依然了提供灾难冗余的能力，为大量客户机提供了高性能的服务。</p>
<p>虽然GFS的设计目标与许多传统的分布式文件系统有很多相同之处，但是，我们的设计还是以我们对自己的应用的负载情况和技术环境的分析为基础 的，不管现在还是将来，GFS和早期的分布式文件系统的设想都有明显的不同。所以我们重新审视了传统文件系统在设计上的折衷选择，衍生出了完全不同的设计 思路。</p>
<p>GFS完全满足了我们对存储的需求。GFS作为存储平台已经被广泛的部署在Google内部，存储我们的服务产生和处理的数据，同时还用于那些 需要大规模数据集的研究和开发工作。目前为止，最大的一个集群利用数千台机器的数千个硬盘，提供了数百TB的存储空间，同时为数百个客户机服务。</p>
<p>在本论文中，我们展示了能够支持分布式应用的文件系统接口的扩展，讨论我们设计的许多方面，最后列出了小规模性能测试以及真实生产系统中性能相关数据。</p>
<h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><p>为了满足Google迅速增长的数据处理需求，我们设计并实现了Google文件系统(Google File System – GFS)。GFS与传统的分布式文件系统有着很多相同的设计目标，比如，性能、可伸缩性、可靠性以及可用性。但是，我们的设计还基于我们对我们自己的应用 的负载情况和技术环境的观察的影响，不管现在还是将来，GFS和早期文件系统的假设都有明显的不同。所以我们重新审视了传统文件系统在设计上的折衷选择， 衍生出了完全不同的设计思路。</p>
<ul>
<li><p>首先，组件失效被认为是常态事件，而不是意外事件。GFS包括几百甚至几千台普通的廉价设备组装的存储机器，同时被相当数量的客户机访问。 GFS组件的数量和质量导致在事实上，任何给定时间内都有可能发生某些组件无法工作，某些组件无法从它们目前的失效状态中恢复。我们遇到过各种各样的问 题，比如应用程序bug、操作系统的bug、人为失误，甚至还有硬盘、内存、连接器、网络以及电源失效等造成的问题。所以，持续的监控、错误侦测、灾难冗 余以及自动恢复的机制必须集成在GFS中。</p>
</li>
<li><p>其次，以通常的标准衡量，我们的文件非常巨大。数GB的文件非常普遍。每个文件通常都包含许多应用程序对象，比如web文档。当我们经常需要处 理快速增长的、并且由数亿个对象构成的、数以TB的数据集时，采用管理数亿个KB大小的小文件的方式是非常不明智的，尽管有些文件系统支持这样的管理方 式。因此，设计的假设条件和参数，比如I/O操作和Block的尺寸都需要重新考虑。</p>
</li>
<li><p>第三，绝大部分文件的修改是采用在文件尾部追加数据，而不是覆盖原有数据的方式。对文件的随机写入操作在实际中几乎不存在。一旦写完之后，对文 件的操作就只有读，而且通常是按顺序读。大量的数据符合这些特性，比如：数据分析程序扫描的超大的数据集；正在运行的应用程序生成的连续的数据流；存档的 数据；由一台机器生成、另外一台机器处理的中间数据，这些中间数据的处理可能是同时进行的、也可能是后续才处理的。对于这种针对海量文件的访问模式，客户 端对数据块缓存是没有意义的，数据的追加操作是性能优化和原子性保证的主要考量因素。</p>
</li>
<li><p>第四，应用程序和文件系统API的协同设计提高了整个系统的灵活性。比如，我们放松了对GFS一致性模型的要求，这样就减轻了文件系统对应用程 序的苛刻要求，大大简化了GFS的设计。我们引入了原子性的记录追加操作，从而保证多个客户端能够同时进行追加操作，不需要额外的同步操作来保证数据的一 致性。本文后面还有对这些问题的细节的详细讨论。</p>
</li>
</ul>
<p>Google已经针对不同的应用部署了多套GFS集群。最大的一个集群拥有超过1000个存储节点，超过300TB的硬盘空间，被不同机器上的数百个客户端连续不断的频繁访问。 </p>
<h3 id="2-设计概述"><a href="#2-设计概述" class="headerlink" title="2 设计概述"></a>2 设计概述</h3><h4 id="2-1-设计预期"><a href="#2-1-设计预期" class="headerlink" title="2.1 设计预期"></a>2.1 设计预期</h4><p>在设计满足我们需求的文件系统时候，我们的设计目标既有机会、又有挑战。之前我们已经提到了一些需要关注的关键点，这里我们将设计的预期目标的细节展开讨论。</p>
<ul>
<li><p>系统由许多廉价的普通组件组成，组件失效是一种常态。系统必须持续监控自身的状态，它必须将组件失效作为一种常态，能够迅速地侦测、冗余并恢复失效的组件。</p>
</li>
<li><p>系统存储一定数量的大文件。我们预期会有几百万文件，文件的大小通常在100MB或者以上。数个GB大小的文件也是普遍存在，并且要能够被有效的管理。系统也必须支持小文件，但是不需要针对小文件做专门的优化。</p>
</li>
<li><p>系统的工作负载主要由两种读操作组成：大规模的流式读取和小规模的随机读取。大规模的流式读取通常一次读取数百KB的数据，更常见的是一次读取 1MB甚至更多的数据。来自同一个客户机的连续操作通常是读取同一个文件中连续的一个区域。小规模的随机读取通常是在文件某个随机的位置读取几个KB数 据。如果应用程序对性能非常关注，通常的做法是把小规模的随机读取操作合并并排序，之后按顺序批量读取，这样就避免了在文件中前后来回的移动读取位置。</p>
</li>
<li><p>系统的工作负载还包括许多大规模的、顺序的、数据追加方式的写操作。一般情况下，每次写入的数据的大小和大规模读类似。数据一旦被写入后，文件就很少会被修改了。系统支持小规模的随机位置写入操作，但是可能效率不彰。</p>
</li>
<li><p>系统必须高效的、行为定义明确的实现多客户端并行追加数据到同一个文件里的语意。我们的文件通常被用于”生产者-消费者“队列，或者其它多路文件合并操作。通常会有数百个生产者，每个生产者进 程运行在一台机器上，同时对一个文件进行追加操作。使用最小的同步开销来实现的原子的多路追加数据操作是必不可少的。文件可以在稍后读取，或者是消费者在 追加的操作的同时读取文件。</p>
</li>
<li><p>高性能的稳定网络带宽远比低延迟重要。我们的目标程序绝大部分要求能够高速率的、大批量的处理数据，极少有程序对单一的读写操作有严格的响应时间要求。</p>
</li>
</ul>
<h4 id="2-2-接口"><a href="#2-2-接口" class="headerlink" title="2.2 接口"></a>2.2 接口</h4><p>GFS提供了一套类似传统文件系统的API接口函数，虽然并不是严格按照POSIX等标准API的形式实现的。文件以分层目录的形式组织，用路径名来标识。我们支持常用的操作，如创建新文件、删除文件、打开文件、关闭文件、读和写文件。</p>
<p>另外，GFS提供了快照和记录追加操作。快照以很低的成本创建一个文件或者目录树的拷贝。记录追加操作允许多个客户端同时对一个文件进行数据追 加操作，同时保证每个客户端的追加操作都是原子性的。这对于实现多路结果合并，以及”生产者-消费者”队列非常有用，多个客户端可以在不需要额外的同步锁 定的情况下，同时对一个文件追加数据。我们发现这些类型的文件对于构建大型分布应用是非常重要的。快照和记录追加操作将在3.4和3.3节分别讨论。</p>
<h4 id="2-3-架构"><a href="#2-3-架构" class="headerlink" title="2.3 架构"></a>2.3 架构</h4><p>一个GFS集群包含一个单独的Master节点<strong>(alex注：这里的一个单 独的Master节点的含义是GFS系统中只存在一个逻辑上的Master组件。后面我们还会提到Master节点复制，因此，为了理解方便，我们把 Master节点视为一个逻辑上的概念，一个逻辑的Master节点包括两台物理主机，即两台Master服务器）</strong>、多台 Chunk服务器，并且同时被多个客户端访问，如图1所示。所有的这些机器通常都是普通的Linux机器，运行着用户级别(user-level)的服务 进程。我们可以很容易的把Chunk服务器和客户端都放在同一台机器上，前提是机器资源允许，并且我们能够接受不可靠的应用程序代码带来的稳定性降低的风险。</p>
<p><img src="/images/GFS2-3.jpg"></p>
<p>GFS存储的文件都被分割成固定大小的Chunk。在Chunk创建的时候，Master服务器会给每个Chunk分配一个不变的、全球唯一的 64位的Chunk标识。Chunk服务器把Chunk以linux文件的形式保存在本地硬盘上，并且根据指定的Chunk标识和字节范围来读写块数据。 出于可靠性的考虑，每个块都会复制到多个块服务器上。缺省情况下，我们使用3个存储复制节点，不过用户可以为不同的文件命名空间设定不同的复制级别。</p>
<p>Master节点管理所有的文件系统元数据。这些元数据包括名字空间、访问控制信息、文件和Chunk的映射信息、以及当前Chunk的位置信息。Master节点还管理着系统范围内的活动，比如，Chunk租用管理 <strong>(alex注：BDB也有关于lease的描述，不知道是否相同)</strong>、孤儿Chunk <strong>(alex注：orphaned chunks)</strong>的回收、以及Chunk在Chunk服务器之间的迁移。Master节点使用心跳信息周期地和每个Chunk服务器通讯，发送指令到各个Chunk服务器并接收Chunk服务器的状态信息。</p>
<p>GFS客户端代码以库的形式被链接到客户程序里。客户端代码实现了GFS文件系统的API接口函数、应用程序与Master节点和Chunk服 务器通讯、以及对数据进行读写操作。客户端和Master节点的通信只获取元数据，所有的数据操作都是由客户端直接和Chunk服务器进行交互的。我们不 提供POSIX标准的API的功能，因此，GFS API调用不需要深入到Linux vnode级别。</p>
<p>无论是客户端还是Chunk服务器都不需要缓存文件数据。客户端缓存数据几乎没有什么用处，因为大部分程序要么以流的方式读取一个巨大文件，要 么工作集太大根本无法被缓存。无需考虑缓存相关的问题也简化了客户端和整个系统的设计和实现。（不过，客户端会缓存元数据。）Chunk服务器不需要缓存 文件数据的原因是，Chunk以本地文件的方式保存，Linux操作系统的文件系统缓存会把经常访问的数据缓存在内存中。</p>
<h4 id="2-4-单一Master节点"><a href="#2-4-单一Master节点" class="headerlink" title="2.4 单一Master节点"></a>2.4 单一Master节点</h4><p>单一的Master节点的策略大大简化了我们的设计。单一的Master节点可以通过全局的信息精确定位Chunk的位置以及进行复制决策。另 外，我们必须减少对Master节点的读写，避免Master节点成为系统的瓶颈。客户端并不通过Master节点读写文件数据。反之，客户端向 Master节点询问它应该联系的Chunk服务器。客户端将这些元数据信息缓存一段时间，后续的操作将直接和Chunk服务器进行数据读写操作。</p>
<p>我们利用图1解释一下一次简单读取的流程。首先，客户端把文件名和程序指定的字节偏移，根据固定的Chunk大小，转换成文件的Chunk索 引。然后，它把文件名和Chunk索引发送给Master节点。Master节点将相应的Chunk标识和副本的位置信息发还给客户端。客户端用文件名和 Chunk索引作为key缓存这些信息。</p>
<p>之后客户端发送请求到其中的一个副本处，一般会选择最近的。请求信息包含了Chunk的标识和字节范围。在对这个Chunk的后续读取操作中， 客户端不必再和Master节点通讯了，除非缓存的元数据信息过期或者文件被重新打开。实际上，客户端通常会在一次请求中查询多个Chunk信 息，Master节点的回应也可能包含了紧跟着这些被请求的Chunk后面的Chunk的信息。在实际应用中，这些额外的信息在没有任何代价的情况下，避 免了客户端和Master节点未来可能会发生的几次通讯。</p>
<h4 id="2-5-Chunk尺寸"><a href="#2-5-Chunk尺寸" class="headerlink" title="2.5 Chunk尺寸"></a>2.5 Chunk尺寸</h4><p>Chunk的大小是关键的设计参数之一。我们选择了64MB，这个尺寸远远大于一般文件系统的Block size。每个Chunk的副本都以普通Linux文件的形式保存在Chunk服务器上，只有在需要的时候才扩大。惰性空间分配策略避免了因内部碎片造成 的空间浪费，内部碎片或许是对选择这么大的Chunk尺寸最具争议一点。</p>
<p>选择较大的Chunk尺寸有几个重要的优点。首先，它减少了客户端和Master节点通讯的需求，因为只需要一次和Mater节点的通信就可以 获取Chunk的位置信息，之后就可以对同一个Chunk进行多次的读写操作。这种方式对降低我们的工作负载来说效果显著，因为我们的应用程序通常是连续 读写大文件。即使是小规模的随机读取，采用较大的Chunk尺寸也带来明显的好处，客户端可以轻松的缓存一个数TB的工作数据集所有的Chunk位置信 息。其次，采用较大的Chunk尺寸，客户端能够对一个块进行多次操作，这样就可以通过与Chunk服务器保持较长时间的TCP连接来减少网络负载。第 三，选用较大的Chunk尺寸减少了Master节点需要保存的元数据的数量。这就允许我们把元数据全部放在内存中，在2.6.1节我们会讨论元数据全部 放在内存中带来的额外的好处。</p>
<p>另一方面，即使配合惰性空间分配，采用较大的Chunk尺寸也有其缺陷。小文件包含较少的Chunk，甚至只有一个Chunk。当有许多的客户 端对同一个小文件进行多次的访问时，存储这些Chunk的Chunk服务器就会变成热点。在实际应用中，由于我们的程序通常是连续的读取包含多个 Chunk的大文件，热点还不是主要的问题。</p>
<p>然而，当我们第一次把GFS用于批处理队列系统的时候，热点的问题还是产生了：一个可执行文件在GFS上保存为single-chunk文件， 之后这个可执行文件在数百台机器上同时启动。存放这个可执行文件的几个Chunk服务器被数百个客户端的并发请求访问导致系统局部过载。我们通过使用更大 的复制参数来保存可执行文件，以及错开批处理队列系统程序的启动时间的方法解决了这个问题。一个可能的长效解决方案是，在这种的情况下，允许客户端从其它 客户端读取数据。</p>
<h4 id="2-6-元数据"><a href="#2-6-元数据" class="headerlink" title="2.6 元数据"></a>2.6 元数据</h4><p>Master服务器 <strong>（alex注：注意逻辑的Master节点和物理的Master服务器的区别。后续我们谈的是每个Master服务器的行为，如存储、内存等等，因此我们将全部使用物理名称）</strong>存储3种主要类型的元数据，包括：文件和Chunk的命名空间、文件和Chunk的对应关系、每个Chunk副本的存放地点。所有的元数据都保存在 Master服务器的内存中。前两种类型的元数据（命名空间、文件和Chunk的对应关系）同时也会以记录变更日志的方式记录在操作系统的系统日志文件 中，日志文件存储在本地磁盘上，同时日志会被复制到其它的远程Master服务器上。采用保存变更日志的方式，我们能够简单可靠的更新Master服务器 的状态，并且不用担心Master服务器崩溃导致数据不一致的风险。Master服务器不会持久保存Chunk位置信息。Master服务器在启动时，或 者有新的Chunk服务器加入时，向各个Chunk服务器轮询它们所存储的Chunk的信息。</p>
<h5 id="2-6-1-内存中的数据结构"><a href="#2-6-1-内存中的数据结构" class="headerlink" title="2.6.1 内存中的数据结构"></a>2.6.1 内存中的数据结构</h5><p>因为元数据保存在内存中，所以Master服务器的操作速度非常快。并且，Master服务器可以在后台简单而高效的周期性扫描自己保存的全部 状态信息。这种周期性的状态扫描也用于实现Chunk垃圾收集、在Chunk服务器失效的时重新复制数据、通过Chunk的迁移实现跨Chunk服务器的 负载均衡以及磁盘使用状况统计等功能。4.3和4.4章节将深入讨论这些行为。</p>
<p>将元数据全部保存在内存中的方法有潜在问题：Chunk的数量以及整个系统的承载能力都受限于Master服务器所拥有的内存大小。但是在实际 应用中，这并不是一个严重的问题。Master服务器只需要不到64个字节的元数据就能够管理一个64MB的Chunk。由于大多数文件都包含多个 Chunk，因此绝大多数Chunk都是满的，除了文件的最后一个Chunk是部分填充的。同样的，每个文件的在命名空间中的数据大小通常在64字节以 下，因为保存的文件名是用前缀压缩算法压缩过的。</p>
<p>即便是需要支持更大的文件系统，为Master服务器增加额外内存的费用是很少的，而通过增加有限的费用，我们就能够把元数据全部保存在内存里，增强了系统的简洁性、可靠性、高性能和灵活性。</p>
<h5 id="2-6-2-Chunk位置信息"><a href="#2-6-2-Chunk位置信息" class="headerlink" title="2.6.2 Chunk位置信息"></a>2.6.2 Chunk位置信息</h5><p>Master服务器并不保存持久化保存哪个Chunk服务器存有指定Chunk的副本的信息。Master服务器只是在启动的时候轮询Chunk服 务器以获取这些信息。Master服务器能够保证它持有的信息始终是最新的，因为它控制了所有的Chunk位置的分配，而且通过周期性的心跳信息监控 Chunk服务器的状态。</p>
<p>最初设计时，我们试图把Chunk的位置信息持久的保存在Master服务器上，但是后来我们发现在启动的时候轮询Chunk服务器，之后定期轮询 更新的方式更简单。这种设计简化了在有Chunk服务器加入集群、离开集群、更名、失效、以及重启的时候，Master服务器和Chunk服务器数据同步 的问题。在一个拥有数百台服务器的集群中，这类事件会频繁的发生。</p>
<p>可以从另外一个角度去理解这个设计决策：只有Chunk服务器才能最终确定一个Chunk是否在它的硬盘上。我们从没有考虑过在Master服务器 上维护一个这些信息的全局视图，因为Chunk服务器的错误可能会导致Chunk自动消失(比如，硬盘损坏了或者无法访问了)，亦或者操作人员可能会重命 名一个Chunk服务器。</p>
<h5 id="2-6-3-操作日志"><a href="#2-6-3-操作日志" class="headerlink" title="2.6.3 操作日志"></a>2.6.3 操作日志</h5><p>操作日志包含了关键的元数据变更历史记录。这对GFS非常重要。这不仅仅是因为操作日志是元数据唯一的持久化存储记录，它也作为判断同步操作顺序的逻辑时间基线<strong>（alex注：也就是通过逻辑日志的序号作为操作发生的逻辑时间，类似于事务系统中的LSN）</strong>。文件和Chunk，连同它们的版本(参考4.5节)，都由它们创建的逻辑时间唯一的、永久的标识。</p>
<p>操作日志非常重要，我们必须确保日志文件的完整，确保只有在元数据的变化被持久化后，日志才对客户端是可见的。否则，即使Chunk本身没有出现任 何问题，我们仍有可能丢失整个文件系统，或者丢失客户端最近的操作。所以，我们会把日志复制到多台远程机器，并且只有把相应的日志记录写入到本地以及远程 机器的硬盘后，才会响应客户端的操作请求。Master服务器会收集多个日志记录后批量处理，以减少写入磁盘和复制对系统整体性能的影响。</p>
<p>Master服务器在灾难恢复时，通过重演操作日志把文件系统恢复到最近的状态。为了缩短Master启动的时间，我们必须使日志足够小 <strong>（alex注：即重演系统操作的日志量尽量的少）</strong>。Master服务器在日志增长到一定量时对系统状态做一次Checkpoint <strong>(alex注：Checkpoint是一种行为，一种对数据库状态作一次快照的行为)</strong>，将所有的状态数据写入一个Checkpoint文件 <strong>（alex注：并删除之前的日志文件）</strong>。 在灾难恢复的时候，Master服务器就通过从磁盘上读取这个Checkpoint文件，以及重演Checkpoint之后的有限个日志文件就能够恢复系统。Checkpoint文件以压缩B-树形势的数据结构存储，可以直接映射到内存，在用于命名空间查询时无需额外的解析。这大大提高了恢复速度，增强了可用性。</p>
<p>由于创建一个Checkpoint文件需要一定的时间，所以Master服务器的内部状态被组织为一种格式，这种格式要确保在Checkpoint 过程中不会阻塞正在进行的修改操作。Master服务器使用独立的线程切换到新的日志文件和创建新的Checkpoint文件。新的Checkpoint 文件包括切换前所有的修改。对于一个包含数百万个文件的集群，创建一个Checkpoint文件需要1分钟左右的时间。创建完成后，Checkpoint 文件会被写入在本地和远程的硬盘里。</p>
<p>Master服务器恢复只需要最新的Checkpoint文件和后续的日志文件。旧的Checkpoint文件和日志文件可以被删除，但是为了应对灾难性的故障<strong>（alex注：catastrophes，数据备份相关文档中经常会遇到这个词，表示一种超出预期范围的灾难性事件）</strong>，我们通常会多保存一些历史文件。Checkpoint失败不会对正确性产生任何影响，因为恢复功能的代码可以检测并跳过没有完成的Checkpoint文件。</p>
<h4 id="2-7-一致性模型"><a href="#2-7-一致性模型" class="headerlink" title="2.7 一致性模型"></a>2.7 一致性模型</h4><p>GFS支持一个宽松的一致性模型，这个模型能够很好的支撑我们的高度分布的应用，同时还保持了相对简单且容易实现的优点。本节我们讨论GFS的一致 性的保障机制，以及对应用程序的意义。我们也着重描述了GFS如何管理这些一致性保障机制，但是实现的细节将在本论文的其它部分讨论。</p>
<h5 id="2-7-1-GFS一致性保障机制"><a href="#2-7-1-GFS一致性保障机制" class="headerlink" title="2.7.1 GFS一致性保障机制"></a>2.7.1 GFS一致性保障机制</h5><p>文件命名空间的修改（例如，文件创建）是原子性的。它们仅由Master节点的控制：命名空间锁提供了原子性和正确性（4.1章）的保障；Master节点的操作日志定义了这些操作在全局的顺序（2.6.3章）。</p>
<p><img src="/images/GFS2-7.jpg"></p>
<p>数据修改后文件region<strong>（alex注：region这个词用中文非常难以表达，我认为应该是修改操作所涉及的文件中的某个范围）</strong>的状态取决于操作的类型、成功与否、以及是否同步修改。表1总结了各种操作的结果。如果所有客户端，无论从哪个副本读取，读到的数据都一样，那么我们认为文 件region是“一致的”；如果对文件的数据修改之后，region是一致的，并且客户端能够看到写入操作全部的内容，那么这个region是“已定义 的”。当一个数据修改操作成功执行，并且没有受到同时执行的其它写入操作的干扰，那么影响的region就是已定义的（隐含了一致性）：所有的客户端都可 以看到写入的内容。并行修改操作成功完成之后，region处于一致的、未定义的状态：所有的客户端看到同样的数据，但是无法读到任何一次写入操作写入的 数据。通常情况下，文件region内包含了来自多个修改操作的、混杂的数据片段。失败的修改操作导致一个region处于不一致状态（同时也是未定义 的）：不同的客户在不同的时间会看到不同的数据。后面我们将描述应用如何区分已定义和未定义的region。应用程序没有必要再去细分未定义region 的不同类型。</p>
<p>数据修改操作分为写入或者记录追加两种。写入操作把数据写在应用程序指定的文件偏移位置上。即使有多个修改操作并行执行时，记录追加操作至少可以把数据原子性的追加到文件中一次，但是偏移位置是由GFS选择的（3.3章） <strong>（alex注：这句话有点费解，其含义是所有的追加写入都会成功，但是有可能被执行了多次，而且每次追加的文件偏移量由GFS自己计算）。</strong> （相比而言，通常说的追加操作写的偏移位置是文件的尾部。）GFS返回给客户端一个偏移量，表示了包含了写入记录的、已定义的region的起点。另 外，GFS可能会在文件中间插入填充数据或者重复记录。这些数据占据的文件region被认定是不一致的，这些数据通常比用户数据小的多。</p>
<p>经过了一系列的成功的修改操作之后，GFS确保被修改的文件region是已定义的，并且包含最后一次修改操作写入的数据。GFS通过以下措施确保 上述行为：</p>
<ul>
<li>（a） 对Chunk的所有副本的修改操作顺序一致（3.1章）</li>
<li>（b）使用Chunk的版本号来检测副本是否因为它所在的Chunk服务器宕机（4.5章）而错过了修改操作而导致其失效。失效的副本不会再进行任何修改操作，Master服务器也不再返回这个Chunk副本的位置信息给客户端。它们会被垃圾收集系 统尽快回收。</li>
</ul>
<p>由于Chunk位置信息会被客户端缓存，所以在信息刷新前，客户端有可能从一个失效的副本读取了数据。在缓存的超时时间和文件下一次被打开的时 间之间存在一个时间窗，文件再次被打开后会清除缓存中与该文件有关的所有Chunk位置信息。而且，由于我们的文件大多数都是只进行追加操作的，所以，一 个失效的副本通常返回一个提前结束的Chunk而不是过期的数据。当一个Reader <strong>（alex注：本文中将用到两个专有名词，Reader和Writer，分别表示执行GFS读取和写入操作的程序）</strong>重新尝试并联络Master服务器时，它就会立刻得到最新的Chunk位置信息。</p>
<p>即使在修改操作成功执行很长时间之后，组件的失效也可能损坏或者删除数据。GFS通过Master服务器和所有Chunk服务器的定期“握手” 来找到失效的Chunk服务器，并且使用Checksum来校验数据是否损坏（5.2章）。一旦发现问题，数据要尽快利用有效的副本进行恢复（4.3 章）。只有当一个Chunk的所有副本在GFS检测到错误并采取应对措施之前全部丢失，这个Chunk才会不可逆转的丢失。在一般情况下GFS的反应时间 <strong>（alex注：指Master节点检测到错误并采取应对措施）</strong>是几分钟。即使在这种情况下，Chunk也只是不可用了，而不是损坏了：应用程序会收到明确的错误信息而不是损坏的数据。</p>
<h5 id="2-7-2-程序的实现"><a href="#2-7-2-程序的实现" class="headerlink" title="2.7.2 程序的实现"></a>2.7.2 程序的实现</h5><p>使用GFS的应用程序可以利用一些简单技术实现这个宽松的一致性模型，这些技术也用来实现一些其它的目标功能，包括：尽量采用追加写入而不是覆盖，Checkpoint，自验证的写入操作，自标识的记录。</p>
<p>在实际应用中，我们所有的应用程序对文件的写入操作都是尽量采用数据追加方式，而不是覆盖方式。一种典型的应用，应用程序从头到尾写入数据，生 成了一个文件。写入所有数据之后，应用程序自动将文件改名为一个永久保存的文件名，或者周期性的作Checkpoint，记录成功写入了多少数据。 Checkpoint文件可以包含程序级别的校验和。Readers仅校验并处理上个Checkpoint之后产生的文件region，这些文件 region的状态一定是已定义的。这个方法满足了我们一致性和并发处理的要求。追加写入比随机位置写入更加有效率，对应用程序的失败处理更具有弹性。 Checkpoint可以让Writer以渐进的方式重新开始，并且可以防止Reader处理已经被成功写入，但是从应用程序的角度来看还并未完成的数 据。</p>
<p>我们再来分析另一种典型的应用。许多应用程序并行的追加数据到同一个文件，比如进行结果的合并或者是一个生产者-消费者队列。记录追加方式的 “至少一次追加”的特性保证了Writer的输出。Readers使用下面的方法来处理偶然性的填充数据和重复内容。Writers在每条写入的记录中都 包含了额外的信息，例如Checksum，用来验证它的有效性。Reader可以利用Checksum识别和抛弃额外的填充数据和记录片段。如果应用不能 容忍偶尔的重复内容(比如，如果这些重复数据触发了非幂等操作)，可以用记录的唯一标识符来过滤它们，这些唯一标识符通常用于命名程序中处理的实体对象， 例如web文档。这些记录I/O功能 <strong>（alex注：These functionalities for record I/O）</strong>（除了剔除重复数据）都包含在我们的程序共享的库中，并且适用于Google内部的其它的文件接口实现。所以，相同序列的记录，加上一些偶尔出现的重复数据，都被分发到Reader了。</p>
<h3 id="3-系统交互"><a href="#3-系统交互" class="headerlink" title="3. 系统交互"></a>3. 系统交互</h3><p>我们在设计这个系统时，一个重要的原则是最小化所有操作和Master节点的交互。带着这样的设计理念，我们现在描述一下客户机、Master服务器和Chunk服务器如何进行交互，以实现数据修改操作、原子的记录追加操作以及快照功能。</p>
<h4 id="3-1-租约（lease）和变更顺序"><a href="#3-1-租约（lease）和变更顺序" class="headerlink" title="3.1 租约（lease）和变更顺序"></a>3.1 租约（lease）和变更顺序</h4><p><strong>（alex注：lease是数据库中的一个术语）</strong></p>
<p>变更是一个会改变Chunk内容或者元数据的操作，比如写入操作或者记录追加操作。变更操作会在Chunk的所有副本上执行。我们使用租约 （lease）机制来保持多个副本间变更顺序的一致性。Master节点为Chunk的一个副本建立一个租约，我们把这个副本叫做主Chunk。主 Chunk对Chunk的所有更改操作进行序列化。所有的副本都遵从这个序列进行修改操作。因此，修改操作全局的顺序首先由Master节点选择的租约的 顺序决定，然后由租约中主Chunk分配的序列号决定。</p>
<p>设计租约机制的目的是为了最小化Master节点的管理负担。租约的初始超时设置为60秒。不过，只要Chunk被修改了，主Chunk就可以 申请更长的租期，通常会得到Master节点的确认并收到租约延长的时间。这些租约延长请求和批准的信息通常都是附加在Master节点和Chunk服务 器之间的心跳消息中来传递。有时Master节点会试图提前取消租约（例如，Master节点想取消在一个已经被改名的文件上的修改操作）。即使 Master节点和主Chunk失去联系，它仍然可以安全地在旧的租约到期后和另外一个Chunk副本签订新的租约。</p>
<p><img src="/images/GFS3-1.jpg"></p>
<ul>
<li><p>1.客户机向Master节点询问哪一个Chunk服务器持有当前的租约，以及其它副本的位置。如果没有一个Chunk持有租约，Master节点就选择其中一个副本建立一个租约（这个步骤在图上没有显示）。</p>
</li>
<li><p>2.Master节点将主Chunk的标识符以及其它副本（又称为secondary副本、二级副本）的位置返回给客户机。客户机缓存这些数据以便 后续的操作。只有在主Chunk不可用，或者主Chunk回复信息表明它已不再持有租约的时候，客户机才需要重新跟Master节点联系。</p>
</li>
<li><p>3.客户机把数据推送到所有的副本上。客户机可以以任意的顺序推送数据。Chunk服务器接收到数据并保存在它的内部LRU缓存中，一直到数据被使 用或者过期交换出去。由于数据流的网络传输负载非常高，通过分离数据流和控制流，我们可以基于网络拓扑情况对数据流进行规划，提高系统性能，而不用去理会 哪个Chunk服务器保存了主Chunk。3.2章节会进一步讨论这点。</p>
</li>
<li><p>4.当所有的副本都确认接收到了数据，客户机发送写请求到主Chunk服务器。这个请求标识了早前推送到所有副本的数据。主Chunk为接收到的所 有操作分配连续的序列号，这些操作可能来自不同的客户机，序列号保证了操作顺序执行。它以序列号的顺序把操作应用到它自己的本地状态中 <strong>（alex注：也就是在本地执行这些操作，这句话按字面翻译有点费解，也许应该翻译为“它顺序执行这些操作，并更新自己的状态”）。</strong></p>
</li>
<li><p>5.主Chunk把写请求传递到所有的二级副本。每个二级副本依照主Chunk分配的序列号以相同的顺序执行这些操作。</p>
</li>
<li><p>6.所有的二级副本回复主Chunk，它们已经完成了操作。</p>
</li>
<li><p>7.主Chunk服务器 <strong>（alex注：即主Chunk所在的Chunk服务器）</strong>回 复客户机。任何副本产生的任何错误都会返回给客户机。在出现错误的情况下，写入操作可能在主Chunk和一些二级副本执行成功。（如果操作在主Chunk 上失败了，操作就不会被分配序列号，也不会被传递。）客户端的请求被确认为失败，被修改的region处于不一致的状态。我们的客户机代码通过重复执行失 败的操作来处理这样的错误。在从头开始重复执行之前，客户机会先从步骤（3）到步骤（7）做几次尝试。</p>
</li>
</ul>
<p>如果应用程序一次写入的数据量很大，或者数据跨越了多个Chunk，GFS客户机代码会把它们分成多个写操作。这些操作都遵循前面描述的控制流 程，但是可能会被其它客户机上同时进行的操作打断或者覆盖。因此，共享的文件region的尾部可能包含来自不同客户机的数据片段，尽管如此，由于这些分 解后的写入操作在所有的副本上都以相同的顺序执行完成，Chunk的所有副本都是一致的。这使文件region处于2.7节描述的一致的、但是未定义的状 态。</p>
<h4 id="3-2-数据流"><a href="#3-2-数据流" class="headerlink" title="3.2 数据流"></a>3.2 数据流</h4><p>为了提高网络效率，我们采取了把数据流和控制流分开的措施。在控制流从客户机到主Chunk、然后再到所有二级副本的同时，数据以管道的方式， 顺序的沿着一个精心选择的Chunk服务器链推送。我们的目标是充分利用每台机器的带宽，避免网络瓶颈和高延时的连接，最小化推送所有数据的延时。</p>
<p>为了充分利用每台机器的带宽，数据沿着一个Chunk服务器链顺序的推送，而不是以其它拓扑形式分散推送（例如，树型拓扑结构）。线性推送模式下，每台机器所有的出口带宽都用于以最快的速度传输数据，而不是在多个接受者之间分配带宽。</p>
<p>为了尽可能的避免出现网络瓶颈和高延迟的链接（eg，inter-switch最有可能出现类似问题），每台机器都尽量的在网络拓扑中选择一台 还没有接收到数据的、离自己最近的机器作为目标推送数据。假设客户机把数据从Chunk服务器S1推送到S4。它把数据推送到最近的Chunk服务器 S1。S1把数据推送到S2，因为S2和S4中最接近的机器是S2。同样的，S2把数据传递给S3和S4之间更近的机器，依次类推推送下去。我们的网络拓 扑非常简单，通过IP地址就可以计算出节点的“距离”。</p>
<p>最后，我们利用基于TCP连接的、管道式数据推送方式来最小化延迟。Chunk服务器接收到数据后，马上开始向前推送。管道方式的数据推送对我 们帮助很大，因为我们采用全双工的交换网络。接收到数据后立刻向前推送不会降低接收的速度。在没有网络拥塞的情况下，传送B字节的数据到R个副本的理想时 间是 B/T+RL ，T是网络的吞吐量，L是在两台机器数据传输的延迟。通常情况下，我们的网络连接速度是100Mbps（T），L将远小于1ms。因此，1MB的数据在理 想情况下80ms左右就能分发出去。</p>
<h4 id="3-3-原子的记录追加"><a href="#3-3-原子的记录追加" class="headerlink" title="3.3 原子的记录追加"></a>3.3 原子的记录追加</h4><p>GFS提供了一种原子的数据追加操作–记录追加。传统方式的写入操作，客户程序会指定数据写入的偏移量。对同一个region的并行写入操作不 是串行的：region尾部可能会包含多个不同客户机写入的数据片段。使用记录追加，客户机只需要指定要写入的数据。GFS保证至少有一次原子的写入操作 成功执行（即写入一个顺序的byte流），写入的数据追加到GFS指定的偏移位置上，之后GFS返回这个偏移量给客户机。这类似于在Unix操作系统编程 环境中，对以O_APPEND模式打开的文件，多个并发写操作在没有竞态条件时的行为。</p>
<p>记录追加在我们的分布应用中非常频繁的使用，在这些分布式应用中，通常有很多的客户机并行地对同一个文件追加写入数据。如果我们采用传统方式的 文件写入操作，客户机需要额外的复杂、昂贵的同步机制，例如使用一个分布式的锁管理器。在我们的工作中，这样的文件通常用于多个生产者/单一消费者的队列 系统，或者是合并了来自多个客户机的数据的结果文件。</p>
<p>记录追加是一种修改操作，它也遵循3.1节描述的控制流程，除了在主Chunk有些额外的控制逻辑。客户机把数据推送给文件最后一个Chunk 的所有副本，之后发送请求给主Chunk。主Chunk会检查这次记录追加操作是否会使Chunk超过最大尺寸（64MB）。如果超过了最大尺寸，主 Chunk首先将当前Chunk填充到最大尺寸，之后通知所有二级副本做同样的操作，然后回复客户机要求其对下一个Chunk重新进行记录追加操作。（记 录追加的数据大小严格控制在Chunk最大尺寸的1/4，这样即使在最坏情况下，数据碎片的数量仍然在可控的范围。）通常情况下追加的记录不超过 Chunk的最大尺寸，主Chunk把数据追加到自己的副本内，然后通知二级副本把数据写在跟主Chunk一样的位置上，最后回复客户机操作成功。</p>
<p>如果记录追加操作在任何一个副本上失败了，客户端就需要重新进行操作。重新进行记录追加的结果是，同一个Chunk的不同副本可能包含不同的数 据–重复包含一个记录全部或者部分的数据。GFS并不保证Chunk的所有副本在字节级别是完全一致的。它只保证数据作为一个整体原子的被至少写入一次。 这个特性可以通过简单观察推导出来：如果操作成功执行，数据一定已经写入到Chunk的所有副本的相同偏移位置上。这之后，所有的副本至少都到了记录尾部 的长度，任何后续的记录都会追加到更大的偏移地址，或者是不同的Chunk上，即使其它的Chunk副本被Master节点选为了主Chunk。就我们的 一致性保障模型而言，记录追加操作成功写入数据的region是已定义的（因此也是一致的），反之则是不一致的（因此也就是未定义的）。正如我们在 2.7.2节讨论的，我们的程序可以处理不一致的区域。</p>
<h4 id="3-4-快照"><a href="#3-4-快照" class="headerlink" title="3.4 快照"></a>3.4 快照</h4><p><strong>(alex注：这一节非常难以理解，总的来说依次讲述了什么是快照、快照使用的COW技术、快照如何不干扰当前操作)</strong></p>
<p>快照操作几乎可以瞬间完成对一个文件或者目录树（“源”）做一个拷贝，并且几乎不会对正在进行的其它操作造成任何干扰。我们的用户可以使用快照 迅速的创建一个巨大的数据集的分支拷贝（而且经常是递归的拷贝拷贝），或者是在做实验性的数据操作之前，使用快照操作备份当前状态，这样之后就可以轻松的 提交或者回滚到备份时的状态。</p>
<p>就像AFS <strong>（alex注：AFS，即Andrew File System，一种分布式文件系统）</strong>，我 们用标准的copy-on-write技术实现快照。当Master节点收到一个快照请求，它首先取消作快照的文件的所有Chunk的租约。这个措施保证 了后续对这些Chunk的写操作都必须与Master交互交互以找到租约持有者。这就给Master节点一个率先创建Chunk的新拷贝的机会。</p>
<p>租约取消或者过期之后，Master节点把这个操作以日志的方式记录到硬盘上。然后，Master节点通过复制源文件或者目录的元数据的方式，把这条日志记录的变化反映到保存在内存的状态中。新创建的快照文件和源文件指向完全相同的Chunk地址。</p>
<p>在快照操作之后，当客户机第一次想写入数据到Chunk C，它首先会发送一个请求到Master节点查询当前的租约持有者。Master节点注意到Chunke C的引用计数超过了1。 Master节点不会马上回复客户机的请求，而是选择一个新的Chunk句柄C’。之后，Master节点要求每个拥有Chunk C当前副本的Chunk服务器创建一个叫做C’的新Chunk。通过在源Chunk所在Chunk服务器上创建新的Chunk，我们确保数据在本地而不是 通过网络复制（我们的硬盘比我们的100Mb以太网大约快3倍）。从这点来讲，请求的处理方式和任何其它Chunk没什么不同：Master节点确保新 Chunk C’的一个副本拥有租约，之后回复客户机，客户机得到回复后就可以正常的写这个Chunk，而不必理会它是从一个已存在的Chunk克隆出来的。</p>
<h3 id="4-Master节点的操作"><a href="#4-Master节点的操作" class="headerlink" title="4. Master节点的操作"></a>4. Master节点的操作</h3><p>Master节点执行所有的名称空间操作。此外，它还管理着整个系统里所有Chunk的副本：它决定Chunk的存储位置，创建新Chunk和 它的副本，协调各种各样的系统活动以保证Chunk被完全复制，在所有的Chunk服务器之间的进行负载均衡，回收不再使用的存储空间。本节我们讨论上述 的主题。</p>
<h4 id="4-1-名称空间管理和锁"><a href="#4-1-名称空间管理和锁" class="headerlink" title="4.1 名称空间管理和锁"></a>4.1 名称空间管理和锁</h4><p>Master节点的很多操作会花费很长的时间：比如，快照操作必须取消Chunk服务器上快照所涉及的所有的Chunk的租约。我们不希望在这 些操作的运行时，延缓了其它的Master节点的操作。因此，我们允许多个操作同时进行，使用名称空间的region上的锁来保证执行的正确顺序。</p>
<p>不同于许多传统文件系统，GFS没有针对每个目录实现能够列出目录下所有文件的数据结构。GFS也不支持文件或者目录的链接（即Unix术语中 的硬链接或者符号链接）。在逻辑上，GFS的名称空间就是一个全路径和元数据映射关系的查找表。利用前缀压缩，这个表可以高效的存储在内存中。在存储名称 空间的树型结构上，每个节点（绝对路径的文件名或绝对路径的目录名）都有一个关联的读写锁。</p>
<p>每个Master节点的操作在开始之前都要获得一系列的锁。通常情况下，如果一个操作涉及/d1/d2/…/dn/leaf，那么操作首先要获 得目录/d1，/d1/d2，…，/d1/d2/…/dn的读锁，以及/d1/d2/…/dn/leaf的读写锁。注意，根据操作的不同，leaf可以是 一个文件，也可以是一个目录。</p>
<p>现在，我们演示一下在/home/user被快照到/save/user的时候，锁机制如何防止创建文件/home/user/foo。快照操 作获取/home和/save的读取锁，以及/home/user和/save/user的写入锁。文件创建操作获得/home和/home/user的 读取锁，以及/home/user/foo的写入锁。这两个操作要顺序执行，因为它们试图获取的/home/user的锁是相互冲突。文件创建操作不需要 获取父目录的写入锁，因为这里没有”目录”，或者类似inode等用来禁止修改的数据结构。文件名的读取锁足以防止父目录被删除。</p>
<p>采用这种锁方案的优点是支持对同一目录的并行操作。比如，可以再同一个目录下同时创建多个文件：每一个操作都获取一个目录名的上的读取锁和文件 名上的写入锁。目录名的读取锁足以的防止目录被删除、改名以及被快照。文件名的写入锁序列化文件创建操作，确保不会多次创建同名的文件。</p>
<p>因为名称空间可能有很多节点，读写锁采用惰性分配策略，在不再使用的时候立刻被删除。同样，锁的获取也要依据一个全局一致的顺序来避免死锁：首先按名称空间的层次排序，在同一个层次内按字典顺序排序。</p>
<h4 id="4-2-副本的位置"><a href="#4-2-副本的位置" class="headerlink" title="4.2 副本的位置"></a>4.2 副本的位置</h4><p>GFS集群是高度分布的多层布局结构，而不是平面结构。典型的拓扑结构是有数百个Chunk服务器安装在许多机架上。Chunk服务器被来自同 一或者不同机架上的数百个客户机轮流访问。不同机架上的两台机器间的通讯可能跨越一个或多个网络交换机。另外，机架的出入带宽可能比机架内所有机器加和在 一起的带宽要小。多层分布架构对数据的灵活性、可靠性以及可用性方面提出特有的挑战。</p>
<p>Chunk副本位置选择的策略服务两大目标：最大化数据可靠性和可用性，最大化网络带宽利用率。为了实现这两个目的，仅仅是在多台机器上分别存 储这些副本是不够的，这只能预防硬盘损坏或者机器失效带来的影响，以及最大化每台机器的网络带宽利用率。我们必须在多个机架间分布储存Chunk的副本。 这保证Chunk的一些副本在整个机架被破坏或掉线（比如，共享资源，如电源或者网络交换机造成的问题）的情况下依然存在且保持可用状态。这还意味着在网 络流量方面，尤其是针对Chunk的读操作，能够有效利用多个机架的整合带宽。另一方面，写操作必须和多个机架上的设备进行网络通信，但是这个代价是我们 愿意付出的。</p>
<h4 id="4-3-创建，重新复制，重新负载均衡"><a href="#4-3-创建，重新复制，重新负载均衡" class="headerlink" title="4.3 创建，重新复制，重新负载均衡"></a>4.3 创建，重新复制，重新负载均衡</h4><p>Chunk的副本有三个用途：Chunk创建，重新复制和重新负载均衡。</p>
<p>当Master节点创建一个Chunk时，它会选择在哪里放置初始的空的副本。Master节点会考虑几个因素。</p>
<ul>
<li>(1) 我们希望在低于平均硬盘 使用率的Chunk服务器上存储新的副本。这样的做法最终能够平衡Chunk服务器之间的硬盘使用率。</li>
<li>(2) 我们希望限制在每个Chunk服务器上”最 近”的Chunk创建操作的次数。虽然创建操作本身是廉价的，但是创建操作也意味着随之会有大量的写入数据的操作，因为Chunk在Writer真正写入 数据的时候才被创建，而在我们的”追加一次，读取多次”的工作模式下，Chunk一旦写入成功之后就会变为只读的了。</li>
<li>(3) 如上所述，我们希望把 Chunk的副本分布在多个机架之间。</li>
</ul>
<p>当Chunk的有效副本数量少于用户指定的复制因数的时候，Master节点会重新复制它。这可能是由几个原因引起的：一个Chunk服务器不 可用了，Chunk服务器报告它所存储的一个副本损坏了，Chunk服务器的一个磁盘因为错误不可用了，或者Chunk副本的复制因数提高了。每个需要被 重新复制的Chunk都会根据几个因素进行排序。一个因素是Chunk现有副本数量和复制因数相差多少。例如，丢失两个副本的Chunk比丢失一个副本的 Chunk有更高的优先级。另外，我们优先重新复制活跃（live）文件的Chunk而不是最近刚被删除的文件的Chunk（查看4.4节）。最后，为了 最小化失效的Chunk对正在运行的应用程序的影响，我们提高会阻塞客户机程序处理流程的Chunk的优先级。</p>
<p>Master节点选择优先级最高的Chunk，然后命令某个Chunk服务器直接从可用的副本”克隆”一个副本出来。选择新副本的位置的策略和 创建时类似：平衡硬盘使用率、限制同一台Chunk服务器上的正在进行的克隆操作的数量、在机架间分布副本。为了防止克隆产生的网络流量大大超过客户机的 流量，Master节点对整个集群和每个Chunk服务器上的同时进行的克隆操作的数量都进行了限制。另外，Chunk服务器通过调节它对源Chunk服 务器读请求的频率来限制它用于克隆操作的带宽。</p>
<p>最后，Master服务器周期性地对副本进行重新负载均衡：它检查当前的副本分布情况，然后移动副本以便更好的利用硬盘空间、更有效的进行负载 均衡。而且在这个过程中，Master服务器逐渐的填满一个新的Chunk服务器，而不是在短时间内用新的Chunk填满它，以至于过载。新副本的存储位 置选择策略和上面讨论的相同。另外，Master节点必须选择哪个副本要被移走。通常情况，Master节点移走那些剩余空间低于平均值的Chunk服务 器上的副本，从而平衡系统整体的硬盘使用率。</p>
<h4 id="4-4-垃圾回收"><a href="#4-4-垃圾回收" class="headerlink" title="4.4 垃圾回收"></a>4.4 垃圾回收</h4><p>GFS在文件删除后不会立刻回收可用的物理空间。GFS空间回收采用惰性的策略，只在文件和Chunk级的常规垃圾收集时进行。我们发现这个方法使系统更简单、更可靠。</p>
<h5 id="4-4-1-机制"><a href="#4-4-1-机制" class="headerlink" title="4.4.1 机制"></a>4.4.1 机制</h5><p>当一个文件被应用程序删除时，Master节点象对待其它修改操作一样，立刻把删除操作以日志的方式记录下来。但是，Master节点并不马上 回收资源，而是把文件名改为一个包含删除时间戳的、隐藏的名字。当Master节点对文件系统命名空间做常规扫描的时候，它会删除所有三天前的隐藏文件 （这个时间间隔是可以设置的）。直到文件被真正删除，它们仍旧可以用新的特殊的名字读取，也可以通过把隐藏文件改名为正常显示的文件名的方式“反删除”。 当隐藏文件被从名称空间中删除，Master服务器内存中保存的这个文件的相关元数据才会被删除。这也有效的切断了文件和它包含的所有Chunk的连接 <strong>（alex注：原文是This effectively severs its links to all its chunks）。</strong></p>
<p>在对Chunk名字空间做类似的常规扫描时，Master节点找到孤儿Chunk（不被任何文件包含的Chunk）并删除它们的元数据。 Chunk服务器在和Master节点交互的心跳信息中，报告它拥有的Chunk子集的信息，Master节点回复Chunk服务器哪些Chunk在 Master节点保存的元数据中已经不存在了。Chunk服务器可以任意删除这些Chunk的副本。</p>
<h5 id="4-4-2-讨论"><a href="#4-4-2-讨论" class="headerlink" title="4.4.2 讨论"></a>4.4.2 讨论</h5><p>虽然分布式垃圾回收在编程语言领域是一个需要复杂的方案才能解决的难题，但是在GFS系统中是非常简单的。我们可以轻易的得到Chunk的所有 引用：它们都只存储在Master服务器上的文件到块的映射表中。我们也可以很轻易的得到所有Chunk的副本：它们都以Linux文件的形式存储在 Chunk服务器的指定目录下。所有Master节点不能识别的副本都是”垃圾”。</p>
<p>垃圾回收在空间回收方面相比直接删除有几个优势。</p>
<ul>
<li>首先，对于组件失效是常态的大规模分布式系统，垃圾回收方式简单可靠。Chunk可能在某些 Chunk服务器创建成功，某些Chunk服务器上创建失败，失败的副本处于无法被Master节点识别的状态。副本删除消息可能丢失，Master节点 必须重新发送失败的删除消息，包括自身的和Chunk服务器的 <strong>（alex注：自身的指删除metadata的消息）。</strong> 垃圾回收提供了一致的、可靠的清除无用副本的方法。</li>
<li>第二，垃圾回收把存储空间的回收操作合并到Master节点规律性的后台活动中，比如，例行扫描和与 Chunk服务器握手等。因此，操作被批量的执行，开销会被分散。另外，垃圾回收在Master节点相对空闲的时候完成。这样Master节点就可以给那 些需要快速反应的客户机请求提供更快捷的响应。</li>
<li>第三，延缓存储空间回收为意外的、不可逆转的删除操作提供了安全保障。</li>
</ul>
<p>根据我们的使用经验，延迟回收空间的主要问题是，延迟回收会阻碍用户调优存储空间的使用，特别是当存储空间比较紧缺的时候。当应用程序重复创建 和删除临时文件时，释放的存储空间不能马上重用。我们通过显式的再次删除一个已经被删除的文件的方式加速空间回收的速度。我们允许用户为命名空间的不同部 分设定不同的复制和回收策略。例如，用户可以指定某些目录树下面的文件不做复制，删除的文件被即时的、不可恢复的从文件系统移除。</p>
<h4 id="4-5-过期失效的副本检测"><a href="#4-5-过期失效的副本检测" class="headerlink" title="4.5 过期失效的副本检测"></a>4.5 过期失效的副本检测</h4><p>当Chunk服务器失效时，Chunk的副本有可能因错失了一些修改操作而过期失效。Master节点保存了每个Chunk的版本号，用来区分当前的副本和过期副本。</p>
<p>无论何时，只要Master节点和Chunk签订一个新的租约，它就增加Chunk的版本号，然后通知最新的副本。Master节点和这些副本 都把新的版本号记录在它们持久化存储的状态信息中。这个动作发生在任何客户机得到通知以前，因此也是对这个Chunk开始写之前。如果某个副本所在的 Chunk服务器正好处于失效状态，那么副本的版本号就不会被增加。Master节点在这个Chunk服务器重新启动，并且向Master节点报告它拥有 的Chunk的集合以及相应的版本号的时候，就会检测出它包含过期的Chunk。如果Master节点看到一个比它记录的版本号更高的版本 号，Master节点会认为它和Chunk服务器签订租约的操作失败了，因此会选择更高的版本号作为当前的版本号。</p>
<p>Master节点在例行的垃圾回收过程中移除所有的过期失效副本。在此之前，Master节点在回复客户机的Chunk信息请求的时候，简单的 认为那些过期的块根本就不存在。另外一重保障措施是，Master节点在通知客户机哪个Chunk服务器持有租约、或者指示Chunk服务器从哪个Chunk服务器进行克隆时，消息中都附带了Chunk的版本号。客户机或者Chunk服务器在执行操作时都会验证版本号以确保总是访问当前版本的数据。</p>
<h3 id="5-容错和诊断"><a href="#5-容错和诊断" class="headerlink" title="5. 容错和诊断"></a>5. 容错和诊断</h3><p>我们在设计GFS时遇到的最大挑战之一是如何处理频繁发生的组件失效。组件的数量和质量让这些问题出现的频率远远超过一般系统意外发生的频率： 我们不能完全依赖机器的稳定性，也不能完全相信硬盘的可靠性。组件的失效可能造成系统不可用，更糟糕的是，还可能产生不完整的数据。我们讨论我们如何面对 这些挑战，以及当组件失效不可避免的发生时，用GFS自带工具诊断系统故障。</p>
<h4 id="5-1-高可用性"><a href="#5-1-高可用性" class="headerlink" title="5.1 高可用性"></a>5.1 高可用性</h4><p>在GFS集群的数百个服务器之中，在任何给定的时间必定会有些服务器是不可用的。我们使用两条简单但是有效的策略保证整个系统的高可用性：快速恢复和复制。</p>
<h5 id="5-1-1-快速恢复"><a href="#5-1-1-快速恢复" class="headerlink" title="5.1.1 快速恢复"></a>5.1.1 快速恢复</h5><p>不管Master服务器和Chunk服务器是如何关闭的，它们都被设计为可以在数秒钟内恢复它们的状态并重新启动。事实上，我们并不区分正常关闭和异常关闭；通常，我们通过直接kill掉进程来关闭服务器。客户机和其它的服务器会感觉到系统有点颠簸<strong> (alex注：a minor hiccup)</strong>，正在发出的请求会超时，需要重新连接到重启后的服务器，然后重试这个请求。6.6.2章节记录了实测的启动时间。</p>
<h5 id="5-1-2-Chunk复制"><a href="#5-1-2-Chunk复制" class="headerlink" title="5.1.2 Chunk复制"></a>5.1.2 Chunk复制</h5><p>正如之前讨论的，每个Chunk都被复制到不同机架上的不同的Chunk服务器上。用户可以为文件命名空间的不同部分设定不同的复制级别。缺省是 3。当有Chunk服务器离线了，或者通过Chksum校验（参考5.2节）发现了已经损坏的数据，Master节点通过克隆已有的副本保证每个 Chunk都被完整复制<strong>（alex注：即每个Chunk都有复制因子制定的个数个副本，缺省是3）</strong>。虽然Chunk复制策略对我们非常有效，但是我们也在寻找其它形式的跨服务器的冗余解决方案，比如使用奇偶校验、或者Erasure codes<strong>（alex注：Erasure codes用来解决链接层中不相关的错误，以及网络拥塞和buffer限制造成的丢包错误）</strong>来解决我们日益增长的只读存储需求。我们的系统主要的工作负载是追加方式的写入和读取操作，很少有随机的写入操作，因此，我们认为在我们这个高度解耦合的系统架构下实现这些复杂的冗余方案很有挑战性，但并非不可实现。</p>
<h5 id="5-1-3-Master服务器的复制"><a href="#5-1-3-Master服务器的复制" class="headerlink" title="5.1.3 Master服务器的复制"></a>5.1.3 Master服务器的复制</h5><p>为了保证Master服务器的可靠性，Master服务器的状态也要复制。Master服务器所有的操作日志和checkpoint文件都被复 制到多台机器上。对Master服务器状态的修改操作能够提交成功的前提是，操作日志写入到Master服务器的备节点和本机的磁盘。简单说来，一个 Master服务进程负责所有的修改操作，包括后台的服务，比如垃圾回收等改变系统内部状态活动。当它失效的时，几乎可以立刻重新启动。如果Master 进程所在的机器或者磁盘失效了，处于GFS系统外部的监控进程会在其它的存有完整操作日志的机器上启动一个新的Master进程。客户端使用规范的名字访 问Master（比如gfs-test）节点，这个名字类似DNS别名，因此也就可以在Master进程转到别的机器上执行时，通过更改别名的实际指向访 问新的Master节点。</p>
<p>此外，GFS中还有些“影子”Master服务器，这些“影子”服务器在“主”Master服务器宕机的时候提供文件系统的只读访问。它们是影子， 而不是镜像，所以它们的数据可能比“主”Master服务器更新要慢，通常是不到1秒。对于那些不经常改变的文件、或者那些允许获取的数据有少量过期的应 用程序，“影子”Master服务器能够提高读取的效率。事实上，因为文件内容是从Chunk服务器上读取的，因此，应用程序不会发现过期的文件内容。在 这个短暂的时间窗内，过期的可能是文件的元数据，比如目录的内容或者访问控制信息。</p>
<p>“影子”Master服务器为了保持自身状态是最新的，它会读取一份当前正在进行的操作的日志副本，并且依照和主Master服务器完全相同的顺序 来更改内部的数据结构。和主Master服务器一样，“影子”Master服务器在启动的时候也会从Chunk服务器轮询数据（之后定期拉数据），数据中 包括了Chunk副本的位置信息；“影子”Master服务器也会定期和Chunk服务器“握手”来确定它们的状态。在主Master服务器因创建和删除 副本导致副本位置信息更新时，“影子”Master服务器才和主Master服务器通信来更新自身状态。</p>
<p>5.2 数据完整性<br>每个Chunk服务器都使用Checksum来检查保存的数据是否损坏。考虑到一个GFS集群通常都有好几百台机器、几千块硬盘，磁盘损坏导致数据 在读写过程中损坏或者丢失是非常常见的（第7节讲了一个原因）。我们可以通过别的Chunk副本来解决数据损坏问题，但是跨越Chunk服务器比较副本来 检查数据是否损坏很不实际。另外，GFS允许有歧义的副本存在：GFS修改操作的语义，特别是早先讨论过的原子纪录追加的操作，并不保证副本完全相同<strong>(alex注：副本不是byte-wise完全一致的))</strong>。因此，每个Chunk服务器必须独立维护Checksum来校验自己的副本的完整性。</p>
<p>我们把每个Chunk都分成64KB大小的块。每个块都对应一个32位的Checksum。和其它元数据一样，Checksum与其它的用户数据是分开的，并且保存在内存和硬盘上，同时也记录操作日志。</p>
<p>对于读操作来说，在把数据返回给客户端或者其它的Chunk服务器之前，Chunk服务器会校验读取操作涉及的范围内的块的Checksum。因此 Chunk服务器不会把错误数据传递到其它的机器上。如果发生某个块的Checksum不正确，Chunk服务器返回给请求者一个错误信息，并且通知 Master服务器这个错误。作为回应，请求者应当从其它副本读取数据，Master服务器也会从其它副本克隆数据进行恢复。当一个新的副本就绪 后，Master服务器通知副本错误的Chunk服务器删掉错误的副本。</p>
<p>Checksum对读操作的性能影响很小，可以基于几个原因来分析一下。因为大部分的读操作都至少要读取几个块，而我们只需要读取一小部分额外的相 关数据进行校验。GFS客户端代码通过每次把读取操作都对齐在Checksum block的边界上，进一步减少了这些额外的读取操作的负面影响。另外，在Chunk服务器上，Chunksum的查找和比较不需要I/O操 作，Checksum的计算可以和I/O操作同时进行。</p>
<p>Checksum的计算针对在Chunk尾部的追加写入操作作了高度优化（与之对应的是覆盖现有数据的写入操作），因为这类操作在我们的工作中占了 很大比例。我们只增量更新最后一个不完整的块的Checksum，并且用所有的追加来的新Checksum块来计算新的Checksum。即使是最后一个 不完整的Checksum块已经损坏了，而且我们不能够马上检查出来，由于新的Checksum和已有数据不吻合，在下次对这个块进行读取操作的时候，会 检查出数据已经损坏了。</p>
<p>相比之下，如果写操作覆盖已经存在的一个范围内的Chunk，我们必须读取和校验被覆盖的第一个和最后一个块，然后再执行写操作；操作完成之后再重 新计算和写入新的Checksum。如果我们不校验第一个和最后一个被写的块，那么新的Checksum可能会隐藏没有被覆盖区域内的数据错误。</p>
<p>在Chunk服务器空闲的时候，它会扫描和校验每个不活动的Chunk的内容。这使得我们能够发现很少被读取的Chunk是否完整。一旦发现有 Chunk的数据损坏，Master可以创建一个新的、正确的副本，然后把损坏的副本删除掉。这个机制也避免了非活动的、已损坏的Chunk欺骗 Master节点，使Master节点认为它们已经有了足够多的副本了。</p>
<h4 id="5-3-诊断工具"><a href="#5-3-诊断工具" class="headerlink" title="5.3 诊断工具"></a>5.3 诊断工具</h4><p>详尽的、深入细节的诊断日志，在问题隔离、调试、以及性能分析等方面给我们带来无法估量的帮助，同时也只需要很小的开销。没有日志的帮助，我们很难 理解短暂的、不重复的机器之间的消息交互。GFS的服务器会产生大量的日志，记录了大量关键的事件（比如，Chunk服务器启动和关闭）以及所有的RPC 的请求和回复。这些诊断日志可以随意删除，对系统的正确运行不造成任何影响。然而，我们在存储空间允许的情况下会尽量的保存这些日志。</p>
<p>RPC日志包含了网络上发生的所有请求和响应的详细记录，但是不包括读写的文件数据。通过匹配请求与回应，以及收集不同机器上的RPC日志记录，我们可以重演所有的消息交互来诊断问题。日志还用来跟踪负载测试和性能分析。</p>
<p>日志对性能的影响很小（远小于它带来的好处），因为这些日志的写入方式是顺序的、异步的。最近发生的事件日志保存在内存中，可用于持续不断的在线监控。</p>
<h3 id="6-度量"><a href="#6-度量" class="headerlink" title="6. 度量"></a>6. 度量</h3><p>本节中，我们将使用一些小规模基准测试来展现GFS系统架构和实现上的一些固有瓶颈，还有些来自Google内部使用的真实的GFS集群的基准数据。</p>
<h4 id="6-1-小规模基准测试"><a href="#6-1-小规模基准测试" class="headerlink" title="6.1 小规模基准测试"></a>6.1 小规模基准测试</h4><p>我们在一个包含1台Master服务器，2台Master服务器复制节点，16台Chunk服务器和16个客户机组成的GFS集群上测量性能。注意，采用这样的集群配置方案只是为了易于测试。典型的GFS集群有数百个Chunk服务器和数百个客户机。</p>
<p>所有机器的配置都一样：两个PIII 1.4GHz处理器，2GB内存，两个80G/5400rpm的硬盘，以及100Mbps全双工以太网连接到一个HP2524交换机。GFS集群中所有的 19台服务器都连接在一个交换机，所有16台客户机连接到另一个交换机上。两个交换机之间使用1Gbps的线路连接。</p>
<h5 id="6-1-1-读取"><a href="#6-1-1-读取" class="headerlink" title="6.1.1 读取"></a>6.1.1 读取</h5><p>N个客户机从GFS文件系统同步读取数据。每个客户机从320GB的文件集合中随机读取4MB region的内容。读取操作重复执行256次，因此，每个客户机最终都读取1GB的数据。所有的Chunk服务器加起来总共只有32GB的内存，因此， 我们预期只有最多10%的读取请求命中Linux的文件系统缓冲。我们的测试结果应该和一个在没有文件系统缓存的情况下读取测试的结果接近。</p>
<p><img src="/images/GFS6-1-1.jpg"></p>
<p>图三：合计吞吐量：上边的曲线显示了我们网络拓扑下的合计理论吞吐量上限。下边的曲线显示了观测到的吞吐量。这个曲线有着95%的可靠性，因为有时候测量会不够精确。</p>
<p>图3（a）显示了N个客户机整体的读取速度以及这个速度的理论极限。当连接两个交换机的1Gbps的链路饱和时，整体读取速度达到理论的极限值 是125MB/S，或者说每个客户机配置的100Mbps网卡达到饱和时，每个客户机读取速度的理论极限值是12.5MB/s。实测结果是，当一个客户机 读取的时候，读取的速度是10MB/s，也就是说达到客户机理论读取速度极限值的80%。对于16个客户机，整体的读取速度达到了94MB/s，大约是理 论整体读取速度极限值的75%，也就是说每个客户机的读取速度是6MB/s。读取效率从80%降低到了75%，主要的原因是当读取的客户机增加时，多个客 户机同时读取一个Chunk服务器的几率也增加了，导致整体的读取效率下降。</p>
<h5 id="6-1-2-写入"><a href="#6-1-2-写入" class="headerlink" title="6.1.2 写入"></a>6.1.2 写入</h5><p>N个客户机同时向N个不同的文件中写入数据。每个客户机以每次1MB的速度连续写入1GB的数据。图3（b）显示了整体的写入速度和它们理论上 的极限值。理论上的极限值是67MB/s，因为我们需要把每一byte写入到16个Chunk服务器中的3个上，而每个Chunk服务器的输入连接速度是 12.5MB/s。</p>
<p>一个客户机的写入速度是6.3MB，大概是理论极限值的一半。导致这个结果的主要原因是我们的网络协议栈。它与我们推送数据到Chunk服务器时采用的管道模式不相适应。从一个副本到另一个副本的数据传输延迟降低了整个的写入速度。</p>
<p>16个客户机整体的写入速度达到了35MB/s（即每个客户机2.2MB/s），大约只是理论极限值的一半。和多个客户机读取的情形很类型，随 着客户机数量的增加，多个客户机同时写入同一个Chunk服务器的几率也增加了。而且，16个客户机并行写入可能引起的冲突比16个客户机并行读取要大得 多，因为每个写入都会涉及三个不同的副本。</p>
<p>写入的速度比我们想象的要慢。在实际应用中，这没有成为我们的主要问题，因为即使在单个客户机上能够感受到延时，它也不会在有大量客户机的时候对整体的写入带宽造成显著的影响。</p>
<h5 id="6-1-3-记录追加"><a href="#6-1-3-记录追加" class="headerlink" title="6.1.3 记录追加"></a>6.1.3 记录追加</h5><p>图3（c）显示了记录追加操作的性能。N个客户机同时追加数据到一个文件。记录追加操作的性能受限于保存文件最后一个Chunk的Chunk服务器 的带宽，而与客户机的数量无关。记录追加的速度由一个客户机的6.0MB/s开始，下降到16个客户机的4.8MB/s为止，速度的下降主要是由于不同客 户端的网络拥塞以及网络传输速度的不同而导致的。</p>
<p>我们的程序倾向于同时处理多个这样的文件。换句话说，即N个客户机同时追加数据到M个共享文件中，这里N和M都是数十或者数百以上。所以，在我们的 实际应用中，Chunk服务器的网络拥塞并没有成为一个严重问题，如果Chunk服务器的某个文件正在写入，客户机会去写另外一个文件。</p>
<h4 id="6-2-实际应用中的集群"><a href="#6-2-实际应用中的集群" class="headerlink" title="6.2 实际应用中的集群"></a>6.2 实际应用中的集群</h4><p>我们现在来仔细评估一下Google内部正在使用的两个集群，它们具有一定的代表性。集群A通常被上百个工程师用于研究和开发。典型的任务是被 人工初始化后连续运行数个小时。它通常读取数MB到数TB的数据，之后进行转化或者分析，最后把结果写回到集群中。集群B主要用于处理当前的生产数据。集 群B的任务持续的时间更长，在很少人工干预的情况下，持续的生成和处理数TB的数据集。在这两个案例中，一个单独的”任务”都是指运行在多个机器上的多个 进程，它们同时读取和写入多个文件。</p>
<p><img src="/images/GFS6-2.jpg"></p>
<h5 id="6-2-1-存储"><a href="#6-2-1-存储" class="headerlink" title="6.2.1 存储"></a>6.2.1 存储</h5><p>如上表前五行所描述的，两个集群都由上百台Chunk服务器组成，支持数TB的硬盘空间；两个集群虽然都存储了大量的数据，但是还有剩余的空间。 “已用空间”包含了所有的Chunk副本。实际上所有的文件都复制了三份。因此，集群实际上各存储了18TB和52TB的文件数据。</p>
<p>两个集群存储的文件数量都差不多，但是集群B上有大量的死文件。所谓“死文件”是指文件被删除了或者是被新版本的文件替换了，但是存储空间还没有来得及被回收。由于集群B存储的文件较大，因此它的Chunk数量也比较多。</p>
<h5 id="6-2-2-元数据"><a href="#6-2-2-元数据" class="headerlink" title="6.2.2 元数据"></a>6.2.2 元数据</h5><p>Chunk服务器总共保存了十几GB的元数据，大多数是来自用户数据的、64KB大小的块的Checksum。保存在Chunk服务器上其它的元数据是Chunk的版本号信息，我们在4.5节描述过。</p>
<p>在Master服务器上保存的元数据就小的多了，大约只有数十MB，或者说平均每个文件100字节的元数据。这和我们设想的是一样的，Master 服务器的内存大小在实际应用中并不会成为GFS系统容量的瓶颈。大多数文件的元数据都是以前缀压缩模式存放的文件名。Master服务器上存放的其它元数 据包括了文件的所有者和权限、文件到Chunk的映射关系，以及每一个Chunk的当前版本号。此外，针对每一个Chunk，我们都保存了当前的副本位置 以及对它的引用计数，这个引用计数用于实现写时拷贝<strong>（alex注：即COW，copy-on-write）。</strong></p>
<p>对于每一个单独的服务器，无论是Chunk服务器还是Master服务器，都只保存了50MB到100MB的元数据。因此，恢复服务器是非常快速 的：在服务器响应客户请求之前，只需要花几秒钟时间从磁盘上读取这些数据就可以了。不过，Master服务器会持续颠簸一段时间–通常是30到60秒–直 到它完成轮询所有的Chunk服务器，并获取到所有Chunk的位置信息。</p>
<h5 id="6-2-3-读写速率"><a href="#6-2-3-读写速率" class="headerlink" title="6.2.3 读写速率"></a>6.2.3 读写速率</h5><p><img src="/images/GFS6-2-3.jpg"> </p>
<p>表三显示了不同时段的读写速率。在测试的时候，这两个集群都运行了一周左右的时间。（这两个集群最近都因为升级新版本的GFS重新启动过了）。</p>
<p>集群重新启动后，平均写入速率小于30MB/s。当我们提取性能数据的时候，集群B正进行大量的写入操作，写入速度达到了100MB/s，并且因为每个Chunk都有三个副本的原因，网络负载达到了300MB/s。<br>读取速率要比写入速率高的多。正如我们设想的那样，总的工作负载中，读取的比例远远高于写入的比例。两个集群都进行着繁重的读取操作。特别是， 集群A在一周时间内都维持了580MB/s的读取速度。集群A的网络配置可以支持750MB/s的速度，显然，它有效的利用了资源。集群B支持的峰值读取 速度是1300MB/s，但是它的应用只用到了380MB/s。 </p>
<h5 id="6-2-4-Master服务器的负载"><a href="#6-2-4-Master服务器的负载" class="headerlink" title="6.2.4 Master服务器的负载"></a>6.2.4 Master服务器的负载</h5><p>表3的数据显示了发送到Master服务器的操作请求大概是每秒钟200到500个。Master服务器可以轻松的应付这个请求速度，所以Master服务器的处理能力不是系统的瓶颈。</p>
<p>在早期版本的GFS中，Master服务器偶尔会成为瓶颈。它大多数时间里都在顺序扫描某个很大的目录（包含数万个文件）去查找某个特定的文 件。因此我们修改了Master服务器的数据结构，通过对名字空间进行二分查找来提高效率。现在Master服务器可以轻松的每秒钟进行数千次文件访问。 如果有需要的话，我们可以通过在名称空间数据结构之前设置名称查询缓冲的方式进一步提高速度。</p>
<h5 id="6-2-5-恢复时间"><a href="#6-2-5-恢复时间" class="headerlink" title="6.2.5 恢复时间"></a>6.2.5 恢复时间</h5><p>当某个Chunk服务器失效了，一些Chunk副本的数量可能会低于复制因子指定的数量，我们必须通过克隆副本使Chunk副本数量达到复制因 子指定的数量。恢复所有Chunk副本所花费的时间取决于资源的数量。在我们的试验中，我们把集群B上的一个Chunk服务器Kill掉。这个Chunk 服务器上大约有15000个Chunk，共计600GB的数据。为了减小克隆操作对正在运行的应用程序的影响，以及为GFS调度决策提供修正空间，我们缺 省的把集群中并发克隆操作的数量设置为91个（Chunk服务器的数量的40%），每个克隆操作最多允许使用的带宽是6.25MB/s（50mbps）。 所有的Chunk在23.2分钟内恢复了，复制的速度高达440MB/s。</p>
<p>在另外一个测试中，我们Kill掉了两个Chunk服务器，每个Chunk服务器大约有16000个Chunk，共计660GB的数据。这两个 故障导致了266个Chunk只有单个副本。这266个Chunk被GFS优先调度进行复制，在2分钟内恢复到至少有两个副本；现在集群被带入到另外一个 状态，在这个状态下，系统可以容忍另外一个Chunk服务器失效而不丢失数据。</p>
<h4 id="6-3-工作负荷分析-Workload-Breakdown"><a href="#6-3-工作负荷分析-Workload-Breakdown" class="headerlink" title="6.3 工作负荷分析(Workload Breakdown)"></a>6.3 工作负荷分析(Workload Breakdown)</h4><p>本节中，我们展示了对两个GFS集群工作负载情况的详细分析，这两个集群和6.2节中的类似，但是不完全相同。集群X用于研究和开发，集群Y用于生产数据处理。 </p>
<h5 id="6-3-1-方法论和注意事项"><a href="#6-3-1-方法论和注意事项" class="headerlink" title="6.3.1 方法论和注意事项"></a>6.3.1 方法论和注意事项</h5><p>本章节列出的这些结果数据只包括客户机发起的原始请求，因此，这些结果能够反映我们的应用程序对GFS文件系统产生的全部工作负载。它们不包含 那些为了实现客户端请求而在服务器间交互的请求，也不包含GFS内部的后台活动相关的请求，比如前向转发的写操作，或者重新负载均衡等操作。</p>
<p>我们从GFS服务器记录的真实的RPC请求日志中推导重建出关于IO操作的统计信息。例如，GFS客户程序可能会把一个读操作分成几个RPC请 求来提高并行度，我们可以通过这些RPC请求推导出原始的读操作。因为我们的访问模式是高度程式化，所以我们认为任何不符合的数据都是误差<strong> (alex注：Since our access patterns are highly stylized, we expect any error to be in the noise)</strong>。应用程序如果能够记录更详尽的日志，就有可能提供更准确的诊断数据；但是为了这个目的去重新编译和重新启动数千个正在运行的客户机是不现实的，而且从那么多客户机上收集结果也是个繁重的工作。</p>
<p>应该避免从我们的工作负荷数据中过度的归纳出普遍的结论<strong> (alex注：即不要把本节的数据作为基础的指导性数据)</strong>。因为Google完全控制着GFS和使用GFS的应用程序，所以，应用程序都针对GFS做了优化，同时，GFS也是为了这些应用程序而设计的。这样的相互作用也可能存在于一般程序和文件系统中，但是在我们的案例中这样的作用影响可能更显著。</p>
<h5 id="6-3-2-Chunk服务器工作负荷"><a href="#6-3-2-Chunk服务器工作负荷" class="headerlink" title="6.3.2 Chunk服务器工作负荷"></a>6.3.2 Chunk服务器工作负荷</h5><p><img src="/images/GFS6-3-2.jpg"></p>
<p>表4显示了操作按涉及的数据量大小的分布情况。读取操作按操作涉及的数据量大小呈现了双峰分布。小的读取操作（小于64KB）一般是由查找操作的客户端发起的，目的在于从巨大的文件中查找小块的数据。大的读取操作（大于512KB）一般是从头到尾顺序的读取整个文件。</p>
<p>在集群Y上，有相当数量的读操作没有返回任何的数据。在我们的应用中，尤其是在生产系统中，经常使用文件作为生产者-消费者队列。生产者并行的向文 件中追加数据，同时，消费者从文件的尾部读取数据。某些情况下，消费者读取的速度超过了生产者写入的速度，这就会导致没有读到任何数据的情况。集群X通常 用于短暂的数据分析任务，而不是长时间运行的分布式应用，因此，集群X很少出现这种情况。</p>
<p>写操作按数据量大小也同样呈现为双峰分布。大的写操作（超过256KB）通常是由于Writer使用了缓存机制导致的。Writer缓存较小的数据，通过频繁的Checkpoint或者同步操作，或者只是简单的统计小的写入（小于64KB）的数据量<strong>(alex注：即汇集多次小的写入操作，当数据量达到一个阈值，一次写入)</strong>，之后批量写入。</p>
<p>再来观察一下记录追加操作。我们可以看到集群Y中大的记录追加操作所占比例比集群X多的多，这是因为集群Y用于我们的生产系统，针对GFS做了更全面的调优。</p>
<p><img src="/images/GFS6-3-2-2.jpg"></p>
<p>表5显示了按操作涉及的数据量的大小统计出来的总数据传输量。在所有的操作中，大的操作（超过256KB）占据了主要的传输量。小的读取（小于64KB）虽然传输的数据量比较少，但是在读取的数据量中仍占了相当的比例，这是因为在文件中随机Seek的工作负荷而导致的。</p>
<h5 id="6-3-3-记录追加-vs-写操作"><a href="#6-3-3-记录追加-vs-写操作" class="headerlink" title="6.3.3 记录追加 vs. 写操作"></a>6.3.3 记录追加 vs. 写操作</h5><p>记录追加操作在我们的生产系统中大量使用。对于集群X，记录追加操作和普通写操作的比例按照字节比是108:1，按照操作次数比是8:1。对于 作为我们的生产系统的集群Y来说，这两个比例分别是3.7:1和2.5:1。更进一步，这一组数据说明在我们的两个集群上，记录追加操作所占比例都要比写 操作要大。对于集群X，在整个测量过程中，记录追加操作所占比率都比较低，因此结果会受到一两个使用某些特定大小的buffer的应用程序的影响。</p>
<p>如同我们所预期的，我们的数据修改操作主要是记录追加操作而不是覆盖方式的写操作。我们测量了第一个副本的数据覆盖写的情况。这近似于一个客户机故 意覆盖刚刚写入的数据，而不是增加新的数据。对于集群X，覆盖写操作在写操作所占据字节上的比例小于0.0001%，在所占据操作数量上的比例小于 0.0003%。对于集群Y，这两个比率都是0.05%。虽然这只是某一片断的情况，但是仍然高于我们的预期。这是由于这些覆盖写的操作，大部分是由于客 户端在发生错误或者超时以后重试的情况。这在本质上应该不算作工作负荷的一部分，而是重试机制产生的结果。</p>
<h5 id="6-3-4-Master的工作负荷"><a href="#6-3-4-Master的工作负荷" class="headerlink" title="6.3.4 Master的工作负荷"></a>6.3.4 Master的工作负荷</h5><p><img src="/images/GFS6-3-4.jpg"></p>
<p>表6显示了Master服务器上的请求按类型区分的明细表。大部分的请求都是读取操作查询Chunk位置信息（FindLocation）、以及修改操作查询lease持有者的信息（FindLease-Locker）。</p>
<p>集群X和Y在删除请求的数量上有着明显的不同，因为集群Y存储了生产数据，一般会重新生成数据以及用新版本的数据替换旧有的数据。数量上的差异 也被隐藏在了Open请求中，因为旧版本的文件可能在以重新写入的模式打开时，隐式的被删除了（类似UNIX的open函数中的“w”模式）。</p>
<p>FindMatchingFiles是一个模式匹配请求，支持“ls”以及其它类似的文件系统操作。不同于Master服务器的其它请求，它可 能会检索namespace的大部分内容，因此是非常昂贵的操作。集群Y的这类请求要多一些，因为自动化数据处理的任务进程需要检查文件系统的各个部分， 以便从全局上了解应用程序的状态。与之不同的是，集群X的应用程序更加倾向于由单独的用户控制，通常预先知道自己所需要使用的全部文件的名称。</p>
<h3 id="7-经验"><a href="#7-经验" class="headerlink" title="7. 经验"></a>7. 经验</h3><p>在建造和部署GFS的过程中，我们经历了各种各样的问题，有些是操作上的，有些是技术上的。</p>
<p>起初，GFS被设想为我们的生产系统的后端文件系统。随着时间推移，在GFS的使用中逐步的增加了对研究和开发任务的支持。我们开始增加一些小 的功能，比如权限和配额，到了现在，GFS已经初步支持了这些功能。虽然我们生产系统是严格受控的，但是用户层却不总是这样的。需要更多的基础架构来防止 用户间的相互干扰。</p>
<p>我们最大的问题是磁盘以及和Linux相关的问题。很多磁盘都声称它们支持某个范围内的Linux IDE硬盘驱动程序，但是实际应用中反映出来的情况却不是这样，它们只支持最新的驱动。因为协议版本很接近，所以大部分磁盘都可以用，但是偶尔也会有由于 协议不匹配，导致驱动和内核对于驱动器的状态判断失误。这会导致数据因为内核中的问题意外的被破坏了。这个问题促使我们使用Checksum来校验数据， 同时我们也修改内核来处理这些因为协议不匹配带来的问题。</p>
<p>较早的时候，我们在使用Linux 2.2内核时遇到了些问题，主要是fsync()的效率问题。它的效率与文件的大小而不是文件修改部分的大小有关。这在我们的操作日志文件过大时给出了难 题，尤其是在我们尚未实现Checkpoint的时候。我们费了很大的力气用同步写来解决这个问题，但是最后还是移植到了Linux2.4内核上。</p>
<p>另一个和Linux相关的问题是单个读写锁的问题，也就是说，在某一个地址空间的任意一个线程都必须在从磁盘page in（读锁）的时候先hold住，或者在mmap()调用（写锁）的时候改写地址空间。我们发现即使我们的系统负载很轻的情况下也会有偶尔的超时，我们花 费了很多的精力去查找资源的瓶颈或者硬件的问题。最后我们终于发现这个单个锁在磁盘线程交换以前映射的数据到磁盘的时候，锁住了当前的网络线程，阻止它把 新数据映射到内存。由于我们的性能主要受限于网络接口，而不是内存copy的带宽，因此，我们用pread()替代mmap()，用了一个额外的copy 动作来解决这个问题。</p>
<p>尽管偶尔还是有其它的问题，Linux的开放源代码还是使我们能够快速探究和理解系统的行为。在适当的时候，我们会改进内核并且和公开源码组织共享这些改动。</p>
<h3 id="8-相关工作"><a href="#8-相关工作" class="headerlink" title="8. 相关工作"></a>8. 相关工作</h3><p>和其它的大型分布式文件系统，比如AFS[5]类似，GFS提供了一个与位置无关的名字空间，这使得数据可以为了负载均衡或者灾难冗余等目的在 不同位置透明的迁移。不同于AFS的是，GFS把文件分布存储到不同的服务器上，这种方式更类似Xfs[1]和Swift[3]，这是为了提高整体性能以 及灾难冗余的能力。</p>
<p>由于磁盘相对来说比较便宜，并且复制的方式比RAID[9]方法简单的多，GFS目前只使用复制的方式来进行冗余，因此要比xFS或者Swift占用更多的裸存储空间 <strong>(alex注：Raw storage，裸盘的空间)</strong>。</p>
<p>与AFS、xFS、Frangipani[12]以及Intermezzo[6]等文件系统不同的是，GFS并没有在文件系统层面提供任何 Cache机制。我们主要的工作在单个应用程序执行的时候几乎不会重复读取数据，因为它们的工作方式要么是流式的读取一个大型的数据集，要么是在大型的数 据集中随机Seek到某个位置，之后每次读取少量的数据。</p>
<p>某些分布式文件系统，比如Frangipani、xFS、Minnesota’s GFS[11]、GPFS[10]，去掉了中心服务器，只依赖于分布式算法来保证一致性和可管理性。我们选择了中心服务器的方法，目的是为了简化设计，增 加可靠性，能够灵活扩展。特别值得一提的是，由于处于中心位置的Master服务器保存有几乎所有的Chunk相关信息，并且控制着Chunk的所有变 更，因此，它极大地简化了原本非常复杂的Chunk分配和复制策略的实现方法。我们通过减少Master服务器保存的状态信息的数量，以及将Master 服务器的状态复制到其它节点来保证系统的灾难冗余能力。扩展能力和高可用性（对于读取）目前是通过我们的影子Master服务器机制来保证的。对 Master服务器状态更改是通过预写日志的方式实现持久化。为此，我们可以调整为使用类似Harp[7]中的primary-copy方案，从而提供比 我们现在的方案更严格的一致性保证。</p>
<p>我们解决了一个难题，这个难题类似Lustre[8]在如何在有大量客户端时保障系统整体性能遇到的问题。不过，我们通过只关注我们的应用程序 的需求，而不是提供一个兼容POSIX的文件系统，从而达到了简化问题的目的。此外，GFS设计预期是使用大量的不可靠节点组建集群，因此，灾难冗余方案 是我们设计的核心。</p>
<p>GFS很类似NASD架构[4]。NASD架构是基于网络磁盘的，而GFS使用的是普通计算机作为Chunk服务器，就像NASD原形中方案一 样。所不同的是，我们的Chunk服务器采用惰性分配固定大小的Chunk的方式，而不是分配变长的对象存储空间。此外，GFS实现了诸如重新负载均衡、 复制、恢复机制等等在生产环境中需要的特性。</p>
<p>不同于与Minnesota’s GFS和NASD，我们并不改变存储设备的Model <strong>(alex注：对这两个文件系统不了解，因为不太明白改变存储设备的Model用来做什么，这不明白这个model是模型、还是型号)</strong>。我们只关注用普通的设备来解决非常复杂的分布式系统日常的数据处理。</p>
<p>我们通过原子的记录追加操作实现了生产者-消费者队列，这个问题类似River[2]中的分布式队列。River使用的是跨主机的、基于内存的 分布式队列，为了实现这个队列，必须仔细控制数据流；而GFS采用可以被生产者并发追加记录的持久化的文件的方式实现。River模式支持m-到-n的分 布式队列，但是缺少由持久化存储提供的容错机制，GFS只支持m-到-1的队列。多个消费者可以同时读取一个文件，但是它们输入流的区间必须是对齐的。</p>
<h3 id="9-结束语"><a href="#9-结束语" class="headerlink" title="9. 结束语"></a>9. 结束语</h3><p>Google文件系统展示了一个使用普通硬件支持大规模数据处理的系统的特质。虽然一些设计要点都是针对我们的特殊的需要定制的，但是还是有很多特性适用于类似规模的和成本的数据处理任务。</p>
<p>首先，我们根据我们当前的和可预期的将来的应用规模和技术环境来评估传统的 文件系统的特性。我们的评估结果将我们引导到一个使用完全不同于传统的设计思路上。根据我们的设计思路，我们认为组件失效是常态而不是异常，针对采用追加 方式（有可能是并发追加）写入、然后再读取（通常序列化读取）的大文件进行优化，以及扩展标准文件系统接口、放松接口限制来改进整个系统。</p>
<p>我们系统通过持续监控，复制关键数据，快速和自动恢复提供灾难冗余。 Chunk复制使得我们可以对Chunk服务器的失效进行容错。高频率的组件失效要求系统具备在线修复机制，能够周期性的、透明的修复损坏的数据，也能够 第一时间重新建立丢失的副本。此外，我们使用Checksum在磁盘或者IDE子系统级别检测数据损坏，在这样磁盘数量惊人的大系统中，损坏率是相当高 的。</p>
<p>我们的设计保证了在有大量的并发读写操作时能够提供很高的合计吞吐量。我们通过分离控制流和数据流来实现这个目标，控制流在Master服务器处理，而数据流在Chunk服务器和客户端处理。当一般的操作涉及到Master服务器时，由于GFS选择的Chunk尺寸较大<strong>(alex注：从而减小了元数据的大小)</strong>，以及通过Chunk Lease将控制权限移交给主副本，这些措施将Master服务器的负担降到最低。这使得一个简单、中心的Master不会成为成为瓶颈。我们相信我们对网络协议栈的优化可以提升当前对于每客户端的写入吞吐量限制。</p>
<p>GFS成功的实现了我们对存储的需求，在Google内部，无论是作为研究和开发的存储平台，还是作为生产系统的数据处理平台，都得到了广泛的应用。它是我们持续创新和处理整个WEB范围内的难题的一个重要工具。<br>致谢<br>We wish to thankt he following people for their contributions to the system or the paper. Brain Bershad (our shepherd) and the anonymous reviewers gave us valuable comments and suggestions. Anurag Acharya, Jeff Dean, and David des-Jardins contributed to the early design. Fay Chang worked on comparison of replicas across chunkservers. Guy Edjlali worked on storage quota. Markus Gutschke worked on a testing frameworkan d security enhancements. David<br>Kramer worked on performance enhancements. Fay Chang, Urs Hoelzle, Max Ibel, Sharon Perl, Rob Pike, and Debby Wallach commented on earlier drafts of the paper. Many of our colleagues at Google bravely trusted their data to a new file system and gave us useful feedback. Yoshka helped with early testing.<br>参考<br>[1] Thomas Anderson, Michael Dahlin, Jeanna Neefe, David Patterson, Drew Roselli, and Randolph Wang. Serverless networkfil e systems. In Proceedings of the 15th ACM Symposium on Operating System Principles, pages 109–126, Copper Mountain Resort, Colorado, December 1995.<br>[2] Remzi H. Arpaci-Dusseau, Eric Anderson, Noah Treuhaft, David E. Culler, Joseph M. Hellerstein, David Patterson, and Kathy Yelick. Cluster I/O with River: Making the fast case common. In Proceedings of the Sixth Workshop on Input/Output in Parallel and Distributed Systems (IOPADS ’99), pages 10–22, Atlanta, Georgia, May 1999.<br>[3] Luis-Felipe Cabrera and Darrell D. E. Long. Swift: Using distributed disks triping to provide high I/O data rates. Computer Systems, 4(4):405–436, 1991.</p>
<p>[4] Garth A. Gibson, David F. Nagle, Khalil Amiri, Jeff Butler, Fay W. Chang, Howard Gobioff, Charles Hardin, ErikR iedel, David Rochberg, and Jim Zelenka. A cost-effective, high-bandwidth storage architecture. In Proceedings of the 8th Architectural Support for Programming Languages and Operating Systems, pages 92–103, San Jose, California, October 1998.</p>
<p>[5] John Howard, Michael Kazar, Sherri Menees, David Nichols, Mahadev Satyanarayanan, Robert Sidebotham, and Michael West. Scale and performance in a distributed file system. ACM Transactions on Computer Systems, 6(1):51–81, February 1988.<br>[6] InterMezzo. <a href="http://www.inter-mezzo.org" target="_blank" rel="external">http://www.inter-mezzo.org</a> , 2003.</p>
<p>[7] Barbara Liskov, Sanjay Ghemawat, Robert Gruber, Paul Johnson, Liuba Shrira, and Michael Williams. Replication in the Harp file system. In 13th Symposium on Operating System Principles, pages 226–238, Pacific Grove, CA, October 1991.<br>[8] Lustre. <a href="http://www.lustreorg" target="_blank" rel="external">http://www.lustreorg</a> , 2003.</p>
<p>[9] David A. Patterson, Garth A. Gibson, and Randy H. Katz. A case for redundant arrays of inexpensive disks (RAID). In Proceedings of the 1988 ACM SIGMOD International Conference on Management of Data, pages 109–116, Chicago, Illinois, September 1988.<br>[10] FrankS chmuck and Roger Haskin. GPFS: A shared-diskfi le system for large computing clusters. In Proceedings of the First USENIX Conference on File and Storage Technologies, pages 231–244, Monterey, California, January 2002.</p>
<p>[11] Steven R. Soltis, Thomas M. Ruwart, and Matthew T.O’Keefe. The Gobal File System. In Proceedings of the Fifth NASA Goddard Space Flight Center Conference on Mass Storage Systems and Technologies, College Park, Maryland, September 1996.<br>[12] Chandramohan A. Thekkath, Timothy Mann, and Edward K. Lee. Frangipani: A scalable distributed file system. In Proceedings of the 16th ACM Symposium on Operating System Principles, pages 224–237, Saint-Malo, France, October 1997</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[gulp js压缩]]></title>
      <url>http://zsr.github.io/2016/08/19/gulp-js%E5%8E%8B%E7%BC%A9/</url>
      <content type="html"><![CDATA[<h4 id="安装nodejs、gulp"><a href="#安装nodejs、gulp" class="headerlink" title="安装nodejs、gulp"></a>安装nodejs、gulp</h4><ul>
<li>安装 nodejs</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install node</div></pre></td></tr></table></figure>
<ul>
<li>安装 gulp</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g gulp</div></pre></td></tr></table></figure>
<h4 id="安装gulp插件"><a href="#安装gulp插件" class="headerlink" title="安装gulp插件"></a>安装gulp插件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install gulp-htmlmin gulp-imagemin imagemin-pngcrush gulp-minify-css gulp-jshint gulp-uglify gulp-concat gulp-rename gulp-notify --save-dev</div></pre></td></tr></table></figure>
<h4 id="gulp配置文件"><a href="#gulp配置文件" class="headerlink" title="gulp配置文件"></a>gulp配置文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line">//在你的项目根目录下创建gulpfile.js，代码如下：</div><div class="line"> </div><div class="line">// 引入 gulp</div><div class="line">var gulp = require(&apos;gulp&apos;);</div><div class="line"> </div><div class="line">// 引入组件</div><div class="line">var htmlmin = require(&apos;gulp-htmlmin&apos;), //html压缩</div><div class="line">    imagemin = require(&apos;gulp-imagemin&apos;),//图片压缩</div><div class="line">    pngcrush = require(&apos;imagemin-pngcrush&apos;),</div><div class="line">    minifycss = require(&apos;gulp-minify-css&apos;),//css压缩</div><div class="line">    jshint = require(&apos;gulp-jshint&apos;),//js检测</div><div class="line">    uglify = require(&apos;gulp-uglify&apos;),//js压缩</div><div class="line">    concat = require(&apos;gulp-concat&apos;),//文件合并</div><div class="line">    rename = require(&apos;gulp-rename&apos;),//文件更名</div><div class="line">    notify = require(&apos;gulp-notify&apos;);//提示信息</div><div class="line"> </div><div class="line">// 压缩html</div><div class="line">gulp.task(&apos;html&apos;, function() &#123;</div><div class="line">  return gulp.src(&apos;src/*.html&apos;)</div><div class="line">    .pipe(htmlmin(&#123;collapseWhitespace: true&#125;))</div><div class="line">    .pipe(gulp.dest(&apos;./dest&apos;))</div><div class="line">    .pipe(notify(&#123; message: &apos;html task ok&apos; &#125;));</div><div class="line"> </div><div class="line">&#125;);</div><div class="line"> </div><div class="line">// 压缩图片</div><div class="line">gulp.task(&apos;img&apos;, function() &#123;</div><div class="line">  return gulp.src(&apos;src/images/*&apos;)</div><div class="line">    .pipe(imagemin(&#123;</div><div class="line">        progressive: true,</div><div class="line">        svgoPlugins: [&#123;removeViewBox: false&#125;],</div><div class="line">        use: [pngcrush()]</div><div class="line">    &#125;))</div><div class="line">    .pipe(gulp.dest(&apos;./dest/images/&apos;))</div><div class="line">    .pipe(notify(&#123; message: &apos;img task ok&apos; &#125;));</div><div class="line">&#125;);</div><div class="line"> </div><div class="line">// 合并、压缩、重命名css</div><div class="line">gulp.task(&apos;css&apos;, function() &#123;</div><div class="line">  return gulp.src(&apos;src/css/*.css&apos;)</div><div class="line">    .pipe(concat(&apos;main.css&apos;))</div><div class="line">    .pipe(gulp.dest(&apos;dest/css&apos;))</div><div class="line">    .pipe(rename(&#123; suffix: &apos;.min&apos; &#125;))</div><div class="line">    .pipe(minifycss())</div><div class="line">    .pipe(gulp.dest(&apos;dest/css&apos;))</div><div class="line">    .pipe(notify(&#123; message: &apos;css task ok&apos; &#125;));</div><div class="line">&#125;);</div><div class="line"> </div><div class="line">// 检查js</div><div class="line">gulp.task(&apos;lint&apos;, function() &#123;</div><div class="line">  return gulp.src(&apos;src/js/*.js&apos;)</div><div class="line">    .pipe(jshint())</div><div class="line">    .pipe(jshint.reporter(&apos;default&apos;))</div><div class="line">    .pipe(notify(&#123; message: &apos;lint task ok&apos; &#125;));</div><div class="line">&#125;);</div><div class="line"> </div><div class="line">// 合并、压缩js文件</div><div class="line">gulp.task(&apos;js&apos;, function() &#123;</div><div class="line">  return gulp.src(&apos;src/js/*.js&apos;)</div><div class="line">    .pipe(concat(&apos;all.js&apos;))</div><div class="line">    .pipe(gulp.dest(&apos;dest/js&apos;))</div><div class="line">    .pipe(rename(&#123; suffix: &apos;.min&apos; &#125;))</div><div class="line">    .pipe(uglify())</div><div class="line">    .pipe(gulp.dest(&apos;dest/js&apos;))</div><div class="line">    .pipe(notify(&#123; message: &apos;js task ok&apos; &#125;));</div><div class="line">&#125;);</div><div class="line"> </div><div class="line">// 默认任务</div><div class="line">gulp.task(&apos;default&apos;, function()&#123;</div><div class="line">  gulp.run(&apos;img&apos;, &apos;css&apos;, &apos;lint&apos;, &apos;js&apos;, &apos;html&apos;);</div><div class="line"> </div><div class="line">  // 监听html文件变化</div><div class="line">  gulp.watch(&apos;src/*.html&apos;, function()&#123;</div><div class="line">    gulp.run(&apos;html&apos;);</div><div class="line">  &#125;);</div><div class="line"> </div><div class="line">  // Watch .css files</div><div class="line">  gulp.watch(&apos;src/css/*.css&apos;, [&apos;css&apos;]);</div><div class="line"> </div><div class="line">  // Watch .js files</div><div class="line">  gulp.watch(&apos;src/js/*.js&apos;, [&apos;lint&apos;, &apos;js&apos;]);</div><div class="line"> </div><div class="line">  // Watch image files</div><div class="line">  gulp.watch(&apos;src/images/*&apos;, [&apos;img&apos;]);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[B+树索引]]></title>
      <url>http://zsr.github.io/2016/08/18/B+%E6%A0%91%E7%B4%A2%E5%BC%95/</url>
      <content type="html"><![CDATA[<h2 id="Mysql-索引原理"><a href="#Mysql-索引原理" class="headerlink" title="Mysql 索引原理"></a>Mysql 索引原理</h2><h3 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h3><p>B-树,这里的 B 表示 balance( 平衡的意思),B-树是一种多路自平衡的搜索树<br>它类似普通的平衡二叉树，不同的一点是B-树允许每个节点有更多的子节点。下图是 B-树的简化图.</p>
<p><img src="/images/B-树.jpg"></p>
<p>B-树有如下特点:</p>
<ul>
<li>所有键值分布在整颗树中；</li>
<li>任何一个关键字出现且只出现在一个结点中；</li>
<li>搜索有可能在非叶子结点结束；</li>
<li>在关键字全集内做一次查找,性能逼近二分查找；</li>
</ul>
<h3 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+树"></a>B+树</h3><p>B+树是B-树的变体，也是一种多路搜索树, 它与B-树的不同之处在于:</p>
<p>所有关键字存储在叶子节点出现,内部节点(非叶子节点并不存储真正的data)<br>为所有叶子结点增加了一个链指针</p>
<p>简化 B+树 如下图</p>
<p><img src="/images/B+树.jpg"></p>
<h3 id="为什么使用B-B-Tree"><a href="#为什么使用B-B-Tree" class="headerlink" title="为什么使用B-/B+ Tree"></a>为什么使用B-/B+ Tree</h3><p>红黑树等数据结构也可以用来实现索引，但是文件系统及数据库系统普遍采用B-/+Tree作为索引结构。MySQL 是基于磁盘的数据库系统,索引往往以索引文件的形式存储的磁盘上,索引查找过程中就要产生磁盘I/O消耗,相对于内存存取，I/O存取的消耗要高几个数量级,索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。为什么使用B-/+Tree，还跟磁盘存取原理有关。</p>
<h4 id="局部性原理与磁盘预读"><a href="#局部性原理与磁盘预读" class="headerlink" title="局部性原理与磁盘预读"></a>局部性原理与磁盘预读</h4><p>磁盘读取数据靠的是机械运动，每次读取数据花费的时间可以分为寻道时间、旋转延迟、传输时间三个部分，寻道时间指的是磁臂移动到指定磁道所需要的时间，主流磁盘一般在5ms以下；旋转延迟就是我们经常听说的磁盘转速，比如一个磁盘7200转，表示每分钟能转7200次，也就是说1秒钟能转120次，旋转延迟就是1/120/2 = 4.17ms；传输时间指的是从磁盘读出或将数据写入磁盘的时间，一般在零点几毫秒，相对于前两个时间可以忽略不计。那么访问一次磁盘的时间，即一次磁盘IO的时间约等于5+4.17 = 9ms左右，听起来还挺不错的，但要知道一台500 -MIPS的机器每秒可以执行5亿条指令，因为指令依靠的是电的性质，换句话说执行一次IO的时间可以执行40万条指令，数据库动辄十万百万乃至千万级数据，每次9毫秒的时间，显然是个灾难。</p>
<p>由于磁盘的存取速度与内存之间鸿沟(访问磁盘的成本大概是访问内存的十万倍左右),为了提高效率,要尽量减少磁盘I/O.磁盘往往不是严格按需读取，而是每次都会预读,磁盘读取完需要的数据,会顺序向后读一定长度的数据放入内存。而这样做的理论依据是计算机科学中著名的局部性原理：</p>
<ul>
<li>当一个数据被用到时，其附近的数据也通常会马上被使用</li>
<li>程序运行期间所需要的数据通常比较集中</li>
</ul>
<p>由于磁盘顺序读取的效率很高(不需要寻道时间，只需很少的旋转时间)，因此对于具有局部性的程序来说，预读可以提高I/O效率.预读的长度一般为页(page)的整倍数。</p>
<p><strong>MySQL(默认使用InnoDB引擎),将记录按照页的方式进行管理,每页大小默认为16K(这个值可以修改).linux 默认页大小为4K(每一次IO读取的数据称之为一页)</strong></p>
<h3 id="B-Tree索引的性能分析"><a href="#B-Tree索引的性能分析" class="headerlink" title="B-/+Tree索引的性能分析"></a>B-/+Tree索引的性能分析</h3><p>实际实现B-Tree还需要使用如下技巧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个结点只需一次I/O。</div><div class="line">假设 B-Tree 的高度为 h,B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O(h)=O(logdN)O(h)=O(logdN)。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。</div><div class="line">而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。</div></pre></td></tr></table></figure>
<h3 id="为什么使用-B-树"><a href="#为什么使用-B-树" class="headerlink" title="为什么使用 B+树"></a>为什么使用 B+树</h3><ul>
<li>B+树更适合外部存储,由于内节点无<code>data</code>域,一个结点可以存储更多的内结点,每个节点能索引的范围更大更精确,也意味着 B+树单次磁盘IO的信息量大于B-树,I/O效率更高。</li>
<li>Mysql是一种关系型数据库，区间访问是常见的一种情况，B+树叶节点增加的链指针,加强了区间访问性，可使用在范围区间查询等，而B-树每个节点 key 和 data 在一起，则无法区间查找。</li>
</ul>
<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p><a href="https://segmentfault.com/a/1190000004690721" target="_blank" rel="external">MySQL索引结构</a></p>
<p><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="external">MySQL索引背后的数据结构及算法原理</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[mysql 锁]]></title>
      <url>http://zsr.github.io/2016/08/18/mysql-%E9%94%81/</url>
      <content type="html"><![CDATA[<h2 id="mysql-锁机制"><a href="#mysql-锁机制" class="headerlink" title="mysql 锁机制"></a>mysql 锁机制</h2><p>数据库为了维护事务的性质，尤其是一致性和隔离性，一般使用加锁这种方式。同时数据库又是个高并发的应用，同一时间会有大量的并发访问，如果加锁过度，会极大的降低并发处理能力。所以对于加锁的处理，可以说就是数据库对于事务处理的精髓所在。</p>
<h3 id="悲观锁和乐观锁"><a href="#悲观锁和乐观锁" class="headerlink" title="悲观锁和乐观锁"></a>悲观锁和乐观锁</h3><ul>
<li><p>悲观锁</p>
<p>正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。</p>
<p>在悲观锁的情况下，为了保证事务的隔离性，就需要一致性锁定读。读取数据时给加锁，其它事务无法修改这些数据。修改删除数据时也要加锁，其它事务无法读取这些数据。</p>
</li>
<li><p>乐观锁</p>
<p>相对悲观锁而言，乐观锁机制采取了更加宽松的加锁机制。悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。</p>
</li>
</ul>
<p>乐观锁，大多是基于数据版本（ Version ）记录机制实现。数据版本:即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。</p>
<h3 id="多版本的并发控制协议-以乐观锁为理论基础"><a href="#多版本的并发控制协议-以乐观锁为理论基础" class="headerlink" title="多版本的并发控制协议(以乐观锁为理论基础)"></a>多版本的并发控制协议(以乐观锁为理论基础)</h3><p>MySQL InnoDB存储引擎，实现的是基于多版本的并发控制协议——MVCC (Multi-Version Concurrency Control) (注：与MVCC相对的，是基于锁的并发控制，Lock-Based Concurrency Control)。MVCC最大的好处：读不加锁，读写不冲突。在读多写少的OLTP应用中，读写不冲突是非常重要的，极大的增加了系统的并发性能，现阶段几乎所有的RDBMS，都支持了MVCC。</p>
<p>在MVCC并发控制中，读操作可以分成两类：快照读 (snapshot read)与当前读 (current read)。快照读，读取的是记录的可见版本 (有可能是历史版本)，不用加锁。当前读，读取的是记录的最新版本，并且，当前读返回的记录，都会加上锁，保证其他事务不会再并发修改这条记录。</p>
<p>以MySQL InnoDB为例：</p>
<ul>
<li>快照读：简单的select操作，属于快照读，不加锁。(当然，也有例外，下面会分析)<ul>
<li>select * from table where ?;</li>
</ul>
</li>
<li><p>当前读：特殊的读操作，插入/更新/删除操作，属于当前读，需要加锁。</p>
<ul>
<li>select * from table where ? lock in share mode;</li>
<li>select * from table where ? for update;</li>
<li>insert into table values (…);</li>
<li>update table set ? where ?;</li>
<li>delete from table where ?;</li>
</ul>
<p>所有以上的语句，都属于当前读，读取记录的最新版本。并且，读取之后，还需要保证其他并发事务不能修改当前记录，对读取记录加锁。其中，除了第一条语句，对读取记录加S锁 (共享锁)外，其他的操作，都加的是X锁 (排它锁)。</p>
</li>
</ul>
<p>插入/更新/删除 操作，都归为当前读.如更新 操作，在数据库中的执行流程：</p>
<p><img src="/images/mysql锁机制1-1.jpg"></p>
<p>从图中，可以看到，一个Update操作的具体流程。当Update SQL被发给MySQL后，MySQL Server会根据where条件，读取第一条满足条件的记录，然后InnoDB引擎会将第一条记录返回，并加锁 (current read)。待MySQL Server收到这条加锁的记录之后，会再发起一个Update请求，更新这条记录。一条记录操作完成，再读取下一条记录，直至没有满足条件的记录为止。因此，Update操作内部，就包含了一个当前读。同理，Delete操作也一样。Insert操作会稍微有些不同，简单来说，就是Insert操作可能会触发Unique Key的冲突检查，也会进行一个当前读。</p>
<p><strong>注：根据上图的交互，针对一条当前读的SQL语句，InnoDB与MySQL Server的交互，是一条一条进行的，因此，加锁也是一条一条进行的。先对一条满足条件的记录加锁，返回给MySQL Server，做一些DML操作(数据操纵语言DML:insert, update, delete)；然后在读取下一条加锁，直至读取完毕。</strong></p>
<a id="more"></a>
<h4 id="MVCC在MySQL的InnoDB中的实现"><a href="#MVCC在MySQL的InnoDB中的实现" class="headerlink" title="MVCC在MySQL的InnoDB中的实现"></a>MVCC在MySQL的InnoDB中的实现</h4><p>在InnoDB中，会在每行数据后添加两个额外的隐藏的值来实现MVCC，这两个值一个记录这行数据何时被创建，另外一个记录这行数据何时过期（或者被删除）。 在实际操作中，存储的并不是时间，而是事务的版本号(<strong>分别表示该行创建的版本和删除的版本</strong>)，每开启一个新事务，事务的版本号就会递增。 在可重读Repeatable reads事务隔离级别下：</p>
<ul>
<li>SELECT时:满足以下两个条件innodb会返回该行数据：1)读取创建版本号&lt;=当前事务版本号,2)删除版本号为空或&gt;当前事务版本号。</li>
<li>INSERT时:将新插入的行的创建版本号设置为当前系统的版本号。</li>
<li>DELETE时:将要删除的行的删除版本号设置为当前系统的版本号。</li>
<li>UPDATE时:不执行原地update，而是转换成insert + delete。将旧行的删除版本号设置为当前版本号，并将新行insert同时设置创建版本号为当前版本号。</li>
</ul>
<p>其中，写操作（insert、delete和update）执行时，需要将系统版本号递增。<br>由于旧数据并不真正的删除，所以必须对这些数据进行清理，innodb会开启一个后台线程执行清理工作，具体的规则是将删除版本号小于当前系统版本的行删除，这个过程叫做purge。</p>
<p>通过MVCC，虽然每行记录都需要额外的存储空间，更多的行检查工作以及一些额外的维护工作，但可以减少锁的使用，大多数读操作都不用加锁，读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行，也只锁住必要行。</p>
<h3 id="两段锁"><a href="#两段锁" class="headerlink" title="两段锁"></a>两段锁</h3><p>数据库遵循的是两段锁协议，将事务分成两个阶段，加锁阶段和解锁阶段</p>
<p>加锁阶段：在该阶段可以进行加锁操作。在对任何数据进行读操作之前要申请并获得S锁（共享锁，其它事务可以继续加共享锁，但不能加排它锁），在进行写操作之前要申请并获得X锁（排它锁，其它事务不能再获得任何锁）。加锁不成功，则事务进入等待状态，直到加锁成功才继续执行。<br>解锁阶段：当事务释放了一个封锁以后，事务进入解锁阶段，在该阶段只能进行解锁操作不能再进行加锁操作。</p>
<p>以mysql为例：</p>
<p><img src="/images/mysql锁机制1-2.jpg"></p>
<p>两段锁协议可以保证事务的并发调度是串行化，加锁阶段：只加锁，不放锁。解锁阶段：只放锁，不加锁。</p>
<h3 id="事务的四种隔离级别"><a href="#事务的四种隔离级别" class="headerlink" title="事务的四种隔离级别"></a>事务的四种隔离级别</h3><p>事务隔离级别：</p>
<table>
<thead>
<tr>
<th style="text-align:center">隔离级别</th>
<th style="text-align:center">脏读（Dirty Read)</th>
<th style="text-align:center">不可重复读（NonRepeatable Read)</th>
<th style="text-align:center">幻读（Phantom Read)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">未提交读（Read uncommitted）</td>
<td style="text-align:center">可能</td>
<td style="text-align:center">可能</td>
<td style="text-align:center">可能</td>
</tr>
<tr>
<td style="text-align:center">已提交读（Read committed）</td>
<td style="text-align:center">不可能</td>
<td style="text-align:center">可能</td>
<td style="text-align:center">可能</td>
</tr>
<tr>
<td style="text-align:center">可重复读（Repeatable read）</td>
<td style="text-align:center">不可能</td>
<td style="text-align:center">不可能</td>
<td style="text-align:center">可能</td>
</tr>
<tr>
<td style="text-align:center">可串行化（Serializable ）</td>
<td style="text-align:center">不可能</td>
<td style="text-align:center">不可能</td>
<td style="text-align:center">不可能</td>
</tr>
</tbody>
</table>
<ul>
<li>未提交读(Read Uncommitted)：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据</li>
<li>提交读(Read Committed)：只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别 (不重复读);针对当前读，RC隔离级别保证对读取到的记录加锁 (记录锁)，存在幻读现象。</li>
<li>可重复读(Repeated Read)：可重复读。在同一个事务内的查询都是事务开始时刻一致的，<strong>InnoDB默认级别</strong>。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻象读;mysql RR隔离级别保证对读取到的记录加锁 (记录锁)，同时保证对<strong>读取的范围加锁(GAP间隙锁)</strong>，新的满足查询条件的记录不能够插入,不存在幻读现象。</li>
<li>串行读(Serializable)：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞</li>
</ul>
<h4 id="不可重复读和幻读的区别"><a href="#不可重复读和幻读的区别" class="headerlink" title="不可重复读和幻读的区别"></a>不可重复读和幻读的区别</h4><p>不可重复读重点在于update和delete，而幻读的重点在于insert。</p>
<p>如果使用锁机制来实现这两种隔离级别，在可重复读中，该sql第一次读取到数据后，就将这些数据加锁，其它事务无法修改这些数据，就可以实现可重复读了。但这种方法却无法锁住insert的数据，所以当事务A先前读取了数据，或者修改了全部数据，事务B还是可以insert数据提交，这时事务A就会发现莫名其妙多了一条之前没有的数据，这就是幻读，不能通过行锁来避免。需要Serializable隔离级别 ，读用读锁，写用写锁，读锁和写锁互斥，这么做可以有效的避免幻读、不可重复读、脏读等问题，但会极大的降低数据库的并发能力。</p>
<h3 id="一条简单SQL的加锁实现分析"><a href="#一条简单SQL的加锁实现分析" class="headerlink" title="一条简单SQL的加锁实现分析"></a>一条简单SQL的加锁实现分析</h3><p>例子：</p>
<p>当id列是二级非唯一索引，RR隔离级别</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SQL1：select * from t1 where id = 10;</div><div class="line">SQL2：delete from t1 where id = 10;</div></pre></td></tr></table></figure>
<p>SQL1为简单的select语句，快照读不用加锁。</p>
<p>Repeatable Read隔离级别，id上有一个非唯一索引，执行delete from t1 where id = 10; 假设选择id列上的索引进行条件过滤，最后的加锁行为，是怎么样的呢？同样看下面这幅图：</p>
<p><img src="/images/mysql锁机制1-3.jpg"></p>
<p>GAP锁，就是RR隔离级别相对于RC隔离级别，不会出现幻读的关键。确实，GAP锁锁住的位置，也不是记录本身，而是两条记录之间的GAP。所谓幻读，就是同一个事务，连续做两次当前读 (例如：select * from t1 where id = 10 for update;)，那么这两次当前读返回的是完全相同的记录 (记录数量一致，记录本身也一致)，第二次的当前读，不会比第一次返回更多的记录 (幻象)。</p>
<p>如何保证两次当前读返回一致的记录，那就需要在第一次当前读与第二次当前读之间，其他的事务不会插入新的满足条件的记录并提交。为了实现这个功能，GAP锁应运而生。</p>
<p>如图中所示，有哪些位置可以插入新的满足条件的项 (id = 10)，考虑到B+树索引的有序性，满足条件的项一定是连续存放的。记录[6,c]之前，不会插入id=10的记录；[6,c]与[10,b]间可以插入[10, aa]；[10,b]与[10,d]间，可以插入新的[10,bb],[10,c]等；[10,d]与[11,f]间可以插入满足条件的[10,e],[10,z]等；而[11,f]之后也不会插入满足条件的记录。因此，为了保证[6,c]与[10,b]间，[10,b]与[10,d]间，[10,d]与[11,f]不会插入新的满足条件的记录，MySQL选择了用GAP锁，将这三个GAP给锁起来。</p>
<p>Insert操作，如insert [10,aa]，首先会定位到[6,c]与[10,b]间，然后在插入前，会检查这个GAP是否已经被锁上，如果被锁上，则Insert不能插入记录。因此，通过第一遍的当前读，不仅将满足条件的记录锁上 (X锁)，与组合三类似。同时还是增加3把GAP锁，将可能插入满足条件记录的3个GAP给锁上，保证后续的Insert不能插入新的id=10的记录，也就杜绝了同一事务的第二次当前读，出现幻象的情况。</p>
<p><strong>结论：Repeatable Read隔离级别下，id列上有一个非唯一索引，对应SQL：delete from t1 where id = 10; 首先，通过id索引定位到第一条满足查询条件的记录，加记录上的X锁，加GAP上的GAP锁，然后加主键聚簇索引上的记录X锁，然后返回；然后读取下一条，重复进行。直至进行到第一条不满足条件的记录[11,f]，此时，不需要加记录X锁，但是仍旧需要加GAP锁，最后返回结束。</strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[java调试-jstack命令]]></title>
      <url>http://zsr.github.io/2016/08/18/java%E8%B0%83%E8%AF%95-jstack%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<h2 id="jstack命令使用"><a href="#jstack命令使用" class="headerlink" title="jstack命令使用"></a>jstack命令使用</h2><p>jstack可用于导出java运用程序的线程堆栈，其基本使用语法为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jstack [<span class="_">-l</span>] pid</div></pre></td></tr></table></figure>
<p>-l 打印关于锁的附加信息,例如属于java.util.concurrent的ownable synchronizers列表.</p>
<h3 id="常用用法"><a href="#常用用法" class="headerlink" title="常用用法"></a>常用用法</h3><p>下面这段代码运行之后会出现死锁现象(因为线程1持有lock1，在等待lock2，线程2持有lock2在等待lock1，造成了循环等待，形成死锁)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.zsr.test.lock;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * </div><div class="line"> * Created by david.zhang</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeadLock</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object lock1 = <span class="keyword">new</span> Object();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object lock2 = <span class="keyword">new</span> Object();</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">synchronized</span> (lock1) &#123;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        Thread.sleep(<span class="number">1000</span>);</div><div class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">synchronized</span> (lock2) &#123;</div><div class="line">                        System.out.println(<span class="string">"线程1执行...."</span>);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">synchronized</span> (lock2) &#123;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        Thread.sleep(<span class="number">1000</span>);</div><div class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">synchronized</span> (lock1) &#123;</div><div class="line">                        System.out.println(<span class="string">"线程2执行..."</span>);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        t1.start();</div><div class="line">        t2.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行这段代码，然后使用jstack命令导出这个程序的线程堆栈信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nalideMacBook-Pro-4:public nali$ jstack <span class="_">-l</span> 35072 &gt; /Users/nali/deadlock.txt</div></pre></td></tr></table></figure>
<p>打开导出的线程堆栈信息文件，文件末尾如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">Found one Java-level deadlock:</div><div class="line"></div><div class="line">=============================</div><div class="line">&quot;Thread-1&quot;:</div><div class="line">  waiting to lock monitor 0x00007fe6d48432b8 (object 0x00000007d558e9d8, a java.lang.Object),</div><div class="line">  which is held by &quot;Thread-0&quot;</div><div class="line">&quot;Thread-0&quot;:</div><div class="line">  waiting to lock monitor 0x00007fe6d4844758 (object 0x00000007d558e9e8, a java.lang.Object),</div><div class="line">  which is held by &quot;Thread-1&quot;</div><div class="line"></div><div class="line">Java stack information for the threads listed above:</div><div class="line"></div><div class="line">===================================================</div><div class="line">&quot;Thread-1&quot;:</div><div class="line">	at com.zsr.test.lock.TestDeadLock$2.run(TestDeadLock.java:39)</div><div class="line">	- waiting to lock &lt;0x00000007d558e9d8&gt; (a java.lang.Object)</div><div class="line">	- locked &lt;0x00000007d558e9e8&gt; (a java.lang.Object)</div><div class="line">	at java.lang.Thread.run(Thread.java:745)</div><div class="line">&quot;Thread-0&quot;:</div><div class="line">	at com.zsr.test.lock.TestDeadLock$1.run(TestDeadLock.java:23)</div><div class="line">	- waiting to lock &lt;0x00000007d558e9e8&gt; (a java.lang.Object)</div><div class="line">	- locked &lt;0x00000007d558e9d8&gt; (a java.lang.Object)</div><div class="line">	at java.lang.Thread.run(Thread.java:745)</div><div class="line"></div><div class="line">Found 1 deadlock.</div></pre></td></tr></table></figure>
<p>导出的线程堆栈文件中明确提示发现死锁，并且指明了死锁的原因。</p>
<p>jstack不仅能够导出线程堆栈，还能自动进行死锁检测，输出线程死锁原因。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[java调试-jmap命令]]></title>
      <url>http://zsr.github.io/2016/08/18/java%E8%B0%83%E8%AF%95-jmap%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<h2 id="jmap命令使用"><a href="#jmap命令使用" class="headerlink" title="jmap命令使用"></a>jmap命令使用</h2><p>jmap是一个多功能的命令。它可以生成java程序的堆dump文件，也可以查看堆内对象实例的统计信息，查看ClassLoader的信息以及Finalizer队列。</p>
<h3 id="常用用法"><a href="#常用用法" class="headerlink" title="常用用法"></a>常用用法</h3><ul>
<li>导出对象统计信息</li>
</ul>
<p>下面的命令生成PID为24205的java成粗的对象的统计信息，并输出到out.txt文件中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nalideMacBook-Pro-4:~ nali$ jmap -histo 24205 &gt; /Users/nali/out.txt</div></pre></td></tr></table></figure>
<p>生成的文件如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"> num     #instances         #bytes  class name</div><div class="line">----------------------------------------------</div><div class="line">   1:        962520       23100480  java.lang.Long</div><div class="line">   2:        481260       19250400  com.ximalaya.test.Ip</div><div class="line">   3:        962779       15404464  java.lang.Integer</div><div class="line">   4:        481300       15401600  java.util.HashMap$Entry</div><div class="line">   5:          6362        9556232  [I</div><div class="line">   6:            19        7341744  [Ljava.util.HashMap$Entry;</div><div class="line">   7:           319        2174856  [Ljava.lang.Object;</div><div class="line">   8:          6060         781024  &lt;methodKlass&gt;</div><div class="line">   9:          6060         692032  &lt;constMethodKlass&gt;</div><div class="line">  10:           415         486208  &lt;constantPoolKlass&gt;</div><div class="line">  11:           378         296288  &lt;constantPoolCacheKlass&gt;</div><div class="line">  12:           415         285880  &lt;instanceKlassKlass&gt;</div><div class="line">  13:          1358         156272  [C</div><div class="line">  14:           573          94240  [B</div><div class="line">  15:           125          52928  &lt;methodDataKlass&gt;</div><div class="line">  16:           478          46680  java.lang.Class</div><div class="line">  17:           704          45152  [[I</div><div class="line">  18:           631          38168  [S</div><div class="line">  19:          1334          32016  java.lang.String</div><div class="line">  20:            46          25024  &lt;objArrayKlassKlass&gt;</div><div class="line">  21:           101           6464  java.net.URL</div><div class="line">  22:            79           5688  java.lang.reflect.Field</div><div class="line">  23:             8           4352  &lt;typeArrayKlassKlass&gt;</div><div class="line">  24:            96           3840  java.util.LinkedHashMap$Entry</div><div class="line">  25:           119           3808  java.util.Hashtable$Entry</div><div class="line">  26:            94           3760  java.lang.ref.SoftReference</div><div class="line">  27:            91           2912  java.util.concurrent.ConcurrentHashMap$HashEntry</div><div class="line">  28:            61           2432  [Ljava.lang.String;</div></pre></td></tr></table></figure>
<p>从文件中可以看到，统计信息显示了内存中实例的数量和合计。</p>
<ul>
<li>导出程序堆快照</li>
</ul>
<p>下面的命令导出PID为24205的java程序当前的堆快照：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">nalideMacBook-Pro-4:~ nali$ jmap -dump:format=b,file=dump.bin 24205</div><div class="line">Dumping heap to /Users/nali/dump.bin ...</div><div class="line">Heap dump file created</div></pre></td></tr></table></figure>
<p>该命令成功地将运用程序的当前的堆快照导出到了dump.bin文件，之后可以使用Visual VM，MAT等工具分析对快照文件。</p>
<ul>
<li>查看java 堆（heap）使用情况</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">nalideMacBook-Pro-4:~ nali$ jmap -heap 30192</div><div class="line">Attaching to process ID 30192, please wait...</div><div class="line">Debugger attached successfully.</div><div class="line">Server compiler detected.</div><div class="line">JVM version is 24.79-b02</div><div class="line"></div><div class="line">using thread-local object allocation.</div><div class="line">Parallel GC with 4 thread(s)</div><div class="line"></div><div class="line">Heap Configuration: //堆内存初始化配置</div><div class="line">   //对应jvm启动参数-XX:M<span class="keyword">in</span>HeapFreeRatio设置JVM堆最小空闲比率</div><div class="line">   M<span class="keyword">in</span>HeapFreeRatio = 0 </div><div class="line">   //对应jvm启动参数 -XX:MaxHeapFreeRatio设置JVM堆最大空闲比率</div><div class="line">   MaxHeapFreeRatio = 100 </div><div class="line">   //对应jvm启动参数-XX:MaxHeapSize=设置JVM堆的最大大小</div><div class="line">   MaxHeapSize      = 2147483648 (2048.0MB)</div><div class="line">   //对应jvm启动参数-XX:NewSize=设置JVM堆的‘新生代’的默认大小</div><div class="line">   NewSize          = 1310720 (1.25MB)</div><div class="line">   //对应jvm启动参数-XX:MaxNewSize=设置JVM堆的‘新生代’的最大大小</div><div class="line">   MaxNewSize       = 17592186044415 MB</div><div class="line">   //对应jvm启动参数-XX:OldSize=&lt;value&gt;:设置JVM堆的‘老生代’的大小</div><div class="line">   OldSize          = 5439488 (5.1875MB)</div><div class="line">   //对应jvm启动参数-XX:NewRatio=:‘新生代’和‘老生代’的大小比率</div><div class="line">   NewRatio         = 2</div><div class="line">   //对应jvm启动参数-XX:SurvivorRatio=设置年轻代中Eden区与Survivor区的大小比值 </div><div class="line">   SurvivorRatio    = 8</div><div class="line">   //对应jvm启动参数-XX:PermSize=&lt;value&gt;:设置JVM堆的‘永生代’的初始大小</div><div class="line">   PermSize         = 21757952 (20.75MB)</div><div class="line">   //对应jvm启动参数-XX:MaxPermSize=&lt;value&gt;:设置JVM堆的‘永生代’的最大大小</div><div class="line">   MaxPermSize      = 85983232 (82.0MB)</div><div class="line">   G1HeapRegionSize = 0 (0.0MB)</div><div class="line"></div><div class="line">Heap Usage:</div><div class="line">PS Young Generation</div><div class="line">Eden Space: //Eden区内存分布</div><div class="line">   //Eden区总容量</div><div class="line">   capacity = 136839168 (130.5MB)</div><div class="line">   //Eden区已使用</div><div class="line">   used     = 62349088 (59.460723876953125MB)</div><div class="line">   //Eden区剩余容量</div><div class="line">   free     = 74490080 (71.03927612304688MB)</div><div class="line">   //Eden区使用比率</div><div class="line">   45.56377308578784% used</div><div class="line">From Space: //其中一个Survivor区的内存分布</div><div class="line">   capacity = 17301504 (16.5MB)</div><div class="line">   used     = 17299704 (16.49828338623047MB)</div><div class="line">   free     = 1800 (0.00171661376953125MB)</div><div class="line">   99.98959628018466% used</div><div class="line">To Space: //另一个Survivor区的内存分布</div><div class="line">   capacity = 27262976 (26.0MB)</div><div class="line">   used     = 0 (0.0MB)</div><div class="line">   free     = 27262976 (26.0MB)</div><div class="line">   0.0% used</div><div class="line">PS Old Generation //当前的Old区内存分布</div><div class="line">   capacity = 89128960 (85.0MB)</div><div class="line">   used     = 35824408 (34.164817810058594MB)</div><div class="line">   free     = 53304552 (50.835182189941406MB)</div><div class="line">   40.19390330595129% used</div><div class="line">PS Perm Generation //当前的 “永生代” 内存分布</div><div class="line">   capacity = 22020096 (21.0MB)</div><div class="line">   used     = 2801672 (2.6718826293945312MB)</div><div class="line">   free     = 19218424 (18.32811737060547MB)</div><div class="line">   12.723250616164435% used</div><div class="line"></div><div class="line">734 interned Strings occupying 47744 bytes.</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[java调试-jstat命令]]></title>
      <url>http://zsr.github.io/2016/08/18/java%E8%B0%83%E8%AF%95-jstat%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<h2 id="jstat命令使用"><a href="#jstat命令使用" class="headerlink" title="jstat命令使用"></a>jstat命令使用</h2><p>jstat是一个可以用于观察java应用程序运行时相关信息的工具，功能非常强大，可以通过它<strong>查看堆信息的详细情况。</strong></p>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>jstat命令的基本使用语法如下：</p>
<p><strong>jstat -option [-t] [-h] pid [interval] [count]</strong></p>
<ul>
<li>选项option可以由以下值构成。<ul>
<li>-class：显示ClassLoader的相关信息。</li>
<li>-compiler：显示JIT编译的相关信息。</li>
<li><strong>-gc：显示与gc相关的堆信息。</strong></li>
<li>-gccapacity：显示各个代的容量及使用情况。</li>
<li>-gccause：显示垃圾回收的相关信息（同-gcutil），同时显示最后一次或当前正在发生的垃圾回收的诱因。</li>
<li>-gcnew：显示新生代信息。</li>
<li>-gcnewcapacity：显示新生代大小与使用情况。</li>
<li>-gcold：显示老生代和永久代的信息。</li>
<li>-gcoldcapacity：显示老年代的大小。</li>
<li>-gcpermcapacity：显示永久代的大小。</li>
<li>-gcutil：显示垃圾收集信息。</li>
<li>-printcompilation：输出JIT编译的方法信息。</li>
</ul>
</li>
<li>-t参数可以在输出信息前面加上一个Timestamp列，显示程序运行的时间。</li>
<li>-h参数可以在周期性的数据输出时，输出多少行数据后，跟着输出一个表头信息。</li>
<li>interval参数用于指定输出统计数据的周期，单位为毫秒(ms)。</li>
<li>count参数用于指定一共输出多少次数据。</li>
</ul>
<h3 id="详细使用"><a href="#详细使用" class="headerlink" title="详细使用"></a>详细使用</h3><h5 id="class使用"><a href="#class使用" class="headerlink" title="-class使用"></a>-class使用</h5><p>下面命令输出pid为2500这个进程的ClassLoader相关信息，每秒统计一次信息，一共输出3次。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">nalideMacBook-Pro-4:~ nali$ jstat -class -t 13640 1000 3</div><div class="line">Timestamp       Loaded  Bytes  Unloaded  Bytes     Time</div><div class="line">1522.7          414     827.5      0     0.0       0.13</div><div class="line">1523.7          414     827.5      0     0.0       0.13</div><div class="line">1524.7          414     827.5      0     0.0       0.13</div></pre></td></tr></table></figure>
<p>Loaded表示载入的类的数量，第一个Bytes表示载入的类的合计大小，Unloaded表示卸载的类数量，第二个Bytes表示卸载的类的合计大小，Time表示加载和卸载类花的总的时间。</p>
<h5 id="compiler使用"><a href="#compiler使用" class="headerlink" title="-compiler使用"></a>-compiler使用</h5><p>下面的命令查看JIT编译的信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">nalideMacBook-Pro-4:~ nali$ jstat -compiler -t 13640</div><div class="line">Timestamp       Compiled Failed Invalid   Time   FailedType FailedMethod</div><div class="line">         1814.8       99      0       0     0.51          0</div></pre></td></tr></table></figure>
<p>Compiled表示编译任务执行的次数，Failed表示编译失败的次数，Invalid表示编译不可用的次数，Time表示编译的总耗时，FailedType表示最后一次编译的类型，FailedMethod表示最后一次编译失败的类名和方法名。</p>
<h5 id="gc使用"><a href="#gc使用" class="headerlink" title="-gc使用"></a>-gc使用</h5><p>下面的命令显示与gc相关的堆信息的输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">nalideMacBook-Pro-4:~ nali$ jstat -gc 16309</div><div class="line">S0C     S1C     S0U      S1U   EC       EU        OC         OU          MC     MU </div><div class="line">45056.0 55296.0 44588.0  0.0   336896.0 222238.4  171520.0   86902.0     -      - </div><div class="line">CCSC CCSU YGC YGCT   FGC     FGCT      GCT</div><div class="line">-     -    8  0.312   1      1.328    1.640</div></pre></td></tr></table></figure>
<ul>
<li>S0C：s0(from)的大小(KB)</li>
<li>S1C：s1(from)的大小(KB)</li>
<li>S0U：s0(from)已使用的空间(KB)</li>
<li>S1U：s1(from)已经使用的空间(KB)</li>
<li>EC：eden区的大小(KB)</li>
<li>EU：eden区已经使用的空间(KB)</li>
<li>OC：老年代大小(KB)</li>
<li>OU：老年代已经使用的空间(KB)</li>
<li>MC：方法区大小(KB)</li>
<li>MU：方法区使用大小(KB)</li>
<li>CCSC:压缩类空间大小(KB)</li>
<li>CCSU:压缩类空间使用大小(KB)</li>
<li>YGC：新生代gc次数</li>
<li>YGCT：新生代gc耗时</li>
<li>FGC：Full gc次数</li>
<li>FGCT：Full gc耗时</li>
<li>GCT：gc总耗时</li>
</ul>
<h5 id="gccapacity使用"><a href="#gccapacity使用" class="headerlink" title="-gccapacity使用"></a>-gccapacity使用</h5><p>下面的命令显示了各个代的信息，与-gc相比，它不仅输出了各个代的当前大小，还输出了各个代的最大值与最小值：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">nalideMacBook-Pro-4:~ nali$ jstat -gccapacity 16309</div><div class="line"> NGCMN    NGCMX     NGC     S0C     S1C       EC        OGCMN      OGCMX   </div><div class="line">44032.0 699392.0 626176.0 45056.0 55296.0 336896.0    87040.0    1397760.0    </div><div class="line"> OGC       OC       MCMN    MCMX     MC       CCSMN    CCSMX     CCSC    YGC    FGC</div><div class="line">171520.0  171520.0    -       -      -        -        -        -      8        1</div><div class="line">nalideMacBook-Pro-4:~ nali$</div></pre></td></tr></table></figure>
<ul>
<li>NGCMN：新生代最小值(KB)</li>
<li>NGCMX：新生代最大值(KB)</li>
<li>NGC：当前新生代大小(KB)</li>
<li>OGCMN：老年大最小值(KB)</li>
<li>OGCMX：老年代最大值(KB)</li>
<li>OGC：当前老年代大小(KB)</li>
<li>MCMN：方法区最小值(KB)</li>
<li>MCMX：方法区最大值(KB)</li>
<li>CCSMN：压缩类空间最小值(KB)</li>
<li>CCSMX：压缩类空间最大值(KB)</li>
</ul>
<h5 id="gccause使用"><a href="#gccause使用" class="headerlink" title="-gccause使用"></a>-gccause使用</h5><p>下面命令显示最近一次gc的原因，以及当前gc的原因：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">nalideMacBook-Pro-4:~ nali$ jstat -gccause 16309</div><div class="line">S0     S1     E      O      M     CCS    YGC    YGCT    FGC    FGCT     GCT   </div><div class="line">98.96  0.00  65.97  50.67   -      -      8      0.312    1    1.328    1.640</div><div class="line">LGCC                  GCC        </div><div class="line">Allocation Failure   No GC</div></pre></td></tr></table></figure>
<ul>
<li>LGCC：上次gc的原因，可以看到上次gc的原因是Allocation Failure</li>
<li>GCC：当前gc的原因，当前没有gc</li>
</ul>
<h5 id="gcnew使用"><a href="#gcnew使用" class="headerlink" title="-gcnew使用"></a>-gcnew使用</h5><p>下面的命令显示新生代的详细信息:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">nalideMacBook-Pro-4:~ nali$ jstat -gcnew 16309</div><div class="line"> S0C    S1C     S0U        S1U  TT MTT  DSS      EC       EU        YGC   YGCT</div><div class="line">45056.0 55296.0 44588.0    0.0  5  15   55296.0  336896.0 222238.4  8     0.312</div></pre></td></tr></table></figure>
<ul>
<li>TT：新生代对象晋升到老年代对象的年龄。</li>
<li>MTT：新生代对象晋升到老年代对象的年龄的最大值。</li>
<li>DSS：所需的Survivor区的大小。</li>
</ul>
<h5 id="gcnewcapacity使用"><a href="#gcnewcapacity使用" class="headerlink" title="-gcnewcapacity使用"></a>-gcnewcapacity使用</h5><p>下面的命令详细输出了新生代各个区的大小信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">nalideMacBook-Pro-4:~ nali$ jstat -gcnewcapacity 16309</div><div class="line">NGCMN    NGCMX    NGC      S0CMX     S0C     S1CMX     S1C       ECMX        EC      </div><div class="line">44032.0  699392.0 626176.0 232960.0  45056.0 232960.0  55296.0   698368.0  336896.0     </div><div class="line">YGC   FGC</div><div class="line">8     1</div><div class="line">```   </div><div class="line"></div><div class="line">- S0CMX：s0区的最大值(KB)</div><div class="line">- S1CMX：s1区的最大值(KB)</div><div class="line">- ECMX：eden区的最大值(KB)</div><div class="line"></div><div class="line"><span class="comment">##### -gcold使用</span></div><div class="line"></div><div class="line">下面的命令显示老年代gc概况：</div><div class="line"></div><div class="line"></div><div class="line">``` bash</div><div class="line">nalideMacBook-Pro-4:~ nali$ jstat -gcold 16309</div><div class="line">MC   MU      CCSC     CCSU       OC          OU       YGC    FGC    FGCT     GCT</div><div class="line">-    -        -        -     171520.0      86902.0     8     1      1.328    1.640</div></pre></td></tr></table></figure>
<h5 id="gcoldcapacity使用"><a href="#gcoldcapacity使用" class="headerlink" title="-gcoldcapacity使用"></a>-gcoldcapacity使用</h5><p>下面的命令用于显示老年代的容量信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">nalideMacBook-Pro-4:~ nali$ jstat -gcoldcapacity 16309</div><div class="line">OGCMN       OGCMX        OGC         OC       YGC   FGC    FGCT     GCT</div><div class="line">87040.0   1397760.0    171520.0    171520.0     8     1    1.328    1.640</div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[java调试-jps命令]]></title>
      <url>http://zsr.github.io/2016/08/18/java%E8%B0%83%E8%AF%95-jps%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<h2 id="jps命令使用"><a href="#jps命令使用" class="headerlink" title="jps命令使用"></a>jps命令使用</h2><p>jps命令类似于linux下的ps命令，用于列出当前正在运行的所有java进程。</p>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>直接运行不加任何参数就能列出所有java进程的pid和类的短名称。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">nalideMacBook-Pro-4:~ nali$ jps</div><div class="line">13698 Jps</div><div class="line">13640 TestJava</div><div class="line">50360</div></pre></td></tr></table></figure>
<h3 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h3><ul>
<li>-q参数</li>
</ul>
<p>-q可以指定jps只列出pid,而不输出类的短名称，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">nalideMacBook-Pro-4:~ nali$ jps -q</div><div class="line">13959</div><div class="line">13640</div><div class="line">50360</div></pre></td></tr></table></figure>
<ul>
<li>-m参数</li>
</ul>
<p>-m参数可以用于列出传递给java进程主函数的参数，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">nalideMacBook-Pro-4:~ nali$ jps -m</div><div class="line">13640 TestJava</div><div class="line">50360</div><div class="line">14029 Jps -m</div></pre></td></tr></table></figure>
<p>可以看到传递给jps（jps本身也是java进程）进程的参数就是-m</p>
<ul>
<li>-l参数</li>
</ul>
<p>-l参数用于输出主类的完整路径，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">nalideMacBook-Pro-4:~ nali$ jps -l</div><div class="line">14198 sun.tools.jps.Jps</div><div class="line">13640 com.david.test.TestJava</div><div class="line">50360</div></pre></td></tr></table></figure>
<ul>
<li>-v参数</li>
</ul>
<p>-v参数可以列出传递给java虚拟机的参数，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">nalideMacBook-Pro-4:~ nali$ jps -v</div><div class="line">14290 Jps -Dapplication.home=/Library/Java/JavaVirtualMachines/jdk1.8.0_91.jdk/Contents/Home -Xms8m</div><div class="line">13640 TestJava -agentlib:jdwp=transport=dt_socket,suspend=y,address=localhost:56353 -Dfile.encoding=UTF-8</div><div class="line">50360  -Dosgi.requiredJavaVersion=1.7 -XstartOnFirstThread -Dorg.eclipse.swt.internal.carbon.smallFonts -XX:MaxPermSize=256m -Xms256m -Xmx2048m -Xdock:icon=../Resources/Eclipse.icns -XstartOnFirstThread -Dorg.eclipse.swt.internal.carbon.smallFonts</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hashtable]]></title>
      <url>http://zsr.github.io/2016/08/17/HashTable/</url>
      <content type="html"><![CDATA[<h1 id="OpenJDK-源代码阅读之-Hashtable"><a href="#OpenJDK-源代码阅读之-Hashtable" class="headerlink" title="OpenJDK 源代码阅读之 Hashtable"></a>OpenJDK 源代码阅读之 Hashtable</h1><hr>
<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><ul>
<li>类继承关系</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">java.lang.Object</div><div class="line">    java.util.Dictionary&lt;K,V&gt;</div><div class="line">        java.util.Hashtable&lt;K,V&gt;</div></pre></td></tr></table></figure>
<ul>
<li>定义 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public class Hashtable&lt;K,V&gt;</div><div class="line">    extends Dictionary&lt;K,V&gt;</div><div class="line">    implements Map&lt;K,V&gt;, Cloneable, java.io.Serializable</div></pre></td></tr></table></figure>
<ul>
<li>hashtable put()方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">        <span class="comment">// Make sure the value is not null</span></div><div class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Makes sure the key is not already in the hashtable.</span></div><div class="line">        Entry tab[] = table;</div><div class="line">        <span class="comment">//在此处计算key的hash值，如果此处key为null，则直接抛出空指针异常。</span></div><div class="line">        <span class="keyword">int</span> hash = hash(key);</div><div class="line">        <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</div><div class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</div><div class="line">            <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</div><div class="line">                V old = e.value;</div><div class="line">                e.value = value;</div><div class="line">                <span class="keyword">return</span> old;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        modCount++;</div><div class="line">        <span class="keyword">if</span> (count &gt;= threshold) &#123;</div><div class="line">            <span class="comment">// Rehash the table if the threshold is exceeded</span></div><div class="line">            rehash();</div><div class="line"></div><div class="line">            tab = table;</div><div class="line">            hash = hash(key);</div><div class="line">            index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Creates the new entry.</span></div><div class="line">        Entry&lt;K,V&gt; e = tab[index];</div><div class="line">        tab[index] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</div><div class="line">        count++;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>hashtable get()方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">        Entry tab[] = table;</div><div class="line">        <span class="keyword">int</span> hash = hash(key);</div><div class="line">        <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</div><div class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</div><div class="line">            <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</div><div class="line">                <span class="keyword">return</span> e.value;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>get()和put()都使用了<code>synchronized</code>加锁，容易阻塞，效率低。<strong>hashtable不允许value为null</strong></p>
<ul>
<li>hashMap put()方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</div><div class="line">            inflateTable(threshold);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span> putForNullKey(value);</div><div class="line">        <span class="keyword">int</span> hash = hash(key);</div><div class="line">        <span class="keyword">int</span> i = indexFor(hash, table.length);</div><div class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</div><div class="line">            Object k;</div><div class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</div><div class="line">                V oldValue = e.value;</div><div class="line">                e.value = value;</div><div class="line">                e.recordAccess(<span class="keyword">this</span>);</div><div class="line">                <span class="keyword">return</span> oldValue;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        modCount++;</div><div class="line">        addEntry(hash, key, value, i);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>hashMap get()方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">           <span class="keyword">return</span> getForNullKey();</div><div class="line">       Entry&lt;K,V&gt; entry = getEntry(key);</div><div class="line"></div><div class="line">       <span class="keyword">return</span> <span class="keyword">null</span> == entry ? <span class="keyword">null</span> : entry.getValue();</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p><strong>hashMap多线程环境不安全。</strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ConcurrentHashMap]]></title>
      <url>http://zsr.github.io/2016/08/17/ConcurrentHashMap/</url>
      <content type="html"><![CDATA[<h1 id="OpenJDK-源代码阅读之-ConcurrentHashMap"><a href="#OpenJDK-源代码阅读之-ConcurrentHashMap" class="headerlink" title="OpenJDK 源代码阅读之 ConcurrentHashMap"></a>OpenJDK 源代码阅读之 ConcurrentHashMap</h1><hr>
<h3 id="ConcurrentHashMap-作用"><a href="#ConcurrentHashMap-作用" class="headerlink" title="ConcurrentHashMap 作用"></a>ConcurrentHashMap 作用</h3><p>多线程环境下，使用<code>Hashmap</code>进行put操作会引起死循环，导致CPU利用率接近100%，所以在并发情况下不能使用HashMap。虽然已经有一个线程安全的<code>HashTable</code>，但是HashTable容器使用synchronized（他的get和put方法的实现代码如下）来保证线程安全，在线程竞争激烈的情况下HashTable的效率非常低下。因为当一个线程访问HashTable的同步方法时，访问其他同步方法的线程就可能会进入阻塞或者轮训状态。如线程1使用put进行添加元素，线程2不但不能使用put方法添加元素，并且也不能使用get方法来获取元素，所以竞争越激烈效率越低。</p>
<p>Hashtable get()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    Entry&lt;?,?&gt; tab[] = table;</div><div class="line">    <span class="keyword">int</span> hash = key.hashCode();</div><div class="line">    <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</div><div class="line">    <span class="keyword">for</span> (Entry&lt;?,?&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</div><div class="line">        <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</div><div class="line">            <span class="keyword">return</span> (V)e.value;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Hashtable put()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    <span class="comment">// Make sure the value is not null</span></div><div class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// Makes sure the key is not already in the hashtable.</span></div><div class="line">    Entry&lt;?,?&gt; tab[] = table;</div><div class="line">    <span class="keyword">int</span> hash = key.hashCode();</div><div class="line">    <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</div><div class="line">    <span class="keyword">for</span>(; entry != <span class="keyword">null</span> ; entry = entry.next) &#123;</div><div class="line">        <span class="keyword">if</span> ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;</div><div class="line">            V old = entry.value;</div><div class="line">            entry.value = value;</div><div class="line">            <span class="keyword">return</span> old;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    addEntry(hash, key, value, index);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>ConcurrentHashMap使用分段锁技术，将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问，能够实现真正的并发访问。如下图是ConcurrentHashMap的内部结构图：</p>
<p><img src="/images/ConcurrentHashMap.png"></p>
<p>从图中可以看到，ConcurrentHashMap内部分为很多个Segment，每一个Segment拥有一把锁，然后每个Segment（继承ReentrantLock）下面包含很多个HashEntry列表数组。对于一个key，需要经过三次（为什么要hash三次下文会详细讲解）hash操作，才能最终定位这个元素的位置，这三次hash分别为：</p>
<ul>
<li>对于一个key，先进行一次hash操作，得到hash值h1，也即h1 = hash1(key)；</li>
<li>将得到的h1的高几位进行第二次hash，得到hash值h2，也即h2 = hash2(h1高几位)，通过h2能够确定该元素的放在哪个Segment；</li>
<li>将得到的h1进行第三次hash，得到hash值h3，也即h3 = hash3(h1)，通过h3能够确定该元素放置在哪个HashEntry。</li>
</ul>
<a id="more"></a>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>构造函数的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></div><div class="line">                         <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel) &#123;</div><div class="line">        <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</div><div class="line">        <span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</div><div class="line">            concurrencyLevel = MAX_SEGMENTS;</div><div class="line">        <span class="comment">// Find power-of-two sizes best matching arguments</span></div><div class="line">        <span class="keyword">int</span> sshift = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> ssize = <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</div><div class="line">            ++sshift;</div><div class="line">            ssize &lt;&lt;= <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">this</span>.segmentShift = <span class="number">32</span> - sshift;</div><div class="line">        <span class="keyword">this</span>.segmentMask = ssize - <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</div><div class="line">            initialCapacity = MAXIMUM_CAPACITY;</div><div class="line">        <span class="keyword">int</span> c = initialCapacity / ssize;</div><div class="line">        <span class="keyword">if</span> (c * ssize &lt; initialCapacity)</div><div class="line">            ++c;</div><div class="line">        <span class="keyword">int</span> cap = MIN_SEGMENT_TABLE_CAPACITY;</div><div class="line">        <span class="keyword">while</span> (cap &lt; c)</div><div class="line">            cap &lt;&lt;= <span class="number">1</span>;</div><div class="line">        <span class="comment">// create segments and segments[0]</span></div><div class="line">        Segment&lt;K,V&gt; s0 =</div><div class="line">            <span class="keyword">new</span> Segment&lt;K,V&gt;(loadFactor, (<span class="keyword">int</span>)(cap * loadFactor),</div><div class="line">                             (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap]);</div><div class="line">        Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])<span class="keyword">new</span> Segment[ssize];</div><div class="line">        UNSAFE.putOrderedObject(ss, SBASE, s0); <span class="comment">// ordered write of segments[0]</span></div><div class="line">        <span class="keyword">this</span>.segments = ss;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><strong>传入的参数有initialCapacity，loadFactor，concurrencyLevel这三个。</strong></p>
<ul>
<li>initialCapacity表示新创建的这个ConcurrentHashMap的初始容量，也就是上面的结构图中的Entry数量。默认值为static final int DEFAULT_INITIAL_CAPACITY = 16;</li>
<li>loadFactor表示负载因子，就是当ConcurrentHashMap中的元素个数大于loadFactor * 最大容量时就需要rehash，扩容。默认值为static final float DEFAULT_LOAD_FACTOR = 0.75f;</li>
<li>concurrencyLevel表示并发级别，这个值用来确定Segment的个数，Segment的个数是大于等于concurrencyLevel的第一个2的n次方的数。比如，如果concurrencyLevel为12，13，14，15，16这些数，则Segment的数目为16(2的4次方)。默认值为static final int DEFAULT_CONCURRENCY_LEVEL = 16;。理想情况下ConcurrentHashMap的真正的并发访问量能够达到concurrencyLevel，因为有concurrencyLevel个Segment，假如有concurrencyLevel个线程需要访问Map，并且需要访问的数据都恰好分别落在不同的Segment中，则这些线程能够无竞争地自由访问（因为他们不需要竞争同一把锁），达到同时访问的效果。这也是为什么这个参数起名为“并发级别”的原因。</li>
</ul>
<p><strong>初始化的一些动作：</strong></p>
<ul>
<li>验证参数的合法性，如果不合法，直接抛出异常。</li>
<li>concurrencyLevel也就是Segment的个数不能超过规定的最大Segment的个数，默认值为static final int MAX_SEGMENTS = 1 &lt;&lt; 16;，如果超过这个值，设置为这个值。</li>
<li>然后使用循环找到大于等于concurrencyLevel的第一个2的n次方的数ssize，这个数就是Segment数组的大小，并记录一共向左按位移动的次数sshift，并令segmentShift = 32 - sshift，并且segmentMask的值等于ssize - 1，segmentMask的各个二进制位都为1，目的是之后可以通过key的hash值与这个值做&amp;运算确定Segment的索引。</li>
<li>检查给的容量值是否大于允许的最大容量值，如果大于该值，设置为该值。最大容量值为static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;。</li>
<li>然后计算每个Segment平均应该放置多少个元素，这个值c是向上取整的值。比如初始容量为15，Segment个数为4，则每个Segment平均需要放置4个元素。</li>
<li>最后创建一个Segment实例，将其当做Segment数组的第一个元素。</li>
</ul>
<h4 id="put操作"><a href="#put操作" class="headerlink" title="put操作"></a>put操作</h4><p>put操作的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">      Segment&lt;K,V&gt; s;</div><div class="line">      <span class="keyword">if</span> (value == <span class="keyword">null</span>)</div><div class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">      <span class="keyword">int</span> hash = hash(key);</div><div class="line">      <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</div><div class="line">      <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="comment">// nonvolatile; recheck</span></div><div class="line">           (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="keyword">null</span>) <span class="comment">//  in ensureSegment</span></div><div class="line">          s = ensureSegment(j);</div><div class="line">      <span class="keyword">return</span> s.put(key, hash, value, <span class="keyword">false</span>);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p><strong>操作步骤如下：</strong></p>
<ul>
<li>判断value是否为null，如果为null，直接抛出异常。</li>
<li>key通过一次hash运算得到一个hash值。(这个hash运算下文详说)</li>
<li>将得到hash值向右按位移动segmentShift位，然后再与segmentMask做&amp;运算得到segment的索引j。<br>在初始化的时候我们说过segmentShift的值等于32-sshift，例如concurrencyLevel等于16，则sshift等于4，则segmentShift为28。hash值是一个32位的整数，将其向右移动28位就变成这个样子：<br>0000 0000 0000 0000 0000 0000 0000 xxxx，然后再用这个值与segmentMask做&amp;运算，也就是取最后四位的值。这个值确定Segment的索引。</li>
<li>使用Unsafe的方式从Segment数组中获取该索引对应的Segment对象。</li>
<li>向这个Segment对象中put值，这个put操作也基本是一样的步骤（通过&amp;运算获取HashEntry的索引，然后set）。</li>
</ul>
<h4 id="get操作"><a href="#get操作" class="headerlink" title="get操作"></a>get操作</h4><p>get操作的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">        Segment&lt;K,V&gt; s; <span class="comment">// manually integrate access methods to reduce overhead</span></div><div class="line">        HashEntry&lt;K,V&gt;[] tab;</div><div class="line">        <span class="keyword">int</span> h = hash(key);</div><div class="line">        <span class="keyword">long</span> u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</div><div class="line">        <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != <span class="keyword">null</span> &amp;&amp;</div><div class="line">            (tab = s.table) != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</div><div class="line">                     (tab, ((<span class="keyword">long</span>)(((tab.length - <span class="number">1</span>) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</div><div class="line">                 e != <span class="keyword">null</span>; e = e.next) &#123;</div><div class="line">                K k;</div><div class="line">                <span class="keyword">if</span> ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))</div><div class="line">                    <span class="keyword">return</span> e.value;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><strong>操作步骤为：</strong></p>
<ul>
<li>和put操作一样，先通过key进行两次hash确定应该去哪个Segment中取数据。</li>
<li>使用Unsafe获取对应的Segment，然后再进行一次&amp;运算得到HashEntry链表的位置，然后从链表头开始遍历整个链表（因为Hash可能会有碰撞，所以用一个链表保存），如果找到对应的key，则返回对应的value值，如果链表遍历完都没有找到对应的key，则说明Map中不包含该key，返回null。</li>
</ul>
<h4 id="size操作"><a href="#size操作" class="headerlink" title="size操作"></a>size操作</h4><p>size操作与put和get操作最大的区别在于，size操作需要遍历所有的Segment才能算出整个Map的大小，而put和get都只关心一个Segment。假设我们当前遍历的Segment为SA，那么在遍历SA过程中其他的Segment比如SB可能会被修改，于是这一次运算出来的size值可能并不是Map当前的真正大小。所以一个比较简单的办法就是计算Map大小的时候所有的Segment都Lock住，不能更新(包含put，remove等等)数据，计算完之后再Unlock。这是普通人能够想到的方案，但是牛逼的作者还有一个更好的Idea：<strong>先给3次机会，不lock所有的Segment，遍历所有Segment，累加各个Segment的大小得到整个Map的大小，如果某相邻的两次计算获取的所有Segment的更新的次数（每个Segment都有一个modCount变量，这个变量在Segment中的Entry被修改时会加一，通过这个值可以得到每个Segment的更新操作的次数）是一样的，说明计算过程中没有更新操作，则直接返回这个值。如果这三次不加锁的计算过程中Map的更新次数有变化，则之后的计算先对所有的Segment加锁，再遍历所有Segment计算Map大小，最后再解锁所有Segment。</strong>源代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// Try a few times to get accurate count. On failure due to</span></div><div class="line">        <span class="comment">// continuous async changes in table, resort to locking.</span></div><div class="line">        <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="keyword">this</span>.segments;</div><div class="line">        <span class="keyword">int</span> size;</div><div class="line">        <span class="keyword">boolean</span> overflow; <span class="comment">// true if size overflows 32 bits</span></div><div class="line">        <span class="keyword">long</span> sum;         <span class="comment">// sum of modCounts</span></div><div class="line">        <span class="keyword">long</span> last = <span class="number">0L</span>;   <span class="comment">// previous sum</span></div><div class="line">        <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// first iteration isn't retry</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">for</span> (;;) &#123;</div><div class="line">                <span class="keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;</div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</div><div class="line">                        ensureSegment(j).lock(); <span class="comment">// force creation</span></div><div class="line">                &#125;</div><div class="line">                sum = <span class="number">0L</span>;</div><div class="line">                size = <span class="number">0</span>;</div><div class="line">                overflow = <span class="keyword">false</span>;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</div><div class="line">                    Segment&lt;K,V&gt; seg = segmentAt(segments, j);</div><div class="line">                    <span class="keyword">if</span> (seg != <span class="keyword">null</span>) &#123;</div><div class="line">                        sum += seg.modCount;</div><div class="line">                        <span class="keyword">int</span> c = seg.count;</div><div class="line">                        <span class="keyword">if</span> (c &lt; <span class="number">0</span> || (size += c) &lt; <span class="number">0</span>)</div><div class="line">                            overflow = <span class="keyword">true</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (sum == last)</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                last = sum;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</div><div class="line">                    segmentAt(segments, j).unlock();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> overflow ? Integer.MAX_VALUE : size;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>举个例子：</p>
<p><code>一个Map有4个Segment，标记为S1，S2，S3，S4，现在我们要获取Map的size。计算过程是这样的：第一次计算，不对S1，S2，S3，S4加锁，遍历所有的Segment，假设每个Segment的大小分别为1，2，3，4，更新操作次数分别为：2，2，3，1，则这次计算可以得到Map的总大小为1+2+3+4=10，总共更新操作次数为2+2+3+1=8；第二次计算，不对S1,S2,S3,S4加锁，遍历所有Segment，假设这次每个Segment的大小变成了2，2，3，4，更新次数分别为3，2，3，1，因为两次计算得到的Map更新次数不一致(第一次是8，第二次是9)则可以断定这段时间Map数据被更新，则此时应该再试一次；第三次计算，不对S1，S2，S3，S4加锁，遍历所有Segment，假设每个Segment的更新操作次数还是为3，2，3，1，则因为第二次计算和第三次计算得到的Map的更新操作的次数是一致的，就能说明第二次计算和第三次计算这段时间内Map数据没有被更新，此时可以直接返回第三次计算得到的Map的大小。最坏的情况：第三次计算得到的数据更新次数和第二次也不一样，则只能先对所有Segment加锁再计算最后解锁。</code></p>
<h3 id="关于hash"><a href="#关于hash" class="headerlink" title="关于hash"></a>关于hash</h3><table>
<thead>
<tr>
<th style="text-align:center">术语</th>
<th style="text-align:center">英文</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">哈希算法</td>
<td style="text-align:center">hash algorithm</td>
<td style="text-align:center">是一种将任意内容的输入转换成相同长度输出的加密方式，其输出被称为哈希值。</td>
</tr>
<tr>
<td style="text-align:center">哈希表</td>
<td style="text-align:center">hash table</td>
<td style="text-align:center">根据设定的哈希函数H(key)和处理冲突方法将一组关键字映象到一个有限的地址区间上，并以关键字在地址区间中的象作为记录在表中的存储位置，这种表称为哈希表或散列，所得存储位置称为哈希地址或散列地址。</td>
</tr>
</tbody>
</table>
<p>hash的源代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> h = hashSeed;</div><div class="line">        <span class="keyword">if</span> ((<span class="number">0</span> != h) &amp;&amp; (k <span class="keyword">instanceof</span> String)) &#123;</div><div class="line">            <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</div><div class="line">        &#125;</div><div class="line">        h ^= k.hashCode();</div><div class="line">        <span class="comment">// Spread bits to regularize both segment and index locations,</span></div><div class="line">        <span class="comment">// using variant of single-word Wang/Jenkins hash.</span></div><div class="line">        h += (h &lt;&lt;  <span class="number">15</span>) ^ <span class="number">0xffffcd7d</span>;</div><div class="line">        h ^= (h &gt;&gt;&gt; <span class="number">10</span>);</div><div class="line">        h += (h &lt;&lt;   <span class="number">3</span>);</div><div class="line">        h ^= (h &gt;&gt;&gt;  <span class="number">6</span>);</div><div class="line">        h += (h &lt;&lt;   <span class="number">2</span>) + (h &lt;&lt; <span class="number">14</span>);</div><div class="line">        <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">16</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这里用到了Wang/Jenkins hash算法的变种，主要的目的是为了减少哈希冲突，使元素能够均匀的分布在不同的Segment上，从而提高容器的存取效率。假如哈希的质量差到极点，那么所有的元素都在一个Segment中，不仅存取元素缓慢，分段锁也会失去意义。</p>
<p>举个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">System.out.println(Integer.parseInt(<span class="string">"0001111"</span>, <span class="number">2</span>) &amp; <span class="number">15</span>);</div><div class="line">System.out.println(Integer.parseInt(<span class="string">"0011111"</span>, <span class="number">2</span>) &amp; <span class="number">15</span>);</div><div class="line">System.out.println(Integer.parseInt(<span class="string">"0111111"</span>, <span class="number">2</span>) &amp; <span class="number">15</span>);</div><div class="line">System.out.println(Integer.parseInt(<span class="string">"1111111"</span>, <span class="number">2</span>) &amp; <span class="number">15</span>);</div></pre></td></tr></table></figure>
<p>这些数字得到的hash值都是一样的，全是15，所以如果不进行第一次预hash，发生冲突的几率还是很大的，但是如果我们先把上例中的二进制数字使用hash()函数先进行一次预hash，得到的结果是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">0100｜0111｜0110｜0111｜1101｜1010｜0100｜1110</div><div class="line">1111｜0111｜0100｜0011｜0000｜0001｜1011｜1000</div><div class="line">0111｜0111｜0110｜1001｜0100｜0110｜0011｜1110</div><div class="line">1000｜0011｜0000｜0000｜1100｜1000｜0001｜1010</div></pre></td></tr></table></figure>
<p>可以看到每一位的数据都散开了，并且ConcurrentHashMap中是使用预hash值的高位参与运算的。比如之前说的先将hash值向右按位移动28位，再与15做&amp;运算，得到的结果都别为：4，15，7，8，没有冲突！</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>ConcurrentHashMap中的key和value值都不能为null。<br>ConcurrentHashMap的整个操作过程中大量使用了Unsafe类来获取Segment/HashEntry，这里Unsafe的主要作用是提供原子操作。Unsafe这个类比较恐怖，破坏力极强，一般场景不建议使用，如果有兴趣可以到这里做详细的了解Java中鲜为人知的特性<br>ConcurrentHashMap是线程安全的类并不能保证使用了ConcurrentHashMap的操作都是线程安全的！</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://www.infoq.com/cn/articles/ConcurrentHashMap/" target="_blank" rel="external">深入分析ConcurrentHashMap</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[BlockingQueue]]></title>
      <url>http://zsr.github.io/2016/08/16/BlockingQueue/</url>
      <content type="html"><![CDATA[<h1 id="OpenJDK-源码阅读之-BlockingQueue"><a href="#OpenJDK-源码阅读之-BlockingQueue" class="headerlink" title="OpenJDK 源码阅读之 BlockingQueue"></a>OpenJDK 源码阅读之 BlockingQueue</h1><h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><p>在java.util.Concurrent包中，BlockingQueue很好的解决了在多线程中，如何高效安全“传输”数据的问题。通过这些高效并且线程安全的队列类，为我们快速搭建高质量的多线程程序带来极大的便利。同时，BlockingQueue也用于java自带线程池的缓冲队列中，了解BlockingQueue也有助于理解线程池的工作模型。</p>
<h4 id="BlockingQueue接口"><a href="#BlockingQueue接口" class="headerlink" title="BlockingQueue接口"></a>BlockingQueue接口</h4><p>该接口属于队列，所以继承了Queue接口，该接口最重要的五个方法分别是offer方法，poll方法，put方法，take方法和drainTo方法。</p>
<p>offer方法和poll方法分别有一个静态重载方法，分别是offer(E e, long timeout, TimeUnit unit)和poll(long timeout, TimeUnit unit)方法。其意义是在限定时间内存入或取出对象，如果不能存入取出则返回false。</p>
<p>put方法会在当队列存储对象达到限定值时阻塞线程，而在队列不为空时唤醒被take方法所阻塞的线程。take方法是相反的。</p>
<p>drainTo方法可批量获取队列中的元素。</p>
<h4 id="常见的BlockingQueue实现"><a href="#常见的BlockingQueue实现" class="headerlink" title="常见的BlockingQueue实现"></a>常见的BlockingQueue实现</h4><ul>
<li>LinkedBlockingQueue</li>
</ul>
<p>LinkedBlockingQueue是比较常见的BlockingQueue的实现，他是基于链表的阻塞队列。在创建该对象时如果不指定可存储对象个数大小时，默认为Integer.MAX_VALUE。当生产者往队列中放入一个数据时，队列会从生产者手中获取数据，并缓存在队列内部，而生产者立即返回；只有当队列缓冲区达到最大值缓存容量时，才会阻塞生产者队列，直到消费者从队列中消费掉一份数据，生产者线程会被唤醒，反之对于消费者这端的处理也基于同样的原理。</p>
<p>LinkedBlockingQueue内部使用了独立的两把锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。</p>
<p>put方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public void put(E e) throws InterruptedException &#123;</div><div class="line">        if (e == null) throw new NullPointerException();</div><div class="line">        int c = -1;</div><div class="line">        Node&lt;E&gt; node = new Node(e);</div><div class="line">        final ReentrantLock putLock = this.putLock;</div><div class="line">        final AtomicInteger count = this.count;</div><div class="line">        putLock.lockInterruptibly();</div><div class="line">        try &#123;</div><div class="line">            while (count.get() == capacity) &#123;</div><div class="line">                notFull.await();</div><div class="line">            &#125;</div><div class="line">            enqueue(node);</div><div class="line">            c = count.getAndIncrement();</div><div class="line">            if (c + 1 &lt; capacity)</div><div class="line">                notFull.signal();</div><div class="line">        &#125; finally &#123;</div><div class="line">            putLock.unlock();</div><div class="line">        &#125;</div><div class="line">        if (c == 0)</div><div class="line">            signalNotEmpty();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>offer方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">    public boolean offer(E e) &#123;</div><div class="line">        if (e == null) throw new NullPointerException();</div><div class="line">        final AtomicInteger count = this.count;</div><div class="line">        if (count.get() == capacity)</div><div class="line">            return false;</div><div class="line">        int c = -1;</div><div class="line">        Node&lt;E&gt; node = new Node(e);</div><div class="line">        final ReentrantLock putLock = this.putLock;</div><div class="line">        putLock.lock();</div><div class="line">        try &#123;</div><div class="line">            if (count.get() &lt; capacity) &#123;</div><div class="line">                enqueue(node);</div><div class="line">                c = count.getAndIncrement();</div><div class="line">                if (c + 1 &lt; capacity)</div><div class="line">                    notFull.signal();</div><div class="line">            &#125;</div><div class="line">        &#125; finally &#123;</div><div class="line">            putLock.unlock();</div><div class="line">        &#125;</div><div class="line">        if (c == 0)</div><div class="line">            signalNotEmpty();</div><div class="line">        return c &gt;= 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这两个方法的区别是put方法在容量达到上限时会阻塞，而offer方法则会直接返回false。</p>
<a id="more"></a>
<ul>
<li>ArrayBlockingQueue</li>
</ul>
<p>ArrayBlockingQueue是基于数组的阻塞队列，除了有一个定长数组外，ArrayBlockingQueue内部还保存着两个整形变量，分别标识着队列的头部和尾部在数组中的位置。ArrayBlockingQueue在生产者放入数据和消费者获取数据，都是共用同一个锁对象，由此也意味着两者无法真正并行运行，这点尤其不同于LinkedBlockingQueue。<br>ArrayBlockingQueue和LinkedBlockingQueue间还有一个明显的不同之处在于，前者在插入或删除元素时不会产生或销毁任何额外的对象实例，而后者则会生成一个额外的Node对象。</p>
<ul>
<li>SynchronousQueue</li>
</ul>
<p>是一种没有缓冲的阻塞队列，在生产者put的同时必须要有一个消费者进行take，否则就会阻塞。声明一个SynchronousQueue有两种不同的方式。公平模式和非公平模式的区别:如果采用公平模式：SynchronousQueue会采用公平锁，并配合一个FIFO队列来阻塞多余的生产者和消费者，从而体系整体的公平策略；但如果是非公平模式（SynchronousQueue默认）：SynchronousQueue采用非公平锁，同时配合一个LIFO队列来管理多余的生产者和消费者，而后一种模式，如果生产者和消费者的处理速度有差距，则很容易出现饥渴的情况，即可能有某些生产者或者是消费者的数据永远都得不到处理。</p>
<ul>
<li>PriorityBlockingQueue和DelayQueue</li>
</ul>
<p>PriorityBlockingQueue是基于优先级的阻塞队列，该队列不会阻塞生产者，只会阻塞消费者。<br>DelayQueue队列存储的对象只有指定的延迟时间到了才能被取出，该队列也不会阻塞生产者。</p>
<h4 id="BlockingQueue的使用"><a href="#BlockingQueue的使用" class="headerlink" title="BlockingQueue的使用"></a>BlockingQueue的使用</h4><p>在处理多线程生产者消费者问题时的演示代码：</p>
<p>main()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">import java.util.concurrent.ArrayBlockingQueue;</div><div class="line">import java.util.concurrent.BlockingQueue;</div><div class="line"> </div><div class="line">public class BlockingQueueTest &#123;</div><div class="line"> </div><div class="line">    public static void main(String[] args)</div><div class="line">    &#123;</div><div class="line">        BlockingQueue&lt;String&gt; queue = new ArrayBlockingQueue&lt;String&gt;(1000);</div><div class="line">        Thread p1 = new Thread(new Producer(queue),&quot;producer1&quot;);</div><div class="line">        Thread p2 = new Thread(new Producer(queue),&quot;producer2&quot;);</div><div class="line">        Thread c1 = new Thread(new Consumer(queue),&quot;consumer1&quot;);</div><div class="line">        Thread c2 = new Thread(new Consumer(queue),&quot;consumer2&quot;);</div><div class="line"> </div><div class="line">        p1.start();</div><div class="line">        p2.start();</div><div class="line">        c1.start();</div><div class="line">        c2.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>生产者：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">class Producer implements Runnable&#123;</div><div class="line">    private BlockingQueue&lt;String&gt; queue;</div><div class="line"> </div><div class="line">    public Producer(BlockingQueue&lt;String&gt; queue) &#123;</div><div class="line">        this.queue = queue;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    public void run() &#123;</div><div class="line">        int i = 0;</div><div class="line">        while (!Thread.currentThread().isInterrupted())</div><div class="line">        &#123;</div><div class="line">            try &#123;</div><div class="line">                queue.put(Thread.currentThread().getName()+&quot; product &quot;+i);</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                System.err.println(Thread.currentThread().getName() + &quot; error&quot;);</div><div class="line">            &#125;</div><div class="line">            i++;</div><div class="line">            try &#123;</div><div class="line">                Thread.sleep(1000);</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line"> </div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>消费者：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">class Consumer implements Runnable&#123;</div><div class="line">    private BlockingQueue&lt;String&gt; queue;</div><div class="line"> </div><div class="line">    public Consumer(BlockingQueue&lt;String&gt; queue) &#123;</div><div class="line">        this.queue = queue;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    public void run() &#123;</div><div class="line">        int i = 0;</div><div class="line">        while (!Thread.currentThread().isInterrupted())</div><div class="line">        &#123;</div><div class="line">            try &#123;</div><div class="line">                String str = queue.take();</div><div class="line">                System.out.println(str);</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line"> </div><div class="line">            &#125;</div><div class="line">            try &#123;</div><div class="line">                Thread.sleep(300);</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line"> </div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>BlockingQueue在并发编程中扮演着重要的角色，既可以自己用来解决生产者消费者问题，也用于java自带线程池的缓冲队列。</p>
<p>参考：</p>
<p><a href="http://wsmajunfeng.iteye.com/blog/1629354" target="_blank" rel="external">BlockingQueue</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[HashSet]]></title>
      <url>http://zsr.github.io/2016/08/16/HashSet/</url>
      <content type="html"><![CDATA[<h1 id="OpenJDK-源代码阅读之-HashSet"><a href="#OpenJDK-源代码阅读之-HashSet" class="headerlink" title="OpenJDK 源代码阅读之 HashSet"></a>OpenJDK 源代码阅读之 HashSet</h1><hr>
<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><ul>
<li>类继承关系</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">java.lang.Object</div><div class="line">    java.util.AbstractCollection&lt;E&gt;</div><div class="line">        java.util.AbstractSet&lt;E&gt;</div><div class="line">            java.util.HashSet&lt;E&gt;</div></pre></td></tr></table></figure>
<ul>
<li>定义</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public class HashSet&lt;E&gt;</div><div class="line">extends AbstractSet&lt;E&gt;</div><div class="line">implements Set&lt;E&gt;, Cloneable, Serializable</div></pre></td></tr></table></figure>
<ul>
<li>要点</li>
</ul>
<ol>
<li>不保证元素次序，甚至不保证次序不随时间变化</li>
<li>基本操作(add, remove, contains, size)常量时间</li>
<li>迭代操作与当前元素个数加底层容量大小成正比</li>
<li>不保证同步</li>
</ol>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul>
<li>总体实现</li>
</ul>
<p>底层是用 <code>HashMap</code> 实现的，<code>Set</code> 中的数据是 <code>HashMap</code> 的 <code>key</code>，所有的 <code>key</code> 指向同一个 <code>value</code>, 此 <code>value</code> 定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Dummy value to associate with an Object in the backing Map</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</div></pre></td></tr></table></figure>
<p>再看一下 <code>add</code>，大概就能明白了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Adds the specified element to this set if it is not already present.</div><div class="line"> * More formally, adds the specified element &lt;tt&gt;e&lt;/tt&gt; to this set if</div><div class="line"> * this set contains no element &lt;tt&gt;e2&lt;/tt&gt; such that</div><div class="line"> * &lt;tt&gt;(e==null&amp;nbsp;?&amp;nbsp;e2==null&amp;nbsp;:&amp;nbsp;e.equals(e2))&lt;/tt&gt;.</div><div class="line"> * If this set already contains the element, the call leaves the set</div><div class="line"> * unchanged and returns &lt;tt&gt;false&lt;/tt&gt;.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> e element to be added to this set</div><div class="line"> * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if this set did not already contain the specified</div><div class="line"> * element</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>load factor</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</div><div class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(Math.max((<span class="keyword">int</span>) (c.size()/.<span class="number">75f</span>) + <span class="number">1</span>, <span class="number">16</span>));</div><div class="line">    addAll(c);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>初始化中，注意使用的 <code>HashMap</code> 的 load factor 设置为 0.75，如果太小，就设置成 16. </p>
<p><code>HashSet</code> 并没有什么特别之处，几乎没有自己特有的实现，都是调用 <code>HashMap</code> 的方法实现相应的功能。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Spring MVC ApplicationContext]]></title>
      <url>http://zsr.github.io/2016/08/16/ApplicationContext/</url>
      <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>以只有1个Servlet的简单情况为例，一般涉及到3个配置文件：web.xml，applicationContext.xml，xxx-servlet.xml。</p>
<h3 id="web-xml"><a href="#web-xml" class="headerlink" title="web.xml"></a>web.xml</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;context-param&gt;  </div><div class="line">         &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;  </div><div class="line">         &lt;param-value&gt;classpath:/applicationContext.xml&lt;/param-value&gt;  </div><div class="line">&lt;/context-param&gt;  </div><div class="line">&lt;listener&gt;  </div><div class="line">         &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;  </div><div class="line">&lt;/listener&gt;  </div><div class="line">&lt;servlet&gt;  </div><div class="line">         &lt;servlet-name&gt;xxx&lt;/servlet-name&gt;  </div><div class="line">         &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;  </div><div class="line">         &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;  </div><div class="line">&lt;/servlet&gt;  </div><div class="line">&lt;servlet-mapping&gt;  </div><div class="line">         &lt;servlet-name&gt;xxx&lt;/servlet-name&gt;  </div><div class="line">         &lt;url-pattern&gt;*.html&lt;/url-pattern&gt;  </div><div class="line">&lt;/servlet-mapping&gt;</div></pre></td></tr></table></figure>
<p>在这种情况下，系统会生成2个ApplicationContext，确切的说是2个WebApplicationContext.</p>
<h3 id="ROOT-ApplicationContext"><a href="#ROOT-ApplicationContext" class="headerlink" title="ROOT ApplicationContext"></a>ROOT ApplicationContext</h3><p>在Tomcat启动时，通过注册的监听器ContextLoaderListener，Spring初始化WebApplicationContext并保存到ServletContext中，初始化使用的配置文件位置由contextConfigLocation参数确定。该Context为整个框架中的ROOT Context，其他的Context都会作为其子节点或子孙节点进行关联。</p>
<p>WebApplicationContext和ServletContext互相保存对方的引用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//保存到ServletContext中  </div><div class="line">servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE,this.context);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//保存ServletContext  </div><div class="line">wac.setServletContext(sc);</div></pre></td></tr></table></figure>
<h3 id="xxx-ApplicationContext"><a href="#xxx-ApplicationContext" class="headerlink" title="xxx ApplicationContext"></a>xxx ApplicationContext</h3><p>Tomcat生成xxx Servlet时，DispatcherServlet会使用xxx-servlet.xml（除非显示指定其他文件）初始化WebApplicationContext，将其父节点设为ROOT Context，并保存到ServletContext中。</p>
<p>在createWebApplicationContext()方法中，设置父节点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wac.setParent(parent);</div></pre></td></tr></table></figure>
<p>在configureAndRefreshWebApplicationContext()方法中保存ServletContext：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">wac.setServletContext(getServletContext());  </div><div class="line">wac.setServletConfig(getServletConfig());</div></pre></td></tr></table></figure>
<p>在initWebApplicationContext()方法中将自己保存到ServletContext中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// Publish the context as a servlet context attribute.  </div><div class="line">String attrName = getServletContextAttributeName();  </div><div class="line">getServletContext().setAttribute(attrName, wac);</div></pre></td></tr></table></figure>
<p>ServletContext、ROOT Context和xxx Context三者引用之间的关系如下：</p>
<p><img src="/images/Application关系.jpg"></p>
<p>获取的方法：</p>
<ul>
<li>ServletContext：</li>
</ul>
<p>无论是在ROOT还是xxx Context中，可以通过:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">WebApplicationContext. getServletContext();</div></pre></td></tr></table></figure>
<ul>
<li>ROOT Context：</li>
</ul>
<p>该Context是” org.springframework.web.context. WebApplicationContext. ROOT”为Key保存在ServletContext中。可以使用Spring提供的工具类方法获取：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">WebApplicationContextUtils.getWebApplicationContext(ServletContextsc)</div></pre></td></tr></table></figure>
<p>在xxx Context中可以通过getParent得到ROOT Context。</p>
<ul>
<li>xxx Context：</li>
</ul>
<p>该Context是以” org.springframework.web.servlet.FrameworkServlet.CONTEXT.xxx”为KEY(xxx为web.xml中定义的Servlet名称)，保存在ServletContext中。可以使用Spring提供的工具类方法获取：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">WebApplicationContextUtils.getWebApplicationContext(ServletContextsc, String attrName)</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[DispatchServlet 初始化]]></title>
      <url>http://zsr.github.io/2016/08/15/DispatchServlet-%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
      <content type="html"><![CDATA[<h3 id="设计模型"><a href="#设计模型" class="headerlink" title="设计模型"></a>设计模型</h3><ul>
<li><p>Spring MVC 请求处理流程</p>
<p><img src="/images/springmvc_1.png"></p>
</li>
</ul>
<ul>
<li><p>Spring MVC 架构图</p>
<p><img src="/images/springmvc_2.png"></p>
</li>
</ul>
<h3 id="代码简要"><a href="#代码简要" class="headerlink" title="代码简要"></a>代码简要</h3><ul>
<li>Servlet:</li>
</ul>
<p>所有的Servlet都是实现了Servlet接口，该接口提供了servlet生命周期的一些方法，如: init(), destroy(),service()&lt;每次接收到请求都由该方法来处理&gt;等，没有具体实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public void init(ServletConfig config) throws ServletException;</div></pre></td></tr></table></figure>
<ul>
<li>GenericServlet:<br>该类实现了Servlet的init()方法以及提供了获取初始化参数的方法。init方法的实现最后需要由子类实现</li>
</ul>
<p>获取初始化参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ServletConfig sc = getServletConfig();</div><div class="line">        if (sc == null) &#123;</div><div class="line">            throw new IllegalStateException(</div><div class="line">                lStrings.getString(&quot;err.servlet_config_not_initialized&quot;));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return sc.getInitParameter(name);</div></pre></td></tr></table></figure>
<p>init()初始化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public void init(ServletConfig config) throws ServletException &#123;</div><div class="line">this.config = config;</div><div class="line">this.init();//调用下面的init()方法（没有具体实现）</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public void init() throws ServletException &#123;</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>HttpServlet<br>实现了servlet的service()方法，所有的请求都由该方法来处理，判断走doGet()还是doPost()等等。<br>该方法是有Tomcat容器来调用的(init()方法也是)。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public void service(ServletRequest req, ServletResponse res)</div><div class="line">        throws ServletException, IOException</div><div class="line">    &#123;</div><div class="line">        HttpServletRequest  request;</div><div class="line">        HttpServletResponse response;</div><div class="line">        </div><div class="line">        if (!(req instanceof HttpServletRequest &amp;&amp;</div><div class="line">                res instanceof HttpServletResponse)) &#123;</div><div class="line">            throw new ServletException(&quot;non-HTTP request or response&quot;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        request = (HttpServletRequest) req;</div><div class="line">        response = (HttpServletResponse) res;</div><div class="line"></div><div class="line">        service(request, response);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">protected void service(HttpServletRequest req, HttpServletResponse resp)</div><div class="line">        throws ServletException, IOException</div><div class="line">    &#123;</div><div class="line">        String method = req.getMethod();</div><div class="line"></div><div class="line">        if (method.equals(METHOD_GET)) &#123;</div><div class="line">            long lastModified = getLastModified(req);</div><div class="line">            if (lastModified == -1) &#123;</div><div class="line">                // servlet doesn&apos;t support if-modified-since, no reason</div><div class="line">                // to go through further expensive logic</div><div class="line">                doGet(req, resp);</div><div class="line">            &#125; else &#123;</div><div class="line">                long ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE);</div><div class="line">                if (ifModifiedSince &lt; lastModified) &#123;</div><div class="line">                    // If the servlet mod time is later, call doGet()</div><div class="line">                    // Round down to the nearest second for a proper compare</div><div class="line">                    // A ifModifiedSince of -1 will always be less</div><div class="line">                    maybeSetLastModified(resp, lastModified);</div><div class="line">                    doGet(req, resp);</div><div class="line">                &#125; else &#123;</div><div class="line">                    resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125; else if (method.equals(METHOD_HEAD)) &#123;</div><div class="line">            long lastModified = getLastModified(req);</div><div class="line">            maybeSetLastModified(resp, lastModified);</div><div class="line">            doHead(req, resp);</div><div class="line"></div><div class="line">        &#125; else if (method.equals(METHOD_POST)) &#123;</div><div class="line">            doPost(req, resp);</div><div class="line">            </div><div class="line">        &#125; else if (method.equals(METHOD_PUT)) &#123;</div><div class="line">            doPut(req, resp);</div><div class="line">            </div><div class="line">        &#125; else if (method.equals(METHOD_DELETE)) &#123;</div><div class="line">            doDelete(req, resp);</div><div class="line">            </div><div class="line">        &#125; else if (method.equals(METHOD_OPTIONS)) &#123;</div><div class="line">            doOptions(req,resp);</div><div class="line">            </div><div class="line">        &#125; else if (method.equals(METHOD_TRACE)) &#123;</div><div class="line">            doTrace(req,resp);</div><div class="line">            </div><div class="line">        &#125; else &#123;</div><div class="line">            //</div><div class="line">            // Note that this means NO servlet supports whatever</div><div class="line">            // method was requested, anywhere on this server.</div><div class="line">            //</div><div class="line"></div><div class="line">            String errMsg = lStrings.getString(&quot;http.method_not_implemented&quot;);</div><div class="line">            Object[] errArgs = new Object[1];</div><div class="line">            errArgs[0] = method;</div><div class="line">            errMsg = MessageFormat.format(errMsg, errArgs);</div><div class="line">            </div><div class="line">            resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>以上几个类都是不需要Spring框架的参与。</p>
<a id="more"></a>
<ul>
<li>HttpServletBean</li>
</ul>
<p>该类最终重载实现了GenericServlet类的init()方法。注意: 方法是final类型，不可以被继承。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">	public final void init() throws ServletException &#123;</div><div class="line">		if (logger.isDebugEnabled()) &#123;</div><div class="line">			logger.debug(&quot;Initializing servlet &apos;&quot; + getServletName() + &quot;&apos;&quot;);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		// Set bean properties from init parameters.</div><div class="line">		try &#123;</div><div class="line">			PropertyValues pvs = new ServletConfigPropertyValues(getServletConfig(), this.requiredProperties);</div><div class="line">			BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(this);</div><div class="line">			ResourceLoader resourceLoader = new ServletContextResourceLoader(getServletContext());</div><div class="line">			bw.registerCustomEditor(Resource.class, new ResourceEditor(resourceLoader, getEnvironment()));</div><div class="line">			initBeanWrapper(bw);</div><div class="line">			bw.setPropertyValues(pvs, true);</div><div class="line">		&#125;</div><div class="line">		catch (BeansException ex) &#123;</div><div class="line">			logger.error(&quot;Failed to set bean properties on servlet &apos;&quot; + getServletName() + &quot;&apos;&quot;, ex);</div><div class="line">			throw ex;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		// Let subclasses do whatever initialization they like.</div><div class="line">		initServletBean();</div><div class="line"></div><div class="line">		if (logger.isDebugEnabled()) &#123;</div><div class="line">			logger.debug(&quot;Servlet &apos;&quot; + getServletName() + &quot;&apos; configured successfully&quot;);</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>上面的类需要调用initServletBean()方法，该方法在HttpServletBean类中没有具体实现，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">protected void initServletBean() throws ServletException &#123;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<ul>
<li>FrameworkServlet<br>实现了HttpServletBean类的initServletBean()方法，初始化WebApplicationContext。并且重载了HttpServlet类的service()方法，以及所有的doGet(),doPost()方法, 这些方法最后都调用了doService()方法(该类没有实现doService(),由DispatchServlet类具体实现)。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">	protected final void initServletBean() throws ServletException &#123;</div><div class="line">		getServletContext().log(&quot;Initializing Spring FrameworkServlet &apos;&quot; + getServletName() + &quot;&apos;&quot;);</div><div class="line">		if (this.logger.isInfoEnabled()) &#123;</div><div class="line">			this.logger.info(&quot;FrameworkServlet &apos;&quot; + getServletName() + &quot;&apos;: initialization started&quot;);</div><div class="line">		&#125;</div><div class="line">		long startTime = System.currentTimeMillis();</div><div class="line"></div><div class="line">		try &#123;</div><div class="line">		    //初始化WebApplicationContext</div><div class="line">			this.webApplicationContext = initWebApplicationContext();</div><div class="line">			initFrameworkServlet();</div><div class="line">		&#125;</div><div class="line">		catch (ServletException ex) &#123;</div><div class="line">			this.logger.error(&quot;Context initialization failed&quot;, ex);</div><div class="line">			throw ex;</div><div class="line">		&#125;</div><div class="line">		catch (RuntimeException ex) &#123;</div><div class="line">			this.logger.error(&quot;Context initialization failed&quot;, ex);</div><div class="line">			throw ex;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		if (this.logger.isInfoEnabled()) &#123;</div><div class="line">			long elapsedTime = System.currentTimeMillis() - startTime;</div><div class="line">			this.logger.info(&quot;FrameworkServlet &apos;&quot; + getServletName() + &quot;&apos;: initialization completed in &quot; +</div><div class="line">					elapsedTime + &quot; ms&quot;);</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">protected WebApplicationContext initWebApplicationContext() &#123;</div><div class="line">		WebApplicationContext rootContext =</div><div class="line">				WebApplicationContextUtils.getWebApplicationContext(getServletContext());</div><div class="line">		WebApplicationContext wac = null;</div><div class="line"></div><div class="line">		if (this.webApplicationContext != null) &#123;</div><div class="line">			// A context instance was injected at construction time -&gt; use it</div><div class="line">			wac = this.webApplicationContext;</div><div class="line">			if (wac instanceof ConfigurableWebApplicationContext) &#123;</div><div class="line">				ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;</div><div class="line">				if (!cwac.isActive()) &#123;</div><div class="line">					// The context has not yet been refreshed -&gt; provide services such as</div><div class="line">					// setting the parent context, setting the application context id, etc</div><div class="line">					if (cwac.getParent() == null) &#123;</div><div class="line">						// The context instance was injected without an explicit parent -&gt; set</div><div class="line">						// the root application context (if any; may be null) as the parent</div><div class="line">						cwac.setParent(rootContext);</div><div class="line">					&#125;</div><div class="line">					configureAndRefreshWebApplicationContext(cwac);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		if (wac == null) &#123;</div><div class="line">			// No context instance was injected at construction time -&gt; see if one</div><div class="line">			// has been registered in the servlet context. If one exists, it is assumed</div><div class="line">			// that the parent context (if any) has already been set and that the</div><div class="line">			// user has performed any initialization such as setting the context id</div><div class="line">			wac = findWebApplicationContext();</div><div class="line">		&#125;</div><div class="line">		if (wac == null) &#123;</div><div class="line">			// No context instance is defined for this servlet -&gt; create a local one</div><div class="line">			wac = createWebApplicationContext(rootContext);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		if (!this.refreshEventReceived) &#123;</div><div class="line">			// Either the context is not a ConfigurableApplicationContext with refresh</div><div class="line">			// support or the context injected at construction time had already been</div><div class="line">			// refreshed -&gt; trigger initial onRefresh manually here.</div><div class="line">			onRefresh(wac);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		if (this.publishContext) &#123;</div><div class="line">			// Publish the context as a servlet context attribute.</div><div class="line">			String attrName = getServletContextAttributeName();</div><div class="line">			getServletContext().setAttribute(attrName, wac);</div><div class="line">			if (this.logger.isDebugEnabled()) &#123;</div><div class="line">				this.logger.debug(&quot;Published WebApplicationContext of servlet &apos;&quot; + getServletName() +</div><div class="line">						&quot;&apos; as ServletContext attribute with name [&quot; + attrName + &quot;]&quot;);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		return wac;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>上面的方法初始化一个WebApplicationContext.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">protected void onRefresh(ApplicationContext context) &#123;</div><div class="line">		// For subclasses: do nothing by default.</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<ul>
<li>DispatcherServlet</li>
</ul>
<p>实现FrameworkServlet类的onRefresh()方法，在该方法中具体初始化Spring MVC需要的一些策略对象。如HandlerMappings，HandlerAdapters等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">	 * This implementation calls &#123;@link #initStrategies&#125;.</div><div class="line">	 */</div><div class="line">	@Override</div><div class="line">	protected void onRefresh(ApplicationContext context) &#123;</div><div class="line">		initStrategies(context);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	/**</div><div class="line">	 * Initialize the strategy objects that this servlet uses.</div><div class="line">	 * &lt;p&gt;May be overridden in subclasses in order to initialize further strategy objects.</div><div class="line">	 */</div><div class="line">	protected void initStrategies(ApplicationContext context) &#123;</div><div class="line">		initMultipartResolver(context);</div><div class="line">		initLocaleResolver(context);</div><div class="line">		initThemeResolver(context);</div><div class="line">		initHandlerMappings(context);</div><div class="line">		initHandlerAdapters(context);</div><div class="line">		initHandlerExceptionResolvers(context);</div><div class="line">		initRequestToViewNameTranslator(context);</div><div class="line">		initViewResolvers(context);</div><div class="line">		initFlashMapManager(context);</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>至此，DispatchServlet对象的初始化完成。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[servlet 生命周期]]></title>
      <url>http://zsr.github.io/2016/08/15/servlet-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      <content type="html"><![CDATA[<h1 id="Servlet生命周期与工作原理"><a href="#Servlet生命周期与工作原理" class="headerlink" title="Servlet生命周期与工作原理"></a>Servlet生命周期与工作原理</h1><p><strong>Servlet生命周期分为三个阶段：</strong></p>
<p>　　1. 初始化阶段  : 调用init()方法</p>
<p>　　2. 响应客户请求阶段　:　调用service()方法</p>
<p>　　3. 终止阶段　:　调用destroy()方法
　　</p>
<h3 id="Servlet初始化阶段："><a href="#Servlet初始化阶段：" class="headerlink" title="Servlet初始化阶段："></a>Servlet初始化阶段：</h3><p>在下列时刻Servlet容器装载Servlet:</p>
<ul>
<li>Servlet容器启动时自动装载某些Servlet，实现它只需要在web.XML文件中的<servlet></servlet>之间添加如下代码：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;loadon-startup&gt;1&lt;/loadon-startup&gt;</div></pre></td></tr></table></figure>
<ul>
<li>在Servlet容器启动后，客户首次向Servlet发送请求</li>
<li>Servlet类文件被更新后，重新装载Servlet</li>
</ul>
<p>Servlet被装载后，Servlet容器创建一个Servlet实例并且调用Servlet的init()方法进行初始化。在Servlet的整个生命周期内，init()方法只被调用一次。</p>
<h3 id="Servlet工作原理："><a href="#Servlet工作原理：" class="headerlink" title="Servlet工作原理："></a>Servlet工作原理：</h3><p>   首先简单解释一下Servlet接收和响应客户请求的过程，首先客户发送一个请求，Servlet是调用service()方法对请求进行响应的，通过源代码可见，service()方法中对请求的方式进行了匹配，选择调用doGet,doPost等这些方法，然后再进入对应的方法中调用逻辑层的方法，实现对客户的响应。在Servlet接口和GenericServlet中是没有doGet,doPost等等这些方法的，HttpServlet中定义了这些方法，但是都是返回error信息，所以，我们每次定义一个Servlet的时候，都必须实现doGet或doPost等这些方法。</p>
<p>   每一个自定义的Servlet都必须实现Servlet的接口，Servlet接口中定义了五个方法，其中比较重要的三个方法涉及到Servlet的生命周期，分别是上文提到的init(),service(),destroy()方法。GenericServlet是一个通用的，不特定于任何协议的Servlet,它实现了Servlet接口。而HttpServlet继承于GenericServlet，因此HttpServlet也实现了Servlet接口。所以我们定义Servlet的时候只需要继承HttpServlet即可。</p>
<p>　　Servlet接口和GenericServlet是不特定于任何协议的，而HttpServlet是特定于HTTP协议的类，所以HttpServlet中实现了service()方法，并将请求ServletRequest,ServletResponse强转为HttpRequest和HttpResponse。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public void service(ServletRequest req,ServletResponse res) </div><div class="line">  throws ServletException,IOException</div><div class="line">&#123;</div><div class="line">      HttpRequest request;</div><div class="line">      HttpResponse response;</div><div class="line"> </div><div class="line">     try</div><div class="line">     &#123;</div><div class="line">         req = (HttpRequest)request;</div><div class="line">         res = (HttpResponse)response;</div><div class="line">      &#125;catch(ClassCastException e)</div><div class="line">      &#123;</div><div class="line">         throw new ServletException(&quot;non-HTTP request response&quot;); </div><div class="line">      &#125;</div><div class="line">      service(request,response);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>   代码的最后调用了HTTPServlet自己的service(request,response)方法，然后根据请求去调用对应的doXXX方法，因为HttpServlet中的doXXX方法都是返回错误信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">protected void doGet(HttpServletRequest res,HttpServletResponse resp)</div><div class="line">  throws ServletException,IOException</div><div class="line">&#123;</div><div class="line">   String protocol = req.getProtocol();</div><div class="line">   String msg = IStrings.getString(&quot;http.method_get_not_supported&quot;);</div><div class="line">   if(protocol.equals(&quot;1.1&quot;))</div><div class="line">   &#123;</div><div class="line">      resp.sendError(HttpServletResponse.SC.METHOD.NOT.ALLOWED,msg);</div><div class="line">    &#125;</div><div class="line">   esle</div><div class="line">    &#123;</div><div class="line">      resp.sendError(HttpServletResponse.SC_BAD_REQUEST,msg);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以需要我们在自定义的Servlet中override这些方法！</p>
<h3 id="Servlet响应请求阶段："><a href="#Servlet响应请求阶段：" class="headerlink" title="Servlet响应请求阶段："></a>Servlet响应请求阶段：</h3><p>对于用户到达Servlet的请求，Servlet容器会创建特定于这个请求的ServletRequest对象和ServletResponse对象，然后调用Servlet的service方法。service方法从ServletRequest对象获得客户请求信息，处理该请求，并通过ServletResponse对象向客户返回响应信息。</p>
<p>对于Tomcat来说，它会将传递过来的参数放在一个Hashtable中，该Hashtable的定义是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">private Hashtable&lt;String String[]&gt; paramHashStringArray = new Hashtable&lt;String String[]&gt;();</div></pre></td></tr></table></figure>
<p>这是一个String–&gt;String[]的键值映射。<br>HashMap线程不安全的，Hashtable线程安全。</p>
<h3 id="Servlet终止阶段："><a href="#Servlet终止阶段：" class="headerlink" title="Servlet终止阶段："></a>Servlet终止阶段：</h3><p>当WEB应用被终止，或Servlet容器终止运行，或Servlet容器重新装载Servlet新实例时，Servlet容器会先调用Servlet的destroy()方法，在destroy()方法中可以释放掉Servlet所占用的资源。</p>
<h3 id="Servlet何时被创建："><a href="#Servlet何时被创建：" class="headerlink" title="Servlet何时被创建："></a>Servlet何时被创建：</h3><ul>
<li><p>默认情况下，当WEB客户第一次请求访问某个Servlet的时候，WEB容器将创建这个Servlet的实例。</p>
</li>
<li><p>当web.xml文件中如果<servlet>元素中指定了<load-on-startup>子元素时，Servlet容器在启动web服务器时，将按照顺序创建并初始化Servlet对象。</load-on-startup></servlet></p>
</li>
</ul>
<p><strong>注意：在web.xml文件中，某些Servlet只有<serlvet>元素，没有<servlet-mapping>元素，这样我们无法通过url的方式访问这些Servlet，这种Servlet通常会在<servlet>元素中配置一个<load-on-startup>子元素，让容器在启动的时候自动加载这些Servlet并调用init()方法，完成一些全局性的初始化工作。</load-on-startup></servlet></servlet-mapping></serlvet></strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Spring MVC 请求方法处理]]></title>
      <url>http://zsr.github.io/2016/08/15/Spring-MVC-%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95%E5%A4%84%E7%90%86/</url>
      <content type="html"><![CDATA[<p>在前面的文章中有说明：<code>&lt;mvc:annotation-driven /&gt;</code>在<code>spring 3.1</code>之后会注册了<code>RequestMappingHandlerMapping</code>和<code>RequestMappingHandlerAdapter</code>，本文详细介绍具体的实现。</p>
<p>在<code>xml</code>文件中配置<code>mvc:annotation-driven</code>，有一个专门的类<code>BeanDefinitionParser</code>来解析处理这个东西。 它只有一个方法： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanDefinitionParser</span> </span>&#123;  </div><div class="line">  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * Parse the specified &#123;<span class="doctag">@link</span> Element&#125; and register the resulting </div><div class="line">     * &#123;<span class="doctag">@link</span> BeanDefinition BeanDefinition(s)&#125; with the </div><div class="line">     * &#123;<span class="doctag">@link</span> org.springframework.beans.factory.xml.ParserContext#getRegistry() BeanDefinitionRegistry&#125; </div><div class="line">     * embedded in the supplied &#123;<span class="doctag">@link</span> ParserContext&#125;. </div><div class="line">     * &lt;p&gt;Implementations must return the primary &#123;<span class="doctag">@link</span> BeanDefinition&#125; that results </div><div class="line">     * from the parse if they will ever be used in a nested fashion (for example as </div><div class="line">     * an inner tag in a &#123;<span class="doctag">@code</span> &lt;property/&gt;&#125; tag). Implementations may return </div><div class="line">     * &#123;<span class="doctag">@code</span> null&#125; if they will &lt;strong&gt;not&lt;/strong&gt; be used in a nested fashion. </div><div class="line">     * <span class="doctag">@param</span> element the element that is to be parsed into one or more &#123;<span class="doctag">@link</span> BeanDefinition BeanDefinitions&#125; </div><div class="line">     * <span class="doctag">@param</span> parserContext the object encapsulating the current state of the parsing process; </div><div class="line">     * provides access to a &#123;<span class="doctag">@link</span> org.springframework.beans.factory.support.BeanDefinitionRegistry&#125; </div><div class="line">     * <span class="doctag">@return</span> the primary &#123;<span class="doctag">@link</span> BeanDefinition&#125; </div><div class="line">     */  </div><div class="line">    <span class="function">BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span></span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>用来专门处理<code>&lt;beans&gt;&lt;/beans&gt;</code>里面的配置元素。然后找到这样的一个实现类<code>AnnotationDrivenBeanDefinitionParser</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** </span></div><div class="line"> * 这里清清楚楚写着该类是专门处理 &lt;mvc:annotation-driven/&gt;标签的 </div><div class="line"> * A &#123;<span class="doctag">@link</span> BeanDefinitionParser&#125; that provides the configuration for the </div><div class="line"> * &#123;<span class="doctag">@code</span> &lt;annotation-driven/&gt;&#125; MVC namespace  element. </div><div class="line"> * </div><div class="line"> * 这里说明了注册的HandlerMapping </div><div class="line"> * &lt;p&gt;This class registers the following &#123;<span class="doctag">@link</span> HandlerMapping&#125;s:&lt;/p&gt; </div><div class="line"> * &lt;ul&gt; </div><div class="line"> *  &lt;li&gt;&#123;<span class="doctag">@link</span> RequestMappingHandlerMapping&#125; </div><div class="line"> *  ordered at 0 for mapping requests to annotated controller methods. </div><div class="line"> *  &lt;li&gt;&#123;<span class="doctag">@link</span> BeanNameUrlHandlerMapping&#125; </div><div class="line"> *  ordered at 2 to map URL paths to controller bean names. </div><div class="line"> * &lt;/ul&gt; </div><div class="line"> * </div><div class="line"> * &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; Additional HandlerMappings may be registered </div><div class="line"> * as a result of using the &#123;<span class="doctag">@code</span> &lt;view-controller&gt;&#125; or the </div><div class="line"> * &#123;<span class="doctag">@code</span> &lt;resources&gt;&#125; MVC namespace elements. </div><div class="line"> * </div><div class="line"> * 这里说明了注册的HandlerAdapter </div><div class="line"> * &lt;p&gt;This class registers the following &#123;<span class="doctag">@link</span> HandlerAdapter&#125;s: </div><div class="line"> * &lt;ul&gt; </div><div class="line"> *  &lt;li&gt;&#123;<span class="doctag">@link</span> RequestMappingHandlerAdapter&#125; </div><div class="line"> *  for processing requests with annotated controller methods. </div><div class="line"> *  &lt;li&gt;&#123;<span class="doctag">@link</span> HttpRequestHandlerAdapter&#125; </div><div class="line"> *  for processing requests with &#123;<span class="doctag">@link</span> HttpRequestHandler&#125;s. </div><div class="line"> *  &lt;li&gt;&#123;<span class="doctag">@link</span> SimpleControllerHandlerAdapter&#125; </div><div class="line"> *  for processing requests with interface-based &#123;<span class="doctag">@link</span> Controller&#125;s. </div><div class="line"> * &lt;/ul&gt; </div><div class="line"> * </div><div class="line"> * &lt;p&gt;This class registers the following &#123;<span class="doctag">@link</span> HandlerExceptionResolver&#125;s: </div><div class="line"> * &lt;ul&gt; </div><div class="line"> *  &lt;li&gt;&#123;<span class="doctag">@link</span> ExceptionHandlerExceptionResolver&#125; for handling exceptions </div><div class="line"> *  through @&#123;<span class="doctag">@link</span> ExceptionHandler&#125; methods. </div><div class="line"> *  &lt;li&gt;&#123;<span class="doctag">@link</span> ResponseStatusExceptionResolver&#125; for exceptions annotated </div><div class="line"> *  with @&#123;<span class="doctag">@link</span> ResponseStatus&#125;. </div><div class="line"> *  &lt;li&gt;&#123;<span class="doctag">@link</span> DefaultHandlerExceptionResolver&#125; for resolving known Spring </div><div class="line"> *  exception types </div><div class="line"> * &lt;/ul&gt; </div><div class="line"> * </div><div class="line"> * &lt;p&gt;Both the &#123;<span class="doctag">@link</span> RequestMappingHandlerAdapter&#125; and the </div><div class="line"> * &#123;<span class="doctag">@link</span> ExceptionHandlerExceptionResolver&#125; are configured with instances of </div><div class="line"> * the following by default: </div><div class="line"> * &lt;ul&gt; </div><div class="line"> *  &lt;li&gt;A &#123;<span class="doctag">@link</span> ContentNegotiationManager&#125; </div><div class="line"> *  &lt;li&gt;A &#123;<span class="doctag">@link</span> DefaultFormattingConversionService&#125; </div><div class="line"> *  &lt;li&gt;A &#123;<span class="doctag">@link</span> org.springframework.validation.beanvalidation.LocalValidatorFactoryBean&#125; </div><div class="line"> *  if a JSR-303 implementation is available on the classpath </div><div class="line"> *  &lt;li&gt;A range of &#123;<span class="doctag">@link</span> HttpMessageConverter&#125;s depending on what 3rd party </div><div class="line"> *  libraries are available on the classpath. </div><div class="line"> * &lt;/ul&gt; </div><div class="line"> * </div><div class="line"> * <span class="doctag">@author</span> Keith Donald </div><div class="line"> * <span class="doctag">@author</span> Juergen Hoeller </div><div class="line"> * <span class="doctag">@author</span> Arjen Poutsma </div><div class="line"> * <span class="doctag">@author</span> Rossen Stoyanchev </div><div class="line"> * <span class="doctag">@author</span> Brian Clozel </div><div class="line"> * <span class="doctag">@since</span> 3.0 </div><div class="line"> */  </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnnotationDrivenBeanDefinitionParser</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionParser</span> </span>&#123;  </div><div class="line">          <span class="comment">//先省略，请详细看下文</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>解析过程的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;  </div><div class="line">        Object source = parserContext.extractSource(element);  </div><div class="line">  </div><div class="line">        <span class="comment">//省略... </span></div><div class="line">       </div><div class="line">        RootBeanDefinition handlerMappingDef = <span class="keyword">new</span> RootBeanDefinition(RequestMappingHandlerMapping.class);  </div><div class="line">          </div><div class="line">        RootBeanDefinition handlerAdapterDef = <span class="keyword">new</span> RootBeanDefinition(RequestMappingHandlerAdapter.class);  </div><div class="line">          </div><div class="line">        <span class="comment">//省略...</span></div><div class="line">      </div><div class="line">        <span class="comment">// 注册了RequestMappingHandlerMapping</span></div><div class="line">        parserContext.registerComponent(<span class="keyword">new</span> BeanComponentDefinition(handlerMappingDef, methodMappingName));</div><div class="line">        <span class="comment">// 注册了RequestMappingHandlerAdapter</span></div><div class="line">		parserContext.registerComponent(<span class="keyword">new</span> BeanComponentDefinition(handlerAdapterDef, handlerAdapterName));</div><div class="line">      </div><div class="line">        <span class="comment">// Ensure BeanNameUrlHandlerMapping (SPR-8289) and default HandlerAdapters are not "turned off"  </span></div><div class="line">        MvcNamespaceUtils.registerDefaultComponents(parserContext, source);  </div><div class="line">  </div><div class="line">        parserContext.popAndRegisterContainingComponent();  </div><div class="line">  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;  </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>默认注册组件<code>MvcNamespaceUtils.registerDefaultComponents</code>的如下： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerDefaultComponents</span><span class="params">(ParserContext parserContext, Object source)</span> </span>&#123;  </div><div class="line">        registerBeanNameUrlHandlerMapping(parserContext, source);  </div><div class="line">        registerHttpRequestHandlerAdapter(parserContext, source);  </div><div class="line">        registerSimpleControllerHandlerAdapter(parserContext, source);  </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>至此所注册的<code>HandlerMapping</code>和<code>HandlerAdapter</code>都找到了。 </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;  </div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span> <span class="attr">xmlns:util</span>=<span class="string">"http://www.springframework.org/schema/util"</span> <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span>  </span></div><div class="line">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans  </span></div><div class="line">    http://www.springframework.org/schema/beans/spring-beans-3.1.xsd  </div><div class="line">    http://www.springframework.org/schema/mvc  </div><div class="line">    http://www.springframework.org/schema/mvc/spring-mvc-3.1.xsd  </div><div class="line">    http://www.springframework.org/schema/util  </div><div class="line">    http://www.springframework.org/schema/util/spring-util-2.0.xsd  </div><div class="line">    http://www.springframework.org/schema/context   </div><div class="line">    http://www.springframework.org/schema/context/spring-context-3.2.xsd"&gt;  </div><div class="line">          </div><div class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span>  </div><div class="line">  </div><div class="line">  <span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
<p>开启了<code>&lt;mvc:annotation-driven/&gt;</code>，同时注册了两个bean。有<code>RequestMappingHandlerMapping</code>和<code>RequestMappingHandlerAdapter</code>作为支持，这里简单说明下：<code>RequestMappingHandlerMapping</code>它会判断一个bean是否含有<code>@Controller</code>标签或者<code>@RequestMapping</code>，如果有其一则会将该bean纳入作为它的处理对象，之后会进一步处理该类上含有<code>@RequestMapping</code>注解的方法。这样做主要是由于<code>@RequestMapping</code>可以配置在类上（作为基础地址），也可以配置在方法上，我们有时候会在类上配置<code>@RequestMapping</code>，有时候又不会，<strong>所以只要类注解含有<code>@Controller</code>或者含有<code>@RequestMapping</code>，<code>RequestMappingHandlerMapping</code>都会将他们纳入自己的handler管辖范围</strong>。所以仅仅在方法中含有<code>@RequestMapping</code>注解是不被处理的，必须在类上加入<code>@RequestMapping</code>或者<code>@Controller</code>，所以<code>@Controller</code>又不是必须的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Controller</span>  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringAction</span> </span>&#123;  </div><div class="line">      </div><div class="line">    <span class="meta">@ResponseBody</span>  </div><div class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"/string"</span>,method=RequestMethod.GET)  </div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testMessageConverter</span><span class="params">(String name)</span> <span class="keyword">throws</span> UnsupportedEncodingException</span>&#123;  </div><div class="line">        System.out.println(name);  </div><div class="line">        <span class="keyword">return</span> name;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>@Controller</code>使得<code>StringAction</code>这个handler纳入<code>RequestMappingHandlerMapping</code>管理，<code>RequestMappingHandlerMapping</code>会将这个handler和handler中的每一个含有<code>@RequestMapping</code>的方法都会构建成一个<code>HandlerMethod</code>对象，该类的构造函数为<code>HandlerMethod(Object bean, Method method)</code>，经过这样的包装之后将构造的<code>HandlerMethod</code>对象作为新的handler，然后进行选择适配器，进行方法调用，当<code>RequestMappingHandlerAdapter</code>判断是否support一个类时，就是依据当前的handle是否是<code>HandlerMethod</code>类型。若是则由<code>RequestMappingHandlerAdapter</code>来调度执行该handler（handler为<code>HandlerMethod</code>类型）的中的method方法。以上就是整个大体的流程。</p>
<ol>
<li>第一步要弄清<code>RequestMappingHandlerMapping</code>在初始化时是如何寻找它所管辖的bean。</li>
</ol>
<p><code>RequestMappingHandlerMapping</code>的父类<code>AbstractHandlerMethodMapping</code>在初始化时，会调用这样的一个方法<code>initHandlerMethods</code>，在该方法中，遍历所有的bean然后判断他们是不是含有<code>@Controller</code>或者<code>@RequestMapping</code>注解： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">  <span class="comment">/**</span></div><div class="line"> * Detects handler methods at initialization.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</div><div class="line">	initHandlerMethods();</div><div class="line">&#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"> * Scan beans in the ApplicationContext, detect and register handler methods.</div><div class="line"> * <span class="doctag">@see</span> #isHandler(Class)</div><div class="line"> * <span class="doctag">@see</span> #getMappingForMethod(Method, Class)</div><div class="line"> * <span class="doctag">@see</span> #handlerMethodsInitialized(Map)</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initHandlerMethods</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line">		logger.debug(<span class="string">"Looking for request mappings in application context: "</span> + getApplicationContext());</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	String[] beanNames = (<span class="keyword">this</span>.detectHandlerMethodsInAncestorContexts ?</div><div class="line">			BeanFactoryUtils.beanNamesForTypeIncludingAncestors(getApplicationContext(), Object.class) :</div><div class="line">			getApplicationContext().getBeanNamesForType(Object.class));</div><div class="line"></div><div class="line">	<span class="keyword">for</span> (String beanName : beanNames) &#123;</div><div class="line">		<span class="keyword">if</span> (isHandler(getApplicationContext().getType(beanName)))&#123;</div><div class="line">			detectHandlerMethods(beanName);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	handlerMethodsInitialized(getHandlerMethods());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中的<code>isHandler</code>(由子类<code>RequestMappingHandlerMapping</code>实现)的判断方法代码如下： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHandler</span><span class="params">(Class&lt;?&gt; beanType)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> ((AnnotationUtils.findAnnotation(beanType, Controller.class) != <span class="keyword">null</span>) ||</div><div class="line">				(AnnotationUtils.findAnnotation(beanType, RequestMapping.class) != <span class="keyword">null</span>));</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>如果handler含有了上述注解的其中之一，就会进一步处理该handler的方法中含有<code>@RequestMapping</code>的方法： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">  <span class="comment">/**</span></div><div class="line">    * 找到Controller中有<span class="doctag">@RequestMapping</span>注解的方法</div><div class="line"> * Look for handler methods in a handler.</div><div class="line"> * <span class="doctag">@param</span> handler the bean name of a handler or a handler instance</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">detectHandlerMethods</span><span class="params">(<span class="keyword">final</span> Object handler)</span> </span>&#123;</div><div class="line">	Class&lt;?&gt; handlerType =</div><div class="line">			(handler <span class="keyword">instanceof</span> String ? getApplicationContext().getType((String) handler) : handler.getClass());</div><div class="line"></div><div class="line">	<span class="comment">// Avoid repeated calls to getMappingForMethod which would rebuild RequestMatchingInfo instances</span></div><div class="line">	<span class="keyword">final</span> Map&lt;Method, T&gt; mappings = <span class="keyword">new</span> IdentityHashMap&lt;Method, T&gt;();</div><div class="line">	<span class="keyword">final</span> Class&lt;?&gt; userType = ClassUtils.getUserClass(handlerType);</div><div class="line"></div><div class="line">	Set&lt;Method&gt; methods = HandlerMethodSelector.selectMethods(userType, <span class="keyword">new</span> MethodFilter() &#123;</div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method)</span> </span>&#123;</div><div class="line">			T mapping = getMappingForMethod(method, userType);</div><div class="line">			<span class="keyword">if</span> (mapping != <span class="keyword">null</span>) &#123;</div><div class="line">				mappings.put(method, mapping);</div><div class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">else</span> &#123;</div><div class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;);</div><div class="line"></div><div class="line">	<span class="keyword">for</span> (Method method : methods) &#123;</div><div class="line">		registerHandlerMethod(handler, method, mappings.get(method));</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>遍历这个handler类的所有方法，过滤条件就是这个内部类<code>MethodFilter</code>，其中的<code>getMappingForMethod</code>方法： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">  <span class="comment">/**</span></div><div class="line"> * Uses method and type-level @&#123;<span class="doctag">@link</span> RequestMapping&#125; annotations to create</div><div class="line"> * the RequestMappingInfo.</div><div class="line"> * <span class="doctag">@return</span> the created RequestMappingInfo, or &#123;<span class="doctag">@code</span> null&#125; if the method</div><div class="line"> * does not have a &#123;<span class="doctag">@code</span> <span class="doctag">@RequestMapping</span>&#125; annotation.</div><div class="line"> * <span class="doctag">@see</span> #getCustomMethodCondition(Method)</div><div class="line"> * <span class="doctag">@see</span> #getCustomTypeCondition(Class)</div><div class="line"> */</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> RequestMappingInfo <span class="title">getMappingForMethod</span><span class="params">(Method method, Class&lt;?&gt; handlerType)</span> </span>&#123;</div><div class="line">	RequestMappingInfo info = <span class="keyword">null</span>;</div><div class="line">	RequestMapping methodAnnotation = AnnotationUtils.findAnnotation(method, RequestMapping.class);</div><div class="line">	<span class="keyword">if</span> (methodAnnotation != <span class="keyword">null</span>) &#123;</div><div class="line">		RequestCondition&lt;?&gt; methodCondition = getCustomMethodCondition(method);</div><div class="line">		info = createRequestMappingInfo(methodAnnotation, methodCondition);</div><div class="line">		RequestMapping typeAnnotation = AnnotationUtils.findAnnotation(handlerType, RequestMapping.class);</div><div class="line">		<span class="keyword">if</span> (typeAnnotation != <span class="keyword">null</span>) &#123;</div><div class="line">			RequestCondition&lt;?&gt; typeCondition = getCustomTypeCondition(handlerType);</div><div class="line">			info = createRequestMappingInfo(typeAnnotation, typeCondition).combine(info);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> info;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如找到了含有<code>RequestMapping</code>注释的方法，则由这个注释的内容构建一个<code>RequestMappingInfo</code>对象： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">  <span class="comment">/**</span></div><div class="line"> * Created a RequestMappingInfo from a RequestMapping annotation.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">protected</span> RequestMappingInfo <span class="title">createRequestMappingInfo</span><span class="params">(RequestMapping annotation, RequestCondition&lt;?&gt; customCondition)</span> </span>&#123;</div><div class="line">	String[] patterns = resolveEmbeddedValuesInPatterns(annotation.value());</div><div class="line">	<span class="keyword">return</span> <span class="keyword">new</span> RequestMappingInfo(</div><div class="line">			<span class="keyword">new</span> PatternsRequestCondition(patterns, getUrlPathHelper(), getPathMatcher(),</div><div class="line">					<span class="keyword">this</span>.useSuffixPatternMatch, <span class="keyword">this</span>.useTrailingSlashMatch, <span class="keyword">this</span>.fileExtensions),</div><div class="line">			<span class="keyword">new</span> RequestMethodsRequestCondition(annotation.method()),</div><div class="line">			<span class="keyword">new</span> ParamsRequestCondition(annotation.params()),</div><div class="line">			<span class="keyword">new</span> HeadersRequestCondition(annotation.headers()),</div><div class="line">			<span class="keyword">new</span> ConsumesRequestCondition(annotation.consumes(), annotation.headers()),</div><div class="line">			<span class="keyword">new</span> ProducesRequestCondition(annotation.produces(), annotation.headers(), getContentNegotiationManager()),</div><div class="line">			customCondition);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>就是拿<code>RequestMapping</code>注释的内容进一步封装进<code>RequestMappingInfo</code>对象中。对handler的所有方法过滤完成之后，就要遍历这些方法，以一定的方式存储起来。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">	 * Register a handler method and its unique mapping.</div><div class="line">	 * <span class="doctag">@param</span> handler the bean name of the handler or the handler instance</div><div class="line">	 * <span class="doctag">@param</span> method the method to register</div><div class="line">	 * <span class="doctag">@param</span> mapping the mapping conditions associated with the handler method</div><div class="line">	 * <span class="doctag">@throws</span> IllegalStateException if another method was already registered</div><div class="line">	 * under the same mapping</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerHandlerMethod</span><span class="params">(Object handler, Method method, T mapping)</span> </span>&#123;</div><div class="line">		HandlerMethod newHandlerMethod = createHandlerMethod(handler, method);</div><div class="line">		HandlerMethod oldHandlerMethod = <span class="keyword">this</span>.handlerMethods.get(mapping);</div><div class="line">		<span class="keyword">if</span> (oldHandlerMethod != <span class="keyword">null</span> &amp;&amp; !oldHandlerMethod.equals(newHandlerMethod)) &#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Ambiguous mapping found. Cannot map '"</span> + newHandlerMethod.getBean() +</div><div class="line">					<span class="string">"' bean method \n"</span> + newHandlerMethod + <span class="string">"\nto "</span> + mapping + <span class="string">": There is already '"</span> +</div><div class="line">					oldHandlerMethod.getBean() + <span class="string">"' bean method\n"</span> + oldHandlerMethod + <span class="string">" mapped."</span>);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">this</span>.handlerMethods.put(mapping, newHandlerMethod);</div><div class="line">		<span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</div><div class="line">			logger.info(<span class="string">"Mapped \""</span> + mapping + <span class="string">"\" onto "</span> + newHandlerMethod);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		Set&lt;String&gt; patterns = getMappingPathPatterns(mapping);</div><div class="line">		<span class="keyword">for</span> (String pattern : patterns) &#123;</div><div class="line">			<span class="keyword">if</span> (!getPathMatcher().isPattern(pattern)) &#123;</div><div class="line">				<span class="keyword">this</span>.urlMap.add(pattern, mapping);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>这里的<code>this.handlerMethods</code>就包含了所有管辖的bean，<strong>key为<code>RequestMappingInfo</code>对象，value为handler和它中含有<code>@RequestMapping</code>注释的方法method构建的HandlerMethod</strong>。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** </span></div><div class="line">     * Create the HandlerMethod instance. </div><div class="line">     * <span class="doctag">@param</span> handler either a bean name or an actual handler instance </div><div class="line">     * <span class="doctag">@param</span> method the target method </div><div class="line">     * <span class="doctag">@return</span> the created HandlerMethod </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">protected</span> HandlerMethod <span class="title">createHandlerMethod</span><span class="params">(Object handler, Method method)</span> </span>&#123;  </div><div class="line">        HandlerMethod handlerMethod;  </div><div class="line">        <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> String) &#123;  </div><div class="line">            String beanName = (String) handler;  </div><div class="line">            handlerMethod = <span class="keyword">new</span> HandlerMethod(beanName, getApplicationContext(), method);  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">else</span> &#123;  </div><div class="line">            handlerMethod = <span class="keyword">new</span> HandlerMethod(handler, method);  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">return</span> handlerMethod;  </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>至此，<code>RequestMappingHandlerMapping</code>的初始化注册工作就完成了。</p>
<p>请求<a href="http://localhost:8080/string?name=a`,RequestMappingHandlerMapping`会匹配到由`StringAction`对象和它的包含注释的方法`testMessageConverter`构建的`HandlerMethod`对象，该对象将作为handler，然后再遍历`HandlerAdapter`判断它们是否支持这个handler，`RequestMappingHandlerAdapter`的判断依据为是否是`HandlerMethod`" target="_blank" rel="external">http://localhost:8080/string?name=a`,RequestMappingHandlerMapping`会匹配到由`StringAction`对象和它的包含注释的方法`testMessageConverter`构建的`HandlerMethod`对象，该对象将作为handler，然后再遍历`HandlerAdapter`判断它们是否支持这个handler，`RequestMappingHandlerAdapter`的判断依据为是否是`HandlerMethod`</a> 类型（在<code>AbstractHandlerMethodAdapter</code>类中）： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">   <span class="comment">/**</span></div><div class="line">	 * This implementation expects the handler to be an &#123;<span class="doctag">@link</span> HandlerMethod&#125;.</div><div class="line">	 * <span class="doctag">@param</span> handler the handler instance to check</div><div class="line">	 * <span class="doctag">@return</span> whether or not this adapter can adapt the given handler</div><div class="line">	 */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> handler <span class="keyword">instanceof</span> HandlerMethod &amp;&amp; supportsInternal((HandlerMethod) handler);  </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>然后将得到匹配，有了这个<code>HandlerMethod</code>对象，便可以通过<code>RequestMappingHandlerAdapter</code>来调度执行<code>HandlerMethod</code>其中的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">  ......省略</div><div class="line">  	<span class="comment">// Determine handler for the current request.</span></div><div class="line">    mappedHandler = getHandler(processedRequest, <span class="keyword">false</span>);</div><div class="line">				<span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span> || mappedHandler.getHandler() == <span class="keyword">null</span>) &#123;</div><div class="line">					noHandlerFound(processedRequest, response);</div><div class="line">					<span class="keyword">return</span>;</div><div class="line">				&#125;</div><div class="line"></div><div class="line">   <span class="comment">// Determine handler adapter for the current request.</span></div><div class="line">   HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</div><div class="line">  ......省略</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>mappedHandler</code>包含handle(这里是<code>HandlerMethod</code>)和一些<code>HandlerInterceptor</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">  <span class="comment">/**</span></div><div class="line"> * Return the HandlerAdapter for this handler object.</div><div class="line"> * <span class="doctag">@param</span> handler the handler object to find an adapter for</div><div class="line"> * <span class="doctag">@throws</span> ServletException if no HandlerAdapter can be found for the handler. This is a fatal error.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">protected</span> HandlerAdapter <span class="title">getHandlerAdapter</span><span class="params">(Object handler)</span> <span class="keyword">throws</span> ServletException </span>&#123;</div><div class="line">	<span class="keyword">for</span> (HandlerAdapter ha : <span class="keyword">this</span>.handlerAdapters) &#123;</div><div class="line">		<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</div><div class="line">			logger.trace(<span class="string">"Testing handler adapter ["</span> + ha + <span class="string">"]"</span>);</div><div class="line">		&#125;</div><div class="line">           <span class="comment">// 重点。。。。。</span></div><div class="line">		<span class="keyword">if</span> (ha.supports(handler)) &#123;</div><div class="line">			<span class="keyword">return</span> ha;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> ServletException(<span class="string">"No adapter for handler ["</span> + handler +</div><div class="line">			<span class="string">"]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[rabbitmq exchange模式]]></title>
      <url>http://zsr.github.io/2016/08/12/rabbitmq-exchange%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h1 id="rabbitmq-exchange"><a href="#rabbitmq-exchange" class="headerlink" title="rabbitmq exchange"></a>rabbitmq exchange</h1><p><strong>主要介绍rabbitmq常用的三种exchange模式：direct, fanout, topic.</strong></p>
<h3 id="Virtual-Host"><a href="#Virtual-Host" class="headerlink" title="Virtual Host"></a>Virtual Host</h3><p>为了在一个单独的代理上实现多个隔离的环境（用户、用户组、交换机、队列 等），AMQP提供了一个虚拟主机（virtual hosts - vhosts）的概念,<strong>默认的virtual host为 “/“.</strong></p>
<h3 id="Default-exchange-默认交换机"><a href="#Default-exchange-默认交换机" class="headerlink" title="Default exchange (默认交换机)"></a>Default exchange (默认交换机)</h3><p>默认交换机（default exchange）实际上是一个由消息代理预先声明好的没有名字（名字为空字符串）的直连交换机（direct exchange）。它有一个特殊的属性使得它对于简单应用特别有用处：那就是每个新建队列（queue）都会自动绑定到默认交换机上，<strong>绑定的路由键（routing key）名称与队列名称相同。</strong></p>
<h3 id="Direct-Exchange"><a href="#Direct-Exchange" class="headerlink" title="Direct Exchange"></a>Direct Exchange</h3><p><img src="/images/rabbitmq-exchange-1.png"></p>
<p><strong>任何发送到Direct Exchange的消息都会被转发到RouteKey中指定的Queue。</strong></p>
<ul>
<li><p>一般情况可以使用rabbitMQ自带的Exchange：””(该Exchange的名字为空字符串，下文称其为default Exchange)。</p>
</li>
<li><p>这种模式下不需要将Exchange进行任何绑定(binding)操作</p>
</li>
<li><p>消息传递时需要一个“RouteKey”，可以简单的理解为要发送到的队列名字。</p>
</li>
<li><p>如果vhost中不存在RouteKey中指定的队列名，则该消息会被抛弃。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Channel channel = connection.createChannel();  </div><div class="line">channel.exchangeDeclare(&quot;exchangeName&quot;, &quot;direct&quot;); //direct fanout topic  </div><div class="line">channel.queueDeclare(&quot;queueName&quot;);  </div><div class="line">channel.queueBind(&quot;queueName&quot;, &quot;exchangeName&quot;, &quot;routingKey&quot;);  </div><div class="line">  </div><div class="line">byte[] messageBodyBytes = &quot;hello world&quot;.getBytes();  </div><div class="line">//需要绑定路由键  </div><div class="line">channel.basicPublish(&quot;exchangeName&quot;, &quot;routingKey&quot;, MessageProperties.PERSISTENT_TEXT_PLAIN, messageBodyBytes);</div></pre></td></tr></table></figure>
<h3 id="Fanout-Exchange"><a href="#Fanout-Exchange" class="headerlink" title="Fanout Exchange"></a>Fanout Exchange</h3><p><img src="/images/rabbitmq-exchange-2.png"></p>
<p><strong>任何发送到Fanout Exchange的消息都会被转发到与该Exchange绑定(Binding)的所有Queue上。</strong></p>
<ul>
<li><p>可以理解为路由表的模式</p>
</li>
<li><p>这种模式不需要RouteKey</p>
</li>
<li><p>这种模式需要提前将Exchange与Queue进行绑定，一个Exchange可以绑定多个Queue，一个Queue可以同多个Exchange进行绑定。</p>
</li>
<li><p>如果接受到消息的Exchange没有与任何Queue绑定，则消息会被抛弃。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Channel channel = connection.createChannel();  </div><div class="line">channel.exchangeDeclare(&quot;exchangeName&quot;, &quot;fanout&quot;); //direct fanout topic  </div><div class="line">channel.queueDeclare(&quot;queueName&quot;);  </div><div class="line">channel.queueBind(&quot;queueName&quot;, &quot;exchangeName&quot;, &quot;routingKey&quot;);  </div><div class="line">  </div><div class="line">channel.queueDeclare(&quot;queueName1&quot;);  </div><div class="line">channel.queueBind(&quot;queueName1&quot;, &quot;exchangeName&quot;, &quot;routingKey1&quot;);  </div><div class="line">  </div><div class="line">byte[] messageBodyBytes = &quot;hello world&quot;.getBytes();  </div><div class="line">//路由键需要设置为空  </div><div class="line">channel.basicPublish(&quot;exchangeName&quot;, &quot;&quot;, MessageProperties.PERSISTENT_TEXT_PLAIN, messageBodyBytes);</div></pre></td></tr></table></figure>
<h3 id="Topic-Exchange"><a href="#Topic-Exchange" class="headerlink" title="Topic Exchange"></a>Topic Exchange</h3><p><img src="/images/rabbitmq-exchange-3.png"></p>
<p><strong>任何发送到Topic Exchange的消息都会被转发到所有关心RouteKey中指定话题的Queue上.</strong></p>
<ul>
<li><p>这种模式较为复杂，简单来说，就是每个队列都有其关心的主题，所有的消息都带有一个“标题”(RouteKey)，Exchange会将消息转发到所有关注主题能与RouteKey模糊匹配的队列。</p>
</li>
<li><p>这种模式需要RouteKey，也许要提前绑定Exchange与Queue。</p>
</li>
<li><p>在进行绑定时，要提供一个该队列关心的主题，如“#.log.#”表示该队列关心所有涉及log的消息(一个RouteKey为”MQ.log.error”的消息会被转发到该队列)。</p>
</li>
<li><p>“#”表示0个或若干个关键字，“<em>”表示一个关键字。如“log.</em>”能与“log.warn”匹配，无法与“log.warn.timeout”匹配；但是“log.#”能与上述两者匹配。</p>
</li>
<li><p>同样，如果Exchange没有发现能够与RouteKey匹配的Queue，则会抛弃此消息。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Channel channel = connection.createChannel();  </div><div class="line">channel.exchangeDeclare(&quot;exchangeName&quot;, &quot;topic&quot;); //direct fanout topic  </div><div class="line">channel.queueDeclare(&quot;queueName&quot;);  </div><div class="line">channel.queueBind(&quot;queueName&quot;, &quot;exchangeName&quot;, &quot;routingKey.*&quot;);  </div><div class="line">  </div><div class="line">byte[] messageBodyBytes = &quot;hello world&quot;.getBytes();  </div><div class="line">channel.basicPublish(&quot;exchangeName&quot;, &quot;routingKey.one&quot;, MessageProperties.PERSISTENT_TEXT_PLAIN, messageBodyBytes);</div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[SpringMVC 参数校验]]></title>
      <url>http://zsr.github.io/2016/08/11/SpringMVC-%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/</url>
      <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>需要对Post请求的表单数据进行简单校验。</p>
<h3 id="Maven-配置"><a href="#Maven-配置" class="headerlink" title="Maven 配置"></a>Maven 配置</h3><ul>
<li>Bean Validation API 1.1: </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;javax.validation&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;validation-api&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;1.1.0.Final&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure>
<ul>
<li>Hibernate Validator 5.0.1.Final: </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.hibernate&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;5.0.1.Final&lt;/version&gt;</div><div class="line"> &lt;/dependency&gt;</div></pre></td></tr></table></figure>
<h3 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h3><h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><p>在application-context.xml文件中加入下面一行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;mvc:annotation-driven /&gt;</div></pre></td></tr></table></figure>
<h5 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h5><ol>
<li>在需要校验的model对象前面加上@Valid注解(javax.validation.Valid):</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@RequestMapping(</div><div class="line">      value = &quot;/v1/live/send/gift&quot;, method = RequestMethod.POST)</div><div class="line">  @Response</div><div class="line">public WebResult requestSendGift(HttpServletRequest request, @Valid @ModelAttribute SendGiftForm sendGiftForm, BindingResult bindingResult) &#123;</div><div class="line"></div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<ol>
<li>在controller方法里面加上参数判断：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (bindingResult.hasErrors()) &#123;</div><div class="line">        throw new IllegalArgumentException(&quot;request params must be not null.&quot;);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h5 id="Validator-Model"><a href="#Validator-Model" class="headerlink" title="Validator Model"></a>Validator Model</h5><p>在需要校验的model字段前面加上注解(hibernate validator):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class SendGiftForm &#123;</div><div class="line">  @NotNull</div><div class="line">  private Long roomId; </div><div class="line">  @NotNull</div><div class="line">  private Long liveId; </div><div class="line">  </div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p><a href="http://www.codejava.net/frameworks/spring/spring-mvc-form-validation-example-with-bean-validation-api" target="_blank" rel="external">Spring Form Validation</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[rabbitmq延时队列]]></title>
      <url>http://zsr.github.io/2016/08/10/rabbitmq%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>rabbitmq 是目前使用最为普及的消息队列组件，基于 AMQP 的 rabbitmq 在各方面设计都比较完善，同时，它具有非常丰富的功能与特性，可以支持各种实际的适用场景。</p>
<p>但是<strong>rabbitmq并不直接支持延时队列</strong>的功能，本文我们就来介绍一下，如何使用 rabbitmq 实现一个延时队列。</p>
<h1 id="延时队列的简易实现"><a href="#延时队列的简易实现" class="headerlink" title="延时队列的简易实现"></a>延时队列的简易实现</h1><p>使用redis集群来实现了这个功能，redis中存储了下单时间，以分钟为粒度扫描相应的key，即可扫出所有下单时间超过指定时间间隔的数据.</p>
<h1 id="rabbitmq-与消息过期时间-–-TTL"><a href="#rabbitmq-与消息过期时间-–-TTL" class="headerlink" title="rabbitmq 与消息过期时间 – TTL"></a>rabbitmq 与消息过期时间 – TTL</h1><h3 id="为队列设置消息过期时间"><a href="#为队列设置消息过期时间" class="headerlink" title="为队列设置消息过期时间"></a>为队列设置消息过期时间</h3><p>rabbitmq 支持在创建队列时对队列设置消息过期时间：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Map&lt;String, Object&gt; args = new HashMap&lt;String, Object&gt;();</div><div class="line">args.put(&quot;x-message-ttl&quot;, 60000);</div><div class="line">channel.queueDeclare(&quot;myqueue&quot;, false, false, false, args);</div></pre></td></tr></table></figure>
<h1 id="失效消息转发队列-–-DLX"><a href="#失效消息转发队列-–-DLX" class="headerlink" title="失效消息转发队列 – DLX"></a>失效消息转发队列 – DLX</h1><p>一旦上述消息过期时间设置生效，某条消息达到消息过期时间，那么他将会成为一条“dead-lettered”，此外，被拒绝的消息如果requeue属性为 false，或者消息所在队列已达到最大长度，那么他也将成为“dead-lettered”.</p>
<p>如果设置了DLX规则，即失效消息转发规则，那么失效的消息就会被转发到相应的exchange和queue.</p>
<h3 id="通过代码设置失效消息转发队列"><a href="#通过代码设置失效消息转发队列" class="headerlink" title="通过代码设置失效消息转发队列"></a>通过代码设置失效消息转发队列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">channel.exchangeDeclare(&quot;some.exchange.name&quot;, &quot;direct&quot;);</div><div class="line"></div><div class="line">Map&lt;String, Object&gt; args = new HashMap&lt;String, Object&gt;();</div><div class="line">args.put(&quot;x-dead-letter-exchange&quot;, &quot;some.exchange.name&quot;);</div><div class="line">channel.queueDeclare(&quot;myqueue&quot;, false, false, false, args);</div></pre></td></tr></table></figure>
<p>这样，一旦消息失效，则消息会被自动转发到你设置的x-dead-letter-exchange上的同名队列.</p>
<p>也可以通过下面的代码指定具体转发的目标 routing-key：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">args.put(&quot;x-dead-letter-routing-key&quot;, &quot;some-routing-key&quot;);</div></pre></td></tr></table></figure>
<h3 id="spring-rabbit-配置"><a href="#spring-rabbit-配置" class="headerlink" title="spring-rabbit 配置"></a>spring-rabbit 配置</h3><p>可以使用spring-rabbit配置替代代码方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;rabbit:queue name=&quot;q.with.dlx&quot;&gt;</div><div class="line">    &lt;rabbit:queue-arguments&gt; </div><div class="line">        &lt;entry key=&quot;x-dead-letter-exchange&quot; value=&quot;dlx&quot;/&gt;</div><div class="line">        &lt;entry key=&quot;x-message-ttl&quot; value=&quot;10000&quot; value-type=&quot;java.lang.Long&quot;/&gt;</div><div class="line">    &lt;/rabbit:queue-arguments&gt;</div><div class="line">&lt;/rabbit:queue&gt;</div><div class="line"></div><div class="line">&lt;rabbit:queue name=&quot;dlq&quot;/&gt;</div><div class="line"></div><div class="line">&lt;rabbit:direct-exchange name=&quot;dlx&quot;&gt;</div><div class="line">    &lt;rabbit:bindings&gt;</div><div class="line">        &lt;rabbit:binding key=&quot;q.with.dlx&quot; queue=&quot;dlq&quot;/&gt;</div><div class="line">    &lt;/rabbit:bindings&gt;</div><div class="line">&lt;/rabbit:direct-exchange&gt;</div></pre></td></tr></table></figure>
<p>This assumes you routed the original message using the default direct exchange (routing by queue name). Hence the dead letter routing uses the same routing key (queue name). If you route using an explicit routing key, you would use that.</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="http://www.rabbitmq.com/ttl.html" target="_blank" rel="external">RabbitMQ TTL</a></p>
<p><a href="http://www.rabbitmq.com/dlx.html" target="_blank" rel="external">RabbitMQ DLX</a></p>
<p><a href="http://docs.spring.io/spring-amqp/docs/1.3.9.RELEASE/reference/html/amqp.html" target="_blank" rel="external">Spring AMQP</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[深入理解Java内存模型]]></title>
      <url>http://zsr.github.io/2016/08/08/java%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
      <content type="html"><![CDATA[<h1 id="深入理解Java内存模型（一）"><a href="#深入理解Java内存模型（一）" class="headerlink" title="深入理解Java内存模型（一）"></a>深入理解Java内存模型（一）</h1><p>原文发表于InfoQ：<a href="http://www.infoq.com/cn/articles/java-memory-model-1" target="_blank" rel="external">http://www.infoq.com/cn/articles/java-memory-model-1</a></p>
<h3 id="并发编程模型的分类"><a href="#并发编程模型的分类" class="headerlink" title="并发编程模型的分类"></a>并发编程模型的分类</h3><p>在并发编程中，我们需要处理两个关键问题：线程之间如何通信及线程之间如何同步（这里的线程是指并发执行的活动实体）。通信是指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种：共享内存和消息传递。<br>在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信。在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信。<br>同步是指程序用于控制不同线程之间操作发生相对顺序的机制。在共享内存并发模型里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。<br><strong>Java的并发采用的是共享内存模型</strong>，Java线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。如果编写多线程程序的Java程序员不理解隐式进行的线程之间通信的工作机制，很可能会遇到各种奇怪的内存可见性问题。</p>
<h3 id="Java内存模型的抽象"><a href="#Java内存模型的抽象" class="headerlink" title="Java内存模型的抽象"></a>Java内存模型的抽象</h3><p>在java中，所有实例域、静态域和数组元素存储在堆内存中，堆内存在线程之间共享（本文使用“共享变量”这个术语代指实例域，静态域和数组元素）。局部变量（Local variables），方法定义参数（java语言规范称之为formal method parameters）和异常处理器参数（exception handler parameters）不会在线程之间共享，它们不会有内存可见性问题，也不受内存模型的影响。<br>Java线程之间的通信由Java内存模型（本文简称为JMM）控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：<strong>线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。</strong>本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。Java内存模型的抽象示意图如下：</p>
<p><img src="/images/java虚拟机1-1.png"></p>
<p>从上图来看，线程A与线程B之间如要通信的话，必须要经历下面2个步骤：</p>
<ol>
<li>首先，线程A把本地内存A中更新过的共享变量刷新到主内存中去。</li>
<li>然后，线程B到主内存中去读取线程A之前已更新过的共享变量。</li>
</ol>
<p>下面通过示意图来说明这两个步骤：</p>
<p><img src="/images/java虚拟机1-2.png"></p>
<p>如上图所示，本地内存A和B有主内存中共享变量x的副本。假设初始时，这三个内存中的x值都为0。线程A在执行时，把更新后的x值（假设值为1）临时存放在自己的本地内存A中。当线程A和线程B需要通信时，线程A首先会把自己本地内存中修改后的x值刷新到主内存中，此时主内存中的x值变为了1。随后，线程B到主内存中去读取线程A更新后的x值，此时线程B的本地内存的x值也变为了1。<br>从整体来看，这两个步骤实质上是线程A在向线程B发送消息，而且这个通信过程必须要经过主内存。JMM通过控制主内存与每个线程的本地内存之间的交互，来为java程序员提供内存可见性保证。</p>
<a id="more"></a> 
<h3 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h3><p>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型：</p>
<ol>
<li>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li>
<li>指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li>
<li>内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。<br>从java源代码到最终实际执行的指令序列，会分别经历下面三种重排序：</li>
</ol>
<p><img src="/images/java虚拟机1-3.png"></p>
<p>上述的1属于编译器重排序，2和3属于处理器重排序。这些重排序都可能会导致多线程程序出现内存可见性问题。对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM的处理器重排序规则会要求java编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers，intel称之为memory fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）。<br>JMM属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。</p>
<h3 id="处理器重排序与内存屏障指令"><a href="#处理器重排序与内存屏障指令" class="headerlink" title="处理器重排序与内存屏障指令"></a>处理器重排序与内存屏障指令</h3><p>现代的处理器使用写缓冲区来临时保存向内存写入的数据。写缓冲区可以保证指令流水线持续运行，它可以避免由于处理器停顿下来等待向内存写入数据而产生的延迟。同时，通过以批处理的方式刷新写缓冲区，以及合并写缓冲区中对同一内存地址的多次写，可以减少对内存总线的占用。虽然写缓冲区有这么多好处，但每个处理器上的写缓冲区，仅仅对它所在的处理器可见。这个特性会对内存操作的执行顺序产生重要的影响：处理器对内存的读/写操作的执行顺序，不一定与内存实际发生的读/写操作顺序一致！为了具体说明，请看下面示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Processor A</div><div class="line"></div><div class="line">a = 1; //A1</div><div class="line">x = b; //A2</div><div class="line"></div><div class="line">Processor B</div><div class="line"></div><div class="line">b = 2; //B1</div><div class="line">y = a; //B2</div><div class="line"></div><div class="line">初始状态：a = b = 0</div><div class="line">处理器允许执行后得到结果：x = y = 0</div></pre></td></tr></table></figure>
<p>假设处理器A和处理器B按程序的顺序并行执行内存访问，最终却可能得到x = y = 0的结果。具体的原因如下图所示：</p>
<p><img src="/images/Java虚拟机1-4.png"></p>
<p>这里处理器A和处理器B可以同时把共享变量写入自己的写缓冲区（A1，B1），然后从内存中读取另一个共享变量（A2，B2），最后才把自己写缓存区中保存的脏数据刷新到内存中（A3，B3）。当以这种时序执行时，程序就可以得到x = y = 0的结果。<br>从内存操作实际发生的顺序来看，直到处理器A执行A3来刷新自己的写缓存区，写操作A1才算真正执行了。虽然处理器A执行内存操作的顺序为：A1-&gt;A2，但内存操作实际发生的顺序却是：A2-&gt;A1。此时，处理器A的内存操作顺序被重排序了（处理器B的情况和处理器A一样，这里就不赘述了）。<br>这里的关键是，由于写缓冲区仅对自己的处理器可见，它会导致处理器执行内存操作的顺序可能会与内存实际的操作执行顺序不一致。由于现代的处理器都会使用写缓冲区，因此现代的处理器都会允许对写-读操作重排序。</p>
<p><strong>为了保证内存可见性，java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。</strong>JMM把内存屏障指令分为下列四类：</p>
<table>
<thead>
<tr>
<th style="text-align:center">屏障类型</th>
<th style="text-align:center">指令示例</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">LoadLoad Barriers</td>
<td style="text-align:center">Load1; LoadLoad; Load2</td>
<td style="text-align:center">确保Load1数据的装载，之前于Load2及所有后续装载指令的装载。</td>
</tr>
<tr>
<td style="text-align:center">StoreStore Barriers</td>
<td style="text-align:center">Store1; StoreStore; Store2</td>
<td style="text-align:center">确保Store1数据对其他处理器可见（刷新到内存），之前于Store2及所有后续存储指令的存储。</td>
</tr>
<tr>
<td style="text-align:center">LoadStore Barriers</td>
<td style="text-align:center">Load1; LoadStore; Store2</td>
<td style="text-align:center">确保Load1数据装载，之前于Store2及所有后续的存储指令刷新到内存。</td>
</tr>
<tr>
<td style="text-align:center">StoreLoad Barriers</td>
<td style="text-align:center">Store1; StoreLoad; Load2</td>
<td style="text-align:center">确保Store1数据对其他处理器变得可见（指刷新到内存），之前于Load2及所有后续装载指令的装载。StoreLoad Barriers会使该屏障之前的所有内存访问指令（存储和装载指令）完成之后，才执行该屏障之后的内存访问指令。</td>
</tr>
</tbody>
</table>
<p>StoreLoad Barriers是一个“全能型”的屏障，它同时具有其他三个屏障的效果。现代的多处理器大都支持该屏障（其他类型的屏障不一定被所有处理器支持）。执行该屏障开销会很昂贵，因为当前处理器通常要把写缓冲区中的数据全部刷新到内存中（buffer fully flush）。</p>
<h3 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h3><p>从JDK5开始，java使用新的JSR -133内存模型（本文除非特别说明，针对的都是JSR- 133内存模型）。JSR-133使用happens-before的概念来阐述操作之间的内存可见性。<strong>在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系。</strong>这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。<br>与程序员密切相关的happens-before规则如下：</p>
<ul>
<li><p>程序顺序规则：一个线程中的每个操作，happens- before 于该线程中的任意后续操作。</p>
</li>
<li><p>监视器锁规则：对一个监视器锁的解锁，happens- before 于随后对这个监视器锁的加锁。</p>
</li>
<li><p>volatile变量规则：对一个volatile域的写，happens- before 于任意后续对这个volatile域的读。</p>
</li>
<li><p>传递性：如果A happens- before B，且B happens- before C，那么A happens- before C。</p>
</li>
</ul>
<p><strong>注意，两个操作之间具有happens-before关系，并不意味着前一个操作必须要在后一个操作之前执行！happens-before仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前（the first is visible to and ordered before the second）。</strong></p>
<p>happens-before与JMM的关系如下图所示：</p>
<p><img src="/images/Java虚拟机1-5.png"></p>
<p>如上图所示，一个happens-before规则通常对应于多个编译器和处理器重排序规则。对于java程序员来说，happens-before规则简单易懂，它避免java程序员为了理解JMM提供的内存可见性保证而去学习复杂的重排序规则以及这些规则的具体实现。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ClassLoader]]></title>
      <url>http://zsr.github.io/2016/08/05/ClassLoader/</url>
      <content type="html"><![CDATA[<h1 id="Java-类加载器"><a href="#Java-类加载器" class="headerlink" title="Java 类加载器"></a>Java 类加载器</h1><hr>
<h3 id="类加载器基本概念"><a href="#类加载器基本概念" class="headerlink" title="类加载器基本概念"></a>类加载器基本概念</h3><p><strong>类加载器（class loader）用来加载 Java 类到 Java 虚拟机中。一般来说，Java 虚拟机使用 Java 类的方式如下：Java 源程序（.java 文件）在经过 Java 编译器编译之后就被转换成 Java 字节代码（.class 文件）。类加载器负责读取 Java 字节代码，并转换成 java.lang.Class类的一个实例。每个这样的实例用来表示一个 Java 类。通过此实例的 newInstance()方法就可以创建出该类的一个对象。实际的情况可能更加复杂，比如 Java 字节代码可能是通过工具动态生成的，也可能是通过网络下载的。</strong></p>
<h3 id="java-lang-ClassLoader类介绍"><a href="#java-lang-ClassLoader类介绍" class="headerlink" title="java.lang.ClassLoader类介绍"></a>java.lang.ClassLoader类介绍</h3><p>java.lang.ClassLoader类的基本职责就是根据一个指定的类的名称，找到或者生成其对应的字节代码，然后从这些字节代码中定义出一个 Java 类，即 java.lang.Class类的一个实例。除此之外，ClassLoader还负责加载 Java 应用所需的资源，如图像文件和配置文件等。为了完成加载类的这个职责，ClassLoader提供了一系列的方法，比较重要的方法如表 1所示。</p>
<h5 id="表-1-ClassLoader-中与加载类相关的方法"><a href="#表-1-ClassLoader-中与加载类相关的方法" class="headerlink" title="表 1. ClassLoader 中与加载类相关的方法"></a>表 1. ClassLoader 中与加载类相关的方法</h5><table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">getParent()</td>
<td style="text-align:center">返回该类加载器的父类加载器</td>
</tr>
<tr>
<td style="text-align:center">loadClass(String name)</td>
<td style="text-align:center">加载名称为 name的类，返回的结果是 java.lang.Class类的实例</td>
</tr>
<tr>
<td style="text-align:center">findClass(String name)</td>
<td style="text-align:center">查找名称为 name的类，返回的结果是 java.lang.Class类的实例</td>
</tr>
<tr>
<td style="text-align:center">findLoadedClass(String name)</td>
<td style="text-align:center">查找名称为 name的已经被加载过的类，返回的结果是java.lang.Class类的实例。</td>
</tr>
<tr>
<td style="text-align:center">defineClass(String name, byte[] b, int off, int len)</td>
<td style="text-align:center">把字节数组 b中的内容转换成 Java 类，返回的结果是 java.lang.Class类的实例。这个方法被声明为 final的</td>
</tr>
<tr>
<td style="text-align:center">resolveClass(Class&lt;?&gt; c)</td>
<td style="text-align:center">链接指定的 Java 类</td>
</tr>
</tbody>
</table>
<p>类加载器的树状组织结构<br>Java 中的类加载器大致可以分成两类，一类是系统提供的，另外一类则是由 Java 应用开发人员编写的。系统提供的类加载器主要有下面三个：</p>
<ul>
<li><p>引导类加载器（bootstrap class loader）：它用来加载 Java 的核心库，是用原生代码来实现的，并不继承自 java.lang.ClassLoader。</p>
</li>
<li><p>扩展类加载器（extensions class loader）：它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。</p>
</li>
<li><p>系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。</p>
</li>
</ul>
<p>除了系统提供的类加载器以外，开发人员可以通过继承 java.lang.ClassLoader类的方式实现自己的类加载器，以满足一些特殊的需求(如tomcat)。<br>除了引导类加载器之外，所有的类加载器都有一个父类加载器。通过 表 1中给出的 getParent()方法可以得到。对于系统提供的类加载器来说，系统类加载器的父类加载器是扩展类加载器，而扩展类加载器的父类加载器是引导类加载器；对于开发人员编写的类加载器来说，其父类加载器是加载此类加载器 Java 类的类加载器。因为类加载器 Java 类如同其它的 Java 类一样，也是要由类加载器来加载的。一般来说，开发人员编写的类加载器的父类加载器是系统类加载器。类加载器通过这种方式组织起来，形成树状结构。树的根节点就是引导类加载器。图 1中给出了一个典型的类加载器树状组织结构示意图，其中的箭头指向的是父类加载器。</p>
<a id="more"></a>
<h5 id="图-1-类加载器树状组织结构示意图"><a href="#图-1-类加载器树状组织结构示意图" class="headerlink" title="图 1. 类加载器树状组织结构示意图"></a>图 1. 类加载器树状组织结构示意图</h5><p><img src="/images/ClassLoader_1.jpg"></p>
<p>测试代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class ClassLoaderTree &#123; </div><div class="line"></div><div class="line">    public static void main(String[] args) &#123; </div><div class="line">        ClassLoader loader = ClassLoaderTree.class.getClassLoader(); </div><div class="line">        while (loader != null) &#123; </div><div class="line">            System.out.println(loader.toString()); </div><div class="line">            loader = loader.getParent(); </div><div class="line">        &#125; </div><div class="line">    &#125; </div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>每个 Java 类都维护着一个指向定义它的类加载器的引用，通过 getClassLoader()方法就可以获取到此引用。</p>
<p><strong>运行结果：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sun.misc.Launcher$AppClassLoader@9304b1</div><div class="line"></div><div class="line">sun.misc.Launcher$ExtClassLoader@190d11</div></pre></td></tr></table></figure>
<p>第一个输出的是 ClassLoaderTree类的类加载器，即系统类加载器。它是 sun.misc.Launcher$AppClassLoader类的实例；第二个输出的是扩展类加载器，是 sun.misc.Launcher$ExtClassLoader类的实例。需要注意的是这里并没有输出引导类加载器，这是由于有些 JDK 的实现对于父类加载器是引导类加载器的情况，getParent()方法返回 null。</p>
<h3 id="类加载器的代理模式"><a href="#类加载器的代理模式" class="headerlink" title="类加载器的代理模式"></a>类加载器的代理模式</h3><p><strong>类加载器在尝试自己去查找某个类的字节代码并定义它时，会先代理给其父类加载器，由父类加载器先去尝试加载这个类，依次类推。在介绍代理模式背后的动机之前，首先需要说明一下 Java 虚拟机是如何判定两个 Java 类是相同的。Java 虚拟机不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。只有两者都相同的情况，才认为两个类是相同的。即便是同样的字节代码，被不同的类加载器加载之后所得到的类，也是不同的。比如一个 Java 类 com.example.Sample，编译之后生成了字节代码文件 Sample.class。两个不同的类加载器 ClassLoaderA和 ClassLoaderB分别读取了这个 Sample.class文件，并定义出两个 java.lang.Class类的实例来表示这个类。这两个实例是不相同的。对于 Java 虚拟机来说，它们是不同的类。试图对这两个类的对象进行相互赋值，会抛出运行时异常 ClassCastException。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">package com.example; </div><div class="line"></div><div class="line"> public class Sample &#123; </div><div class="line">    private Sample instance; </div><div class="line"></div><div class="line">    public void setSample(Object instance) &#123; </div><div class="line">        this.instance = (Sample) instance; </div><div class="line">    &#125; </div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>com.example.Sample类的方法 setSample接受一个 java.lang.Object类型的参数，并且会把该参数强制转换成 com.example.Sample类型。</p>
<p><strong>测试java类：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public void testClassIdentity() &#123; </div><div class="line">    String classDataRootPath = &quot;C:\\workspace\\Classloader\\classData&quot;; </div><div class="line">    FileSystemClassLoader fscl1 = new FileSystemClassLoader(classDataRootPath); </div><div class="line">    FileSystemClassLoader fscl2 = new FileSystemClassLoader(classDataRootPath); </div><div class="line">    String className = &quot;com.example.Sample&quot;; 	</div><div class="line">    try &#123; </div><div class="line">        Class&lt;?&gt; class1 = fscl1.loadClass(className); </div><div class="line">        Object obj1 = class1.newInstance(); </div><div class="line">        Class&lt;?&gt; class2 = fscl2.loadClass(className); </div><div class="line">        Object obj2 = class2.newInstance(); </div><div class="line">        Method setSampleMethod = class1.getMethod(&quot;setSample&quot;, java.lang.Object.class); </div><div class="line">        setSampleMethod.invoke(obj1, obj2); </div><div class="line">    &#125; catch (Exception e) &#123; </div><div class="line">        e.printStackTrace(); </div><div class="line">    &#125; </div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>用了类 FileSystemClassLoader的两个不同实例来分别加载类 com.example.Sample，得到了两个不同的 java.lang.Class的实例，接着通过 newInstance()方法分别生成了两个类的对象obj1和obj2，最后通过 Java的反射API在对象obj1上调用方法setSample，试图把对象obj2赋值给obj1内部的instance对象。</p>
<p><strong>运行结果：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">java.lang.reflect.InvocationTargetException </div><div class="line">at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) </div><div class="line">at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) </div><div class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)</div><div class="line">at java.lang.reflect.Method.invoke(Method.java:597) </div><div class="line">at classloader.ClassIdentity.testClassIdentity(ClassIdentity.java:26) </div><div class="line">at classloader.ClassIdentity.main(ClassIdentity.java:9) </div><div class="line">Caused by: java.lang.ClassCastException: com.example.Sample </div><div class="line">cannot be cast to com.example.Sample </div><div class="line">at com.example.Sample.setSample(Sample.java:7) </div><div class="line">... 6 more</div></pre></td></tr></table></figure>
<p>从运行结果可以看到，运行时抛出了 java.lang.ClassCastException异常。虽然两个对象 obj1和 obj2的类的名字相同，但是这两个类是由不同的类加载器实例来加载的，因此不被 Java 虚拟机认为是相同的。</p>
<p>了解了这一点之后，就可以理解代理模式的设计动机了。代理模式是为了保证 Java 核心库的类型安全。所有 Java 应用都至少需要引用 java.lang.Object类，也就是说在运行的时候，java.lang.Object这个类需要被加载到 Java 虚拟机中。如果这个加载过程由 Java 应用自己的类加载器来完成的话，很可能就存在多个版本的 java.lang.Object类，而且这些类之间是不兼容的。通过代理模式，对于 Java 核心库的类的加载工作由引导类加载器来统一完成，保证了 Java 应用所使用的都是同一个版本的 Java 核心库的类，是互相兼容的。<br>不同的类加载器为相同名称的类创建了额外的名称空间。相同名称的类可以并存在 Java 虚拟机中，只需要用不同的类加载器来加载它们即可。不同类加载器加载的类之间是不兼容的，这就相当于在 Java 虚拟机内部创建了一个个相互隔离的 Java 类空间。</p>
<p>下面具体介绍类加载器加载类的详细过程。</p>
<h3 id="加载类的过程"><a href="#加载类的过程" class="headerlink" title="加载类的过程"></a>加载类的过程</h3><p>在前面介绍类加载器的代理模式的时候，提到过类加载器会首先代理给其它类加载器来尝试加载某个类。这就意味着真正完成类的加载工作的类加载器和启动这个加载过程的类加载器，有可能不是同一个。真正完成类的加载工作是通过调用 defineClass来实现的；而启动类的加载过程是通过调用 loadClass来实现的。前者称为一个类的定义加载器（defining loader），后者称为初始加载器（initiating loader）。在 Java 虚拟机判断两个类是否相同的时候，使用的是类的定义加载器。也就是说，哪个类加载器启动类的加载过程并不重要，重要的是最终定义这个类的加载器。两种类加载器的关联之处在于：一个类的定义加载器是它引用的其它类的初始加载器。如类 com.example.Outer引用了类 com.example.Inner，则由类 com.example.Outer的定义加载器负责启动类 com.example.Inner的加载过程。<br>方法 loadClass()抛出的是 java.lang.ClassNotFoundException异常；方法 defineClass()抛出的是 java.lang.NoClassDefFoundError异常。<br>类加载器在成功加载某个类之后，会把得到的 java.lang.Class类的实例缓存起来。下次再请求加载该类的时候，类加载器会直接使用缓存的类的实例，而不会尝试再次加载。也就是说，对于一个类加载器实例来说，相同全名的类只加载一次，即 loadClass方法不会被重复调用。</p>
<p>下面讨论另外一种类加载器：线程上下文类加载器。</p>
<h4 id="线程上下文类加载器"><a href="#线程上下文类加载器" class="headerlink" title="线程上下文类加载器"></a>线程上下文类加载器</h4><p>线程上下文类加载器（context class loader）是从 JDK 1.2 开始引入的。类 java.lang.Thread中的方法 getContextClassLoader()和 setContextClassLoader(ClassLoader cl)用来获取和设置线程的上下文类加载器。如果没有通过 setContextClassLoader(ClassLoader cl)方法进行设置的话，线程将继承其父线程的上下文类加载器。Java 应用运行的初始线程的上下文类加载器是系统类加载器。在线程中运行的代码可以通过此类加载器来加载类和资源。<br>前面提到的类加载器的代理模式并不能解决 Java 应用开发中会遇到的类加载器的全部问题。Java 提供了很多服务提供者接口（Service Provider Interface，SPI），允许第三方为这些接口提供实现。常见的 SPI 有 JDBC、JCE、JNDI、JAXP 和 JBI 等。这些 SPI 的接口由 Java 核心库来提供，如 JAXP 的 SPI 接口定义包含在 javax.xml.parsers包中。这些 SPI 的实现代码很可能是作为 Java 应用所依赖的 jar 包被包含进来，可以通过类路径（CLASSPATH）来找到，如实现了 JAXP SPI 的 Apache Xerces所包含的 jar 包。SPI 接口中的代码经常需要加载具体的实现类。如 JAXP 中的 javax.xml.parsers.DocumentBuilderFactory类中的 newInstance()方法用来生成一个新的 DocumentBuilderFactory的实例。这里的实例的真正的类是继承自 javax.xml.parsers.DocumentBuilderFactory，由 SPI 的实现所提供的。如在 Apache Xerces 中，实现的类是 org.apache.xerces.jaxp.DocumentBuilderFactoryImpl。而问题在于，SPI 的接口是 Java 核心库的一部分，是由引导类加载器来加载的；SPI 实现的 Java 类一般是由系统类加载器来加载的。引导类加载器是无法找到 SPI 的实现类的，因为它只加载 Java 的核心库。它也不能代理给系统类加载器，因为它是系统类加载器的祖先类加载器。也就是说，类加载器的代理模式无法解决这个问题。<br>线程上下文类加载器正好解决了这个问题。如果不做任何的设置，Java 应用的线程的上下文类加载器默认就是系统上下文类加载器。在 SPI 接口的代码中使用线程上下文类加载器，就可以成功的加载到 SPI 实现的类。线程上下文类加载器在很多 SPI 的实现中都会用到。</p>
<p>下面介绍另外一种加载类的方法：Class.forName。</p>
<h4 id="Class-forName"><a href="#Class-forName" class="headerlink" title="Class.forName"></a>Class.forName</h4><p>Class.forName是一个静态方法，同样可以用来加载类。该方法有两种形式：Class.forName(String name, boolean initialize, ClassLoader loader)和 Class.forName(String className)。第一种形式的参数 name表示的是类的全名；initialize表示是否初始化类；loader表示加载时使用的类加载器。第二种形式则相当于设置了参数 initialize的值为 true，loader的值为当前类的类加载器。Class.forName的一个很常见的用法是在加载数据库驱动的时候。如 Class.forName(“org.apache.derby.jdbc.EmbeddedDriver”).newInstance()用来加载 Apache Derby 数据库的驱动。</p>
<h3 id="开发自己的类加载器"><a href="#开发自己的类加载器" class="headerlink" title="开发自己的类加载器"></a>开发自己的类加载器</h3><p>用来加载存储在文件系统上的 Java 字节代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">public class FileSystemClassLoader extends ClassLoader &#123; </div><div class="line"></div><div class="line">    private String rootDir; </div><div class="line"></div><div class="line">    public FileSystemClassLoader(String rootDir) &#123; </div><div class="line">        this.rootDir = rootDir; </div><div class="line">    &#125; </div><div class="line"></div><div class="line">    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; </div><div class="line">        byte[] classData = getClassData(name); </div><div class="line">        if (classData == null) &#123; </div><div class="line">            throw new ClassNotFoundException(); </div><div class="line">        &#125; </div><div class="line">        else &#123; </div><div class="line">            return defineClass(name, classData, 0, classData.length); </div><div class="line">        &#125; </div><div class="line">    &#125; </div><div class="line"></div><div class="line">    private byte[] getClassData(String className) &#123; </div><div class="line">        String path = classNameToPath(className); </div><div class="line">        try &#123; </div><div class="line">            InputStream ins = new FileInputStream(path); </div><div class="line">            ByteArrayOutputStream baos = new ByteArrayOutputStream(); </div><div class="line">            int bufferSize = 4096; </div><div class="line">            byte[] buffer = new byte[bufferSize]; </div><div class="line">            int bytesNumRead = 0; </div><div class="line">            while ((bytesNumRead = ins.read(buffer)) != -1) &#123; </div><div class="line">                baos.write(buffer, 0, bytesNumRead); </div><div class="line">            &#125; </div><div class="line">            return baos.toByteArray(); </div><div class="line">        &#125; catch (IOException e) &#123; </div><div class="line">            e.printStackTrace(); </div><div class="line">        &#125; </div><div class="line">        return null; </div><div class="line">    &#125; </div><div class="line"></div><div class="line">    private String classNameToPath(String className) &#123; </div><div class="line">        return rootDir + File.separatorChar </div><div class="line">                + className.replace(&apos;.&apos;, File.separatorChar) + &quot;.class&quot;; </div><div class="line">    &#125; </div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>类 FileSystemClassLoader继承自类 java.lang.ClassLoader。在 表 1中列出的 java.lang.ClassLoader类的常用方法中，一般来说，自己开发的类加载器只需要覆写 findClass(String name)方法即可。java.lang.ClassLoader类的方法 loadClass()封装了前面提到的代理模式的实现。该方法会首先调用 findLoadedClass()方法来检查该类是否已经被加载过；如果没有加载过的话，会调用父类加载器的 loadClass()方法来尝试加载该类；如果父类加载器无法加载该类的话，就调用 findClass()方法来查找该类。因此，为了保证类加载器都正确实现代理模式，在开发自己的类加载器时，最好不要覆写 loadClass()方法，而是覆写 findClass()方法。</p>
<p>类 FileSystemClassLoader的 findClass()方法首先根据类的全名在硬盘上查找类的字节代码文件（.class 文件），然后读取该文件内容，最后通过 defineClass()方法来把这些字节代码转换成 java.lang.Class类的实例。</p>
<h3 id="类加载器与-Web-容器"><a href="#类加载器与-Web-容器" class="headerlink" title="类加载器与 Web 容器"></a>类加载器与 Web 容器</h3><p>对于运行在 Java EE™容器中的 Web 应用来说，类加载器的实现方式与一般的 Java 应用有所不同。不同的 Web 容器的实现方式也会有所不同。以 Apache Tomcat 来说，每个 Web 应用都有一个对应的类加载器实例。该类加载器也使用代理模式，所不同的是它是首先尝试去加载某个类，如果找不到再代理给父类加载器。这与一般类加载器的顺序是相反的。这是 Java Servlet 规范中的推荐做法，其目的是使得 Web 应用自己的类的优先级高于 Web 容器提供的类。这种代理模式的一个例外是：Java 核心库的类是不在查找范围之内的。这也是为了保证 Java 核心库的类型安全。<br>绝大多数情况下，Web 应用的开发人员不需要考虑与类加载器相关的细节。下面给出几条简单的原则：</p>
<ul>
<li>每个 Web 应用自己的 Java 类文件和使用的库的 jar 包，分别放在 WEB-INF/classes和 WEB-INF/lib目录下面。</li>
<li>多个应用共享的 Java 类文件和 jar 包，分别放在 Web 容器指定的由所有 Web 应用共享的目录下面。</li>
<li>当出现找不到类的错误时，检查当前类的类加载器和当前线程的上下文类加载器是否正确。</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[String]]></title>
      <url>http://zsr.github.io/2016/08/03/String/</url>
      <content type="html"><![CDATA[<h1 id="OpenJDK-源代码阅读之-String"><a href="#OpenJDK-源代码阅读之-String" class="headerlink" title="OpenJDK 源代码阅读之 String"></a>OpenJDK 源代码阅读之 String</h1><hr>
<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><ul>
<li>类继承关系</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">java.lang.Object</div><div class="line">    java.lang.String</div></pre></td></tr></table></figure>
<ul>
<li>定义</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></div><div class="line"><span class="keyword">extends</span> <span class="title">Object</span></div><div class="line"><span class="keyword">implements</span> <span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span></div></pre></td></tr></table></figure>
<ul>
<li>要点</li>
</ul>
<p>一旦创建就不可改变</p>
<a id="more"></a>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul>
<li>storage</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** The value is used for character storage. */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</div></pre></td></tr></table></figure>
<p>可以看出 <code>String</code> 中的数据是如何存储的。</p>
<ul>
<li>初始化</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String original)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.value = original.value;</div><div class="line">    <span class="keyword">this</span>.hash = original.hash;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出使用 <code>String</code> 类型初始化，新 <code>String</code> 实际上与原来的 <code>String</code> 指向同一块内存。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[])</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.value = Arrays.copyOf(value, value.length);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果用 <code>char[]</code> 初始化，可以看出，新分配了内存，并复制，保证了两者相互独立，只是内容相同。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(StringBuffer buffer)</span> </span>&#123;</div><div class="line">    <span class="keyword">synchronized</span>(buffer) &#123;</div><div class="line">        <span class="keyword">this</span>.value = Arrays.copyOf(buffer.getValue(), buffer.length());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意用 <code>StringBuffer</code> 初始化时，对同一 <code>buffer</code> 是线程安全的，即初始化 <code>String</code> 的过程中，其它线程不会改变 <code>buffer</code> 的内容。</p>
<p>另外，能告诉我下面这段代码是怎么回事么？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(StringBuilder builder)</span> </span>&#123;</div><div class="line">     <span class="keyword">this</span>.value = Arrays.copyOf(builder.getValue(), builder.length());</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>为啥这次不同步了呢？</p>
<ul>
<li>equals </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</div><div class="line">        String anotherString = (String) anObject;</div><div class="line">        <span class="keyword">int</span> n = value.length;</div><div class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</div><div class="line">            <span class="keyword">char</span> v1[] = value;</div><div class="line">            <span class="keyword">char</span> v2[] = anotherString.value;</div><div class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</div><div class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                i++;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意：</p>
<p>1) 检查类型<br>2) <code>value</code> 直接通过点访问了，<code>value</code> 是 <code>private</code> 的啊，怎么能这样？</p>
<ul>
<li>hashCode </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> h = hash;</div><div class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">char</span> val[] = value;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</div><div class="line">            h = <span class="number">31</span> * h + val[i];</div><div class="line">        &#125;</div><div class="line">        hash = h;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> h;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>String</code> 的 <code>hashCode</code> 公式：</p>
<blockquote>
<p>s[0]*31^(n-1) + s[1]*31^(n-2) + … + s[n-1]</p>
</blockquote>
<ul>
<li>replace</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replace</span><span class="params">(<span class="keyword">char</span> oldChar, <span class="keyword">char</span> newChar)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (oldChar != newChar) &#123;</div><div class="line">        <span class="keyword">int</span> len = value.length;</div><div class="line">        <span class="keyword">int</span> i = -<span class="number">1</span>;</div><div class="line">        <span class="keyword">char</span>[] val = value; <span class="comment">/* avoid getfield opcode */</span></div><div class="line"></div><div class="line">        <span class="keyword">while</span> (++i &lt; len) &#123;</div><div class="line">            <span class="keyword">if</span> (val[i] == oldChar) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (i &lt; len) &#123;</div><div class="line">            <span class="keyword">char</span> buf[] = <span class="keyword">new</span> <span class="keyword">char</span>[len];</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</div><div class="line">                buf[j] = val[j];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">while</span> (i &lt; len) &#123;</div><div class="line">                <span class="keyword">char</span> c = val[i];</div><div class="line">                buf[i] = (c == oldChar) ? newChar : c;</div><div class="line">                i++;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> String(buf, <span class="keyword">true</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从中可以看出，虽然说是 <code>replace</code>，但是实际上还是新生成了 <code>buf</code> ，然后再生成新的 <code>String</code>，而不是在原来的 <code>value</code> 上修改。如果有大量的替换，还是自己实现比较好诶～</p>
<ul>
<li>indexOf</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Code shared by String and StringBuffer to do searches. The</div><div class="line"> * source is the character array being searched, and the target</div><div class="line"> * is the string being searched for.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span>   source       the characters being searched.</div><div class="line"> * <span class="doctag">@param</span>   sourceOffset offset of the source string.</div><div class="line"> * <span class="doctag">@param</span>   sourceCount  count of the source string.</div><div class="line"> * <span class="doctag">@param</span>   target       the characters being searched for.</div><div class="line"> * <span class="doctag">@param</span>   targetOffset offset of the target string.</div><div class="line"> * <span class="doctag">@param</span>   targetCount  count of the target string.</div><div class="line"> * <span class="doctag">@param</span>   fromIndex    the index to begin searching from.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">char</span>[] source, <span class="keyword">int</span> sourceOffset, <span class="keyword">int</span> sourceCount,</span></span></div><div class="line">        <span class="keyword">char</span>[] target, <span class="keyword">int</span> targetOffset, <span class="keyword">int</span> targetCount,</div><div class="line">        <span class="keyword">int</span> fromIndex) &#123;</div><div class="line">    <span class="keyword">if</span> (fromIndex &gt;= sourceCount) &#123;</div><div class="line">        <span class="keyword">return</span> (targetCount == <span class="number">0</span> ? sourceCount : -<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (fromIndex &lt; <span class="number">0</span>) &#123;</div><div class="line">        fromIndex = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (targetCount == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> fromIndex;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">char</span> first = target[targetOffset];</div><div class="line">    <span class="keyword">int</span> max = sourceOffset + (sourceCount - targetCount);</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = sourceOffset + fromIndex; i &lt;= max; i++) &#123;</div><div class="line">        <span class="comment">/* Look for first character. */</span></div><div class="line">        <span class="keyword">if</span> (source[i] != first) &#123;</div><div class="line">            <span class="keyword">while</span> (++i &lt;= max &amp;&amp; source[i] != first);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/* Found first character, now look at the rest of v2 */</span></div><div class="line">        <span class="keyword">if</span> (i &lt;= max) &#123;</div><div class="line">            <span class="keyword">int</span> j = i + <span class="number">1</span>;</div><div class="line">            <span class="keyword">int</span> end = j + targetCount - <span class="number">1</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = targetOffset + <span class="number">1</span>; j &lt; end &amp;&amp; source[j]</div><div class="line">                    == target[k]; j++, k++);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (j == end) &#123;</div><div class="line">                <span class="comment">/* Found whole string. */</span></div><div class="line">                <span class="keyword">return</span> i - sourceOffset;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码从 <code>source</code> 中寻找 <code>target</code> 第一次出现的位置，<code>for</code> 循环每次都先让 <code>i</code> 停留在一个位置，此位置上内容与 <code>target</code> 首字符相同，然后开始遍历。可以看出这是一个 <code>O(n^2)</code> 的算法，所以，标准库也不一定是最高效的，要是要高效，还是需要自己实现，或者找其它库的。</p>
<ul>
<li>matches</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(String regex)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> Pattern.matches(regex, <span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>正则表达式匹配函数。可以看出，是直接调用了 <code>Pattern</code> 中的相应函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> String[] split(String regex, <span class="keyword">int</span> limit) &#123;</div><div class="line">    <span class="comment">/* fastpath if the regex is a</span></div><div class="line">     (1)one-char String and this character is not one of the</div><div class="line">        RegEx's meta characters ".$|()[&#123;^?*+\\", or</div><div class="line">     (2)two-char String and the first char is the backslash and</div><div class="line">        the second is not the ascii digit or ascii letter.</div><div class="line">     */</div><div class="line">    <span class="keyword">char</span> ch = <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (((regex.value.length == <span class="number">1</span> &amp;&amp;</div><div class="line">         <span class="string">".$|()[&#123;^?*+\\"</span>.indexOf(ch = regex.charAt(<span class="number">0</span>)) == -<span class="number">1</span>) ||</div><div class="line">         (regex.length() == <span class="number">2</span> &amp;&amp;</div><div class="line">          regex.charAt(<span class="number">0</span>) == <span class="string">'\\'</span> &amp;&amp;</div><div class="line">          (((ch = regex.charAt(<span class="number">1</span>))-<span class="string">'0'</span>)|(<span class="string">'9'</span>-ch)) &lt; <span class="number">0</span> &amp;&amp;</div><div class="line">          ((ch-<span class="string">'a'</span>)|(<span class="string">'z'</span>-ch)) &lt; <span class="number">0</span> &amp;&amp;</div><div class="line">          ((ch-<span class="string">'A'</span>)|(<span class="string">'Z'</span>-ch)) &lt; <span class="number">0</span>)) &amp;&amp;</div><div class="line">        (ch &lt; Character.MIN_HIGH_SURROGATE ||</div><div class="line">         ch &gt; Character.MAX_LOW_SURROGATE))</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> off = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> next = <span class="number">0</span>;</div><div class="line">        <span class="keyword">boolean</span> limited = limit &gt; <span class="number">0</span>;</div><div class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">while</span> ((next = indexOf(ch, off)) != -<span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (!limited || list.size() &lt; limit - <span class="number">1</span>) &#123;</div><div class="line">                list.add(substring(off, next));</div><div class="line">                off = next + <span class="number">1</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;    <span class="comment">// last one</span></div><div class="line">                <span class="comment">//assert (list.size() == limit - 1);</span></div><div class="line">                list.add(substring(off, value.length));</div><div class="line">                off = value.length;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// If no match was found, return this</span></div><div class="line">        <span class="keyword">if</span> (off == <span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;<span class="keyword">this</span>&#125;;</div><div class="line"></div><div class="line">        <span class="comment">// Add remaining segment</span></div><div class="line">        <span class="keyword">if</span> (!limited || list.size() &lt; limit)</div><div class="line">            list.add(substring(off, value.length));</div><div class="line"></div><div class="line">        <span class="comment">// Construct result</span></div><div class="line">        <span class="keyword">int</span> resultSize = list.size();</div><div class="line">        <span class="keyword">if</span> (limit == <span class="number">0</span>)</div><div class="line">            <span class="keyword">while</span> (resultSize &gt; <span class="number">0</span> &amp;&amp; list.get(resultSize - <span class="number">1</span>).length() == <span class="number">0</span>)</div><div class="line">                resultSize--;</div><div class="line">        String[] result = <span class="keyword">new</span> String[resultSize];</div><div class="line">        <span class="keyword">return</span> list.subList(<span class="number">0</span>, resultSize).toArray(result);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> Pattern.compile(regex).split(<span class="keyword">this</span>, limit);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>按 <code>regex</code> 将字符串分割，思路是如果是单个字符，或者转义字符，就手工分割，否则就直接调用 <code>Pattern.comile(regex).split</code> 函数。手工分割时每次都将 <code>[off, next]</code> 之间的内容加入 <code>list</code>，最后将 剩余的 <code>[off, ]</code>  加入。另外注意 <code>limit</code> 对分割次数的限制。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JAVA NIO Demo]]></title>
      <url>http://zsr.github.io/2016/08/02/Java-Nio-demo/</url>
      <content type="html"><![CDATA[<h1 id="JAVA-NIO-Demo"><a href="#JAVA-NIO-Demo" class="headerlink" title="JAVA NIO Demo"></a>JAVA NIO Demo</h1><hr>
<h3 id="Nio-服务端"><a href="#Nio-服务端" class="headerlink" title="Nio 服务端"></a>Nio 服务端</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div></pre></td><td class="code"><pre><div class="line">package com.zsr.test.nio;</div><div class="line"></div><div class="line">import java.io.IOException;</div><div class="line">import java.net.InetSocketAddress;</div><div class="line">import java.nio.ByteBuffer;</div><div class="line">import java.nio.channels.SelectionKey;</div><div class="line">import java.nio.channels.Selector;</div><div class="line">import java.nio.channels.ServerSocketChannel;</div><div class="line">import java.nio.channels.SocketChannel;</div><div class="line">import java.util.Iterator;</div><div class="line"></div><div class="line">/**</div><div class="line"> * nio 服务端 Created by david.zhang</div><div class="line"> */</div><div class="line">public class NIOServer &#123;</div><div class="line"></div><div class="line">  // 通道管理器</div><div class="line">  private Selector selector;</div><div class="line"></div><div class="line">  /**</div><div class="line">   * 获得一个ServerSocket通道，并对该通道做一些初始化的工作</div><div class="line">   * </div><div class="line">   * @param port 绑定的端口号</div><div class="line">   * @throws IOException</div><div class="line">   */</div><div class="line">  public void initServer(int port) throws IOException &#123;</div><div class="line">    // 获得一个ServerSocket通道</div><div class="line">    ServerSocketChannel serverChannel = ServerSocketChannel.open();</div><div class="line">    // 设置通道为非阻塞</div><div class="line">    serverChannel.configureBlocking(false);</div><div class="line">    // 将该通道对应的ServerSocket绑定到指定端口</div><div class="line">    serverChannel.socket().bind(new InetSocketAddress(port));</div><div class="line">    // 获得一个通道管理器</div><div class="line">    this.selector = Selector.open();</div><div class="line">    // 将通道管理器和该通道绑定，并为该通道注册SelectionKey.OP_ACCEPT事件,注册该事件后，</div><div class="line">    // 当该事件到达时，selector.select()会返回，如果该事件没到达selector.select()会一直阻塞。</div><div class="line">    serverChannel.register(selector, SelectionKey.OP_ACCEPT);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  /**</div><div class="line">   * 采用轮询的方式监听selector上是否有需要处理的事件，如果有，则进行处理</div><div class="line">   * </div><div class="line">   * @throws IOException</div><div class="line">   */</div><div class="line">  public void listen() throws IOException &#123;</div><div class="line">    System.out.println(&quot;nio server listen start.&quot;);</div><div class="line">    // 轮询访问selector</div><div class="line">    while (true) &#123;</div><div class="line">      // 当注册的事件到达时，方法返回；否则,该方法会一直阻塞</div><div class="line">      selector.select();</div><div class="line">      // 获得selector中选中的项的迭代器，选中的项为注册的事件</div><div class="line">      Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();</div><div class="line">      while (it.hasNext()) &#123;</div><div class="line">        SelectionKey key = it.next();</div><div class="line">        // 删除已选的key,以防重复处理</div><div class="line">        it.remove();</div><div class="line">        // 客户端请求连接事件</div><div class="line">        if (key.isAcceptable()) &#123;</div><div class="line">          ServerSocketChannel server = (ServerSocketChannel) key.channel();</div><div class="line">          // 获得和客户端连接的通道</div><div class="line">          SocketChannel channel = server.accept();</div><div class="line">          // 设置成非阻塞</div><div class="line">          channel.configureBlocking(false);</div><div class="line"></div><div class="line">          // 在这里可以给客户端发送信息</div><div class="line">          channel.write(ByteBuffer.wrap(new String(&quot;服务器收到客户端连接请求.&quot;).getBytes()));</div><div class="line"></div><div class="line">          // 在和客户端连接成功之后，为了可以接收到客户端的信息，需要给通道设置读的权限。</div><div class="line">          channel.register(selector, SelectionKey.OP_READ);</div><div class="line">          // 获得了可读事件</div><div class="line">        &#125; else if (key.isReadable()) &#123;</div><div class="line">          read(key);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  /**</div><div class="line">   * 处理读取客户端发来的信息 的事件</div><div class="line">   * </div><div class="line">   * @param key</div><div class="line">   * @throws IOException</div><div class="line">   */</div><div class="line">  public void read(SelectionKey key) throws IOException &#123;</div><div class="line"></div><div class="line">    // 服务器可读取消息:得到事件发生的Socket通道</div><div class="line">    SocketChannel channel = (SocketChannel) key.channel();</div><div class="line">    // 创建读取的缓冲区</div><div class="line">    ByteBuffer buffer = ByteBuffer.allocate(1024);</div><div class="line">    channel.read(buffer);</div><div class="line">    byte[] data = buffer.array();</div><div class="line">    String msg = new String(data);</div><div class="line">    System.out.println(&quot;服务器端收到客户端信息:&quot; + msg);</div><div class="line">    // 将消息回送给客户端</div><div class="line">    ByteBuffer outBuffer = ByteBuffer.wrap(new String(&quot;服务器端发送客户端消息: world.&quot;).getBytes());</div><div class="line">    channel.write(outBuffer);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  // 服务器端测试</div><div class="line">  public static void main(String[] args) throws IOException &#123;</div><div class="line">    NIOServer nioServer = new NIOServer();</div><div class="line">    nioServer.initServer(8000);</div><div class="line">    nioServer.listen();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="Nio-客户端"><a href="#Nio-客户端" class="headerlink" title="Nio 客户端"></a>Nio 客户端</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div></pre></td><td class="code"><pre><div class="line">package com.zsr.test.nio;</div><div class="line"></div><div class="line">import java.io.IOException;</div><div class="line">import java.net.InetSocketAddress;</div><div class="line">import java.nio.ByteBuffer;</div><div class="line">import java.nio.channels.SelectionKey;</div><div class="line">import java.nio.channels.Selector;</div><div class="line">import java.nio.channels.SocketChannel;</div><div class="line">import java.util.Iterator;</div><div class="line"></div><div class="line">/**</div><div class="line"> * nio 客户端 Created by david.zhang</div><div class="line"> */</div><div class="line">public class NIOClient &#123;</div><div class="line"></div><div class="line">  // 通道管理器</div><div class="line">  private Selector selector;</div><div class="line"></div><div class="line">  /**</div><div class="line">   * 获得一个Socket通道，并对该通道做一些初始化的工作</div><div class="line">   * </div><div class="line">   * @param ip 连接的服务器的ip</div><div class="line">   * @param port 连接的服务器的端口号</div><div class="line">   * @throws IOException</div><div class="line">   */</div><div class="line">  public void initClient(String ip, int port) throws IOException &#123;</div><div class="line">    // 获得一个Socket通道</div><div class="line">    SocketChannel channel = SocketChannel.open();</div><div class="line">    // 设置通道为非阻塞</div><div class="line">    channel.configureBlocking(false);</div><div class="line">    // 获得一个通道管理器</div><div class="line">    this.selector = Selector.open();</div><div class="line"></div><div class="line">    // 客户端连接服务器,其实方法执行并没有实现连接，需要在listen（）方法中调</div><div class="line">    // 用channel.finishConnect();才能完成连接</div><div class="line">    channel.connect(new InetSocketAddress(ip, port));</div><div class="line">    // 将通道管理器和该通道绑定，并为该通道注册SelectionKey.OP_CONNECT事件。</div><div class="line">    channel.register(selector, SelectionKey.OP_CONNECT);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  /**</div><div class="line">   * 采用轮询的方式监听selector上是否有需要处理的事件，如果有，则进行处理</div><div class="line">   * </div><div class="line">   * @throws IOException</div><div class="line">   */</div><div class="line">  public void listen() throws IOException &#123;</div><div class="line">    System.out.println(&quot;nio client liesten start.&quot;);</div><div class="line">    // 轮询访问selector</div><div class="line">    while (true) &#123;</div><div class="line">      // 当注册的事件到达时，方法返回；否则,该方法会一直阻塞</div><div class="line">      selector.select();</div><div class="line">      // 获得selector中选中的项的迭代器，选中的项为注册的事件</div><div class="line">      Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();</div><div class="line">      while (it.hasNext()) &#123;</div><div class="line">        SelectionKey key = it.next();</div><div class="line">        // 删除已选的key,以防重复处理</div><div class="line">        it.remove();</div><div class="line">        // 连接事件发生</div><div class="line">        if (key.isConnectable()) &#123;</div><div class="line">          SocketChannel channel = (SocketChannel) key.channel();</div><div class="line">          // 如果正在连接，则完成连接</div><div class="line">          if (channel.isConnectionPending()) &#123;</div><div class="line">            channel.finishConnect();</div><div class="line">          &#125;</div><div class="line">          // 设置非阻塞</div><div class="line">          channel.configureBlocking(false);</div><div class="line"></div><div class="line">          // 向服务器端发送信息</div><div class="line">          channel.write(ByteBuffer.wrap(new String(&quot;客户端请求连接服务器端.&quot;).getBytes()));</div><div class="line">          // 在和服务端连接成功之后，为了可以接收到服务端的信息，需要给通道设置读的权限。</div><div class="line">          channel.register(selector, SelectionKey.OP_READ);</div><div class="line"></div><div class="line">          // 获得了可读的事件</div><div class="line">        &#125; else if (key.isReadable()) &#123;</div><div class="line">          read(key);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  /**</div><div class="line">   * 处理读取服务器端发来的信息 的事件</div><div class="line">   * </div><div class="line">   * @param key</div><div class="line">   * @throws IOException</div><div class="line">   */</div><div class="line">  public void read(SelectionKey key) throws IOException &#123;</div><div class="line">    // 服务器可读取消息:得到事件发生的Socket通道</div><div class="line">    SocketChannel channel = (SocketChannel) key.channel();</div><div class="line">    // 创建读取的缓冲区</div><div class="line">    ByteBuffer buffer = ByteBuffer.allocate(1024);</div><div class="line">    channel.read(buffer);</div><div class="line">    byte[] data = buffer.array();</div><div class="line">    String msg = new String(data);</div><div class="line">    System.out.println(&quot;客户端收到服务器信息:&quot; + msg);</div><div class="line">    ByteBuffer outBuffer = ByteBuffer.wrap(new String(&quot;客户端发送服务器消息: hello&quot;).getBytes());</div><div class="line">    channel.write(outBuffer);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  // 客户端测试</div><div class="line">  public static void main(String[] args) throws IOException &#123;</div><div class="line">    NIOClient nioClient = new NIOClient();</div><div class="line">    nioClient.initClient(&quot;127.0.0.1&quot;, 8000);</div><div class="line">    nioClient.listen();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[MapReducer]]></title>
      <url>http://zsr.github.io/2016/08/02/MapReducer/</url>
      <content type="html"><![CDATA[<h1 id="MapReducer笔记"><a href="#MapReducer笔记" class="headerlink" title="MapReducer笔记"></a>MapReducer笔记</h1><h3 id="参入mapreduce作业执行涉及4个独立的实体："><a href="#参入mapreduce作业执行涉及4个独立的实体：" class="headerlink" title="参入mapreduce作业执行涉及4个独立的实体："></a>参入mapreduce作业执行涉及4个独立的实体：</h3><ul>
<li><p>客户端（client）：编写mapreduce程序，配置作业，提交作业，这就是程序员完成的工作；</p>
</li>
<li><p>JobTracker：初始化作业，分配作业，与TaskTracker通信，协调整个作业的执行；</p>
</li>
<li><p>TaskTracker：保持与JobTracker的通信，在分配的数据片段上执行Map或Reduce任务，TaskTracker和JobTracker的不同有个很重要的方面，就是在执行任务时候TaskTracker可以有n多个，JobTracker则只会有一个</p>
</li>
<li><p>Hdfs：保存作业的数据、配置信息等等，最后的结果也是保存在hdfs上面</p>
</li>
</ul>
<p><img src="/images/MapReducer.jpg"></p>
<a id="more"></a>
<h3 id="mapreduce运行过程"><a href="#mapreduce运行过程" class="headerlink" title="mapreduce运行过程"></a>mapreduce运行过程</h3><ul>
<li><p>首先是客户端要编写好mapreduce程序，配置好mapreduce的作业也就是job，接下来就是提交job了，提交job是提交到JobTracker上的，这个时候JobTracker就会构建这个job，具体就是分配一个新的job任务的ID值，接下来它会做检查操作，这个检查就是确定输出目录是否存在，如果存在那么job就不能正常运行下去，JobTracker会抛出错误给客户端，接下来还要检查输入目录是否存在，如果不存在同样抛出错误，如果存在JobTracker会根据输入计算输入分片（Input Split），如果分片计算不出来也会抛出错误，至于输入分片我后面会做讲解的，这些都做好了JobTracker就会配置Job需要的资源了。分配好资源后，JobTracker就会初始化作业，初始化主要做的是将Job放入一个内部的队列，让配置好的作业调度器能调度到这个作业，作业调度器会初始化这个job，初始化就是创建一个正在运行的job对象（封装任务和记录信息），以便JobTracker跟踪job的状态和进程。</p>
</li>
<li><p>初始化完毕后，作业调度器会获取输入分片信息（input split），每个分片创建一个map任务。接下来就是任务分配了，这个时候tasktracker会运行一个简单的循环机制定期发送心跳给jobtracker，心跳间隔是5秒，程序员可以配置这个时间，心跳就是jobtracker和tasktracker沟通的桥梁，通过心跳，jobtracker可以监控tasktracker是否存活，也可以获取tasktracker处理的状态和问题，同时tasktracker也可以通过心跳里的返回值获取jobtracker给它的操作指令。任务分配好后就是执行任务了。在任务执行时候jobtracker可以通过心跳机制监控tasktracker的状态和进度，同时也能计算出整个job的状态和进度，而tasktracker也可以本地监控自己的状态和进度。当jobtracker获得了最后一个完成指定任务的tasktracker操作成功的通知时候，jobtracker会把整个job状态置为成功，然后当客户端查询job运行状态时候（注意：这个是异步操作），客户端会查到job完成的通知的。如果job中途失败，mapreduce也会有相应机制处理，一般而言如果不是程序员程序本身有bug，mapreduce错误处理机制都能保证提交的job能正常完成。</p>
</li>
</ul>
<h5 id="从逻辑实体的角度讲解mapreduce运行机制，这些按照时间顺序包括：输入分片（input-split）、map阶段、combiner阶段、shuffle阶段和reduce阶段。"><a href="#从逻辑实体的角度讲解mapreduce运行机制，这些按照时间顺序包括：输入分片（input-split）、map阶段、combiner阶段、shuffle阶段和reduce阶段。" class="headerlink" title="从逻辑实体的角度讲解mapreduce运行机制，这些按照时间顺序包括：输入分片（input split）、map阶段、combiner阶段、shuffle阶段和reduce阶段。"></a>从逻辑实体的角度讲解mapreduce运行机制，这些按照时间顺序包括：输入分片（input split）、map阶段、combiner阶段、shuffle阶段和reduce阶段。</h5><ol>
<li>输入分片（input split）：在进行map计算之前，mapreduce会根据输入文件计算输入分片（input split），每个输入分片（input split）针对一个map任务，输入分片（input split）存储的并非数据本身，而是一个分片长度和一个记录数据的位置的数组，输入分片（input split）往往和hdfs的block（块）关系很密切，假如我们设定hdfs的块的大小是64mb，如果我们输入有三个文件，大小分别是3mb、65mb和127mb，那么mapreduce会把3mb文件分为一个输入分片（input split），65mb则是两个输入分片（input split）而127mb也是两个输入分片（input split），换句话说我们如果在map计算前做输入分片调整，例如合并小文件，那么就会有5个map任务将执行，而且每个map执行的数据大小不均，这个也是mapreduce优化计算的一个关键点。</li>
</ol>
<ol>
<li><p>map阶段：就是程序员编写好的map函数了，因此map函数效率相对好控制，而且一般map操作都是本地化操作也就是在数据存储节点上进行；</p>
</li>
<li><p>combiner阶段：combiner阶段是程序员可以选择的，combiner其实也是一种reduce操作，因此我们看见WordCount类里是用reduce进行加载的。Combiner是一个本地化的reduce操作，它是map运算的后续操作，主要是在map计算出中间文件前做一个简单的合并重复key值的操作，例如我们对文件里的单词频率做统计，map计算时候如果碰到一个hadoop的单词就会记录为1，但是这篇文章里hadoop可能会出现n多次，那么map输出文件冗余就会很多，因此在reduce计算前对相同的key做一个合并操作，那么文件会变小，这样就提高了宽带的传输效率，毕竟hadoop计算力宽带资源往往是计算的瓶颈也是最为宝贵的资源，但是combiner操作是有风险的，使用它的原则是combiner的输入不会影响到reduce计算的最终输入，例如：如果计算只是求总数，最大值，最小值可以使用combiner，但是做平均值计算使用combiner的话，最终的reduce计算结果就会出错。</p>
</li>
<li><p>shuffle阶段：将map的输出作为reduce的输入的过程就是shuffle了，这个是mapreduce优化的重点地方。这里我不讲怎么优化shuffle阶段，讲讲shuffle阶段的原理，因为大部分的书籍里都没讲清楚shuffle阶段。Shuffle一开始就是map阶段做输出操作，一般mapreduce计算的都是海量数据，map输出时候不可能把所有文件都放到内存操作，因此map写入磁盘的过程十分的复杂，更何况map输出时候要对结果进行排序，内存开销是很大的，map在做输出时候会在内存里开启一个环形内存缓冲区，这个缓冲区专门用来输出的，默认大小是100mb，并且在配置文件里为这个缓冲区设定了一个阀值，默认是0.80（这个大小和阀值都是可以在配置文件里进行配置的），同时map还会为输出操作启动一个守护线程，如果缓冲区的内存达到了阀值的80%时候，这个守护线程就会把内容写到磁盘上，这个过程叫spill，另外的20%内存可以继续写入要写进磁盘的数据，写入磁盘和写入内存操作是互不干扰的，如果缓存区被撑满了，那么map就会阻塞写入内存的操作，让写入磁盘操作完成后再继续执行写入内存操作，前面我讲到写入磁盘前会有个排序操作，这个是在写入磁盘操作时候进行，不是在写入内存时候进行的，如果我们定义了combiner函数，那么排序前还会执行combiner操作。<br>每次spill操作也就是写入磁盘操作时候就会写一个溢出文件，也就是说在做map输出有几次spill就会产生多少个溢出文件，等map输出全部做完后，map会合并这些输出文件。这个过程里还会有一个Partitioner操作，对于这个操作很多人都很迷糊，其实Partitioner操作和map阶段的输入分片（Input split）很像，一个Partitioner对应一个reduce作业，如果我们mapreduce操作只有一个reduce操作，那么Partitioner就只有一个，如果我们有多个reduce操作，那么Partitioner对应的就会有多个，Partitioner因此就是reduce的输入分片，这个程序员可以编程控制，主要是根据实际key和value的值，根据实际业务类型或者为了更好的reduce负载均衡要求进行，这是提高reduce效率的一个关键所在。到了reduce阶段就是合并map输出文件了，Partitioner会找到对应的map输出文件，然后进行复制操作，复制操作时reduce会开启几个复制线程，这些线程默认个数是5个，程序员也可以在配置文件更改复制线程的个数，这个复制过程和map写入磁盘过程类似，也有阀值和内存大小，阀值一样可以在配置文件里配置，而内存大小是直接使用reduce的tasktracker的内存大小，复制时候reduce还会进行排序操作和合并文件操作，这些操作完了就会进行reduce计算了。</p>
</li>
<li><p>reduce阶段：和map函数一样也是程序员编写的，最终结果是存储在hdfs上的。</p>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java动态代理]]></title>
      <url>http://zsr.github.io/2016/08/01/Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
      <content type="html"><![CDATA[<h1 id="Java动态代理"><a href="#Java动态代理" class="headerlink" title="Java动态代理"></a>Java动态代理</h1><hr>
<h6 id="Spring-AOP使用动态代理技术在运行期织入增强的代码，为了揭示Spring-AOP底层的工作机理，有必要对涉及到的Java知识进行学习。Spring-AOP使用了两种代理机制：一种是基于JDK的动态代理；另一种是基于CGLib的动态代理。之所以需要两种代理机制，很大程度上是因为JDK本身只提供接口的代理，而不支持类的代理。"><a href="#Spring-AOP使用动态代理技术在运行期织入增强的代码，为了揭示Spring-AOP底层的工作机理，有必要对涉及到的Java知识进行学习。Spring-AOP使用了两种代理机制：一种是基于JDK的动态代理；另一种是基于CGLib的动态代理。之所以需要两种代理机制，很大程度上是因为JDK本身只提供接口的代理，而不支持类的代理。" class="headerlink" title="Spring AOP使用动态代理技术在运行期织入增强的代码，为了揭示Spring AOP底层的工作机理，有必要对涉及到的Java知识进行学习。Spring AOP使用了两种代理机制：一种是基于JDK的动态代理；另一种是基于CGLib的动态代理。之所以需要两种代理机制，很大程度上是因为JDK本身只提供接口的代理，而不支持类的代理。"></a>Spring AOP使用动态代理技术在运行期织入增强的代码，为了揭示Spring AOP底层的工作机理，有必要对涉及到的Java知识进行学习。Spring AOP使用了两种代理机制：一种是基于JDK的动态代理；另一种是基于CGLib的动态代理。之所以需要两种代理机制，很大程度上是因为JDK本身只提供接口的代理，而不支持类的代理。</h6><h5 id="带有横切逻辑的实例"><a href="#带有横切逻辑的实例" class="headerlink" title="带有横切逻辑的实例"></a>带有横切逻辑的实例</h5><p>我们通过具体化代码实现上一节所介绍例子的性能监视横切逻辑，并通过动态代理技术对此进行改造。在调用每一个目标类方法时启动方法的性能监视，在目标类方法调用完成时记录方法的花费时间。 </p>
<p>代码清单6-2  ForumService：包含性能监视横切代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">package com.baobaotao.proxy;  </div><div class="line">public class ForumServiceImpl implements ForumService &#123;  </div><div class="line">    public void removeTopic(int topicId) &#123;          </div><div class="line">         //①-1开始对该方法进行性能监视  </div><div class="line">        PerformanceMonitor.begin(  </div><div class="line">                            &quot;com.baobaotao.proxy.ForumServiceImpl. removeTopic&quot;);  </div><div class="line">        System.out.println(&quot;模拟删除Topic记录:&quot;+topicId);  </div><div class="line">        try &#123;  </div><div class="line">            Thread.currentThread().sleep(20);  </div><div class="line">        &#125; catch (Exception e) &#123;  </div><div class="line">            throw new RuntimeException(e);  </div><div class="line">        &#125;         </div><div class="line">         //①-2结束对该方法进行性能监视  </div><div class="line">        PerformanceMonitor.end();  </div><div class="line">    &#125;  </div><div class="line">    public void removeForum(int forumId) &#123;  </div><div class="line">          //②-1开始对该方法进行性能监视  </div><div class="line">        PerformanceMonitor.begin(  </div><div class="line">&quot;com.baobaotao.proxy.ForumServiceImpl. removeForum&quot;);  </div><div class="line">        System.out.println(&quot;模拟删除Forum记录:&quot;+forumId);  </div><div class="line">        try &#123;  </div><div class="line">            Thread.currentThread().sleep(40);  </div><div class="line">        &#125; catch (Exception e) &#123;  </div><div class="line">            throw new RuntimeException(e);  </div><div class="line">        &#125;         </div><div class="line">         //②-2结束对该方法进行性能监视  </div><div class="line">        PerformanceMonitor.end();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>代码清单6-2中粗体表示的代码就是具有横切逻辑特征的代码，每个Service类和每个业务方法体的前后都执行相同的代码逻辑：方法调用前启动PerformanceMonitor，方法调用后通知PerformanceMonitor结束性能监视并给记录性能监视结果。<br><a id="more"></a></p>
<p>PerformanceMonitor是性能监视的实现类，我们给出一个非常简单的实现版本，其代码如代码清单6-3所示： </p>
<p>代码清单6-3  PerformanceMonitor<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">package com.baobaotao.proxy;  </div><div class="line">public class PerformanceMonitor &#123;  </div><div class="line">     //①通过一个ThreadLocal保存调用线程相关的性能监视信息  </div><div class="line">    private static ThreadLocal&lt;MethodPerformace&gt; performanceRecord =          </div><div class="line">                                new ThreadLocal&lt;MethodPerformance&gt;();  </div><div class="line">    //②启动对某一目标方法的性能监视  </div><div class="line">     public static void begin(String method) &#123;  </div><div class="line">        System.out.println(&quot;begin monitor...&quot;);  </div><div class="line">        MethodPerformance mp = new MethodPerformance(method);  </div><div class="line">        performanceRecord.set(mp);  </div><div class="line">    &#125;  </div><div class="line">    public static void end() &#123;  </div><div class="line">        System.out.println(&quot;end monitor...&quot;);  </div><div class="line">        MethodPerformance mp = performanceRecord.get();  </div><div class="line">         //③打印出方法性能监视的结果信息。  </div><div class="line">        mp.printPerformance();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ThreadLocal是将非线程安全类改造为线程安全类的法宝，在9.2节中我们将详细介绍这个Java基础知识。PerformanceMonitor提供了两个方法：通过调用begin(String method)方法开始对某个目标类方法的监视，method为目标类方法的全限定名；而end()方法结束对目标类方法的监视，并给出性能监视的信息。这两个方法必须配套使用。 </p>
<p>用于记录性能监视信息的MethodPerformance类的代码如所示： </p>
<p>代码清单6-4  MethodPerformance<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">package com.baobaotao.proxy;  </div><div class="line">public class MethodPerformance &#123;  </div><div class="line">    private long begin;  </div><div class="line">    private long end;  </div><div class="line">    private String serviceMethod;  </div><div class="line">    public MethodPerformance(String serviceMethod)&#123;  </div><div class="line">       this.serviceMethod = serviceMethod;  </div><div class="line">       //①记录目标类方法开始执行点的系统时间    </div><div class="line">       this.begin = System.currentTimeMillis();    </div><div class="line">    &#125;  </div><div class="line">    public void printPerformance()&#123;  </div><div class="line">        //②获取目标类方法执行完成后的系统时间，并进而计算出目标类方法执行时间  </div><div class="line">        end = System.currentTimeMillis();   </div><div class="line">        long elapse = end - begin;  </div><div class="line">        //③报告目标类方法的执行时间  </div><div class="line">        System.out.println(serviceMethod+&quot;花费&quot;+elapse+&quot;毫秒。&quot;);    </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过下面的代码测试拥有性能监视能力的ForumServiceImpl业务方法： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">package com.baobaotao.proxy; </div><div class="line">public class TestForumService &#123;  </div><div class="line">    public static void main(String[] args) &#123;  </div><div class="line">        ForumService forumService = new ForumServiceImpl();  </div><div class="line">        forumService .removeForum(10);  </div><div class="line">       forumService .removeTopic(1012);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们得到以下输出信息： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">begin monitor... ①removeForum(10)方法的性能监视报告 </div><div class="line">模拟删除Forum记录:10 </div><div class="line">end monitor... </div><div class="line">com.baobaotao.proxy.ForumServiceImpl.removeForum花费47毫秒。 </div><div class="line">begin monitor... ①removeTopic(1012)方法的性能监视报告 </div><div class="line">模拟删除Topic记录:1012 </div><div class="line">end monitor... </div><div class="line">com.baobaotao.proxy.ForumServiceImpl.removeTopic花费26毫秒。</div></pre></td></tr></table></figure>
<p>正如代码清单6 2实例所示，当某个方法需要进行性能监视，就必须调整方法代码，在方法体前后分别添加上开启性能监视和结束性能监视的代码。这些非业务逻辑的性能监视代码破坏了ForumServiceImpl业务逻辑的纯粹性。我们希望通过代理的方式，将业务类方法中开启和结束性能监视的这些横切代码从业务类中完全移除。并通过JDK动态代理技术或CGLib动态代理技术将横切代码动态织入到目标方法的相应位置。 </p>
<h3 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h3><p>JDK 1.3以后，Java提供了动态代理的技术，允许开发者在运行期创建接口的代理实例。在Sun刚推出动态代理时，还很难想象它有多大的实际用途，现在我们终于发现动态代理是实现AOP的绝好底层技术。 </p>
<p>JDK的动态代理主要涉及到java.lang.reflect包中的两个类：Proxy和InvocationHandler。其中InvocationHandler是一个接口，可以通过实现该接口定义横切逻辑，并通过反射机制调用目标类的代码，动态将横切逻辑和业务逻辑编织在一起。 </p>
<p>而Proxy利用InvocationHandler动态创建一个符合某一接口的实例，生成目标类的代理对象。这样讲一定很抽象，我们马上着手使用Proxy和InvocationHandler这两个魔法戒对上一节中的性能监视代码进行革新。 </p>
<p>首先，我们从业务类ForumServiceImpl中删除性能监视的横切代码，使ForumServiceImpl只负责具体的业务逻辑，如代码清单6-5所示： </p>
<p>代码清单6-5  ForumServiceImpl：移除性能监视横切代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">package com.baobaotao.proxy;   </div><div class="line">public class ForumServiceImpl implements ForumService &#123;  </div><div class="line">    public void removeTopic(int topicId) &#123;                                </div><div class="line">                             ①  </div><div class="line">        System.out.println(&quot;模拟删除Topic记录:&quot;+topicId);  </div><div class="line">        try &#123;  </div><div class="line">            Thread.currentThread().sleep(20);  </div><div class="line">        &#125; catch (Exception e) &#123;  </div><div class="line">            throw new RuntimeException(e);  </div><div class="line">        &#125;  </div><div class="line">                             ①  </div><div class="line">    &#125;  </div><div class="line">    public void removeForum(int forumId) &#123;  </div><div class="line">                          ②  </div><div class="line">        System.out.println(&quot;模拟删除Forum记录:&quot;+forumId);  </div><div class="line">        try &#123;  </div><div class="line">            Thread.currentThread().sleep(40);  </div><div class="line">        &#125; catch (Exception e) &#123;  </div><div class="line">            throw new RuntimeException(e);  </div><div class="line">        &#125;  </div><div class="line">                          ②  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在代码清单6-5中的①和②处，原来的性能监视代码被移除了，我们只保留了真正的业务逻辑。 </p>
<p>从业务类中移除的性能监视横切代码当然不能漂浮在空气中，它还得找到一个安身之所，InvocationHandler就是横切代码的安家乐园，我们将性能监视的代码安置在PerformanceHandler中，如代码清单6-6所示： </p>
<p>代码清单6-6  PerformanceHandler<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">package com.baobaotao.proxy;  </div><div class="line">import java.lang.reflect.InvocationHandler;  </div><div class="line">import java.lang.reflect.Method;  </div><div class="line">public class PerformanceHandler implements InvocationHandler &#123;//①实现InvocationHandler  </div><div class="line">    private Object target;  </div><div class="line">    public PerformanceHandler(Object target)&#123; //②target为目标的业务类  </div><div class="line">        this.target = target;  </div><div class="line">    &#125;  </div><div class="line">    public Object invoke(Object proxy, Method method, Object[] args) ③  </div><div class="line">            throws Throwable &#123;  </div><div class="line">        PerformanceMonitor.begin(target.getClass().getName()+&quot;.&quot;+ method. getName());③-1  </div><div class="line">        Object obj = method.invoke(target, args);// ③-2通过反射方法调用业务类的目标方法  </div><div class="line">        PerformanceMonitor.end();③-1  </div><div class="line">        return obj;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>③处invoke()方法中粗体所示部分的代码为性能监视的横切代码，我们发现，横切代码只出现一次，而不是原来那样星洒各处。③-2处的method.invoke()语句通过Java反射机制间接调用目标对象的方法，这样InvocationHandler的invoke()方法就将横切逻辑代码（③-1）和业务类方法的业务逻辑代码（③-2）编织到一起了，所以我们可以将InvocationHandler看成是一个编织器。下面，我们对这段代码做进一步的说明。 </p>
<p>首先，我们实现InvocationHandler接口，该接口定义了一个 invoke(Object proxy, Method method, Object[] args)的方法，proxy是最终生成的代理实例，一般不会用到；method是被代理目标实例的某个具体方法，通过它可以发起目标实例方法的反射调用；args是通过被代理实例某一个方法的入参，在方法反射调用时使用。 </p>
<p>此外，我们在构造函数里通过target传入希望被代理的目标对象，如②处所示，在InvocationHandler接口方法invoke(Object proxy, Method method, Object[] args)里，将目标实例传给method.invoke()方法，调用目标实例的方法，如③所示。<br>下面，我们通过Proxy结合PerformanceHandler创建ForumService接口的代理实例，如代码清单6-7所示： </p>
<p>代码清单6-7  TestForumService：创建代理实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">package com.baobaotao.proxy;  </div><div class="line">import java.lang.reflect.Proxy;  </div><div class="line">public class TestForumService &#123;  </div><div class="line">    public static void main(String[] args) &#123;                 </div><div class="line">               //①希望被代理的目标业务类  </div><div class="line">        ForumService target = new ForumServiceImpl();            </div><div class="line">               //②将目标业务类和横切代码编织到一起  </div><div class="line">        PerformanceHandler handler = new PerformanceHandler(target);  </div><div class="line">               //③根据编织了目标业务类逻辑和性能监视横切逻辑的InvocationHandler实例创建代理实例  </div><div class="line">        ForumService proxy = (ForumService) Proxy.newProxyInstance(    </div><div class="line">                target.getClass().getClassLoader(),  </div><div class="line">                target.getClass().getInterfaces(),  </div><div class="line">                handler);  </div><div class="line">               //④调用代理实例  </div><div class="line">        proxy.removeForum(10);     </div><div class="line">        proxy.removeTopic(1012);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的代码完成业务类代码和横切代码的编织工作并生成了代理实例。在②处，我们让PerformanceHandler将性能监视横切逻辑编织到ForumService实例中，然后在③处，通过Proxy的newProxyInstance()静态方法为编织了业务类逻辑和性能监视逻辑的handler创建一个符合ForumService接口的代理实例。该方法的第一个入参为类加载器；第二个入参为创建代理实例所需要实现的一组接口；第三个参数是整合了业务逻辑和横切逻辑的编织器对象。 </p>
<p>按照③处的设置方式，这个代理实例实现了目标业务类的所有接口，即Forum ServiceImpl的ForumService接口。这样，我们就可以按照调用ForumService接口实例相同的方式调用代理实例，如④所示。运行以上的代码，输出以下信息： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">begin monitor... </div><div class="line">模拟删除Forum记录:10 </div><div class="line">end monitor... </div><div class="line">com.baobaotao.proxy.ForumServiceImpl.removeForum花费47毫秒。 </div><div class="line">begin monitor... </div><div class="line">模拟删除Topic记录:1012 </div><div class="line">end monitor... </div><div class="line">com.baobaotao.proxy.ForumServiceImpl.removeTopic花费26毫秒。</div></pre></td></tr></table></figure>
<p>我们发现，程序的运行效果和直接在业务类中编写性能监视逻辑的效果一致，但是在这里，原来分散的横切逻辑代码已经被我们抽取到PerformanceHandler中。当其他业务类（如UserService、SystemService等）的业务方法也需要使用性能监视时，我们只要按照代码清单6-7相似的方式，分别为它们创建代理对象就可以了。下面，我们通过时序图描述通过创建代理对象进行业务方法调用的整体逻辑，以进一步认识代理对象的本质，如图6-3所示。 </p>
<p><img src="/images/图6-3 动态代理.jpg"></p>
<p>我们在上图中使用虚线的方式对通过Proxy创建的ForumService代理实例加以凸显，ForumService代理实例内部利用PerformaceHandler整合横切逻辑和业务逻辑。调用者调用代理对象的removeForum()和removeTopic()方法时，上图的内部调用时序清晰地告诉我们实际上所发生的一切。 </p>
<h4 id="CGLib动态代理"><a href="#CGLib动态代理" class="headerlink" title="CGLib动态代理"></a>CGLib动态代理</h4><p>使用JDK创建代理有一个限制，即它只能为接口创建代理实例，这一点我们可从Proxy的接口newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler h)的方法签名中就看得很清楚：第二个入参interfaces就是需要代理实例实现的接口列表。虽然面向接口编程的思想被很多大师级人物（包括Rod Johnson）推崇，但在实际开发中，许多开发者也对此深感困惑：难道对一个简单业务表的操作也需要老老实实地创建5个类（领域对象类、Dao接口，Dao实现类，Service接口和Service实现类）吗？难道不能直接通过实现类构建程序吗？对于这个问题，我们很难给出一个孰好孰劣的准确判断，但我们确实发现有很多不使用接口的项目也取得了非常好的效果（包括大家所熟悉的SpringSide开源项目）。 </p>
<p>对于没有通过接口定义业务方法的类，如何动态创建代理实例呢？JDK的代理技术显然已经黔驴技穷，CGLib作为一个替代者，填补了这个空缺。 </p>
<p>CGLib采用非常底层的字节码技术，可以为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，并顺势织入横切逻辑。下面，我们采用CGLib技术，编写一个可以为任何类创建织入性能监视横切逻辑代理对象的代理创建器，如代码清单 6-8所示： </p>
<p>代码清单6-8  CglibProxy<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">package com.baobaotao.proxy;  </div><div class="line">import java.lang.reflect.Method;  </div><div class="line">import net.sf.cglib.proxy.Enhancer;  </div><div class="line">import net.sf.cglib.proxy.MethodInterceptor;  </div><div class="line">import net.sf.cglib.proxy.MethodProxy;  </div><div class="line">public class CglibProxy implements MethodInterceptor &#123;  </div><div class="line">    private Enhancer enhancer = new Enhancer();  </div><div class="line">    public Object getProxy(Class clazz) &#123;  </div><div class="line">        enhancer.setSuperclass(clazz); //① 设置需要创建子类的类  </div><div class="line">        enhancer.setCallback(this);   </div><div class="line">        return enhancer.create(); //②通过字节码技术动态创建子类实例  </div><div class="line">    &#125;  </div><div class="line">        //③拦截父类所有方法的调用  </div><div class="line">    public Object intercept(Object obj, Method method, Object[] args,   </div><div class="line">            MethodProxy proxy) throws Throwable &#123;  </div><div class="line">        PerformanceMonitor.begin(obj.getClass().getName()+&quot;.&quot;+method. getName());//③-1  </div><div class="line">        Object result=proxy.invokeSuper(obj, args); ③-2   </div><div class="line">        PerformanceMonitor.end();//③-1通过代理类调用父类中的方法  </div><div class="line">        return result;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在上面代码中，用户可以通过getProxy(Class clazz)为一个类创建动态代理对象，该代理对象通过扩展clazz创建代理对象。在这个代理对象中，我们织入性能监视的横切逻辑（③-1）。intercept(Object obj, Method method, Object[] args,MethodProxy proxy)是CGLib定义的Interceptor接口的方法，它拦截所有目标类方法的调用，obj表示目标类的实例；method为目标类方法的反射对象；args为方法的动态入参；而proxy为代理类实例。 </p>
<p>下面，我们通过CglibProxy为ForumServiceImpl类创建代理对象，并测试代理对象的方法，如代码清单6-9所示： </p>
<p>代码清单6-9  TestForumService：测试Cglib创建的代理类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">package com.baobaotao.proxy;  </div><div class="line">import java.lang.reflect.Proxy;  </div><div class="line">public class TestForumService &#123;  </div><div class="line">    public static void main(String[] args) &#123;  </div><div class="line">      CglibProxy proxy = new CglibProxy();  </div><div class="line">      ForumServiceImpl forumService = ①   </div><div class="line">                (ForumServiceImpl )proxy.getProxy(ForumServiceImpl.class);  </div><div class="line">      forumService.removeForum(10);  </div><div class="line">      forumService.removeTopic(1023);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在①中，我们通过CglibProxy为ForumServiceImpl动态创建了一个织入性能监视逻辑的代理对象，并调用代理类的业务方法。运行上面的代码，输入以下信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">begin monitor... </div><div class="line">模拟删除Forum记录:10 </div><div class="line">end monitor... </div><div class="line">com.baobaotao.proxy.ForumServiceImpl$$EnhancerByCGLIB$$2a9199c0.removeForum花费47毫秒。 </div><div class="line">begin monitor... </div><div class="line">模拟删除Topic记录:1023 </div><div class="line">end monitor... </div><div class="line">com.baobaotao.proxy.ForumServiceImpl$$EnhancerByCGLIB$$2a9199c0.removeTopic花费16毫秒。</div></pre></td></tr></table></figure></p>
<p>观察以上的输出，除了发现两个业务方法中都织入了性能监控的逻辑外，我们还发现代理类的名字是com.baobaotao.proxy.ForumServiceImpl$$EnhancerByCGLIB$$2a9199c0，这个特殊的类就是CGLib为ForumServiceImpl动态创建的子类。 </p>
<h3 id="代理知识小结"><a href="#代理知识小结" class="headerlink" title="代理知识小结"></a>代理知识小结</h3><p>Spring AOP的底层就是通过使用JDK动态代理或CGLib动态代理技术为目标Bean织入横切逻辑。在这里，我们对前面两节动态创建代理对象作一个小结。 </p>
<p>我们虽然通过PerformanceHandler或CglibProxy实现了性能监视横切逻辑的动态织入，但这种实现方式存在三个明显需要改进的地方： </p>
<ul>
<li>目标类的所有方法都添加了性能监视横切逻辑，而有时，这并不是我们所期望的，我们可能只希望对业务类中的某些特定方法添加横切逻辑； </li>
<li>我们通过硬编码的方式指定了织入横切逻辑的织入点，即在目标类业务方法的开始和结束前织入代码； </li>
<li>我们手工编写代理实例的创建过程，为不同类创建代理时，需要分别编写相应的创建代码，无法做到通用。 </li>
</ul>
<p>以上三个问题，在AOP中占用重要的地位，因为Spring AOP的主要工作就是围绕以上三点展开：Spring AOP通过Pointcut（切点）指定在哪些类的哪些方法上织入横切逻辑，通过Advice（增强）描述横切逻辑和方法的具体织入点（方法前、方法后、方法的两端等）。此外，Spring通过Advisor（切面）将Pointcut和Advice两者组装起来。有了Advisor的信息，Spring就可以利用JDK或CGLib的动态代理技术采用统一的方式为目标Bean创建织入切面的代理对象了。 </p>
<p>JDK动态代理所创建的代理对象，在JDK 1.3下，性能强差人意。虽然在高版本的JDK中，动态代理对象的性能得到了很大的提高，但是有研究表明，CGLib所创建的动态代理对象的性能依旧比JDK的所创建的代理对象的性能高不少（大概10倍）。但CGLib在创建代理对象时所花费的时间却比JDK动态代理多（大概8倍），所以对于singleton的代理对象或者具有实例池的代理，因为无须频繁创建代理对象，所以比较适合用CGLib动态代理技术，反之适合用JDK动态代理技术。值得一提的是，由于CGLib采用动态创建子类的方式生成代理对象，所以不能对目标类中的final方法进行代理。 </p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java反射]]></title>
      <url>http://zsr.github.io/2016/08/01/Java%E5%8F%8D%E5%B0%84/</url>
      <content type="html"><![CDATA[<h1 id="Java反射"><a href="#Java反射" class="headerlink" title="Java反射"></a>Java反射</h1><hr>
<h6 id="Java语言允许通过程序化的方式间接对Class进行操作，Class文件由类装载器装载后，在JVM中将形成一份描述Class结构的元信息对象，通过该元信息对象可以获知Class的结构信息：如构造函数、属性和方法等。Java允许用户借由这个Class相关的元信息对象间接调用Class对象的功能，这就为使用程序化方式操作Class对象开辟了途径。"><a href="#Java语言允许通过程序化的方式间接对Class进行操作，Class文件由类装载器装载后，在JVM中将形成一份描述Class结构的元信息对象，通过该元信息对象可以获知Class的结构信息：如构造函数、属性和方法等。Java允许用户借由这个Class相关的元信息对象间接调用Class对象的功能，这就为使用程序化方式操作Class对象开辟了途径。" class="headerlink" title="Java语言允许通过程序化的方式间接对Class进行操作，Class文件由类装载器装载后，在JVM中将形成一份描述Class结构的元信息对象，通过该元信息对象可以获知Class的结构信息：如构造函数、属性和方法等。Java允许用户借由这个Class相关的元信息对象间接调用Class对象的功能，这就为使用程序化方式操作Class对象开辟了途径。"></a>Java语言允许通过程序化的方式间接对Class进行操作，Class文件由类装载器装载后，在JVM中将形成一份描述Class结构的元信息对象，通过该元信息对象可以获知Class的结构信息：如构造函数、属性和方法等。Java允许用户借由这个Class相关的元信息对象间接调用Class对象的功能，这就为使用程序化方式操作Class对象开辟了途径。</h6><h3 id="简单实例"><a href="#简单实例" class="headerlink" title="简单实例"></a>简单实例</h3><p>我们将从一个简单例子开始探访Java反射机制的征程，下面的Car类拥有两个构造函数、两个方法以及三个属性，如代码清单3-9所示： </p>
<p>代码清单3-9  Car<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.baobaotao.reflect;  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> String brand;  </div><div class="line">    <span class="keyword">private</span> String color;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSpeed; </div><div class="line">    <span class="comment">//①默认构造函数  </span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">()</span></span>&#123;&#125;  </div><div class="line">     <span class="comment">//②带参构造函数  </span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(String brand,String color,<span class="keyword">int</span> maxSpeed)</span></span>&#123;   </div><div class="line">        <span class="keyword">this</span>.brand = brand;  </div><div class="line">        <span class="keyword">this</span>.color = color;  </div><div class="line">        <span class="keyword">this</span>.maxSpeed = maxSpeed;  </div><div class="line">    &#125;  </div><div class="line">     <span class="comment">//③未带参的方法  </span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">introduce</span><span class="params">()</span> </span>&#123;   </div><div class="line">       System.out.println(<span class="string">"brand:"</span>+brand+<span class="string">";color:"</span>+color+<span class="string">";maxSpeed:"</span> +maxSpeed);  </div><div class="line">    &#125;  </div><div class="line">     <span class="comment">//省略参数的getter/Setter方法  </span></div><div class="line">     …  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>一般情况下，我们会使用如下的代码创建Car的实例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Car car = <span class="keyword">new</span> Car();  </div><div class="line">car.setBrand(<span class="string">"红旗CA72"</span>);</div></pre></td></tr></table></figure></p>
<p>或者：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Car car = new Car(&quot;红旗CA72&quot;,&quot;黑色&quot;);</div></pre></td></tr></table></figure></p>
<p>以上两种方法都采用传统方式的直接调用目标类的方法，下面我们通过Java反射机制以一种更加通用的方式间接地操作目标类：<br><a id="more"></a></p>
<p>代码清单3-10  ReflectTest<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.baobaotao. reflect;  </div><div class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;  </div><div class="line"><span class="keyword">import</span> java.lang.reflect.Field;  </div><div class="line"><span class="keyword">import</span> java.lang.reflect.Method;  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectTest</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car  <span class="title">initByDefaultConst</span><span class="params">()</span> <span class="keyword">throws</span> Throwable  </span></div><div class="line">    &#123;  </div><div class="line">        <span class="comment">//①通过类装载器获取Car类对象  </span></div><div class="line">        ClassLoader loader = Thread.currentThread().getContextClassLoader();   </div><div class="line">        Class clazz = loader.loadClass(<span class="string">"com.baobaotao.reflect.Car"</span>); </div><div class="line">        <span class="comment">//②获取类的默认构造器对象并通过它实例化Car  </span></div><div class="line">        Constructor cons = clazz.getDeclaredConstructor((Class[])<span class="keyword">null</span>);   </div><div class="line">        Car car = (Car)cons.newInstance();  </div><div class="line">        <span class="comment">//③通过反射方法设置属性  </span></div><div class="line">        Method setBrand = clazz.getMethod(<span class="string">"setBrand"</span>,String.class);          </div><div class="line">        setBrand.invoke(car,<span class="string">"红旗CA72"</span>);        </div><div class="line">        Method setColor = clazz.getMethod(<span class="string">"setColor"</span>,String.class);  </div><div class="line">        setColor.invoke(car,<span class="string">"黑色"</span>);        </div><div class="line">        Method setMaxSpeed = clazz.getMethod(<span class="string">"setMaxSpeed"</span>,<span class="keyword">int</span>.class);  </div><div class="line">        setMaxSpeed.invoke(car,<span class="number">200</span>);          </div><div class="line">        <span class="keyword">return</span> car;  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;  </div><div class="line">        Car car = initByDefaultConst();  </div><div class="line">        car.introduce();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行以上程序，在控制台上将打印出以下信息：<br>引用<br>brand:红旗CA72;color:黑色;maxSpeed:200</p>
<p>这说明我们完全可以通过编程方式调用Class的各项功能，这和直接通过构造函数和方法调用类功能的效果是一致的，只不过前者是间接调用，后者是直接调用罢了。 </p>
<p>在ReflectTest中，使用了几个重要的反射类，分别是ClassLoader、Class、Constructor和Method，通过这些反射类就可以间接调用目标Class的各项功能了。在①处，我们获取当前线程的ClassLoader，然后通过指定的全限定类“com.baobaotao.beans.Car”装载Car类对应的反射实例。在②处，我们通过Car的反射类对象获取Car的构造函数对象cons，通过构造函数对象的newInstrance()方法实例化Car对象，其效果等同于new Car()。在③处，我们又通过Car的反射类对象的getMethod（String methodName,Class paramClass）获取属性的Setter方法对象，第一个参数是目标Class的方法名；第二个参数是方法入参的对象类型。获取方法反射对象后，即可通过invoke（Object obj,Object param）方法调用目标类的方法，该方法的第一个参数是操作的目标类对象实例；第二个参数是目标方法的入参。 </p>
<p>在代码清单3 10中，粗体所示部分的信息即是通过反射方法操控目标类的元信息，如果我们将这些信息以一个配置文件的方式提供，就可以使用Java语言的反射功能编写一段通用的代码对类似于Car的类进行实例化及功能调用操作了。 </p>
<h3 id="类装载器ClassLoader"><a href="#类装载器ClassLoader" class="headerlink" title="类装载器ClassLoader"></a>类装载器ClassLoader</h3><h4 id="类装载器工作机制"><a href="#类装载器工作机制" class="headerlink" title="类装载器工作机制"></a>类装载器工作机制</h4><p>类装载器就是寻找类的节码文件并构造出类在JVM内部表示对象的组件。在Java中，类装载器把一个类装入JVM中，要经过以下步骤： </p>
<ul>
<li>装载：查找和导入Class文件； </li>
<li>链接：执行校验、准备和解析步骤，其中解析步骤是可以选择的： <ul>
<li>校验：检查载入Class文件数据的正确性； </li>
<li>准备：给类的静态变量分配存储空间； </li>
<li>解析：将符号引用转成直接引用； </li>
</ul>
</li>
<li>初始化：对类的静态变量、静态代码块执行初始化工作。 </li>
</ul>
<p>类装载工作由ClassLoader及其子类负责，ClassLoader是一个重要的Java运行时系统组件，它负责在运行时查找和装入Class字节码文件。JVM在运行时会产生三个ClassLoader：根装载器、ExtClassLoader（扩展类装载器）和AppClassLoader（系统类装载器）。其中，根装载器不是ClassLoader的子类，它使用C++编写，因此我们在Java中看不到它，根装载器负责装载JRE的核心类库，如JRE目标下的rt.jar、charsets.jar等。ExtClassLoader和AppClassLoader都是ClassLoader的子类。其中ExtClassLoader负责装载JRE扩展目录ext中的JAR类包；AppClassLoader负责装载Classpath路径下的类包。 </p>
<p>这三个类装载器之间存在父子层级关系，即根装载器是ExtClassLoader的父装载器，ExtClassLoader是AppClassLoader的父装载器。默认情况下，使用AppClassLoader装载应用程序的类，我们可以做一个实验： </p>
<p>代码清单3-11  ClassLoaderTest<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public class ClassLoaderTest &#123;  </div><div class="line">    public static void main(String[] args) &#123;  </div><div class="line">        ClassLoader loader = Thread.currentThread().getContextClassLoader();  </div><div class="line">        System.out.println(&quot;current loader:&quot;+loader);  </div><div class="line">        System.out.println(&quot;parent loader:&quot;+loader.getParent());  </div><div class="line">        System.out.println(&quot;grandparent loader:&quot;+loader.getParent(). getParent());  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行以上代码，在控制台上将打出以下信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">current loader:sun.misc.Launcher$AppClassLoader@131f71a </div><div class="line">parent loader:sun.misc.Launcher$ExtClassLoader@15601ea </div><div class="line"> //①根装载器在Java中访问不到，所以返回null </div><div class="line">grandparent loader:null</div></pre></td></tr></table></figure></p>
<p>通过以上的输出信息，我们知道当前的ClassLoader是AppClassLoader，父ClassLoader是ExtClassLoader，祖父ClassLoader是根类装载器，因为在Java中无法获得它的句柄，所以仅返回null。 </p>
<p>JVM装载类时使用“全盘负责委托机制”，“全盘负责”是指当一个ClassLoader装载一个类的时，除非显式地使用另一个ClassLoader，该类所依赖及引用的类也由这个ClassLoader载入；“委托机制”是指先委托父装载器寻找目标类，只有在找不到的情况下才从自己的类路径中查找并装载目标类。这一点是从安全角度考虑的，试想如果有人编写了一个恶意的基础类（如java.lang.String）并装载到JVM中将会引起多么可怕的后果。但是由于有了“全盘负责委托机制”，java.lang.String永远是由根装载器来装载的，这样就避免了上述事件的发生。 </p>
<h4 id="ClassLoader重要方法"><a href="#ClassLoader重要方法" class="headerlink" title="ClassLoader重要方法"></a>ClassLoader重要方法</h4><p>在Java中，ClassLoader是一个抽象类，位于java.lang包中。下面对该类的一些重要接口方法进行介绍： </p>
<ul>
<li><p>Class loadClass(String name)<br>  name参数指定类装载器需要装载类的名字，必须使用全限定类名，如com.baobaotao. beans.Car。该方法有一个重载方法loadClass(String name ,boolean resolve)，resolve参数告诉类装载器是否需要解析该类。在初始化类之前，应考虑进行类解析的工作，但并不是所有的类都需要解析，如果JVM只需要知道该类是否存在或找出该类的超类，那么就不需要进行解析。 </p>
</li>
<li><p>Class defineClass(String name, byte[] b, int off, int len)<br> 将类文件的字节数组转换成JVM内部的java.lang.Class对象。字节数组可以从本地文件系统、远程网络获取。name为字节数组对应的全限定类名。</p>
</li>
<li><p>Class findSystemClass(String name)<br> 从本地文件系统载入Class文件，如果本地文件系统不存在该Class文件，将抛出ClassNotFoundException异常。该方法是JVM默认使用的装载机制。 </p>
</li>
<li><p>Class findLoadedClass(String name)<br>调用该方法来查看ClassLoader是否已装入某个类。如果已装入，那么返回java.lang.Class对象，否则返回null。如果强行装载已存在的类，将会抛出链接错误。 </p>
</li>
<li><p>ClassLoader getParent()<br> 获取类装载器的父装载器，除根装载器外，所有的类装载器都有且仅有一个父装载器，ExtClassLoader的父装载器是根装载器，因为根装载器非Java编写，所以无法获得，将返回null。 </p>
</li>
</ul>
<p>除JVM默认的三个ClassLoader以外，可以编写自己的第三方类装载器，以实现一些特殊的需求。类文件被装载并解析后，在JVM内将拥有一个对应的java.lang.Class类描述对象，该类的实例都拥有指向这个类描述对象的引用，而类描述对象又拥有指向关联ClassLoader的引用，如图3-4所示。 </p>
<p><img src="/images/图3-4 类加载.jpg"></p>
<p>每一个类在JVM中都拥有一个对应的java.lang.Class对象，它提供了类结构信息的描述。数组、枚举、注解以及基本Java类型（如int、double等），甚至void都拥有对应的Class对象。Class没有public的构造方法。Class对象是在装载类时由JVM通过调用类装载器中的defineClass()方法自动构造的。 </p>
<h3 id="Java反射机制"><a href="#Java反射机制" class="headerlink" title="Java反射机制"></a>Java反射机制</h3><p>Class反射对象描述类语义结构，可以从Class对象中获取构造函数、成员变量、方法类等类元素的反射对象，并以编程的方式通过这些反射对象对目标类对象进行操作。这些反射对象类在java.reflect包中定义，下面是最主要的三个反射类： </p>
<ul>
<li><p>Constructor：类的构造函数反射类，通过Class#getConstructors()方法可以获得类的所有构造函数反射对象数组。在JDK5.0中，还可以通过getConstructor(Class… parameterTypes)获取拥有特定入参的构造函数反射对象。Constructor的一个主要方法是newInstance(Object[] initargs)，通过该方法可以创建一个对象类的实例，相当于new关键字。在JDK5.0中该方法演化为更为灵活的形式：newInstance (Object… initargs)。</p>
</li>
<li><p>Method：类方法的反射类，通过Class#getDeclaredMethods()方法可以获取类的所有方法反射类对象数组Method[]。在JDK5.0中可以通过getDeclaredMethod(String name, Class… parameterTypes)获取特定签名的方法，name为方法名；Class…为方法入参类型列表。Method最主要的方法是invoke(Object obj, Object[] args)，obj表示操作的目标对象；args为方法入参，代码清单3 10③处演示了这个反射类的使用方法。在JDK 5.0中，该方法的形式调整为invoke(Object obj, Object… args)。此外，Method还有很多用于获取类方法更多信息的方法：</p>
<pre><code>- Class getReturnType()：获取方法的返回值类型； 
- Class[] getParameterTypes()：获取方法的入参类型数组； 
- Class[] getExceptionTypes()：获取方法的异常类型数组； 
- Annotation[][] getParameterAnnotations()：获取方法的注解信息，JDK 5.0中的新方法；
</code></pre></li>
<li><p>Field：类的成员变量的反射类，通过Class#getDeclaredFields()方法可以获取类的成员变量反射对象数组，通过Class#getDeclaredField(String name)则可获取某个特定名称的成员变量反射对象。Field类最主要的方法是set(Object obj, Object value)，obj表示操作的目标对象，通过value为目标对象的成员变量设置值。如果成员变量为基础类型，用户可以使用Field类中提供的带类型名的值设置方法，如setBoolean(Object obj, boolean value)、setInt(Object obj, int value)等。</p>
</li>
</ul>
<p>此外，Java还为包提供了Package反射类，在JDK 5.0中还为注解提供了AnnotatedElement反射类。总之，Java的反射体系保证了可以通过程序化的方式访问目标类中所有的元素，对于private或protected的成员变量和方法，只要JVM的安全机制允许，也可以通过反射进行调用，请看下面的例子： </p>
<p>代码清单3-12  PrivateCarReflect<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">package com.baobaotao.reflect;  </div><div class="line">public class PrivateCar &#123;  </div><div class="line">   //①private成员变量：使用传统的类实例调用方式，只能在本类中访问  </div><div class="line">   private String color;   </div><div class="line">   //②protected方法：使用传统的类实例调用方式，只能在子类和本包中访问  </div><div class="line">   protected void drive()&#123;       </div><div class="line">		System.out.println(&quot;drive private car! the color is:&quot;+color);  </div><div class="line">   &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>color变量和drive()方法都是私有的，通过类实例变量无法在外部访问私有变量、调用私有方法的，但通过反射机制却可以绕过这个限制： </p>
<p>代码清单3-13  PrivateCarReflect<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">…  </div><div class="line">public class PrivateCarReflect &#123;  </div><div class="line">   public static void main(String[] args) throws Throwable&#123;  </div><div class="line">       ClassLoader loader = Thread.currentThread().getContextClassLoader();  </div><div class="line">       Class clazz = loader.loadClass(&quot;com.baobaotao.reflect.PrivateCar&quot;);  </div><div class="line">       PrivateCar pcar = (PrivateCar)clazz.newInstance();   </div><div class="line">       Field colorFld = clazz.getDeclaredField(&quot;color&quot;);  </div><div class="line">        //①取消Java语言访问检查以访问private变量  </div><div class="line">       colorFld.setAccessible(true);   </div><div class="line">       colorFld.set(pcar,&quot;红色&quot;);  </div><div class="line">       Method driveMtd = clazz.getDeclaredMethod(&quot;drive&quot;,(Class[])null);  </div><div class="line">        //Method driveMtd = clazz.getDeclaredMethod(&quot;drive&quot;); JDK5.0下使用  </div><div class="line">        //②取消Java语言访问检查以访问protected方法  </div><div class="line">       driveMtd.setAccessible(true);   </div><div class="line">       driveMtd.invoke(pcar,(Object[])null);  </div><div class="line">  &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行该类，打印出以下信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">drive private car! the color is:红色</div></pre></td></tr></table></figure></p>
<p>在访问private、protected成员变量和方法时必须通过setAccessible(boolean access)方法取消Java语言检查，否则将抛出IllegalAccessException。如果JVM的安全管理器设置了相应的安全机制，调用该方法将抛出SecurityException。 </p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[HashMap]]></title>
      <url>http://zsr.github.io/2016/08/01/HashMap/</url>
      <content type="html"><![CDATA[<h1 id="OpenJDK-源代码阅读之-HashMap"><a href="#OpenJDK-源代码阅读之-HashMap" class="headerlink" title="OpenJDK 源代码阅读之 HashMap"></a>OpenJDK 源代码阅读之 HashMap</h1><hr>
<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><ul>
<li>类继承关系</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">java.lang.Object</div><div class="line">    java.util.AbstractMap&lt;K,V&gt;</div><div class="line">        java.util.HashMap&lt;K,V&gt;</div></pre></td></tr></table></figure>
<ul>
<li>定义 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public class HashMap&lt;K,V&gt;</div><div class="line">extends AbstractMap&lt;K,V&gt;</div><div class="line">implements Map&lt;K,V&gt;, Cloneable, Serializable</div></pre></td></tr></table></figure>
<ul>
<li>核心成员变量</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;  <span class="comment">//默认装载因子</span></div><div class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;    <span class="comment">//装载因子</span></div><div class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;   <span class="comment">//数组，作为Hash桶</span></div></pre></td></tr></table></figure>
<ul>
<li>内部节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line">       <span class="keyword">final</span> <span class="keyword">int</span> hash;   <span class="comment">//hash值</span></div><div class="line">       <span class="keyword">final</span> K key;      <span class="comment">//键</span></div><div class="line">       V value;          <span class="comment">//值</span></div><div class="line">       Node&lt;K,V&gt; next;   <span class="comment">//指向hash值相同的下一个节点</span></div><div class="line"></div><div class="line">       Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</div><div class="line">           <span class="keyword">this</span>.hash = hash;</div><div class="line">           <span class="keyword">this</span>.key = key;</div><div class="line">           <span class="keyword">this</span>.value = value;</div><div class="line">           <span class="keyword">this</span>.next = next;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</div><div class="line"></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</div><div class="line">           <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</div><div class="line">           V oldValue = value;</div><div class="line">           value = newValue;</div><div class="line">           <span class="keyword">return</span> oldValue;</div><div class="line">       &#125;</div></pre></td></tr></table></figure>
<ul>
<li>要点</li>
</ul>
<p>1) 与 Hashtable 区别在于：非同步，允许 <code>null</code><br>2) 不保证次序，甚至不保证次序随时间不变<br>3) 基本操作 put, get 常量时间<br>4) 遍历操作 与 capacity+size 成正比<br>5) HashMap 性能与 <code>capacity</code> 和 <code>load factor</code> 相关，<code>load factor</code> 是当前元素个数与 <code>capacity</code> 的比值，通常设定为 <code>0.75</code>，如果此值过大，空间利用率高，但是冲突的可能性增加，因而可能导致查找时间增加，如果过小，反之。当元素个数大于 <code>capacity * load_factor</code> 时，<code>HashMap</code> 会重新安排 Hash 表。因此高效地使用 <code>HashMap</code> 需要预估元素个数，设置最佳的 <code>capacity</code> 和 <code>load factor</code> ，使得重新安排 Hash 表的次数下降。</p>
<a id="more"></a>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul>
<li>capacity</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</div><div class="line">                                           initialCapacity);</div><div class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</div><div class="line">        initialCapacity = MAXIMUM_CAPACITY;</div><div class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</div><div class="line">                                           loadFactor);</div><div class="line"></div><div class="line">    <span class="comment">// Find a power of 2 &gt;= initialCapacity</span></div><div class="line">    <span class="keyword">int</span> capacity = <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span> (capacity &lt; initialCapacity)</div><div class="line">        capacity &lt;&lt;= <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</div><div class="line">    threshold = (<span class="keyword">int</span>)Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</div><div class="line">    table = <span class="keyword">new</span> Entry[capacity];</div><div class="line">    useAltHashing = sun.misc.VM.isBooted() &amp;&amp;</div><div class="line">            (capacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);</div><div class="line">    init();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意，<code>HashMap</code> 并不会按照你指定的 <code>initialCapacity</code> 来确定 <code>capacity</code> 大小，而是会找到一个比它大的数，并且是 <code>2的n次方</code>（原因见末尾）。</p>
<ul>
<li>hash </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Retrieve object hash code and applies a supplemental hash function to the</div><div class="line"> * result hash, which defends against poor quality hash functions.  This is</div><div class="line"> * critical because HashMap uses power-of-two length hash tables, that</div><div class="line"> * otherwise encounter collisions for hashCodes that do not differ</div><div class="line"> * in lower bits. Note: Null keys always map to hash 0, thus index 0.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> h = <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (useAltHashing) &#123;</div><div class="line">        <span class="keyword">if</span> (k <span class="keyword">instanceof</span> String) &#123;</div><div class="line">            <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</div><div class="line">        &#125;</div><div class="line">        h = hashSeed;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    h ^= k.hashCode();</div><div class="line"></div><div class="line">    <span class="comment">// This function ensures that hashCodes that differ only by</span></div><div class="line">    <span class="comment">// constant multiples at each bit position have a bounded</span></div><div class="line">    <span class="comment">// number of collisions (approximately 8 at default load factor).</span></div><div class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</div><div class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果 <code>k</code> 是 <code>String</code> 类型，使用了特别的 <code>hash</code> 函数，否则首先得到 <code>hashCode</code>，然后又对 <code>h</code> 作了移位，异或操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">at 22: </div><div class="line">h = abcdefgh</div><div class="line">h1 = h &gt;&gt;&gt; 20 = 00000abc</div><div class="line">h2 = h &gt;&gt;&gt; 12 = 000abcde</div><div class="line">h3 = h1 ^ h2 = [0][0][0][a][b][a^c][b^d][c^e]</div><div class="line">h4 = h ^ h3 = [a][b][c][a^d][b^e][a^c^f][b^d^g][c^e^h]</div><div class="line">h5 = h4 &gt;&gt;&gt; 4 = [0][a][b][c][a^d][b^e][a^c^f][b^d^g]</div><div class="line">h6 = h4 &gt;&gt;&gt; 7 = ([0][:3])[0][0][a][b][c][a^d][b^e][a^c^f]([a^c^f][0])</div></pre></td></tr></table></figure>
<ul>
<li>put</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Associates the specified value with the specified key in this map.</div><div class="line"> * If the map previously contained a mapping for the key, the old</div><div class="line"> * value is replaced.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> key key with which the specified value is to be associated</div><div class="line"> * <span class="doctag">@param</span> value value to be associated with the specified key</div><div class="line"> * <span class="doctag">@return</span> the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</div><div class="line"> *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.</div><div class="line"> *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map</div><div class="line"> *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">return</span> putForNullKey(value);</div><div class="line">    <span class="keyword">int</span> hash = hash(key);</div><div class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</div><div class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</div><div class="line">        Object k;</div><div class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</div><div class="line">            V oldValue = e.value;</div><div class="line">            e.value = value;</div><div class="line">            e.recordAccess(<span class="keyword">this</span>);</div><div class="line">            <span class="keyword">return</span> oldValue;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    modCount++;</div><div class="line">    addEntry(hash, key, value, i);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从 <code>put</code> 其实可以看出各个 <code>hash</code> 表是如何实现的，首先取得 <code>hash</code> 值，然后由 <code>indexFor</code> 找到链表头的 <code>index</code>，然后开始遍历链表，如果链表里的一个元素 <code>hash</code> 值与当前 <code>key</code> 的 <code>hash</code> 值相同，或者元素 <code>key</code> 的引用与当前 <code>key</code> 相同，或者 <code>equals</code> 相同，就说明当前 <code>key</code> 已经在 <code>hash</code> 表里了，那么修改它的值，返回旧值。</p>
<p>如果不在表里，会调用 <code>addEntry</code>，将这一 <code>(key, value)</code> 对添加进去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Adds a new entry with the specified key, value and hash code to</div><div class="line"> * the specified bucket.  It is the responsibility of this</div><div class="line"> * method to resize the table if appropriate.</div><div class="line"> *</div><div class="line"> * Subclass overrides this to alter the behavior of put method.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</div><div class="line">        resize(<span class="number">2</span> * table.length);</div><div class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</div><div class="line">        bucketIndex = indexFor(hash, table.length);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    createEntry(hash, key, value, bucketIndex);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Like addEntry except that this version is used when creating entries</div><div class="line"> * as part of Map construction or "pseudo-construction" (cloning,</div><div class="line"> * deserialization).  This version needn't worry about resizing the table.</div><div class="line"> *</div><div class="line"> * Subclass overrides this to alter the behavior of HashMap(Map),</div><div class="line"> * clone, and readObject.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</div><div class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</div><div class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</div><div class="line">    size++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出，新增加元素时，可能会调整 <code>hash</code> 表的大小，原因之前已经讨论过。直接的添加在 <code>createEntry</code> 中完成，但是这里并没有体现出如何处理冲突。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Entry(<span class="keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</div><div class="line">    value = v;</div><div class="line">    next = n;</div><div class="line">    key = k;</div><div class="line">    hash = h;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意这里，将 <code>n</code> 赋值给了 <code>next</code>，这其实就是将新添加的项指向了当前链表头。这一操作在 <code>Entry</code> 的构造函数中完成。</p>
<p><code>put</code> 操作的基本思路在到这里已经很清楚了，有了这个思路，不难想象 <code>get</code> 是如何动作的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">return</span> getForNullKey();</div><div class="line">    Entry&lt;K,V&gt; entry = getEntry(key);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span> == entry ? <span class="keyword">null</span> : entry.getValue();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</div><div class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</div><div class="line">         e != <span class="keyword">null</span>;</div><div class="line">         e = e.next) &#123;</div><div class="line">        Object k;</div><div class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">            <span class="keyword">return</span> e;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>和 <code>put</code> 差不多，只是找到了就会返回相应的 <code>value</code> ，找不到就返回 <code>null</code>。</p>
<ul>
<li>HashMap的底层数组长度总是2的n次方 原因:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">    * Returns index for hash code h.</div><div class="line">    */</div><div class="line">   static int indexFor(int h, int length) &#123;</div><div class="line">   // assert Integer.bitCount(length) == 1 : &quot;length must be a non-zero power of 2&quot;;</div><div class="line">      return h &amp; (length-1);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>当length为2的n次方时，h&amp;(length - 1)就相当于对length取模，而且速度比直接取模快得多，这是HashMap在速度上的一个优化</p>
<p>indexFor方法，该方法仅有一条语句：h&amp;(length - 1)，这句话除了取模运算外还有一个非常重要的责任：均匀分布table数据和充分利用空间。</p>
<p>这里我们假设length为16(2^n)和15，h为5、6、7。</p>
<p><img src="/images/hashmap1-1.jpg"></p>
<p> 当n=15时，6和7的结果一样，这样表示他们在table存储的位置是相同的，也就是产生了碰撞，6、7就会在一个位置形成链表，这样就会导致查询速度降低。诚然这里只分析三个数字不是很多，那么我们就看0-15。</p>
<p><img src="/images/hashmap1-2.jpg"></p>
<p> 从上面的图表中看到总共发生了8此碰撞，同时发现浪费的空间非常大，有1、3、5、7、9、11、13、15处没有记录，也就是没有存放数据。这是因为他们在与14进行&amp;运算时，得到的结果最后一位永远都是0，即0001、0011、0101、0111、1001、1011、1101、1111位置处是不可能存储数据的，空间减少，进一步增加碰撞几率，这样就会导致查询速度慢。而当length = 16时，length – 1 = 15 即1111，那么进行低位&amp;运算时，值总是与原来hash值相同，而进行高位运算时，其值等于其低位值。所以说当length = 2^n时，不同的hash值发生碰撞的概率比较小，这样就会使得数据在table数组中分布较均匀，查询速度也较快。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[git使用小记]]></title>
      <url>http://zsr.github.io/2016/08/01/git%E4%BD%BF%E7%94%A8%E5%B0%8F%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h1 id="Git使用小记"><a href="#Git使用小记" class="headerlink" title="Git使用小记"></a>Git使用小记</h1><h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>我们写代码写完后总要进行管理，以前写的很多代码虽然写的不是很好，但因为没有一个比较好的代码管理习惯，所以很多都遗失掉了，为此现在都还觉得很可惜，近来在学习使用git来进行代码管理，git是一个很强大的分布式版本控制系统。</p>
<!--![git](git流程.png)-->
<p><img src="/images/git流程.png"></p>
<h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><h3 id="git工作流程"><a href="#git工作流程" class="headerlink" title="git工作流程"></a>git工作流程</h3><p>了解git，首先要弄清楚对象在被git管理过程中所处的4个阶段，分别是：工作目录、index(又称为暂存区)、本地仓库和远程仓库。</p>
<p>从时间先后来讲，工作目录的内容是你当前看到的，也是最新的；index区标记了你当前工作目录中，哪些内容是被git管理的；而本地仓库保存了对象被提交过的各个版本，比起工作目录和暂存区的内容，它要更旧一些；远程仓库是本地仓库的异地备份，远程仓库的内容可能被分布在多个地点的处于协作关系的本地仓库修改，因此它可能与本地仓库同步，也可能不同步，但是它的内容是最旧的。</p>
<p>任何对象都是在工作目录中诞生和被修改；任何修改都是从进入index区才开始被版本控制；只有把修改提交到本地仓库，该修改才能在仓库中留下痕迹；而要与协作者分享本地的修改，可以把它们push到远程仓库来共享。图最上方的add、commit、push等，展示了git仓库的产生过程。反过来，我们可以从远程历史仓库中获得本地仓库的最后一个版本，clone到本地，从本地检出对象的各个版本到index暂存区或工作目录中，从而实现任何对象或整个仓库的任意阶段状态的”回滚”。当正向和反向都能自由切换后，git就强大到无所不能了。<br><a id="more"></a></p>
<h3 id="远程仓库操作命令"><a href="#远程仓库操作命令" class="headerlink" title="远程仓库操作命令"></a>远程仓库操作命令</h3><ul>
<li><p>从远程仓库克隆仓库到本地：$ git clone git://github.com/**.git</p>
</li>
<li><p>查看远程仓库别名以及地址：$ git remote -v</p>
</li>
<li><p>添加远程仓库：$ git remote add [name] [url]</p>
</li>
<li><p>删除远程仓库：$ git remote rm [name]</p>
</li>
<li><p>修改远程仓库：$ git remote set-url –push [name] [newUrl]</p>
</li>
<li><p>拉取远程仓库：$ git pull [remoteName] [localBranchName]</p>
</li>
<li><p>推送远程仓库：$ git push [remoteName] [localBranchName]</p>
</li>
<li><p>提交本地test分支作为远程的master分支：$git push origin test:master</p>
</li>
<li><p>提交本地test分支作为远程的test分支：$git push origin test:test</p>
</li>
</ul>
<h3 id="分支操作命令–branch"><a href="#分支操作命令–branch" class="headerlink" title="分支操作命令–branch"></a>分支操作命令–branch</h3><ul>
<li><p>查看远程和本地所有分支：$ git branch -a</p>
</li>
<li><p>创建本地分支：$ git branch [name]</p>
</li>
<li><p>切换分支：$ git checkout [name]</p>
</li>
<li><p>创建新分支并且切换到新的分支：$ git check -b [name]</p>
</li>
<li><p>复制远程的分支并且以此来创建新分支：$ git check -t /remotes/origin/branch1 //这样就能在本地创建一个复制来自远程branch1分支</p>
</li>
<li><p>删除分支：$ git branch -d [name] //-d选项只能删除已经参与了合并的分支，对于未有合并的分支是无法删除的。如果想强制删除一个分支，可以使用-D选项</p>
</li>
<li><p>合并分支：$git merge [name] //将名称为[name]的分支与当前的分支合并</p>
</li>
<li><p>创建远程分支：(本地分支push到远程)：$ git push origin [name]</p>
</li>
<li><p>删除远程分支：$ git push origin :heads/[name] 或 $ git push origin :[name]</p>
</li>
</ul>
<h3 id="版本-tag-操作相关命令"><a href="#版本-tag-操作相关命令" class="headerlink" title="版本(tag)操作相关命令"></a>版本(tag)操作相关命令</h3><ul>
<li><p>查看版本：$ git tag</p>
</li>
<li><p>创建版本：$ git tag [name]</p>
</li>
<li><p>删除版本：$ git tag -d [name]</p>
</li>
<li><p>查看远程版本：$ git tag -r</p>
</li>
<li><p>创建远程版本(本地版本push到远程)：$ git push origin [name]</p>
</li>
<li><p>删除远程版本：$ git push origin :refs/tags/[name]</p>
</li>
<li><p>合并远程仓库的tag到本地：$ git pull origin –tags</p>
</li>
<li><p>上传本地tag到远程仓库：$ git push origin –tags</p>
</li>
<li><p>创建带注释的tag：$ git tag -a [name] -m ‘yourMessage’</p>
</li>
</ul>
<h3 id="子模块-submodule-相关操作命令"><a href="#子模块-submodule-相关操作命令" class="headerlink" title="子模块(submodule)相关操作命令"></a>子模块(submodule)相关操作命令</h3><ul>
<li><p>添加子模块：$ git submodule add [url] [path]</p>
</li>
<li><p>初始化子模块：$ git submodule init —-只在首次检出仓库时运行一次就行</p>
</li>
<li><p>更新子模块：$ git submodule update —-每次更新或切换分支后都需要运行一下</p>
</li>
<li><p>删除子模块：（分4步走哦）</p>
<ul>
<li><p>$ git rm –cached [path]</p>
</li>
<li><p>编辑“.gitmodules”文件，将子模块的相关配置节点删除掉</p>
</li>
<li><p>编辑“ .git/config”文件，将子模块的相关配置节点删除掉</p>
</li>
<li><p>手动删除子模块残留的目录</p>
</li>
</ul>
</li>
<li><p>忽略一些文件、文件夹不提交</p>
<ul>
<li>在仓库根目录下创建名称为“.gitignore”的文件，写入不需要的文件夹名或文件，每个元素占一行即可，如</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">target</div><div class="line">bin</div><div class="line">*.db</div></pre></td></tr></table></figure>
<ul>
<li><p>删除缓存区的文件</p>
<ul>
<li>不怎么进行删除操作，所以就常用这一个命令：$ git rm -r –cached .</li>
</ul>
</li>
</ul>
<h3 id="git撤销操作"><a href="#git撤销操作" class="headerlink" title="git撤销操作"></a>git撤销操作</h3><h5 id="撤销已暂存的操作"><a href="#撤销已暂存的操作" class="headerlink" title="撤销已暂存的操作"></a>撤销已暂存的操作</h5><p>对于一些已经被git add后的文件，如果想要撤销刚刚的操作，就要进行如下操作:</p>
<ul>
<li>首先查看一下本地有哪些已经被add但是还未commit的数据，</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git status</div></pre></td></tr></table></figure>
<ul>
<li>然后找到你要进行删掉的文件后，执行：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git reset HEAD filename</div></pre></td></tr></table></figure>
<h5 id="撤销commit"><a href="#撤销commit" class="headerlink" title="撤销commit"></a>撤销commit</h5><p>对于已经commit的数据，要回退的步骤为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git rm -r --cached</div></pre></td></tr></table></figure>
<h3 id="git-版本回退"><a href="#git-版本回退" class="headerlink" title="git 版本回退"></a>git 版本回退</h3><h5 id="关于版本回退略微有点小复杂，因为回退的版本涉及到两种情况，一种就是本地的版本回退，另一种则是本地和远程仓库都提交后的版本回退"><a href="#关于版本回退略微有点小复杂，因为回退的版本涉及到两种情况，一种就是本地的版本回退，另一种则是本地和远程仓库都提交后的版本回退" class="headerlink" title="关于版本回退略微有点小复杂，因为回退的版本涉及到两种情况，一种就是本地的版本回退，另一种则是本地和远程仓库都提交后的版本回退"></a>关于版本回退略微有点小复杂，因为回退的版本涉及到两种情况，一种就是本地的版本回退，另一种则是本地和远程仓库都提交后的版本回退</h5><p>1.先来说说本地的好了，本地的话就依次执行一下操作即可。</p>
<p>根据-soft,-mixed,-hard，会对working tree和index和HEAD进行重置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1.git reset -mixed：这种为默认方式，不带任何参数的git reset，它回退到某个版本，只保留源码，回退commit和index信息</div><div class="line">2.git reset -soft: 回退到某个版本，只回退了commit信息，不会恢复到index file一级。如果还要提交的话，直接commit即可。</div><div class="line">3.git reset -hard:彻底回退到某个版本，本地的源码也会变成上一个版本的内容，操作需要谨慎！！</div><div class="line">示例：</div><div class="line">* HEAD是指向最新的提交的，上一次的提交是HEAD^,上上次是HEAD^^,也可以写成HEAD~2,其中的--hard表示放弃所有本地改动</div><div class="line">git reset --hard HEAD^</div></pre></td></tr></table></figure></p>
<p>或者也可以回退倒指定的版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git reset --hard &lt;哈希值&gt;</div></pre></td></tr></table></figure>
<p>2.关于远程的话也得分情况了，如果远程仓库能够远程ssh上去的话那就比较简单了，方法和在本地一样了，但是如果ssh上不上去就不行了，这里我看到找到了两种方法：</p>
<ul>
<li>第一种就是比较暴力的方法，就是直接强制提交，git push -f,但是这个非常不推荐，除非你是自己一个人开发的小项目。</li>
<li>第二种就是先将远程分支备份好以后直接删除，然后再将本地的回滚后的版本的push到远程分支上，这样就等于回退了版本。</li>
</ul>
<h3 id="git-merge解冲突"><a href="#git-merge解冲突" class="headerlink" title="git merge解冲突"></a>git merge解冲突</h3><h5 id="在进行git管理时在对两个分支进行merge时难免会产生冲突，这时候就要对两个分支进行解冲突。"><a href="#在进行git管理时在对两个分支进行merge时难免会产生冲突，这时候就要对两个分支进行解冲突。" class="headerlink" title="在进行git管理时在对两个分支进行merge时难免会产生冲突，这时候就要对两个分支进行解冲突。"></a>在进行git管理时在对两个分支进行merge时难免会产生冲突，这时候就要对两个分支进行解冲突。</h5><p>这里假设有两个分支，一个是develop分支，一个是developby分支，develop分支是主要分支，这时候，我们可以 在developby分支里面运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git merge develop</div></pre></td></tr></table></figure>
<p>这样的话就将将develop中的内容merge到了developby分支中，如果没有冲突的话，merge完成，如果有冲突的话，运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git diff</div></pre></td></tr></table></figure>
<p>这样的话git会列出有冲突的文件，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</div><div class="line">printf (“test1″);</div><div class="line">=======</div><div class="line">printf (“test2″);</div><div class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; develop</div></pre></td></tr></table></figure>
<h5 id="接下来我们来讲解一下里面的符号各代表什么意思。"><a href="#接下来我们来讲解一下里面的符号各代表什么意思。" class="headerlink" title="接下来我们来讲解一下里面的符号各代表什么意思。"></a>接下来我们来讲解一下里面的符号各代表什么意思。</h5><p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; 标记冲突的开始，后面的内同是当前分支中的内容。</p>
<p>HEAD 指向当前分支末梢的提交。</p>
<p>=======之后，&gt;&gt;&gt;&gt;&gt;&gt;&gt;之前 是从develop分支上面merge过来的代码。&gt;&gt;&gt;&gt;&gt;&gt;&gt;之后跟的是要合并过来的分支的名称。</p>
<h5 id="然后我们就开始手动解冲突了"><a href="#然后我们就开始手动解冲突了" class="headerlink" title="然后我们就开始手动解冲突了"></a>然后我们就开始手动解冲突了</h5><p>这时候根据你的需要选择你要保留的是哪个分支上的代码，你要删除哪个分支上的代码，想要删除的代码就直接删掉就可以了，最后将多余符号删掉保存就可以了。</p>
<h3 id="一般的代码管理流程："><a href="#一般的代码管理流程：" class="headerlink" title="一般的代码管理流程："></a>一般的代码管理流程：</h3><ul>
<li><p>远程已经建完仓库后直接克隆到本地： $ git clone [仓库地址]</p>
</li>
<li><p>查看本地和远程的branch：$ git branch -a</p>
</li>
<li><p>如果远程的branch更新了的话运行：$ git fetch -p //这样会将远程的分支列表重新拉取</p>
</li>
<li><p>将远程的branch复制到本地并且切换到这个分支下面：$ git checkout -t [远程分支名字]</p>
</li>
<li><p>这是看到自己已经在新建的branch下面了，然后看一下有没有文件。</p>
</li>
<li><p>若没有的话试一下：$ git pull</p>
</li>
<li><p>做完修改以后的话先add：$ git add . //这样会将除了在.gitignore中写入的文件都加入进要提交的文件内</p>
</li>
<li><p>然后进行提交到本地仓库：$ git commit - m “提交”</p>
</li>
<li><p>可以查看状态：$ git status 或者 $git diff</p>
</li>
<li><p>如果没什么问题的话就进行提交到远程库： $ git push //如果加入-f的话是强制提交。</p>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ArrayList]]></title>
      <url>http://zsr.github.io/2016/07/29/ArrayList/</url>
      <content type="html"><![CDATA[<h1 id="OpenJDK-源码阅读之-ArrayList"><a href="#OpenJDK-源码阅读之-ArrayList" class="headerlink" title="OpenJDK 源码阅读之 ArrayList"></a>OpenJDK 源码阅读之 ArrayList</h1><hr>
<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><ul>
<li>类继承关系 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">java.lang.Object</div><div class="line">    java.util.AbstractCollection&lt;E&gt;</div><div class="line">        java.util.AbstractList&lt;E&gt;</div><div class="line">            java.util.ArrayList&lt;E&gt;</div></pre></td></tr></table></figure>
<ul>
<li>定义</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></div><div class="line">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></div><div class="line">&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul>
<li>transient</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[] elementData;</div></pre></td></tr></table></figure>
<p>声明为 <code>transient</code>后，这个字段不会被序列化。</p>
<ul>
<li>toArray</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Constructs a list containing the elements of the specified</div><div class="line"> * collection, in the order they are returned by the collection's</div><div class="line"> * iterator.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> c the collection whose elements are to be placed into this list</div><div class="line"> * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</div><div class="line">    elementData = c.toArray();</div><div class="line">    size = elementData.length;</div><div class="line">    <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></div><div class="line">    <span class="keyword">if</span> (elementData.getClass() != Object[].class)</div><div class="line">        elementData = Arrays.copyOf(elementData, size, Object[].class);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意对 <code>elementData</code> 的检查，<a href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6260652" target="_blank" rel="external">Bug 6260652</a>中对此有详细描述。主要原因是 <code>c.toArray()</code> 不一定会返回　<code>Object[]</code> 类型的值。</p>
<a id="more"></a>
<ul>
<li>SuppressWarnings</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">               ArrayList&lt;E&gt; v = (ArrayList&lt;E&gt;) <span class="keyword">super</span>.clone();</div></pre></td></tr></table></figure>
<p>告诉编译器，对特定类型的 <code>warning</code> 保持静默。</p>
<ul>
<li>参数检查</li>
</ul>
<p>可以看出标准库中的程序，在很多地方都需要对参数进行检查，以保证程序的健壮性。</p>
<p>检查 <code>null</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</div></pre></td></tr></table></figure>
<p>检查参数上界，下界</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">       <span class="comment">// overflow-conscious code</span></div><div class="line">       <span class="keyword">int</span> oldCapacity = elementData.length;</div><div class="line">       <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</div><div class="line">       <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</div><div class="line">           newCapacity = minCapacity;</div><div class="line">       <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</div><div class="line">           newCapacity = hugeCapacity(minCapacity);</div><div class="line">       <span class="comment">// minCapacity is usually close to size, so this is a win:</span></div><div class="line">       elementData = Arrays.copyOf(elementData, newCapacity);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<ul>
<li>ArrayList 的 index 检查</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">   <span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> (E) elementData[index];</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">       rangeCheck(index);</div><div class="line"></div><div class="line">       <span class="keyword">return</span> elementData(index);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (index &gt;= size)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>注意　<code>rangeCheck</code> 只检查了上界，但是如果将　<code>index</code> 设置成负数，也会抛出异常，异常是在 <code>elementData[index]</code> 中抛出的，猜想是在数组的实现中，对负数进行检查，因为任何一个数组，<code>index</code> 都不可能为负数，但是在实现数组时，不知道数组的元素个数，所以上界检查在此时发生。</p>
<ul>
<li>元素访问</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">   <span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> (E) elementData[index];</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>专门写了一个函数用来访问元素，而不是直接使用 <code>elementData[index]</code>，只因为需要向上转型么？还是 <code>SuppressWarning</code>　会重复。</p>
<ul>
<li>private</li>
</ul>
<p>对于仅仅在类内部使用的函数，要声明为 <code>private</code>。</p>
<ul>
<li>add 参数检查</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</div><div class="line">     rangeCheckForAdd(index);</div><div class="line"></div><div class="line">     ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></div><div class="line">     System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</div><div class="line">                      size - index);</div><div class="line">     elementData[index] = element;</div><div class="line">     size++;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">     <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</div><div class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>可以看出这里对　<code>index</code> 的上界和下界都检查了，虽然　<code>add</code> 的<code>7</code> 行会进行检查，但在 <code>add</code>　的 <code>4</code>, <code>5</code> 行中就已经可能出错。</p>
<ul>
<li>强制垃圾回收</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    rangeCheck(index);</div><div class="line"></div><div class="line">    modCount++;</div><div class="line">    E oldValue = elementData(index);</div><div class="line"></div><div class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</div><div class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</div><div class="line">                         numMoved);</div><div class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// Let gc do its work</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> oldValue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意第 <code>11</code>行把最后一个元素设置为<code>null</code>，这可以使得<code>gc</code>工作。好奇如何用实验验证这一点。</p>
<ul>
<li>remove(Object o)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</div><div class="line">            <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</div><div class="line">                fastRemove(index);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</div><div class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</div><div class="line">                fastRemove(index);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>整个框架与 <code>indexOf</code> 函数是相似的，注意那个 <code>fastRemove</code> 函数，它与 <code>remove(index)</code> 的不同在于它：</p>
<ol>
<li>是 <code>private</code></li>
<li>无参数检查，因为传给它的参数一定是合法的</li>
<li>不返回值</li>
</ol>
<p>由此细节可见，标准库中函数的精益求精。(不知道是不是我过度揣测了，有经过性能测试么？)</p>
<ul>
<li>batchRemove</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">batchRemove</span><span class="params">(Collection&lt;?&gt; c, <span class="keyword">boolean</span> complement)</span> </span>&#123;</div><div class="line">     <span class="keyword">final</span> Object[] elementData = <span class="keyword">this</span>.elementData;</div><div class="line">     <span class="keyword">int</span> r = <span class="number">0</span>, w = <span class="number">0</span>;</div><div class="line">     <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</div><div class="line">     <span class="keyword">try</span> &#123;</div><div class="line">         <span class="keyword">for</span> (; r &lt; size; r++)</div><div class="line">             <span class="keyword">if</span> (c.contains(elementData[r]) == complement)</div><div class="line">                 elementData[w++] = elementData[r];</div><div class="line">     &#125; <span class="keyword">finally</span> &#123;</div><div class="line">         <span class="comment">// Preserve behavioral compatibility with AbstractCollection,</span></div><div class="line">         <span class="comment">// even if c.contains() throws.</span></div><div class="line">         <span class="keyword">if</span> (r != size) &#123;</div><div class="line">             System.arraycopy(elementData, r,</div><div class="line">                              elementData, w,</div><div class="line">                              size - r);</div><div class="line">             w += size - r;</div><div class="line">         &#125;</div><div class="line">         <span class="keyword">if</span> (w != size) &#123;</div><div class="line">             <span class="keyword">for</span> (<span class="keyword">int</span> i = w; i &lt; size; i++)</div><div class="line">                 elementData[i] = <span class="keyword">null</span>;</div><div class="line">             modCount += size - w;</div><div class="line">             size = w;</div><div class="line">             modified = <span class="keyword">true</span>;</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> modified;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>注意 <code>finally</code> 里的代码，这段代码保证，即使 <code>try</code> 中的代码出了问题，也会最大程度上保证数据的一致性。如果 <code>r</code> 没有遍历完，那么后面没有检查过的数据都要保留下来。</p>
<ul>
<li>线程安全</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></div><div class="line">    <span class="keyword">throws</span> java.io.IOException&#123;</div><div class="line">    <span class="comment">// Write out element count, and any hidden stuff</span></div><div class="line">    <span class="keyword">int</span> expectedModCount = modCount;</div><div class="line">    s.defaultWriteObject();</div><div class="line"></div><div class="line">    <span class="comment">// Write out array length</span></div><div class="line">    s.writeInt(elementData.length);</div><div class="line"></div><div class="line">    <span class="comment">// Write out all elements in the proper order.</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++)</div><div class="line">        s.writeObject(elementData[i]);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意那个　<code>modCount</code> 的检查，这是为了确定在 <code>5-12</code>　行代码执行过程中，<code>List</code> 没有改变。改变的原因可能是由于多线程并发执行，在这期间另一个线程执行，改变了 <code>List</code> 的状态。</p>
<ul>
<li>容量扩充</li>
</ul>
<p>容量扩充会在任何可能引起　<code>ArrayList</code> 大小改变的情况下发生，如何扩充呢，代码在 <code>grow</code> 函数中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">     <span class="comment">// overflow-conscious code</span></div><div class="line">     <span class="keyword">int</span> oldCapacity = elementData.length;</div><div class="line">     <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</div><div class="line">     <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</div><div class="line">         newCapacity = minCapacity;</div><div class="line">     <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</div><div class="line">         newCapacity = hugeCapacity(minCapacity);</div><div class="line">     <span class="comment">// minCapacity is usually close to size, so this is a win:</span></div><div class="line">     elementData = Arrays.copyOf(elementData, newCapacity);</div><div class="line"> &#125;</div><div class="line"> </div><div class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">     <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></div><div class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</div><div class="line">     <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</div><div class="line">         Integer.MAX_VALUE :</div><div class="line">         MAX_ARRAY_SIZE;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>可以看出，<code>oldCapacity</code> 新增的容量是它的一半。另外，还有一个 <code>hugeCapacity</code>，如果需要扩充的容量比　<code>MAX_ARRAY_SIZE</code> 还大，会调用这个函数，重新调整大小。但再大也大不过　<code>Integer.MAX_VALUE</code>。</p>
<ul>
<li>元素位置调整</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</div><div class="line">    rangeCheckForAdd(index);</div><div class="line"></div><div class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></div><div class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</div><div class="line">                     size - index);</div><div class="line">    elementData[index] = element;</div><div class="line">    size++;</div><div class="line">&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    rangeCheck(index);</div><div class="line"></div><div class="line">    modCount++;</div><div class="line">    E oldValue = elementData(index);</div><div class="line"></div><div class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</div><div class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</div><div class="line">                         numMoved);</div><div class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// Let gc do its work</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> oldValue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>无论是增加元素还是删除元素，都可能使得很多元素的位置发生改变，这里就是用 <code>System.arraycopy</code> 来把大量元素放在其它位置，如果元素很多，经常需要调整，是很浪费时间的。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[java-coding-style]]></title>
      <url>http://zsr.github.io/2016/07/29/java-coding-style/</url>
      <content type="html"><![CDATA[<h1 id="Java编码风格"><a href="#Java编码风格" class="headerlink" title="Java编码风格"></a>Java编码风格</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这份文档源自Google Java编程风格规范，并根据我的想法，做了一些调整，当且仅当一个Java源文件符合此文档中的规则， 我们才认为它符合Ximalaya直播team的Java编程风格。</p>
<p>与其它的编程风格指南一样，这里所讨论的不仅仅是编码格式美不美观的问题， 同时也讨论一些约定及编码标准。然而，这份文档主要侧重于我们所普遍遵循的规则，对于那些不是强制要求的，我们尽量不提供意见。</p>
<h3 id="1-1-术语说明"><a href="#1-1-术语说明" class="headerlink" title="1.1 术语说明"></a>1.1 术语说明</h3><p>在本文档中，除非另有说明：</p>
<p>术语<code>class</code>可表示一个普通类，枚举类，接口或是annotation类型(@interface)<br>术语<code>comment</code>只用来指代实现的注释(implementation comments)，我们不使用“documentation comments”一词，而是用Javadoc。<br>其他的术语说明会偶尔在后面的文档出现。</p>
<h3 id="1-2-指南说明"><a href="#1-2-指南说明" class="headerlink" title="1.2 指南说明"></a>1.2 指南说明</h3><p>本文档中的示例代码并不作为规范。也就是说，虽然示例代码是遵循Ximalaya编程风格，但并不意味着这是展现这些代码的唯一方式。 示例中的格式选择不应该被强制定为规则。</p>
<a id="more"></a>
<h2 id="源文件基础"><a href="#源文件基础" class="headerlink" title="源文件基础"></a>源文件基础</h2><h3 id="2-1-文件名"><a href="#2-1-文件名" class="headerlink" title="2.1 文件名"></a>2.1 文件名</h3><p>源文件以其最顶层的类名来命名，大小写敏感，文件扩展名为<code>.java</code>。</p>
<h3 id="2-2-编码"><a href="#2-2-编码" class="headerlink" title="2.2 编码"></a>2.2 编码</h3><p>源文件编码格式为<code>UTF-8</code>。</p>
<h3 id="2-3-特殊字符"><a href="#2-3-特殊字符" class="headerlink" title="2.3 特殊字符"></a>2.3 特殊字符</h3><p>不要使用特殊字符。</p>
<h2 id="源文件结构"><a href="#源文件结构" class="headerlink" title="源文件结构"></a>源文件结构</h2><p>一个源文件包含(按顺序地)：</p>
<ul>
<li>许可证或版权信息</li>
<li>package语句</li>
<li>import语句</li>
<li>一个顶级类(只有一个)</li>
</ul>
<blockquote>
<p>以上每个部分之间用一个空行隔开。</p>
</blockquote>
<h3 id="3-1-许可证或版权信息"><a href="#3-1-许可证或版权信息" class="headerlink" title="3.1 许可证或版权信息"></a>3.1 许可证或版权信息</h3><p>如果一个文件包含许可证或版权信息，那么它应当被放在文件最前面。<br>公司版权信息如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * 文件名称: $&#123;filename&#125; Copyright 2011-2014 Ximalaya All right reserved.</div><div class="line"> */</div></pre></td></tr></table></figure>
<h3 id="3-2-package语句"><a href="#3-2-package语句" class="headerlink" title="3.2 package语句"></a>3.2 package语句</h3><p>package语句不换行，即package语句写在一行里。</p>
<h3 id="3-3-import语句"><a href="#3-3-import语句" class="headerlink" title="3.3 import语句"></a>3.3 import语句</h3><h4 id="3-3-1-import不要使用通配符"><a href="#3-3-1-import不要使用通配符" class="headerlink" title="3.3.1 import不要使用通配符"></a>3.3.1 import不要使用通配符</h4><p>即，不要出现类似这样的import语句：<code>import java.util.*;</code></p>
<h4 id="3-3-2-不要import静态变量和方法"><a href="#3-3-2-不要import静态变量和方法" class="headerlink" title="3.3.2 不要import静态变量和方法"></a>3.3.2 不要import静态变量和方法</h4><p>即，不要出现类似这样的import语句：<code>import static org.junit.Assert.fail;</code></p>
<h4 id="3-3-3-不要换行"><a href="#3-3-3-不要换行" class="headerlink" title="3.3.3 不要换行"></a>3.3.3 不要换行</h4><p>import语句不换行，即每个import语句独立成行。</p>
<h4 id="3-3-4-顺序和间距"><a href="#3-3-4-顺序和间距" class="headerlink" title="3.3.4 顺序和间距"></a>3.3.4 顺序和间距</h4><p>import语句可分为以下几组，按照这个顺序，每组由一个空行分隔：</p>
<p>每个顶级包为一组，字典序，组内不空行，按字典序排列。</p>
<h3 id="3-4-类声明"><a href="#3-4-类声明" class="headerlink" title="3.4 类声明"></a>3.4 类声明</h3><h4 id="3-4-1-只有一个顶级类声明"><a href="#3-4-1-只有一个顶级类声明" class="headerlink" title="3.4.1 只有一个顶级类声明"></a>3.4.1 只有一个顶级类声明</h4><p>每个顶级类都在一个与它同名的源文件中(当然，还包含.java后缀)。</p>
<p>例外：package-info.java，该文件中可没有package-info类。</p>
<h4 id="3-4-2-类成员顺序"><a href="#3-4-2-类成员顺序" class="headerlink" title="3.4.2 类成员顺序"></a>3.4.2 类成员顺序</h4><p>类的成员顺序对易学性有很大的影响，但这也不存在唯一的通用法则。不同的类对成员的排序可能是不同的。 最重要的一点，每个类应该以某种逻辑去排序它的成员，维护者应该要能解释这种排序逻辑。比如， 新的方法不能总是习惯性地添加到类的结尾，因为这样就是按时间顺序而非某种逻辑来排序的。</p>
<p>总的来说，按照<code>static</code>、<code>private</code>、<code>protected</code>等修饰符归类。</p>
<h5 id="3-4-2-1-重载：永不分离"><a href="#3-4-2-1-重载：永不分离" class="headerlink" title="3.4.2.1 重载：永不分离"></a>3.4.2.1 重载：永不分离</h5><p>当一个类有多个构造函数，或是多个同名方法，这些函数/方法应该按顺序出现在一起，中间不要放进其它函数/方法。</p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><p>术语说明：块状结构(block-like construct)指的是一个类，方法或构造函数的主体。需要注意的是，数组初始化中的初始值可被选择性地视为块状结构(4.8.3.1节)。</p>
<h3 id="4-1-大括号"><a href="#4-1-大括号" class="headerlink" title="4.1 大括号"></a>4.1 大括号</h3><h4 id="4-1-1-使用大括号-即使是可选的"><a href="#4-1-1-使用大括号-即使是可选的" class="headerlink" title="4.1.1 使用大括号(即使是可选的)"></a>4.1.1 使用大括号(即使是可选的)</h4><p>大括号与if, else, for, do, while语句一起使用，即使只有一条语句(或是空)，也应该把大括号写上。</p>
<h4 id="4-1-2-非空块：K-amp-R-风格"><a href="#4-1-2-非空块：K-amp-R-风格" class="headerlink" title="4.1.2 非空块：K &amp; R 风格"></a>4.1.2 非空块：K &amp; R 风格</h4><p>对于非空块和块状结构，大括号遵循Kernighan和Ritchie风格 (Egyptian brackets):</p>
<p>左大括号前不换行<br>左大括号后换行<br>右大括号前换行<br>如果右大括号是一个语句、函数体或类的终止，则右大括号后换行; 否则不换行。例如，如果右大括号后面是else或逗号，则不换行。<br>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">return new MyClass() &#123;</div><div class="line">  @Override public void method() &#123;</div><div class="line">    if (condition()) &#123;</div><div class="line">      try &#123;</div><div class="line">        something();</div><div class="line">      &#125; catch (ProblemException e) &#123;</div><div class="line">        recover();</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<blockquote>
<p>4.8.1节给出了enum类的一些例外。</p>
</blockquote>
<h4 id="4-1-3-空块：可以用简洁版本"><a href="#4-1-3-空块：可以用简洁版本" class="headerlink" title="4.1.3 空块：可以用简洁版本"></a>4.1.3 空块：可以用简洁版本</h4><p>一个空的块状结构里什么也不包含，大括号可以简洁地写成{}，不需要换行。例外：如果它是一个多块语句的一部分(if/else 或 try/catch/finally) ，即使大括号内没内容，右大括号也要换行。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void doNothing() &#123;&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>不过理论上不应该出现这样什么都不做的方法或if/else等。</p>
</blockquote>
<h3 id="4-2-块缩进：2个空格"><a href="#4-2-块缩进：2个空格" class="headerlink" title="4.2 块缩进：2个空格"></a>4.2 块缩进：2个空格</h3><p>每当开始一个新的块，缩进增加2个空格，当块结束时，缩进返回先前的缩进级别。缩进级别适用于代码和注释。(见4.1.2节中的代码示例)</p>
<h3 id="4-3-一行一个语句"><a href="#4-3-一行一个语句" class="headerlink" title="4.3 一行一个语句"></a>4.3 一行一个语句</h3><p>每个语句后要换行。</p>
<h3 id="4-4-列限制：100"><a href="#4-4-列限制：100" class="headerlink" title="4.4 列限制：100"></a>4.4 列限制：100</h3><p>一个项目可以选择一行100个字符的列限制，除了下述例外，任何一行如果超过这个字符数限制，必须自动换行。</p>
<p>例外：</p>
<p>不可能满足列限制的行(例如，Javadoc中的一个长URL，或是一个长的JSNI方法参考)。<br>package和import语句(见3.2节和3.3节)。<br>注释中那些可能被剪切并粘贴到shell中的命令行。</p>
<h3 id="4-5-自动换行"><a href="#4-5-自动换行" class="headerlink" title="4.5 自动换行"></a>4.5 自动换行</h3><p>术语说明：一般情况下，一行长代码为了避免超出列限制(80或100个字符)而被分为多行，我们称之为自动换行(line-wrapping)。</p>
<p>我们并没有全面，确定性的准则来决定在每一种情况下如何自动换行，我们通常通过使用统一的eclipse formatter来保证大家的换行格式统一，格式优美是首先要考虑的。</p>
<blockquote>
<p>Tip: 提取方法或局部变量可以在不换行的情况下解决代码过长的问题，或者合理缩短命名长度。</p>
</blockquote>
<h3 id="4-6-空白"><a href="#4-6-空白" class="headerlink" title="4.6 空白"></a>4.6 空白</h3><h4 id="4-6-1-垂直空白"><a href="#4-6-1-垂直空白" class="headerlink" title="4.6.1 垂直空白"></a>4.6.1 垂直空白</h4><p>以下情况需要使用一个空行：</p>
<p>类内连续的成员之间：</p>
<ul>
<li>字段</li>
<li>构造函数</li>
<li>方法</li>
<li>嵌套类</li>
<li>静态初始化块</li>
<li>实例初始化块</li>
</ul>
<p>例外：</p>
<ul>
<li><code>两个连续字段之间的空行是可选的</code>，用于字段的空行主要用来对字段进行逻辑分组。</li>
<li>在函数体内，语句根据业务逻辑分组。</li>
<li>类内的第一个成员前或最后一个成员后的空行是可选的(既不鼓励也不反对这样做，视个人喜好而定)。</li>
<li>要满足本文档中其他节的空行要求(比如3.3节：import语句)</li>
<li>多个连续的空行是允许的，但没有必要这样做(我们也不鼓励这样做)。</li>
</ul>
<h4 id="4-6-2-水平空白"><a href="#4-6-2-水平空白" class="headerlink" title="4.6.2 水平空白"></a>4.6.2 水平空白</h4><p>除了语言需求和其它规则，并且除了文字，注释和Javadoc用到单个空格，单个ASCII空格也出现在以下几个地方：</p>
<ul>
<li>分隔任何保留字与紧随其后的左括号(()(如if, for catch等)。</li>
<li>分隔任何保留字与其前面的右大括号(})(如else, catch)。</li>
<li>在任何左大括号前({)，两个例外：<ul>
<li>@SomeAnnotation({a, b})(不使用空格)。</li>
<li>String[][] x = foo;(大括号间没有空格，见下面的Note)。</li>
</ul>
</li>
<li>在任何二元或三元运算符的两侧。这也适用于以下“类运算符”符号：<ul>
<li>类型界限中的&amp;(<t extends="" foo="" &="" bar="">)。</t></li>
</ul>
</li>
<li>catch块中的管道符号(catch (FooException | BarException e)。</li>
<li>foreach语句中的分号。</li>
<li>在, : ;及右括号())后</li>
<li>如果在一条语句后做注释，则双斜杠(//)两边都要空格。这里可以允许多个空格，但没有必要。</li>
<li>类型和变量之间：List list。</li>
<li>数组初始化中，大括号内的空格是可选的，即new int[] {5, 6}和new int[] { 5, 6 }都是可以的。</li>
</ul>
<blockquote>
<p>Note：这个规则并不要求或禁止一行的开关或结尾需要额外的空格，只对内部空格做要求。</p>
</blockquote>
<h4 id="4-6-3-水平对齐：不建议"><a href="#4-6-3-水平对齐：不建议" class="headerlink" title="4.6.3 水平对齐：不建议"></a>4.6.3 水平对齐：不建议</h4><p>术语说明：水平对齐指的是通过增加可变数量的空格来使某一行的字符与上一行的相应字符对齐。</p>
<p>这是允许的(而且在不少地方可以看到这样的代码)，但Google编程风格对此不做要求。即使对于已经使用水平对齐的代码，我们也不需要去保持这种风格。</p>
<p>以下示例先展示未对齐的代码，然后是对齐的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">private int x; // this is fine</div><div class="line">private Color color; // this too</div><div class="line"></div><div class="line">private int   x;      // 不建议</div><div class="line">private Color color;  // 不建议</div></pre></td></tr></table></figure>
<blockquote>
<p>Tip：对齐可增加代码可读性，但它为日后的维护带来问题。考虑未来某个时候，我们需要修改一堆对齐的代码中的一行。 这可能导致原本很漂亮的对齐代码变得错位。很可能它会提示你调整周围代码的空白来使这一堆代码重新水平对齐(比如程序员想保持这种水平对齐的风格)， 这就会让你做许多的无用功，增加了reviewer的工作并且可能导致更多的合并冲突。</p>
</blockquote>
<h3 id="4-7-用小括号来限定组：推荐"><a href="#4-7-用小括号来限定组：推荐" class="headerlink" title="4.7 用小括号来限定组：推荐"></a>4.7 用小括号来限定组：推荐</h3><p>除非作者和reviewer都认为去掉小括号也不会使代码被误解，或是去掉小括号能让代码更易于阅读，否则我们不应该去掉小括号。 我们没有理由假设读者能记住整个Java运算符优先级表。</p>
<h3 id="4-8-具体结构"><a href="#4-8-具体结构" class="headerlink" title="4.8 具体结构"></a>4.8 具体结构</h3><h4 id="4-8-1-枚举类"><a href="#4-8-1-枚举类" class="headerlink" title="4.8.1 枚举类"></a>4.8.1 枚举类</h4><p>枚举常量间用逗号隔开，换行可选。</p>
<p>没有方法和文档的枚举类可写成数组初始化的格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">private enum Suit &#123; CLUBS, HEARTS, SPADES, DIAMONDS &#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>由于枚举类也是一个类，因此所有适用于其它类的格式规则也适用于枚举类。</p>
</blockquote>
<h4 id="4-8-2-变量声明"><a href="#4-8-2-变量声明" class="headerlink" title="4.8.2 变量声明"></a>4.8.2 变量声明</h4><h5 id="4-8-2-1-每次只声明一个变量"><a href="#4-8-2-1-每次只声明一个变量" class="headerlink" title="4.8.2.1 每次只声明一个变量"></a>4.8.2.1 每次只声明一个变量</h5><p>不要使用组合声明，比如<code>int a, b;</code>。</p>
<h5 id="4-8-2-2-需要时才声明，并尽快进行初始化"><a href="#4-8-2-2-需要时才声明，并尽快进行初始化" class="headerlink" title="4.8.2.2 需要时才声明，并尽快进行初始化"></a>4.8.2.2 需要时才声明，并尽快进行初始化</h5><p>不要在一个代码块的开头把局部变量一次性都声明了(这是c语言的做法)，而是在第一次需要使用它时才声明。 局部变量在声明时最好就进行初始化，或者声明后尽快进行初始化。</p>
<h4 id="4-8-3-数组"><a href="#4-8-3-数组" class="headerlink" title="4.8.3 数组"></a>4.8.3 数组</h4><h5 id="4-8-3-1-数组初始化：可写成块状结构"><a href="#4-8-3-1-数组初始化：可写成块状结构" class="headerlink" title="4.8.3.1 数组初始化：可写成块状结构"></a>4.8.3.1 数组初始化：可写成块状结构</h5><p>数组初始化可以写成块状结构，比如，下面的写法都是OK的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">new int[] &#123;</div><div class="line">  0, 1, 2, 3 </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">new int[] &#123;</div><div class="line">  0,</div><div class="line">  1,</div><div class="line">  2,</div><div class="line">  3</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">new int[] &#123;</div><div class="line">  0, 1,</div><div class="line">  2, 3</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">new int[]</div><div class="line">    &#123;0, 1, 2, 3&#125;</div></pre></td></tr></table></figure>
<h5 id="4-8-3-2-非C风格的数组声明"><a href="#4-8-3-2-非C风格的数组声明" class="headerlink" title="4.8.3.2 非C风格的数组声明"></a>4.8.3.2 非C风格的数组声明</h5><p>中括号是类型的一部分：String[] args， 而非String args[]。</p>
<h4 id="4-8-4-switch语句"><a href="#4-8-4-switch语句" class="headerlink" title="4.8.4 switch语句"></a>4.8.4 switch语句</h4><p>术语说明：switch块的大括号内是一个或多个语句组。每个语句组包含一个或多个switch标签(case FOO:或default:)，后面跟着一条或多条语句。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">switch (input) &#123;</div><div class="line">  case 1:</div><div class="line">  case 2:</div><div class="line">    handleOneTwoOr();</div><div class="line">    break;</div><div class="line">  case 3:</div><div class="line">    handleThree();</div><div class="line">    break;</div><div class="line">  default:</div><div class="line">    handleLargeNumber(input);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="4-8-4-1-缩进"><a href="#4-8-4-1-缩进" class="headerlink" title="4.8.4.1 缩进"></a>4.8.4.1 缩进</h5><p>与其它块状结构一致，switch块中的内容缩进为2个空格。</p>
<p>每个switch标签后新起一行，再缩进2个空格，写下一条或多条语句。</p>
<h5 id="4-8-4-2-default的情况要写出来"><a href="#4-8-4-2-default的情况要写出来" class="headerlink" title="4.8.4.2 default的情况要写出来"></a>4.8.4.2 default的情况要写出来</h5><p>每个switch语句都包含一个default语句组，即使它什么代码也不包含。</p>
<h4 id="4-8-5-注解-Annotations"><a href="#4-8-5-注解-Annotations" class="headerlink" title="4.8.5 注解(Annotations)"></a>4.8.5 注解(Annotations)</h4><p>注解紧跟在文档块后面，应用于类、方法和构造函数，一个注解独占一行。这些换行不属于自动换行(第4.5节，自动换行)，因此缩进级别不变。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">@Nullable</div><div class="line">public String getNameIfPresent() &#123; ... &#125;</div></pre></td></tr></table></figure>
<p>应用于字段的多个注解不允许与字段出现在同一行，并且一个注解独占一行。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@Partial </div><div class="line">@Mock </div><div class="line">DataLoader loader;</div></pre></td></tr></table></figure>
<p>参数和局部变量注解没有特定规则。</p>
<p>例外：应用于方法参数的注解<code>不用换行</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public String getNameIfPresent(@RequestParam String param) &#123; ... &#125;</div></pre></td></tr></table></figure>
<h4 id="4-8-6-注释"><a href="#4-8-6-注释" class="headerlink" title="4.8.6 注释"></a>4.8.6 注释</h4><h5 id="4-8-6-1-块注释风格"><a href="#4-8-6-1-块注释风格" class="headerlink" title="4.8.6.1 块注释风格"></a>4.8.6.1 块注释风格</h5><p>块注释与其周围的代码在同一缩进级别。它们可以是/<em> … </em>/风格，也可以是// …风格。对于多行的/<em> … </em>/注释，后续行必须从<em>开始， 并且与前一行的</em>对齐。以下示例注释都是OK的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * This is          // And so           /**  </div><div class="line"> * okay.            // is this.          * Or you can even do this.</div><div class="line"> */                                      */</div><div class="line">注释不要封闭在由星号或其它字符绘制的框架里。</div></pre></td></tr></table></figure>
<blockquote>
<p>Tip：在写多行注释时，如果你希望在必要时能重新换行(即注释像段落风格一样)，那么使用/<em> … </em>/。</p>
</blockquote>
<h5 id="4-8-6-2-被注释的代码"><a href="#4-8-6-2-被注释的代码" class="headerlink" title="4.8.6.2 被注释的代码"></a>4.8.6.2 被注释的代码</h5><p>有时可能出于某种原因某段代码被注释，那么在之后的10个commit内，建议移除。</p>
<h4 id="4-8-7-Modifiers"><a href="#4-8-7-Modifiers" class="headerlink" title="4.8.7 Modifiers"></a>4.8.7 Modifiers</h4><p>类和成员的modifiers如果存在，则按Java语言规范中推荐的顺序出现。</p>
<ul>
<li>public </li>
<li>protected </li>
<li>private </li>
<li>abstract </li>
<li>static </li>
<li>final </li>
<li>transient </li>
<li>volatile </li>
<li>synchronized </li>
<li>native </li>
<li>strictfp</li>
</ul>
<h2 id="命名约定"><a href="#命名约定" class="headerlink" title="命名约定"></a>命名约定</h2><h3 id="5-1-对所有标识符都通用的规则"><a href="#5-1-对所有标识符都通用的规则" class="headerlink" title="5.1 对所有标识符都通用的规则"></a>5.1 对所有标识符都通用的规则</h3><p>标识符只能使用ASCII字母和数字，因此每个有效的标识符名称都能匹配正则表达式\w+。</p>
<p>在Google其它编程语言风格中使用的特殊前缀或后缀，如name_, mName, s_name和kName，在Java编程风格中都不再使用。</p>
<h3 id="5-2-标识符类型的规则"><a href="#5-2-标识符类型的规则" class="headerlink" title="5.2 标识符类型的规则"></a>5.2 标识符类型的规则</h3><h4 id="5-2-1-包名"><a href="#5-2-1-包名" class="headerlink" title="5.2.1 包名"></a>5.2.1 包名</h4><p>包名全部小写，连续的单词只是简单地连接起来，不使用下划线。</p>
<h4 id="5-2-2-类名"><a href="#5-2-2-类名" class="headerlink" title="5.2.2 类名"></a>5.2.2 类名</h4><p>类名都以UpperCamelCase风格编写。</p>
<p>类名通常是名词或名词短语，接口名称有时可能是形容词或形容词短语。现在还没有特定的规则或行之有效的约定来命名注解类型。</p>
<p>测试类的命名以它要测试的类的名称开始，以Test结束。例如，HashTest或HashIntegrationTest。</p>
<h4 id="5-2-3-方法名"><a href="#5-2-3-方法名" class="headerlink" title="5.2.3 方法名"></a>5.2.3 方法名</h4><p>方法名都以lowerCamelCase风格编写。</p>
<p>方法名通常是动词或动词短语。</p>
<h4 id="5-2-4-常量名"><a href="#5-2-4-常量名" class="headerlink" title="5.2.4 常量名"></a>5.2.4 常量名</h4><p>常量名命名模式为CONSTANT_CASE，全部字母大写，用下划线分隔单词。那，到底什么算是一个常量？</p>
<p>每个常量都是一个静态final字段，但不是所有静态final字段都是常量。在决定一个字段是否是一个常量时， 考虑它是否真的感觉像是一个常量。例如，如果任何一个该实例的观测状态是可变的，则它几乎肯定不会是一个常量。 只是永远不打算改变对象一般是不够的，它要真的一直不变才能将它示为常量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// Constants</div><div class="line">static final int NUMBER = 5;</div><div class="line">static final ImmutableList&lt;String&gt; NAMES = ImmutableList.of(&quot;Ed&quot;, &quot;Ann&quot;);</div><div class="line">static final Joiner COMMA_JOINER = Joiner.on(&apos;,&apos;);  // because Joiner is immutable</div><div class="line">static final SomeMutableType[] EMPTY_ARRAY = &#123;&#125;;</div><div class="line">enum SomeEnum &#123; ENUM_CONSTANT &#125;</div><div class="line"></div><div class="line">// Not constants</div><div class="line">static String nonFinal = &quot;non-final&quot;;</div><div class="line">final String nonStatic = &quot;non-static&quot;;</div><div class="line">static final Set&lt;String&gt; mutableCollection = new HashSet&lt;String&gt;();</div><div class="line">static final ImmutableSet&lt;SomeMutableType&gt; mutableElements = ImmutableSet.of(mutable);</div><div class="line">static final Logger logger = Logger.getLogger(MyClass.getName());</div><div class="line">static final String[] nonEmptyArray = &#123;&quot;these&quot;, &quot;can&quot;, &quot;change&quot;&#125;;</div></pre></td></tr></table></figure>
<p>这些名字通常是名词或名词短语。</p>
<h4 id="5-2-5-非常量字段名"><a href="#5-2-5-非常量字段名" class="headerlink" title="5.2.5 非常量字段名"></a>5.2.5 非常量字段名</h4><p>非常量字段名以lowerCamelCase风格编写。</p>
<p>这些名字通常是名词或名词短语。</p>
<h4 id="5-2-6-参数名"><a href="#5-2-6-参数名" class="headerlink" title="5.2.6 参数名"></a>5.2.6 参数名</h4><p>参数名以lowerCamelCase风格编写。</p>
<p>参数应该避免用单个字符命名，并且要尽量容易理解。</p>
<h4 id="5-2-7-局部变量名"><a href="#5-2-7-局部变量名" class="headerlink" title="5.2.7 局部变量名"></a>5.2.7 局部变量名</h4><p>局部变量名以lowerCamelCase风格编写，比起其它类型的名称，局部变量名可以有更为宽松的缩写。</p>
<p>虽然缩写更宽松，但还是要避免用单字符进行命名，除了临时变量和循环变量。</p>
<p>即使局部变量是final和不可改变的，也不应该把它示为常量，自然也不能用常量的规则去命名它。</p>
<h4 id="5-2-8-类型变量名"><a href="#5-2-8-类型变量名" class="headerlink" title="5.2.8 类型变量名"></a>5.2.8 类型变量名</h4><p>类型变量可用以下两种风格之一进行命名：</p>
<p>单个或者多个的大写字母，后面可以跟一个数字(如：E, T, X, IN, OUT)。</p>
<h3 id="5-3-驼峰式命名法-CamelCase"><a href="#5-3-驼峰式命名法-CamelCase" class="headerlink" title="5.3 驼峰式命名法(CamelCase)"></a>5.3 驼峰式命名法(CamelCase)</h3><p>驼峰式命名法分大驼峰式命名法(UpperCamelCase)和小驼峰式命名法(lowerCamelCase)。 有时，我们有不只一种合理的方式将一个英语词组转换成驼峰形式，如缩略语或不寻常的结构(例如”IPv6”或”iOS”)。Google指定了以下的转换方案。</p>
<p>名字从散文形式(prose form)开始:</p>
<ul>
<li>把短语转换为纯ASCII码，并且移除任何单引号。例如：”Müller’s algorithm”将变成”Muellers algorithm”。</li>
<li>把这个结果切分成单词，在空格或其它标点符号(通常是连字符)处分割开。<ul>
<li>推荐：如果某个单词已经有了常用的驼峰表示形式，按它的组成将它分割开(如”AdWords”将分割成”ad words”)。 需要注意的是”iOS”并不是一个真正的驼峰表示形式，因此该推荐对它并不适用。</li>
</ul>
</li>
<li>现在将所有字母都小写(包括缩写)，然后将单词的第一个字母大写：<ul>
<li>每个单词的第一个字母都大写，来得到大驼峰式命名。</li>
<li>除了第一个单词，每个单词的第一个字母都大写，来得到小驼峰式命名。</li>
</ul>
</li>
<li>最后将所有的单词连接起来得到一个标识符。<br>示例：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Prose form                Correct               Incorrect</div><div class="line">------------------------------------------------------------------</div><div class="line">&quot;XML HTTP request&quot;        XmlHttpRequest        XMLHTTPRequest</div><div class="line">&quot;new customer ID&quot;         newCustomerId         newCustomerID</div><div class="line">&quot;inner stopwatch&quot;         innerStopwatch        innerStopWatch</div><div class="line">&quot;supports IPv6 on iOS?&quot;   supportsIpv6OnIos     supportsIPv6OnIOS</div><div class="line">&quot;YouTube importer&quot;        YouTubeImporter</div><div class="line">                          YoutubeImporter*</div></pre></td></tr></table></figure>
<p>加星号处表示可以，但不推荐。</p>
<blockquote>
<p>Note：在英语中，某些带有连字符的单词形式不唯一。例如：”nonempty”和”non-empty”都是正确的，因此方法名checkNonempty和checkNonEmpty也都是正确的。</p>
</blockquote>
<h2 id="编程实践"><a href="#编程实践" class="headerlink" title="编程实践"></a>编程实践</h2><h3 id="6-1-Override：能用则用"><a href="#6-1-Override：能用则用" class="headerlink" title="6.1 @Override：能用则用"></a>6.1 @Override：能用则用</h3><p>只要是合法的，就把@Override注解给用上。</p>
<h3 id="6-2-捕获的异常：不能忽视"><a href="#6-2-捕获的异常：不能忽视" class="headerlink" title="6.2 捕获的异常：不能忽视"></a>6.2 捕获的异常：不能忽视</h3><p>除了下面的例子，对捕获的异常不做响应是极少正确的。(典型的响应方式是打印日志，或者如果它被认为是不可能的，则把它当作一个AssertionError重新抛出。)</p>
<p>如果它确实是不需要在catch块中做任何响应，需要做注释加以说明(如下面的例子)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">try &#123;</div><div class="line">  int i = Integer.parseInt(response);</div><div class="line">  return handleNumericResponse(i);</div><div class="line">&#125; catch (NumberFormatException ok) &#123;</div><div class="line">  // it&apos;s not numeric; that&apos;s fine, just continue</div><div class="line">&#125;</div><div class="line">return handleTextResponse(response);</div></pre></td></tr></table></figure>
<p>例外：在测试中，如果一个捕获的异常被命名为expected，则它可以被不加注释地忽略。下面是一种非常常见的情形，用以确保所测试的方法会抛出一个期望中的异常， 因此在这里就没有必要加注释。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">try &#123;</div><div class="line">  emptyStack.pop();</div><div class="line">  fail();</div><div class="line">&#125; catch (NoSuchElementException expected) &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="6-3-静态成员：使用类进行调用"><a href="#6-3-静态成员：使用类进行调用" class="headerlink" title="6.3 静态成员：使用类进行调用"></a>6.3 静态成员：使用类进行调用</h3><p>使用类名调用静态的类成员，而不是具体某个对象或表达式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Foo aFoo = ...;</div><div class="line">Foo.aStaticMethod(); // good</div><div class="line">aFoo.aStaticMethod(); // bad</div><div class="line">somethingThatYieldsAFoo().aStaticMethod(); // very bad</div></pre></td></tr></table></figure>
<h3 id="6-4-Finalizers-禁用"><a href="#6-4-Finalizers-禁用" class="headerlink" title="6.4 Finalizers: 禁用"></a>6.4 Finalizers: 禁用</h3><p>极少会去重载Object.finalize。</p>
<blockquote>
<p>Tip：不要使用finalize。如果你非要使用它，请先仔细阅读和理解Effective Java 第7条款：“Avoid Finalizers”，然后不要使用它。</p>
</blockquote>
<h2 id="Javadoc"><a href="#Javadoc" class="headerlink" title="Javadoc"></a>Javadoc</h2><h3 id="7-1-格式"><a href="#7-1-格式" class="headerlink" title="7.1 格式"></a>7.1 格式</h3><h4 id="7-1-1-一般形式"><a href="#7-1-1-一般形式" class="headerlink" title="7.1.1 一般形式"></a>7.1.1 一般形式</h4><p>Javadoc块的基本格式如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Multiple lines of Javadoc text are written here,</div><div class="line"> * wrapped normally...</div><div class="line"> */</div><div class="line">public int method(String p1) &#123; ... &#125;</div></pre></td></tr></table></figure>
<p>或者是以下单行形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/** An especially short bit of Javadoc. */</div></pre></td></tr></table></figure>
<p>基本格式总是OK的。当整个Javadoc块能容纳于一行时(且没有Javadoc标记@XXX)，可以使用单行形式。</p>
<h4 id="7-1-2-段落"><a href="#7-1-2-段落" class="headerlink" title="7.1.2 段落"></a>7.1.2 段落</h4><p>空行(即，只包含最左侧星号的行)会出现在段落之间和Javadoc标记(@XXX)之前(如果有的话)。 除了第一个段落，每个段落第一个单词前都有标签</p><p>，并且它和第一个单词间没有空格。</p>
<h4 id="7-1-3-Javadoc标记"><a href="#7-1-3-Javadoc标记" class="headerlink" title="7.1.3 Javadoc标记"></a>7.1.3 Javadoc标记</h4><p>标准的Javadoc标记按以下顺序出现：<code>@param</code>, <code>@return</code>, <code>@throws</code>, <code>@deprecated</code>, 前面这4种标记如果出现，描述都不能为空。 当描述无法在一行中容纳，连续行需要至少再缩进4个空格。</p>
<h3 id="7-2-摘要片段"><a href="#7-2-摘要片段" class="headerlink" title="7.2 摘要片段"></a>7.2 摘要片段</h3><p>每个类或成员的Javadoc以一个简短的摘要片段开始。这个片段是非常重要的，在某些情况下，它是唯一出现的文本，比如在类和方法索引中。</p>
<p>这只是一个小片段，可以是一个名词短语或动词短语，但不是一个完整的句子。它不会以<code>A {@code Foo} is a...</code>或<code>This method returns...</code>开头, 它也不会是一个完整的祈使句，如<code>Save the record...</code>。然而，由于开头大写及被加了标点，它看起来就像是个完整的句子。</p>
<blockquote>
<p>Tip：一个常见的错误是把简单的Javadoc写成<code>/** @return the customer ID */</code>，这是不正确的。<br>它应该写成<code>/** Returns the customer ID. */</code>。</p>
</blockquote>
<h3 id="7-3-哪里需要使用Javadoc"><a href="#7-3-哪里需要使用Javadoc" class="headerlink" title="7.3 哪里需要使用Javadoc"></a>7.3 哪里需要使用Javadoc</h3><p>至少在每个public的<code>class</code>及它的每个public和protected成员处使用Javadoc，以下是一些例外：</p>
<h4 id="7-3-1-例外：不言自明的方法"><a href="#7-3-1-例外：不言自明的方法" class="headerlink" title="7.3.1 例外：不言自明的方法"></a>7.3.1 例外：不言自明的方法</h4><p>对于简单明显的方法如<code>getFoo</code>，Javadoc是可选的(即，是可以不写的)。这种情况下除了写“Returns the foo”，确实也没有什么值得写了。</p>
<blockquote>
<p>Tip：如果有一些相关信息是需要读者了解的，那么以上的例外不应作为忽视这些信息的理由。例如，对于方法名<code>getCanonicalName</code>， 就不应该忽视文档说明，因为读者很可能不知道词语canonical name指的是什么。</p>
</blockquote>
<h4 id="7-3-2-例外：重载"><a href="#7-3-2-例外：重载" class="headerlink" title="7.3.2 例外：重载"></a>7.3.2 例外：重载</h4><p>如果一个方法重载了超类中的方法，那么Javadoc并非必需的。</p>
<h4 id="7-3-3-可选的Javadoc"><a href="#7-3-3-可选的Javadoc" class="headerlink" title="7.3.3 可选的Javadoc"></a>7.3.3 可选的Javadoc</h4><p>对于包外不可见的类和方法，如有需要，也是要使用Javadoc的。如果一个注释是用来定义一个类，方法，字段的整体目的或行为， 那么这个注释应该写成Javadoc，这样更统一更友好。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://zsr.github.io/2016/07/26/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    </entry>
    
  
  
</search>
