<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="Develop Notes">
<meta property="og:type" content="website">
<meta property="og:title" content="Hello Coder">
<meta property="og:url" content="http://zsr.github.io/page/3/index.html">
<meta property="og:site_name" content="Hello Coder">
<meta property="og:description" content="Develop Notes">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hello Coder">
<meta name="twitter:description" content="Develop Notes">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://zsr.github.io/page/3/"/>

  <title> Hello Coder </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-81477846-1', 'auto');
  ga('send', 'pageview');
</script>









  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Hello Coder</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>


    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/12/04/Java-NIO-Selector详解/" itemprop="url">
                  Java NIO:Selector详解
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-12-04T14:44:01+08:00" content="2018-12-04">
              2018-12-04
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><code>Selector</code>事件分发器(单线程选择就绪的事件)作为Java NIO的核心组件，这里详细了解内部实现</p>
<h3 id="服务端代码"><a href="#服务端代码" class="headerlink" title="服务端代码"></a>服务端代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">ServerSocketChannel serverChannel = ServerSocketChannel.open();</div><div class="line">serverChannel.configureBlocking(<span class="keyword">false</span>);</div><div class="line">serverChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(port));</div><div class="line">Selector selector = Selector.open();</div><div class="line">serverChannel.register(selector, SelectionKey.OP_ACCEPT);</div><div class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">    selector.select();</div><div class="line">    Iterator iter = <span class="keyword">this</span>.selector.selectedKeys().iterator();</div><div class="line">    <span class="keyword">while</span>(iter.hasNext())&#123;</div><div class="line">        SelectionKey key = (SelectionKey)iter.next();</div><div class="line">        <span class="keyword">if</span> (key.isAcceptable())&#123;</div><div class="line">            SocketChannel clientChannel = ((ServerSocketChannel) key.channel()).accept();</div><div class="line">            clientChannel.configureBlocking(<span class="keyword">false</span>);</div><div class="line">            <span class="comment">// 监听客户端socket可读就绪事件</span></div><div class="line">            client.register(selector, SelectionKey.OP_READ);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (key.isReadable())&#123;</div><div class="line">            handleRead(key);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (key.isWritable() &amp;&amp; key.isValid())&#123;</div><div class="line">            handleWrite(key);</div><div class="line">        &#125;</div><div class="line">      iter.remove();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>如果有客户端A连接服务，执行<code>select</code>方法时，可以通过<code>serverSocketChannel</code>获取客户端A的<code>socketChannel</code>，并在<code>selector</code>上注册<code>socketChannel</code>的<code>OP_READ</code>事件。</li>
<li>如果客户端A发送数据，会触发<code>OP_READ</code>事件，这样下次轮询调用<code>select</code>方法时，就能通过<code>socketChannel</code>读取数据，同时在<code>selector</code>上注册该<code>socketChannel</code>的<code>OP_WRITE</code>事件，实现服务器往客户端写数据。</li>
</ol>
<h3 id="Selector-open-实现原理"><a href="#Selector-open-实现原理" class="headerlink" title="Selector.open()实现原理"></a><code>Selector.open()</code>实现原理</h3><p><strong>注意：以下源代码皆来源于<code>openjdk8</code></strong></p>
<ul>
<li><code>Selector.open()</code>可以得到一个<code>Selector</code>实例</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Selector <span class="title">open</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="comment">// 首先找到provider,然后再打开Selector</span></div><div class="line">    <span class="keyword">return</span> SelectorProvider.provider().openSelector();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// java.nio.channels.spi.SelectorProvider</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SelectorProvider <span class="title">provider</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">synchronized</span> (lock) &#123;</div><div class="line">        <span class="keyword">if</span> (provider != <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span> provider;</div><div class="line">        <span class="keyword">return</span> AccessController.doPrivileged(</div><div class="line">            <span class="keyword">new</span> PrivilegedAction&lt;SelectorProvider&gt;() &#123;</div><div class="line">                <span class="function"><span class="keyword">public</span> SelectorProvider <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                        <span class="keyword">if</span> (loadProviderFromProperty())</div><div class="line">                            <span class="keyword">return</span> provider;</div><div class="line">                        <span class="keyword">if</span> (loadProviderAsService())</div><div class="line">                            <span class="keyword">return</span> provider;</div><div class="line">                            <span class="comment">// 实际创建SelectorProvider的方法</span></div><div class="line">                        provider = sun.nio.ch.DefaultSelectorProvider.create();</div><div class="line">                        <span class="keyword">return</span> provider;</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>sun.nio.ch.DefaultSelectorProvider</code></li>
</ul>
<p>不同系统对应着不同的<code>sun.nio.ch.DefaultSelectorProvider</code>，以<code>Linux</code>为例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Returns the default SelectorProvider.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SelectorProvider <span class="title">create</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 获取OS名称</span></div><div class="line">    String osname = AccessController</div><div class="line">        .doPrivileged(<span class="keyword">new</span> GetPropertyAction(<span class="string">"os.name"</span>));</div><div class="line">    <span class="comment">// 根据名称来创建不同的Selctor</span></div><div class="line">    <span class="keyword">if</span> (osname.equals(<span class="string">"SunOS"</span>))</div><div class="line">        <span class="keyword">return</span> createProvider(<span class="string">"sun.nio.ch.DevPollSelectorProvider"</span>);</div><div class="line">    <span class="keyword">if</span> (osname.equals(<span class="string">"Linux"</span>))</div><div class="line">        <span class="keyword">return</span> createProvider(<span class="string">"sun.nio.ch.EPollSelectorProvider"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> sun.nio.ch.PollSelectorProvider();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果系统名称是<code>Linux</code>的话，真正创建的是<code>sun.nio.ch.EPollSelectorProvider</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// EPollSelectorProvider.openSelector()</span></div><div class="line"><span class="function"><span class="keyword">public</span> AbstractSelector <span class="title">openSelector</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> EPollSelectorImpl(<span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Linux</code>最终的<code>Selector</code>实现:<code>sun.nio.ch.EPollSelectorImpl</code></p>
<h3 id="EPollSelectorImpl-select-实现原理"><a href="#EPollSelectorImpl-select-实现原理" class="headerlink" title="EPollSelectorImpl.select()实现原理"></a><code>EPollSelectorImpl.select()</code>实现原理</h3><p><code>epoll</code>系统调用主要分为3个函数: <code>epoll_create</code>, <code>epoll_ctl</code>, <code>epoll_wait</code></p>
<h4 id="epoll-create：创建一个epoll-fd"><a href="#epoll-create：创建一个epoll-fd" class="headerlink" title="epoll_create：创建一个epoll fd"></a><code>epoll_create</code>：创建一个<code>epoll fd</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// class EPollSelectorImpl extends SelectorImpl</span></div><div class="line">EPollSelectorImpl(SelectorProvider sp) <span class="keyword">throws</span> IOException &#123;</div><div class="line">        <span class="keyword">super</span>(sp);</div><div class="line">        <span class="comment">// makePipe返回管道的2个文件描述符，编码在一个long类型的变量中</span></div><div class="line">        <span class="comment">// 高32位代表读 低32位代表写</span></div><div class="line">        <span class="comment">// 使用pipe为了实现Selector的wakeup逻辑</span></div><div class="line">        <span class="keyword">long</span> pipeFds = IOUtil.makePipe(<span class="keyword">false</span>);</div><div class="line">        fd0 = (<span class="keyword">int</span>) (pipeFds &gt;&gt;&gt; <span class="number">32</span>);</div><div class="line">        fd1 = (<span class="keyword">int</span>) pipeFds;</div><div class="line">        <span class="comment">// 创建一个EPollArrayWrapper</span></div><div class="line">        pollWrapper = <span class="keyword">new</span> EPollArrayWrapper();</div><div class="line">        pollWrapper.initInterrupt(fd0, fd1);</div><div class="line">        fdToKey = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p> 创建一个<code>EPollArrayWrapper</code> 初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">EPollArrayWrapper() <span class="keyword">throws</span> IOException &#123;</div><div class="line">    <span class="comment">// 创建epoll fd</span></div><div class="line">    epfd = epollCreate();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">epollCreate</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure>
<p>在初始化过程中调用了<code>native epollCreate</code>方法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Java_sun_nio_ch_EPollArrayWrapper_epollCreate(JNIEnv *env, jobject <span class="keyword">this</span>)</div><div class="line">&#123;</div><div class="line">     <span class="comment">//从Linux2.6.8之后，改用了红黑树结构，指定了大小也没用</span></div><div class="line">    <span class="keyword">int</span> epfd = epoll_create(<span class="number">256</span>);</div><div class="line">    <span class="keyword">if</span> (epfd &lt; <span class="number">0</span>) &#123;</div><div class="line">       JNU_ThrowIOExceptionWithLastError(env, <span class="string">"epoll_create failed"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> epfd;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><code>epoll_create</code>: 内核系统调用，创建一个<code>epoll fd</code>, 并且开辟epoll自己的内核高速cache区，建立红黑树分配初始size的内存对象，同时建立一个list链表，用于存储准备就绪的事件</strong></p>
<h4 id="Epoll-wait-等待内核IO事件"><a href="#Epoll-wait-等待内核IO事件" class="headerlink" title="Epoll wait:等待内核IO事件"></a><code>Epoll wait</code>:等待内核IO事件</h4><p>调用<code>Selector.select()</code>,最后会委托给<code>EPollSelectorImpl</code>的<code>doSelect()</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doSelect</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="keyword">if</span> (closed)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClosedSelectorException();</div><div class="line">    processDeregisterQueue();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        begin();</div><div class="line">        <span class="comment">// 等待事件到来，收集事件到来的fd并用来处理</span></div><div class="line">        pollWrapper.poll(timeout);</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        end();</div><div class="line">    &#125;</div><div class="line">    processDeregisterQueue();</div><div class="line">    <span class="keyword">int</span> numKeysUpdated = updateSelectedKeys();</div><div class="line">  </div><div class="line">    <span class="keyword">if</span> (pollWrapper.interrupted()) &#123;</div><div class="line">        <span class="comment">// Clear the wakeup pipe</span></div><div class="line">        pollWrapper.putEventOps(pollWrapper.interruptedIndex(), <span class="number">0</span>);</div><div class="line">        <span class="keyword">synchronized</span> (interruptLock) &#123;</div><div class="line">            pollWrapper.clearInterrupted();</div><div class="line">            IOUtil.drain(fd0);</div><div class="line">            interruptTriggered = <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> numKeysUpdated;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实际执行<code>EPollArrayWrapper.poll(timeout);</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="comment">// 看下文</span></div><div class="line">    updateRegistrations();</div><div class="line">    <span class="comment">// 调用native方法，发起系统内核调用</span></div><div class="line">    updated = epollWait(pollArrayAddress, NUM_EPOLLEVENTS, timeout, epfd);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;updated; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (getDescriptor(i) == incomingInterruptFD) &#123;</div><div class="line">            interruptedIndex = i;</div><div class="line">            interrupted = <span class="keyword">true</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> updated;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">epollWait</span><span class="params">(<span class="keyword">long</span> pollAddress, <span class="keyword">int</span> numfds, <span class="keyword">long</span> timeout,</span></span></div><div class="line">                             <span class="keyword">int</span> epfd) <span class="keyword">throws</span> IOException;</div></pre></td></tr></table></figure>
<p><code>epollWait</code>也是个<code>native</code>方法:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">Java_sun_nio_ch_EPollArrayWrapper_epollWait(JNIEnv *env, jobject <span class="keyword">this</span>,</div><div class="line">                                            jlong address, jint numfds,</div><div class="line">                                            jlong timeout, jint epfd)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">struct</span> epoll_event *events = jlong_to_ptr(address);</div><div class="line">    <span class="keyword">int</span> res;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (timeout &lt;= <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// 发起epoll_wait系统调用等待内核事件</span></div><div class="line">        RESTARTABLE(epoll_wait(epfd, events, numfds, timeout), res);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        res = iepoll(epfd, events, numfds, timeout);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</div><div class="line">        JNU_ThrowIOExceptionWithLastError(env, <span class="string">"epoll_wait failed"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><code>epoll_wait</code>: 内核系统调用, 等待内核返回IO事件</strong></p>
<h4 id="epoll-ctl-IO事件管理"><a href="#epoll-ctl-IO事件管理" class="headerlink" title="epoll_ctl: IO事件管理"></a><code>epoll_ctl</code>: IO事件管理</h4><p>注册到<code>Selector</code>上的IO事件是使用<code>SelectionKey</code>来表示，代表了<code>Channel</code>感兴趣的事件，如<code>Read</code>,<code>Write</code>,<code>Connect</code>,<code>Accept</code>.</p>
<p>调用<code>Selector.register()</code>完成IO事件注册，实际执行<code>EPollSelectorImpl.implRegister()</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">implRegister</span><span class="params">(SelectionKeyImpl ski)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (closed)</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> ClosedSelectorException();</div><div class="line">       SelChImpl ch = ski.channel;</div><div class="line">       <span class="keyword">int</span> fd = Integer.valueOf(ch.getFDVal());</div><div class="line">       fdToKey.put(fd, ski);</div><div class="line">       pollWrapper.add(fd);</div><div class="line">       keys.add(ski);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>调用<code>Selector.register()</code>时均会将事件存储到<code>EpollArrayWrapper</code>的成员变量<code>eventsLow</code>和<code>eventsHigh</code>中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 使用数组保存事件变更, 数组的最大长度是MAX_UPDATE_ARRAY_SIZE, 最大64*1024</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] eventsLow = <span class="keyword">new</span> <span class="keyword">byte</span>[MAX_UPDATE_ARRAY_SIZE];</div><div class="line"><span class="comment">// 超过数组长度的事件会缓存到这个map中，等待下次处理</span></div><div class="line"><span class="keyword">private</span> Map&lt;Integer,Byte&gt; eventsHigh;</div><div class="line"></div><div class="line"><span class="comment">// 添加文件描述符fd</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</div><div class="line">        <span class="comment">// force the initial update events to 0 as it may be KILLED by a</span></div><div class="line">        <span class="comment">// previous registration.</span></div><div class="line">        <span class="keyword">synchronized</span> (updateLock) &#123;</div><div class="line">            <span class="keyword">assert</span> !registered.get(fd);</div><div class="line">            setUpdateEvents(fd, (<span class="keyword">byte</span>)<span class="number">0</span>, <span class="keyword">true</span>);</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setUpdateEvents</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">byte</span> events, <span class="keyword">boolean</span> force)</span> </span>&#123;</div><div class="line">    <span class="comment">// 判断fd和数组长度</span></div><div class="line">    <span class="keyword">if</span> (fd &lt; MAX_UPDATE_ARRAY_SIZE) &#123;</div><div class="line">        <span class="keyword">if</span> ((eventsLow[fd] != KILLED) || force) &#123;</div><div class="line">            eventsLow[fd] = events;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        Integer key = Integer.valueOf(fd);</div><div class="line">        <span class="keyword">if</span> (!isEventsHighKilled(key) || force) &#123;</div><div class="line">            eventsHigh.put(key, Byte.valueOf(events));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行<code>EpollArrayWrapper.poll()</code>的时候, 首先会调用<code>updateRegistrations()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Returns the pending update events for the given file descriptor.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">byte</span> <span class="title">getUpdateEvents</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (fd &lt; MAX_UPDATE_ARRAY_SIZE) &#123;</div><div class="line">        <span class="keyword">return</span> eventsLow[fd];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        Byte result = eventsHigh.get(Integer.valueOf(fd));</div><div class="line">        <span class="comment">// result should never be null</span></div><div class="line">        <span class="keyword">return</span> result.byteValue();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateRegistrations</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">synchronized</span> (updateLock) &#123;</div><div class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (j &lt; updateCount) &#123;</div><div class="line">            <span class="keyword">int</span> fd = updateDescriptors[j];</div><div class="line">            <span class="comment">// 从保存的eventsLow和eventsHigh里取出事件</span></div><div class="line">            <span class="keyword">short</span> events = getUpdateEvents(fd);</div><div class="line">            <span class="keyword">boolean</span> isRegistered = registered.get(fd);</div><div class="line">            <span class="keyword">int</span> opcode = <span class="number">0</span>;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (events != KILLED) &#123;</div><div class="line">                <span class="comment">// 判断操作类型以传给epoll_ctl</span></div><div class="line">                <span class="comment">// 没有指定EPOLLET事件类型</span></div><div class="line">                <span class="keyword">if</span> (isRegistered) &#123;</div><div class="line">                    <span class="comment">// 如果已经注册过，不需要调用epollCtl去内核红黑树新增节点</span></div><div class="line">                    opcode = (events != <span class="number">0</span>) ? EPOLL_CTL_MOD : EPOLL_CTL_DEL;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    opcode = (events != <span class="number">0</span>) ? EPOLL_CTL_ADD : <span class="number">0</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (opcode != <span class="number">0</span>) &#123;</div><div class="line">                    <span class="comment">// 熟悉的epoll_ctl</span></div><div class="line">                    epollCtl(epfd, opcode, fd, events);</div><div class="line">                    <span class="keyword">if</span> (opcode == EPOLL_CTL_ADD) &#123;</div><div class="line">                        registered.set(fd);</div><div class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (opcode == EPOLL_CTL_DEL) &#123;</div><div class="line">                        registered.clear(fd);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            j++;</div><div class="line">        &#125;</div><div class="line">        updateCount = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">epollCtl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> opcode, <span class="keyword">int</span> fd, <span class="keyword">int</span> events)</span></span>;</div></pre></td></tr></table></figure>
<p>在获取到事件之后将操作委托给了<code>epollCtl</code>,这又是个native方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Java_sun_nio_ch_EPollArrayWrapper_epollCtl(JNIEnv *env, jobject <span class="keyword">this</span>, jint epfd,</div><div class="line">                                           jint opcode, jint fd, jint events)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">struct</span> epoll_event event;</div><div class="line">    <span class="keyword">int</span> res;</div><div class="line"></div><div class="line">    event.events = events;</div><div class="line">    event.data.fd = fd;</div><div class="line"></div><div class="line">    <span class="comment">// 发起epoll_ctl调用来进行IO事件的管理</span></div><div class="line">    RESTARTABLE(epoll_ctl(epfd, (<span class="keyword">int</span>)opcode, (<span class="keyword">int</span>)fd, &amp;event), res);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (res &lt; <span class="number">0</span> &amp;&amp; errno != EBADF &amp;&amp; errno != ENOENT &amp;&amp; errno != EPERM) &#123;</div><div class="line">        JNU_ThrowIOExceptionWithLastError(env, <span class="string">"epoll_ctl failed"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>注意：jdk nio没有指定<code>ET(边缘触发)</code>还是<code>LT(水平触发)</code>, 所以默认会用<code>LT</code>, 而<code>Netty epoll transport</code>使用<code>ET</code>触发</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1fxv38f07maj310g0jmdm2.jpg" alt=""></p>
<p>通过<code>channel</code>就能不断的获取客户端<code>socket</code>数据，实现后端业务处理</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://juejin.im/entry/5b51546df265da0f70070b93" target="_blank" rel="external">Java NIO分析(8): 高并发核心Selector详解</a></p>
<p><a href="https://www.jianshu.com/p/7b507069debb" target="_blank" rel="external">java NIO 运行原理介绍</a></p>
<p><a href="https://www.baeldung.com/java-nio-selector" target="_blank" rel="external">Introduction to the Java NIO Selector</a></p>
<p><a href="https://www.jianshu.com/p/0d497fe5484a" target="_blank" rel="external">深入浅出NIO之Selector实现原理</a></p>
<p><a href="http://matt33.com/2017/08/12/java-nio/" target="_blank" rel="external">谈一谈 Java IO 模型</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/11/29/IO多路复用机制/" itemprop="url">
                  IO多路复用机制
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-11-29T15:34:28+08:00" content="2018-11-29">
              2018-11-29
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">One basic concept of Linux (actually Unix) is the rule that everything in Unix/Linux is a file. Each process has a table of file descriptors that point to files, sockets, devices and other operating system objects</div></pre></td></tr></table></figure>
<h3 id="用户空间与内核空间"><a href="#用户空间与内核空间" class="headerlink" title="用户空间与内核空间"></a>用户空间与内核空间</h3><p>对于一次IO访问（以<code>read</code>举例），数据会先被拷贝到操作系统内核的缓冲区中(通过DMA，不需要CPU)，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间(需要CPU)。所以说，当一个read操作发生时，它会经历两个阶段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1. 等待数据准备 (Waiting for the data to be ready)；对于一个socket接口上的操作，这一步骤关系到数据从网络到达，并将其复制到内核的缓冲区</div><div class="line">2. 将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)</div></pre></td></tr></table></figure>
<h3 id="Blocking-IO"><a href="#Blocking-IO" class="headerlink" title="Blocking IO"></a>Blocking IO</h3><p>传统的阻塞 I/O 模型工作方式：当线程使用 <code>read</code> 或者 <code>write</code> 对某一个<strong>文件描述符（File Descriptor 以下简称 FD)</strong>进行读写时，如果当前 FD 不可读或不可写，当前线程会被CPU挂起阻塞，一直等待数据准备完毕。</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1fxp3a06e2jj30rs0ku0wq.jpg" alt=""></p>
<p>例如：tomcat服务器BIO模式，利用多线程 + 线程池 处理；即每一个socket连接创建一个独立的线程处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line"> ExecutorService executor = Excutors.newFixedThreadPollExecutor(<span class="number">100</span>);<span class="comment">//线程池</span></div><div class="line"> ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket();</div><div class="line"> serverSocket.bind(<span class="number">8080</span>);</div><div class="line"> <span class="keyword">while</span>(<span class="keyword">true</span>)&#123; <span class="comment">//死循环等待新连接到来</span></div><div class="line"> 	Socket socket = serverSocket.accept();</div><div class="line"> 	executor.submit(<span class="keyword">new</span> ConnectIOHandler(socket));<span class="comment">//为新的连接创建新的线程</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConnectIOHandler</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> Socket socket;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConnectIOnHandler</span><span class="params">(Socket socket)</span></span>&#123;</div><div class="line">       <span class="keyword">this</span>.socket = socket;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">      <span class="keyword">while</span>(!socket.isClosed())&#123; <span class="comment">// 死循环处理读写事件</span></div><div class="line">          String someThing = socket.read()....<span class="comment">//读取数据</span></div><div class="line">          <span class="keyword">if</span>(someThing!=<span class="keyword">null</span>)&#123;</div><div class="line">             ......<span class="comment">//处理数据</span></div><div class="line">             socket.write()....<span class="comment">//写数据</span></div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>线程本身占用较大内存，像Java的线程栈，一般至少分配512K～1M的空间，如果系统中的线程数过千，恐怕整个JVM的内存都会被吃掉一半</li>
<li>线程的切换成本是很高的。操作系统发生线程切换的时候，需要保留线程的上下文，然后执行系统调用。如果线程数过高，可能执行线程切换的时间甚至会大于线程执行的时间</li>
</ul>
<h3 id="IO多路复用-IO-mutiplexing"><a href="#IO多路复用-IO-mutiplexing" class="headerlink" title="IO多路复用(IO mutiplexing)"></a>IO多路复用(IO mutiplexing)</h3><p>IO多路复用就通过一种机制，单个线程通过监视多个I/O流的状态来同时管理多个I/O流，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1fxpxgg7qbfj30rs0kun32.jpg" alt=""></p>
<p>当应用进程通过<code>select</code>读取文件(<code>socket</code>)，应用进程会被<code>block</code>，于此同时内核会“监视”所有通过<code>select</code>请求的文件读取(<code>socket</code>)，任何一个文件(<code>socket</code>)的数据被准备好，<code>select</code>就会返回，应用进程再调用<code>read</code>操作，把数据从内核中拷贝到应用进程。</p>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><ul>
<li>IO复用技术的优势在于，只需要使用一个线程就可以管理多个socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，很大程度上减少了资源占用；适合于连接数多的场景(nginx，rpc，redis等)。</li>
<li>如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于<strong>能处理更多的连接</strong></li>
</ul>
<h3 id="select，poll，epoll"><a href="#select，poll，epoll" class="headerlink" title="select，poll，epoll"></a><code>select</code>，<code>poll</code>，<code>epoll</code></h3><p><code>select</code>，<code>poll</code>，<code>epoll</code>都是IO多路复用的实现机制。<code>select</code>，<code>poll</code>，<code>epoll</code>本质上都是同步I/O，因为它们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的</p>
<p><strong>注意: IO多路复用经常被称为异步非阻塞，这里的异步只是相对于以前同步阻塞而起的名称，并非实际情况下的unix异步模型，如果从Unix IO模型角度只能将IO多路复用称为非阻塞IO</strong></p>
<p>对于IO多路复用，有两件事是必须要做的(对于监控可读事件而言)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1. 准备好需要监控的fds集合</div><div class="line">2. 探测并返回fds集合中哪些fd可读</div></pre></td></tr></table></figure>
<h4 id="select"><a href="#select" class="headerlink" title="select"></a><code>select</code></h4><h5 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">单个进程就可以同时处理多个网络连接的IO请求（同时阻塞多个IO操作）。基本原理就是程序调用select()，然后整个程序就阻塞了，这时候，select会将需要监控的readfds集合拷贝到内核空间（假设监控的仅仅是socket可读），kernel就会轮询检查所有select负责的fd，当找到一个client中的数据准备就绪了，select就会返回，这个时候程序就会系统调用，将数据从kernel复制到进程缓冲区。</div></pre></td></tr></table></figure>
<h5 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h5><ul>
<li><code>select</code>目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点</li>
<li>每次调用<code>select</code>，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大</li>
<li>同时每次调用<code>select</code>都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大</li>
<li><code>select</code>支持的文件描述符数量太小了，默认是1024</li>
</ul>
<h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a><code>poll</code></h4><h5 id="基本原理-1"><a href="#基本原理-1" class="headerlink" title="基本原理"></a>基本原理</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">poll的原理与select非常相似，差别如下：</div><div class="line">	1) 描述fd集合的方式不同，poll使用 pollfd 结构而不是select结构fd_set结构，所以poll是链式的，没有最大连接数的限制</div><div class="line">	2) poll有一个特点是水平触发，也就是通知程序fd就绪后，这次没有被处理，那么下次poll的时候会再次通知该fd已经就绪。</div></pre></td></tr></table></figure>
<h5 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h5><p><code>poll</code>机制虽然改进了<code>select</code>的监控大小1024的限制，但以下两个性能问题还没有解决 :</p>
<ul>
<li>fds集合整体仍然需要从用户空间拷贝到内核空间的问题，而不管这样的复制是不是有意义</li>
<li>当被监控的fds中某些有数据可读的时候，我们希望通知更加精细一点，就是我们希望能够从通知中得到有可读事件的fds列表，而不是需要遍历整个fds来收集。</li>
</ul>
<h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a><code>epoll</code></h4><p>它是由<code>Linux</code>内核2.6推出的可伸缩的IO多路复用实现，目的是为了替代<code>select()</code>与<code>poll()</code></p>
<p>事实上，同时连接的大量客户端在一时刻可能只有很少的处于就绪状态，因此随着监视的描述符数量的增长，<code>select()</code>与<code>poll()</code>的效率也会线性下降。</p>
<h5 id="基本原理-2"><a href="#基本原理-2" class="headerlink" title="基本原理"></a>基本原理</h5><p><code>select</code>和<code>poll</code>都只提供了一个函数－<code>select</code>或者<code>poll</code>函数。而<code>epoll</code>提供了三个函数，分别如下：</p>
<ul>
<li><strong>int epoll_create(int size)</strong>：// 创建一个<code>epoll</code>的句柄，size用来告诉内核这个监听的数目一共有多大</li>
<li><strong>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)</strong>：// 注册描述符fd要监听的事件类型；<code>epfd</code>:是<code>epoll_create()</code>的返回值; fd:需要监听的文件描述符; <code>epoll_event</code>:告诉内核需要监听什么事</li>
<li><strong>int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout)</strong>： // 等待<code>epfd</code>上的io事件，返回在<code>events</code>中发生的事件, 最多返回<code>maxevents</code>个事件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">epoll执行过程:</div><div class="line">	1) 首先执行epoll_create创建一个epoll句柄；并开辟epoll自己的内核高速cache区，在该缓冲区建立红黑树和就绪链表</div><div class="line">	2) epoll_ctl执行add动作时除了将要监听的文件句柄放到红黑树上之外，还向内核注册了该文件句柄的回调函数(内核中断处理程序注册一个回调函数)，内核在检测到某句柄可读可写时（内核针对读缓冲区和写缓冲区来判断是否可读可写）则调用该回调函数，回调函数将文件句柄放到就绪链表(当一个socket上有数据到了，内核在把网卡上的数据copy到内核中后就来把socket插入到准备就绪链表里了)。</div><div class="line">	3) epoll_wait只监控就绪链表就可以(利用schedule_timeout()实现睡一会，判断一会的效果)，如果就绪链表有文件句柄不为空，则表示该文件句柄可读可写，并返回到用户态（少量的拷贝）</div><div class="line">	4) 由于内核不修改文件句柄的位置，因此只需要在第一次传入就可以重复监控，直到使用epoll_ctl删除，否则不需要重新传入，因此无多次拷贝</div></pre></td></tr></table></figure>
<p><code>epoll_ctl</code>通过(<code>EPOLL_CTL_ADD</code>、<code>EPOLL_CTL_MOD</code>、<code>EPOLL_CTL_DEL</code>)三个操作来分散对需要监控的fds集合的修改，做到了有变化才变更，将<code>select/poll</code>高频、大块内存拷贝(集中处理)变成<code>epoll_ctl</code>的低频、小块内存的拷贝(分散处理)，避免了大量的内存拷贝</p>
<h5 id="优缺点-3"><a href="#优缺点-3" class="headerlink" title="优缺点"></a>优缺点</h5><p>相比<code>select/poll</code>，epoll的优点如下：</p>
<ul>
<li>没有最大并发连接的限制，能打开的FD的上限远大于1024 (在1GB内存的机器上大约是10万左右)</li>
<li>效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用<code>callback</code>函数；即<code>epoll</code>最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，<code>epoll</code>的效率就会远远高于<code>select</code>和<code>poll</code>。</li>
<li><code>epoll</code>内部使用了<code>mmap</code>共享了用户和内核的部分空间，避免了数据的来回拷贝</li>
<li><code>epoll</code> 有个致命的缺点，只有<code>linux</code>支持</li>
</ul>
<h5 id="epoll的两种工作模式"><a href="#epoll的两种工作模式" class="headerlink" title="epoll的两种工作模式"></a><code>epoll</code>的两种工作模式</h5><p>支持边缘触发<strong>ET（edge trigger）</strong>与水平触发<strong>LT（level trigger）</strong>两种模式（<code>poll()</code>只支持水平触发）</p>
<ul>
<li><strong>LT模式</strong>：缺省的工作方式，并且同时支持<code>block</code>和<code>no-block socket</code>；当<code>epoll_wait</code>检测到描述符事件发生并将此事件通知应用程序，<code>应用程序可以不立即处理该事件</code>。下次调用<code>epoll_wait</code>时，会再次响应应用程序并通知此事件(<strong>清理就绪列表后，重新把句柄放回刚刚清空的就绪列表</strong>)</li>
<li><p><strong>ET模式</strong>：高速工作方式，只支持<code>no-block socket</code>；当<code>epoll_wait</code>检测到描述符事件发生并将此事件通知应用程序，<code>应用程序必须立即处理该事件</code>。如果不处理，下次调用<code>epoll_wait</code>时，不会再次响应应用程序并通知此事件(<strong>only once</strong>)。所以在<strong>ET模式</strong>下，一般是通过while循环，一次性读完全部数据．<code>epoll</code>默认使用的是LT．</p>
<p><strong>ET模式</strong>在很大程度上减少了<code>epoll</code>事件被重复触发的次数，因此效率要比<strong>LT模式</strong>高。<code>epoll</code>工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p>
</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://devarea.com/linux-io-multiplexing-select-vs-poll-vs-epoll/" target="_blank" rel="external">LINUX – IO MULTIPLEXING – SELECT VS POLL VS EPOLL</a></p>
<p><a href="https://github.com/jasonGeng88/blog/blob/master/201708/java-socket.md" target="_blank" rel="external">JAVA 中原生的 socket 通信机制</a></p>
<p><a href="https://www.zybuluo.com/phper/note/595507" target="_blank" rel="external">通俗讲解 异步，非阻塞和 IO 复用</a></p>
<p><a href="https://draveness.me/redis-io-multiplexing" target="_blank" rel="external">Redis 和 I/O 多路复用</a></p>
<p><a href="https://www.cnblogs.com/Anker/p/3265058.html" target="_blank" rel="external">select、poll、epoll之间的区别总结</a></p>
<p><a href="https://segmentfault.com/a/1190000003063859" target="_blank" rel="external">Linux IO模式及 select、poll、epoll详解</a></p>
<p><a href="https://cs.xieyonghui.com/java/33.html" target="_blank" rel="external">Java NIO和多路复用(I/O multiplexing)</a></p>
<p><a href="https://tech.meituan.com/nio.html" target="_blank" rel="external">Java NIO浅析</a></p>
<p><a href="http://ifeve.com/netty-2-5/" target="_blank" rel="external">《Netty 权威指南》—4种IO的对比</a></p>
<p><a href="https://www.zhihu.com/question/20122137" target="_blank" rel="external">epoll 或者 kqueue 的原理是什么？</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/10/22/innoDb快照读/" itemprop="url">
                  innoDb快照读
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-10-22T10:47:47+08:00" content="2018-10-22">
              2018-10-22
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="快照读-Snapshot-Read"><a href="#快照读-Snapshot-Read" class="headerlink" title="快照读(Snapshot Read)"></a>快照读(Snapshot Read)</h3><p>MySQL数据库，InnoDB存储引擎，为了提高并发，使用MVCC(<strong>多版本并发控制</strong>)机制，在并发事务时，通过读取数据行的历史数据版本，不加锁，来提高并发的一种不加锁一致性读(Consistent Nonlocking Read)。一致性读，又称为快照读</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">A consistent read means that InnoDB uses multi-versioning to present to a query a snapshot of the database at a point in time. The query sees the changes made by transactions that committed before that point of time, and no changes made by later or uncommitted transactions. The exception to this rule is that the query sees the changes made by earlier statements within the same transaction.</div></pre></td></tr></table></figure>
<p><strong>注意：本事务中修改的数据，即使未提交的数据也可以被本事务的后面部分读取到</strong></p>
<h3 id="快照实现"><a href="#快照实现" class="headerlink" title="快照实现"></a>快照实现</h3><ul>
<li><strong>undo log</strong> ：记录事务变更前的状态。操作数据之前，先将数据备份到undo log，然后进行数据修改(COW:写时备份)，如果出现错误或用户执行了rollback语句，则系统就可以利用undo log中的备份数据恢复到事务开始之前的状态。</li>
<li><strong>redo log：</strong> 记录事务变更后的状态。在事务提交前，只要将redo log持久化即可，数据在内存中变更。当系统崩溃时，虽然数据没有落盘，但是redo log已持久化，系统可以根据redo Log的内容，将所有数据恢复到最新的状态。</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://dev.mysql.com/doc/refman/5.6/en/innodb-consistent-read.html" target="_blank" rel="external">一致性读</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/09/17/nginx负载均衡策略/" itemprop="url">
                  nginx负载均衡策略
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-09-17T14:45:30+08:00" content="2018-09-17">
              2018-09-17
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>负载均衡可以将前端的请求分担到后端多个节点上，提升系统的响应和处理能力。</p>
<h3 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h3><p>负载均衡的策略可以分为两大类：<code>内置策略</code> 和<code>扩展策略</code></p>
<ul>
<li>内置策略：一般会直接编译进Nginx内核，常用的有<code>轮询</code>、<code>ip hash</code></li>
<li>扩展策略：<code>fair</code>、<code>url hash</code>等</li>
</ul>
<h4 id="普通轮询方式"><a href="#普通轮询方式" class="headerlink" title="普通轮询方式"></a>普通轮询方式</h4><p>默认选项，当<code>weight</code>不指定时，各服务器权重相同， 每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">upstream</span> bakend &#123;</div><div class="line">  <span class="attribute">server</span> <span class="number">10.11.0.1</span>;</div><div class="line">  <span class="attribute">server</span> <span class="number">10.11.0.2</span>;</div><div class="line">  <span class="attribute">server</span> <span class="number">10.11.0.3</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="加权轮询方式"><a href="#加权轮询方式" class="headerlink" title="加权轮询方式"></a>加权轮询方式</h4><p>指定轮询几率，<code>weight</code>和访问比率成正比，用于后端服务器性能不均的情况。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">upstream</span> backend &#123;</div><div class="line">  <span class="attribute">server</span> <span class="number">10.11.0.1</span> weight=<span class="number">3</span>;</div><div class="line">  <span class="attribute">server</span> <span class="number">10.11.0.2</span> weight=<span class="number">7</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>权重越高，在被访问的概率越大，如上例，分别是30%，70%。</p>
<h5 id="轮询流程图"><a href="#轮询流程图" class="headerlink" title="轮询流程图"></a>轮询流程图</h5><p><img src="http://www.rowkey.me/images/blog_images/nginx/ngx_wr.png" alt=""></p>
<p>首先将请求都分给高权重的机器，直到该机器的权值降到了比其他机器低，才开始将请求分给下一个高权重的机器；当所有后端机器都down掉时，<code>nginx</code>会立即将所有机器的标志位清成初始状态，以避免造成所有的机器都处在<code>timeout</code>的状态</p>
<h4 id="ip-hash方式"><a href="#ip-hash方式" class="headerlink" title="ip hash方式"></a>ip hash方式</h4><p><strong>默认情况下，Nginx 会为你提供轮询作为负载均衡策略</strong>。</p>
<p>采用<code>ip_hash</code>策略解决登录信息丢失，如果客户已经访问了某个服务器，当用户再次访问时，会将该请求通过<strong>哈希算法，自动定位到同一个服务器</strong>，当然，如果所 <code>hash</code> 到的 <code>server</code> 当前不可用，则请求会被转移到其他<code>server</code>。<br>每个请求按访问<code>ip</code>的<code>hash</code>结果分配，这样每个访客固定访问一个后端服务器，可以解决<strong>session的问题</strong>。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">upstream backend &#123;</div><div class="line">    ip_hash;</div><div class="line">    server 10.11.0.1;</div><div class="line">    server 10.11.0.2;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="fair"><a href="#fair" class="headerlink" title="fair"></a>fair</h4><p>根据后端服务器的响应时间判断负载情况，从中选出负载最轻的机器进行优先分配。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">upstream backend &#123;</div><div class="line">    server 10.11.0.1;</div><div class="line">    server 10.11.0.2;</div><div class="line">    fair;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>缺点：需要「负载均衡器」不停的去统计每一台后端服务器对请求的处理速度，比如一分钟统计一次，生成一个后端服务器处理速度的排行榜，然后「负载均衡器」根据这个排行榜去转发服务。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/05/10/jvm内存参数/" itemprop="url">
                  jvm内存参数
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-05-10T17:49:08+08:00" content="2018-05-10">
              2018-05-10
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="线上jvm参数"><a href="#线上jvm参数" class="headerlink" title="线上jvm参数"></a>线上jvm参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">-Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager,</div><div class="line">-XX:MetaspaceSize=256M, // 分配给类元数据空间的初始大小</div><div class="line">-XX:MaxMetaspaceSize=256M, // 分配给类元数据空间的最大值</div><div class="line">-Xms4g, // 初始堆大小</div><div class="line">-Xmx4g, // 最大堆大小</div><div class="line">-Xmn1g, // 年轻代大小</div><div class="line">-Xss256k, // 每个线程的堆栈大小</div><div class="line">-XX:SurvivorRatio=8, // Eden区与Survivor区的大小比值</div><div class="line">-XX:MaxTenuringThreshold=8, // 垃圾最大年龄, 该参数只有在串行GC时才有效.</div><div class="line">-XX:ParallelGCThreads=8, // 并行收集器的线程数</div><div class="line">-XX:+UseConcMarkSweepGC, // 使用CMS内存收集</div><div class="line">-XX:+UseParNewGC, // 设置年轻代为并行收集</div><div class="line">-XX:+DisableExplicitGC, // 关闭System.gc()</div><div class="line">-XX:+CMSParallelRemarkEnabled, // 降低标记停顿</div><div class="line">-XX:+CMSClassUnloadingEnabled, // 在CMS中清理过期的Class而不等到Full GC</div><div class="line">-XX:CMSInitiatingOccupancyFraction=70, // 使用cms作为垃圾回收，使用70％后开始CMS收集</div><div class="line">-XX:CMSFullGCsBeforeCompaction=5, // 多少次GC后进行内存压缩</div><div class="line">-XX:+UseCMSCompactAtFullCollection, // 在FULLGC的时候，对年老代的压缩</div><div class="line">-XX:+CMSScavengeBeforeRemark, // 在CMS remark前，先执行一次minor GC将新生代清掉</div><div class="line">-XX:+HeapDumpOnOutOfMemoryError, // 当OutOfMemoryError发生时，将heap内存dump到文件</div><div class="line">......</div></pre></td></tr></table></figure>
<h4 id="XX-MetaspaceSize"><a href="#XX-MetaspaceSize" class="headerlink" title="-XX:MetaspaceSize"></a>-XX:MetaspaceSize</h4><p><code>Java 8</code>彻底将永久代 (<code>PermGen</code>) 移除出了 <code>HotSpot JVM</code>，将其原有的数据迁移至 <code>Java Heap</code> 或 <code>Metaspace</code></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/31/">31</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="David" />
          <p class="site-author-name" itemprop="name">David</p>
          <p class="site-description motion-element" itemprop="description">Develop Notes</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">155</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">37</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/zsr" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/u/2214956781" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">David</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
       search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();

    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
    'use strict';
    $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
            // get the contents from search data
            isfetched = true;
            $('.popup').detach().appendTo('.header-inner');
            var datas = $( "entry", xmlResponse ).map(function() {
                return {
                    title: $( "title", this ).text(),
                    content: $("content",this).text(),
                    url: $( "url" , this).text()
                };
            }).get();
            var $input = document.getElementById(search_id);
            var $resultContent = document.getElementById(content_id);
            $input.addEventListener('input', function(){
                var matchcounts = 0;
                var str='<ul class=\"search-result-list\">';
                var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                $resultContent.innerHTML = "";
                if (this.value.trim().length > 1) {
                // perform local searching
                datas.forEach(function(data) {
                    var isMatch = true;
                    var content_index = [];
                    var data_title = data.title.trim().toLowerCase();
                    var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                    var data_url = data.url;
                    var index_title = -1;
                    var index_content = -1;
                    var first_occur = -1;
                    // only match artiles with not empty titles and contents
                    if(data_title != '' && data_content != '') {
                        keywords.forEach(function(keyword, i) {
                            index_title = data_title.indexOf(keyword);
                            index_content = data_content.indexOf(keyword);
                            if( index_title < 0 && index_content < 0 ){
                                isMatch = false;
                            } else {
                                if (index_content < 0) {
                                    index_content = 0;
                                }
                                if (i == 0) {
                                    first_occur = index_content;
                                }
                            }
                        });
                    }
                    // show search results
                    if (isMatch) {
                        matchcounts += 1;
                        str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                        var content = data.content.trim().replace(/<[^>]+>/g,"");
                        if (first_occur >= 0) {
                            // cut out 100 characters
                            var start = first_occur - 20;
                            var end = first_occur + 80;
                            if(start < 0){
                                start = 0;
                            }
                            if(start == 0){
                                end = 50;
                            }
                            if(end > content.length){
                                end = content.length;
                            }
                            var match_content = content.substring(start, end);
                            // highlight all keywords
                            keywords.forEach(function(keyword){
                                var regS = new RegExp(keyword, "gi");
                                match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                            });

                            str += "<p class=\"search-result\">" + match_content +"...</p>"
                        }
                        str += "</li>";
                    }
                })};
                str += "</ul>";
                if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
                if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
                $resultContent.innerHTML = str;
            });
            proceedsearch();
        }
    });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };

    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>


  

  

  

</body>
</html>
