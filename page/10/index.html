<!doctype html><html class="theme-next pisces use-motion"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css"><link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css"><meta name="keywords" content="Hexo, NexT"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1"><meta name="description" content="Develop Notes"><meta property="og:type" content="website"><meta property="og:title" content="Hello Coder"><meta property="og:url" content="http://zsr.github.io/page/10/index.html"><meta property="og:site_name" content="Hello Coder"><meta property="og:description" content="Develop Notes"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Hello Coder"><meta name="twitter:description" content="Develop Notes"><script type="text/javascript" id="hexo.configuration">var NexT=window.NexT||{},CONFIG={scheme:"Pisces",sidebar:{position:"left",display:"post"},fancybox:!0,motion:!0,duoshuo:{userId:0,author:"博主"}}</script><link rel="canonical" href="http://zsr.github.io/page/10/"><title> Hello Coder</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><script>!function(e,a,t,n,c,o,s){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,o=a.createElement(t),s=a.getElementsByTagName(t)[0],o.async=1,o.src=n,s.parentNode.insertBefore(o,s)}(window,document,"script","//www.google-analytics.com/analytics.js","ga"),ga("create","UA-81477846-1","auto"),ga("send","pageview")</script><div class="container one-collumn sidebar-position-left page-home"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Hello Coder</span><span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle"></p></div><div class="site-nav-toggle"> <button><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br> 首页</a></li><li class="menu-item menu-item-archives"><a href="/archives" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br> 归档</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br> 标签</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br> 搜索</a></li></ul><div class="site-search"><div class="popup"><span class="search-icon fa fa-search"></span> <input type="text" id="local-search-input"><div id="local-search-result"></div> <span class="popup-btn-close">close</span></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><section id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><header class="post-header"><h1 class="post-title" itemprop="name headline"> <a class="post-title-link" href="/2017/07/05/redis-分布式锁/" itemprop="url">redis 分布式锁</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time itemprop="dateCreated" datetime="2017-07-05T14:08:56+08:00" content="2017-07-05">2017-07-05</time></span></div></header><div class="post-body" itemprop="articleBody"><h3 id="基于redis实现分布式锁"><a href="#基于redis实现分布式锁" class="headerlink" title="基于redis实现分布式锁"></a>基于redis实现分布式锁</h3><p>分布式锁都是借助第三方来管理锁，以达到多应用直接共同享有一把锁。比较常用且轻量级的就是基于redis实现。</p><p>实现原理：Redis为单进程单线程模式，采用队列模式将并发访问变成串行访问，且多客户端对Redis的连接并不存在竞争关系。其次Redis提供一些命令SETNX，GETSET，可以方便实现分布式锁机制。</p><p>SETNX命令（SET if Not eXists） 语法： SETNX key value 功能：</p><ul><li>当且仅当 key 不存在，返回1，则该客户端获得锁，把key的键值设置为value表示该键已被锁定，该客户端最后可以通过DEL key来释放该锁(获取锁后必须要释放)；</li><li>若给定的 key 已经存在，返回0，表明该锁已被其他客户端取得，这时我们可以先返回或进行重试等对方完成或等待锁超时。</li></ul><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>如果获取锁的客户端端执行时间过长，进程被kill掉，或者因为其他异常崩溃，导致无法释放锁，就会造成死锁。所以，需要对加锁要做时效性检测。因此，我们在加锁时，把当前时间戳作为value存入此锁中，通过当前时间戳和Redis中的时间戳进行对比，如果超过一定差值，认为锁已经时效，防止锁无限期的锁下去，但是，在大并发情况，如果同时检测锁失效，并简单粗暴的删除死锁，再通过SETNX上锁，可能会导致竞争条件的产生，即多个客户端同时获取锁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">C1 获取锁，并崩溃。C2和C3调用SETNX上锁返回0后，获得foo.lock(key)的时间戳，通过比对时间戳，发现锁超时。</div><div class="line">C2 向foo.lock发送DEL命令。</div><div class="line">C2 向foo.lock发送SETNX获取锁。</div><div class="line">C3 向foo.lock发送DEL命令，此时C3发送DEL时，其实DEL掉的是C2的锁。</div><div class="line">C3 向foo.lock发送SETNX获取锁。</div></pre></td></tr></table></figure><p>此时C2和C3都获取了锁，产生竞争条件，如果在更高并发的情况，可能会有更多客户端获取锁。所以，DEL锁的操作，不能直接使用在锁超时的情况下，幸好有GETSET方法，假设现在有另外一个客户端C4，看看如何使用GETSET方式，避免这种情况产生。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">C4 发送SETNX lock.foo 想要获得锁，由于C1还持有锁，所以Redis返回给C4一个0</div><div class="line">C4 发送GET lock.foo 以检查锁是否超时了，如果没超时，则等待或重试。反之，如果已超时，C4通过下面的操作来尝试获得锁：</div><div class="line">	GETSET lock.foo &lt;current Unix time + lock timeout + 1&gt;</div><div class="line">通过GETSET，C4拿到的时间戳如果仍然是超时的，那就说明，C4如愿以偿拿到锁了。</div><div class="line">如果在C4之前，有个叫C5的客户端比C4快一步执行了上面的操作，那么C4拿到的时间戳是个未超时的值，这时，C4没有如期获得锁，需要再次等待或重试。注意：尽管C4没拿到锁，但它改写了C5设置的锁的超时值，不过这一点非常微小的误差带来的影响可以忽略不计。</div></pre></td></tr></table></figure><p><strong>注意：</strong>为了让分布式锁的算法更稳键些，持有锁的客户端在解锁之前应该再检查一次自己的锁是否已经超时，再去做DEL操作，因为可能客户端因为某个耗时的操作而挂起，操作完的时候锁因为超时已经被别人获得，这时就不必解锁了。</p><h4 id="分布式锁的问题"><a href="#分布式锁的问题" class="headerlink" title="分布式锁的问题"></a>分布式锁的问题</h4><ol><li>必要的超时机制：获取锁的客户端一旦崩溃，一定要有过期机制，否则其他客户端都降无法获取锁，造成死锁问题。</li><li>分布式锁，多客户端的时间戳不能保证严格意义的一致性，所以在某些特定因素下，有可能存在锁串的情况。要适度的机制，可以承受小概率的事件产生。</li><li>只对关键处理节点加锁，良好的习惯是，把相关的资源准备好，比如连接数据库后，调用加锁机制获取锁，直接进行操作，然后释放，尽量减少持有锁的时间。</li><li>在持有锁期间要不要CHECK锁，如果需要严格依赖锁的状态，最好在关键步骤中做锁的CHECK检查机制，但是根据我们的测试发现，在大并发时，每一次CHECK锁操作，都要消耗掉几个毫秒，而我们的整个持锁处理逻辑才不到10毫秒，玩客没有选择做锁的检查。</li><li>为了减少对Redis的压力，获取锁尝试时，循环之间一定要做sleep操作。但是sleep时间是多少是门学问。需要根据自己的Redis的QPS，加上持锁处理时间等进行合理计算。</li></ol><h3 id="实现基于redis的锁"><a href="#实现基于redis的锁" class="headerlink" title="实现基于redis的锁"></a>实现基于redis的锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.zsr.test.redislock;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.slf4j.Logger;</div><div class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</div><div class="line"><span class="keyword">import</span> org.springframework.dao.DataAccessException;</div><div class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnection;</div><div class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisCallback;</div><div class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</div><div class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 实现分布式锁</div><div class="line"> */</div><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisLock</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(RedisLock.class);</div><div class="line"></div><div class="line">  <span class="keyword">private</span> RedisTemplate redisTemplate;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_ACQUIRY_RESOLUTION_MILLIS = <span class="number">100</span>;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * Lock key path.</div><div class="line">   */</div><div class="line">  <span class="keyword">private</span> String lockKey;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 锁超时时间，防止线程在入锁以后，无限的执行等待</div><div class="line">   */</div><div class="line">  <span class="keyword">private</span> <span class="keyword">int</span> expireMsecs = <span class="number">1000</span>;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 锁等待时间，防止线程饥饿</div><div class="line">   */</div><div class="line">  <span class="keyword">private</span> <span class="keyword">int</span> timeoutMsecs = <span class="number">1000</span>;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 锁到期时间</div><div class="line">   */</div><div class="line">  <span class="keyword">private</span> String expiresStr = <span class="string">""</span>;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> locked = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * Detailed constructor with default acquire timeout 10000 msecs and lock expiration of 60000</div><div class="line">   * msecs.</div><div class="line">   *</div><div class="line">   * <span class="doctag">@param</span> lockKey lock key (ex. account:1, ...)</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RedisLock</span><span class="params">(String lockKey)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.lockKey = <span class="string">"LOCK_"</span> + lockKey;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * Detailed constructor with default lock expiration of 60000 msecs.</div><div class="line">   *</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RedisLock</span><span class="params">(String lockKey, <span class="keyword">int</span> timeoutMsecs)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(lockKey);</div><div class="line">    <span class="keyword">this</span>.timeoutMsecs = timeoutMsecs;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * Detailed constructor.</div><div class="line">   *</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RedisLock</span><span class="params">(String lockKey, <span class="keyword">int</span> timeoutMsecs, <span class="keyword">int</span> expireMsecs)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(lockKey, timeoutMsecs);</div><div class="line">    <span class="keyword">this</span>.expireMsecs = expireMsecs;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * <span class="doctag">@return</span> lock key</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getLockKey</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> lockKey;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> String <span class="title">get</span><span class="params">(<span class="keyword">final</span> String key)</span> </span>&#123;</div><div class="line">    Object obj = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      obj = redisTemplate.execute(<span class="keyword">new</span> RedisCallback&lt;Object&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">doInRedis</span><span class="params">(RedisConnection connection)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</div><div class="line">          StringRedisSerializer serializer = <span class="keyword">new</span> StringRedisSerializer();</div><div class="line">          <span class="keyword">byte</span>[] data = connection.get(serializer.serialize(key));</div><div class="line">          connection.close();</div><div class="line">          <span class="keyword">if</span> (data == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">return</span> serializer.deserialize(data);</div><div class="line">        &#125;</div><div class="line">      &#125;);</div><div class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">      logger.error(<span class="string">"get redis error, key : &#123;&#125;"</span>, key);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> obj != <span class="keyword">null</span> ? obj.toString() : <span class="keyword">null</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">setNX</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> String value)</span> </span>&#123;</div><div class="line">    Object obj = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      obj = redisTemplate.execute(<span class="keyword">new</span> RedisCallback&lt;Object&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">doInRedis</span><span class="params">(RedisConnection connection)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</div><div class="line">          StringRedisSerializer serializer = <span class="keyword">new</span> StringRedisSerializer();</div><div class="line">          Boolean success = connection.setNX(serializer.serialize(key), serializer.serialize(value));</div><div class="line">          connection.close();</div><div class="line">          <span class="keyword">return</span> success;</div><div class="line">        &#125;</div><div class="line">      &#125;);</div><div class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">      logger.error(<span class="string">"setNX redis error, key : &#123;&#125;"</span>, key);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> obj != <span class="keyword">null</span> ? (Boolean) obj : <span class="keyword">false</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> String <span class="title">getSet</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> String value)</span> </span>&#123;</div><div class="line">    Object obj = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      obj = redisTemplate.execute(<span class="keyword">new</span> RedisCallback&lt;Object&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">doInRedis</span><span class="params">(RedisConnection connection)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</div><div class="line">          StringRedisSerializer serializer = <span class="keyword">new</span> StringRedisSerializer();</div><div class="line">          <span class="keyword">byte</span>[] ret = connection.getSet(serializer.serialize(key), serializer.serialize(value));</div><div class="line">          connection.close();</div><div class="line">          <span class="keyword">return</span> serializer.deserialize(ret);</div><div class="line">        &#125;</div><div class="line">      &#125;);</div><div class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">      logger.error(<span class="string">"setNX redis error, key : &#123;&#125;"</span>, key);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> obj != <span class="keyword">null</span> ? (String) obj : <span class="keyword">null</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 主要是使用了redis 的setnx命令,缓存了锁. reids缓存的key是锁的key,所有的共享,</div><div class="line">   * value是锁的到期时间(注意:这里把过期时间放在value了,没有时间上设置其超时时间)</div><div class="line">   * &lt;p&gt;</div><div class="line">   * 执行过程:</div><div class="line">   * &lt;p&gt;</div><div class="line">   * 1.通过setnx尝试设置某个key的值,成功(当前没有这个锁)则返回,成功获得锁</div><div class="line">   * &lt;p&gt;</div><div class="line">   * 2.锁已经存在则获取锁的到期时间,和当前时间比较,超时的话,则设置新的值</div><div class="line">   *</div><div class="line">   * <span class="doctag">@return</span> true if lock is acquired, false acquire timeouted</div><div class="line">   * <span class="doctag">@throws</span> InterruptedException in case of thread interruption</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    <span class="keyword">int</span> timeout = timeoutMsecs;</div><div class="line">    <span class="keyword">while</span> (timeout &gt;= <span class="number">0</span>) &#123;</div><div class="line">      <span class="comment">// 锁到期时间</span></div><div class="line">      expiresStr = String.valueOf(System.currentTimeMillis() + expireMsecs + <span class="number">1</span>);</div><div class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.setNX(lockKey, expiresStr)) &#123;</div><div class="line">        <span class="comment">// lock acquired</span></div><div class="line">        locked = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      String currentValueStr = <span class="keyword">this</span>.get(lockKey); <span class="comment">// redis里的时间</span></div><div class="line">      <span class="keyword">if</span> (currentValueStr != <span class="keyword">null</span> &amp;&amp; Long.parseLong(currentValueStr) &lt; System.currentTimeMillis()) &#123;</div><div class="line">        <span class="comment">// 判断是否为空，不为空的情况下，如果被其他线程设置了值，则第二个条件判断是过不去的</span></div><div class="line">        <span class="comment">// lock is expired</span></div><div class="line"></div><div class="line">        String oldValueStr = <span class="keyword">this</span>.getSet(lockKey, expiresStr);</div><div class="line">        <span class="comment">// 获取上一个锁到期时间，并设置现在的锁到期时间，</span></div><div class="line">        <span class="comment">// 只有一个线程才能获取上一个线上的设置时间，因为jedis.getSet是同步的</span></div><div class="line">        <span class="keyword">if</span> (oldValueStr != <span class="keyword">null</span> &amp;&amp; oldValueStr.equals(currentValueStr)) &#123;</div><div class="line">          <span class="comment">// 防止误删（覆盖，因为key是相同的）了他人的锁——这里达不到效果，这里值会被覆盖，但是因为什么相差了很少的时间，所以可以接受</span></div><div class="line"></div><div class="line">          <span class="comment">// [分布式的情况下]:如过这个时候，多个线程恰好都到了这里，但是只有一个线程的设置值和当前值相同，他才有权利获取锁</span></div><div class="line">          <span class="comment">// lock acquired</span></div><div class="line">          locked = <span class="keyword">true</span>;</div><div class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      timeout -= DEFAULT_ACQUIRY_RESOLUTION_MILLIS;</div><div class="line"></div><div class="line">      <span class="comment">/*</span></div><div class="line">       * 延迟100 毫秒, 这里使用随机时间可能会好一点,可以防止饥饿进程的出现,即,当同时到达多个进程,</div><div class="line">       * 只会有一个进程获得锁,其他的都用同样的频率进行尝试,后面有来了一些进行,也以同样的频率申请锁,这将可能导致前面来的锁得不到满足. 使用随机的等待时间可以一定程度上保证公平性</div><div class="line">       */</div><div class="line">      Thread.sleep(DEFAULT_ACQUIRY_RESOLUTION_MILLIS);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * Acqurired lock release.</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (locked) &#123;</div><div class="line">      <span class="keyword">if</span> (expiresStr != <span class="keyword">null</span> &amp;&amp; expiresStr.equals(redisTemplate.opsForValue().get(lockKey))) &#123;</div><div class="line">        redisTemplate.delete(lockKey);</div><div class="line">        locked = <span class="keyword">false</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 测试</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> String key = <span class="string">"lockKey"</span>;</div><div class="line">    <span class="keyword">final</span> RedisLock lock = <span class="keyword">new</span> RedisLock(key, <span class="number">1000</span>, <span class="number">2000</span>);</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">      <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">          <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">if</span> (lock.lock()) &#123;</div><div class="line">              System.out.println(<span class="string">"Thread: "</span> + Thread.currentThread().getName() + <span class="string">"running"</span>);</div><div class="line">            &#125;</div><div class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">          &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            lock.unlock();</div><div class="line">          &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">      &#125;, <span class="string">""</span> + i).start();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>具体spring integration中已经实现这样的功能了。具体实现源码<a href="https://github.com/spring-projects/spring-integration/blob/master/spring-integration-redis/src/main/java/org/springframework/integration/redis/util/RedisLockRegistry.java" target="_blank" rel="external">链接</a>，具体源码分析可以查看<a href="https://wangkang007.gitbooks.io/java/redislockregistry.html" target="_blank" rel="external">gitbook链接</a></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://0opslab.com/2017/02/13/%E5%9F%BA%E4%BA%8ERedis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" target="_blank" rel="external">基于redis实现分布式锁</a></p><p><a href="https://github.com/spring-projects/spring-integration/blob/master/spring-integration-redis/src/main/java/org/springframework/integration/redis/util/RedisLockRegistry.java" target="_blank" rel="external">RedisLockRegistry</a></p><p><a href="https://wangkang007.gitbooks.io/java/redislockregistry.html" target="_blank" rel="external">RedisLockRegistry源码分析</a></p></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><header class="post-header"><h1 class="post-title" itemprop="name headline"> <a class="post-title-link" href="/2017/07/03/redis-zset内部实现/" itemprop="url">redis zset内部实现</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time itemprop="dateCreated" datetime="2017-07-03T11:44:21+08:00" content="2017-07-03">2017-07-03</time></span></div></header><div class="post-body" itemprop="articleBody"><h3 id="Redis对象"><a href="#Redis对象" class="headerlink" title="Redis对象"></a>Redis对象</h3><p>Redis对象由<code>redisObject</code>结构体表示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> redisObject &#123;</div><div class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;            <span class="comment">// 对象的类型，包括 /* Object types */</span></div><div class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;        <span class="comment">// 底部为了节省空间，一种type的数据，可以采用不同的存储方式</span></div><div class="line">    <span class="keyword">unsigned</span> lru:REDIS_LRU_BITS; <span class="comment">/* lru time (relative to server.lruclock) */</span></div><div class="line">    <span class="keyword">int</span> refcount;         <span class="comment">// 引用计数</span></div><div class="line">    <span class="keyword">void</span> *ptr;</div><div class="line">&#125; robj;</div></pre></td></tr></table></figure><ul><li>Redis中的每个键值对的键和值都是一个redisObject。</li><li>共有五种类型的对象：字符串（String）、列表（List）、哈希（Hash）、集合（Set）、有序集合（SortedSet），源码<code>server.h</code>如下定义：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/* The actual Redis Object */</div><div class="line">#define OBJ_STRING 0</div><div class="line">#define OBJ_LIST 1 </div><div class="line">#define OBJ_SET 2</div><div class="line">#define OBJ_ZSET 3</div><div class="line">#define OBJ_HASH 4</div></pre></td></tr></table></figure><ul><li>每种类型的对象至少都有两种或以上的编码方式；可以在不同的使用场景上优化对象的使用场景。用<code>TYPE</code>命令可查看某个键值对的类型</li></ul><h3 id="对象编码"><a href="#对象编码" class="headerlink" title="对象编码"></a>对象编码</h3><p>Redis目前使用的编码方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/* Objects encoding. Some kind of objects like Strings and Hashes can be</div><div class="line"> * internally represented in multiple ways. The &apos;encoding&apos; field of the object</div><div class="line"> * is set to one of this fields for this object. </div><div class="line"> */</div><div class="line">#define OBJ_ENCODING_RAW     /* Raw representation */ 简单动态字符串</div><div class="line">#define OBJ_ENCODING_INT      /* Encoded as integer */ 整数</div><div class="line">#define OBJ_ENCODING_HT       /* Encoded as hash table */ 字典</div><div class="line">#define OBJ_ENCODING_ZIPLIST  /* Encoded as ziplist */ 压缩列表</div><div class="line">#define OBJ_ENCODING_INTSET   /* Encoded as intset */ 整数集合</div><div class="line">#define OBJ_ENCODING_SKIPLIST   /* Encoded as skiplist */ 跳跃表</div><div class="line">#define OBJ_ENCODING_EMBSTR  /* Embedded sds string encoding */ embstr编码的简单动态字符串</div><div class="line">#define OBJ_ENCODING_QUICKLIST  /* Encoded as linked list of ziplists */</div></pre></td></tr></table></figure><p>本质上，Redis就是基于这些数据结构而构造出一个对象存储系统。redisObject结构体有个ptr指针，指向对象的底层实现数据结构，encoding属性记录对象所使用的编码，即该对象使用什么数据结构作为底层实现。</p><h3 id="zset介绍"><a href="#zset介绍" class="headerlink" title="zset介绍"></a>zset介绍</h3><p>有序集合对象的编码可以是<code>ziplist</code>或者<code>skiplist</code>。同时满足以下条件时使用ziplist编码：</p><ul><li>元素数量小于128个</li><li>所有member的长度都小于64字节</li></ul><p>以上两个条件的上限值可通过zset-max-ziplist-entries和zset-max-ziplist-value来修改。</p><p><code>ziplist</code>编码的有序集合使用紧挨在一起的压缩列表节点来保存，第一个节点保存member，第二个保存score。ziplist内的集合元素按score从小到大排序，score较小的排在表头位置。</p><p><code>skiplist</code>编码的有序集合底层是一个命名为<code>zset</code>的结构体，而一个zset结构同时包含一个字典和一个跳跃表。跳跃表按score从小到大保存所有集合元素。而字典则保存着从member到score的映射，这样就可以用O(1)的复杂度来查找member对应的score值。虽然同时使用两种结构，但它们会通过指针来共享相同元素的member和score，因此不会浪费额外的内存。</p><h3 id="zset操作命令"><a href="#zset操作命令" class="headerlink" title="zset操作命令"></a>zset操作命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">zadd(key, score, member)：向名称为key的zset中添加元素member，score用于排序。如果该元素已经存在，则根据score更新该元素的顺序。</div><div class="line"></div><div class="line">zrem(key, member) ：删除名称为key的zset中的元素member</div><div class="line"></div><div class="line">zincrby(key, increment, member) ：如果在名称为key的zset中已经存在元素member，则该元素的score增加increment；否则向集合中添加该元素，其score的值为increment</div><div class="line"></div><div class="line">zrank(key, member) ：返回名称为key的zset（元素已按score从小到大排序）中member元素的rank（即index，从0开始），若没有member元素，返回“nil”</div><div class="line"></div><div class="line">zrevrank(key, member) ：返回名称为key的zset（元素已按score从大到小排序）中member元素的rank（即index，从0开始），若没有member元素，返回“nil”</div><div class="line"></div><div class="line">zrange(key, start, end)：返回名称为key的zset（元素已按score从小到大排序）中的index从start到end的所有元素</div><div class="line"></div><div class="line">zrevrange(key, start, end)：返回名称为key的zset（元素已按score从大到小排序）中的index从start到end的所有元素</div><div class="line"></div><div class="line">zrangebyscore(key, min, max)：返回名称为key的zset中score &gt;= min且score &lt;= max的所有元素 zcard(key)：返回名称为key的zset的基数</div><div class="line"></div><div class="line">zscore(key, element)：返回名称为key的zset中元素element的score zremrangebyrank(key, min, max)：删除名称为key的zset中rank &gt;= min且rank &lt;= max的所有元素 zremrangebyscore(key, min, max) ：删除名称为key的zset中score &gt;= min且score &lt;= max的所有元素</div></pre></td></tr></table></figure><h3 id="skiplist介绍"><a href="#skiplist介绍" class="headerlink" title="skiplist介绍"></a><strong>skiplist介绍</strong></h3><p>跳表(skip List)是一种随机化的数据结构，基于并联的链表，实现简单，插入、删除、查找的复杂度均为O(logN)。简单说来跳表也是链表的一种，只不过它在链表的基础上增加了跳跃功能，正是这个跳跃的功能，使得在查找元素时，跳表能够提供O(logN)的时间复杂度。</p><p>先来看一个有序链表，如下图（最左侧的灰色节点表示一个空的头结点）：</p><p><a href="http://zhangtielei.com/assets/photos_redis/skiplist/sorted_linked_list.png" target="_blank" rel="external"><img src="http://zhangtielei.com/assets/photos_redis/skiplist/sorted_linked_list.png" alt="有序链表结构图"></a></p><p>在这样一个链表中，如果我们要查找某个数据，那么需要从头开始逐个进行比较，直到找到包含数据的那个节点，或者找到第一个比给定数据大的节点为止（没找到）。也就是说，时间复杂度为O(n)。同样，当我们要插入新数据的时候，也要经历同样的查找过程，从而确定插入位置。</p><p>假如我们每相邻两个节点增加一个指针，让指针指向下下个节点，如下图：</p><p><a href="http://zhangtielei.com/assets/photos_redis/skiplist/skip2node_linked_list.png" target="_blank" rel="external"><img src="http://zhangtielei.com/assets/photos_redis/skiplist/skip2node_linked_list.png" alt="每两个节点增加一个跳跃指针的有序链表"></a></p><p>这样所有新增加的指针连成了一个新的链表，但它包含的节点个数只有原来的一半（上图中是7, 19, 26）。现在当我们想查找数据的时候，可以先沿着这个新链表进行查找。当碰到比待查数据大的节点时，再回到原来的链表中进行查找。比如，我们想查找23，查找的路径是沿着下图中标红的指针所指向的方向进行的：</p><p><a href="http://zhangtielei.com/assets/photos_redis/skiplist/search_path_on_skip2node_list.png" target="_blank" rel="external"><img src="http://zhangtielei.com/assets/photos_redis/skiplist/search_path_on_skip2node_list.png" alt="一个搜索路径的例子"></a></p><ul><li>23首先和7比较，再和19比较，比它们都大，继续向后比较。</li><li>但23和26比较的时候，比26要小，因此回到下面的链表（原链表），与22比较。</li><li>23比22要大，沿下面的指针继续向后和26比较。23比26小，说明待查数据23在原链表中不存在，而且它的插入位置应该在22和26之间。</li></ul><p>在这个查找过程中，由于新增加的指针，我们不再需要与链表中每个节点逐个进行比较了。需要比较的节点数大概只有原来的一半。</p><p>利用同样的方式，我们可以在上层新产生的链表上，继续为每相邻的两个节点增加一个指针，从而产生第三层链表。如下图：</p><p><a href="http://zhangtielei.com/assets/photos_redis/skiplist/skip2node_level3_linked_list.png" target="_blank" rel="external"><img src="http://zhangtielei.com/assets/photos_redis/skiplist/skip2node_level3_linked_list.png" alt="两层跳跃指针"></a></p><p>在这个新的三层链表结构上，如果我们还是查找23，那么沿着最上层链表首先要比较的是19，发现23比19大，接下来我们就知道只需要到19的后面去继续查找，从而一下子跳过了19前面的所有节点。可以想象，当链表足够长的时候，这种多层链表的查找方式能让我们跳过很多下层节点，大大加快查找的速度。</p><p><code>skiplist</code>正是受这种多层链表的想法的启发而设计出来的。实际上，按照上面生成链表的方式，上面每一层链表的节点个数，是下面一层的节点个数的一半，这样查找过程就非常类似于一个二分查找，使得查找的时间复杂度可以降低到O(log n)。但是，这种方法在插入数据的时候有很大的问题。新插入一个节点之后，就会打乱上下相邻两层链表上节点个数严格的2:1的对应关系。如果要维持这种对应关系，就必须把新插入的节点后面的所有节点（也包括新插入的节点）重新进行调整，这会让时间复杂度重新蜕化成O(n)。删除数据也有同样的问题。</p><p>skiplist为了避免这一问题，它不要求上下相邻两层链表之间的节点个数有严格的对应关系，而是为每个节点随机出一个层数(level)。比如，一个节点随机出的层数是3，那么就把它链入到第1层到第3层这三层链表中。为了表达清楚，下图展示了如何通过一步步的插入操作从而形成一个skiplist的过程：</p><p><a href="http://zhangtielei.com/assets/photos_redis/skiplist/skiplist_insertions.png" target="_blank" rel="external"><img src="http://zhangtielei.com/assets/photos_redis/skiplist/skiplist_insertions.png" alt="skiplist插入形成过程"></a></p><p>从上面skiplist的创建和插入过程可以看出，每一个节点的层数（level）是随机出来的，而且新插入一个节点不会影响其它节点的层数。因此，插入操作只需要修改插入节点前后的指针，而不需要对很多节点都进行调整。这就降低了插入操作的复杂度。实际上，这是skiplist的一个很重要的特性，这让它在插入性能上明显优于平衡树的方案。这在后面我们还会提到。</p><p>skiplist，指的就是除了最下面第1层链表之外，它会产生若干层稀疏的链表，这些链表里面的指针故意跳过了一些节点（而且越高层的链表跳过的节点越多）。这就使得我们在查找数据的时候能够先在高层的链表中进行查找，然后逐层降低，最终降到第1层链表来精确地确定数据位置。在这个过程中，我们跳过了一些节点，从而也就加快了查找速度。</p><p>刚刚创建的这个skiplist总共包含4层链表，现在假设我们在它里面依然查找23，下图给出了查找路径：</p><p><a href="http://zhangtielei.com/assets/photos_redis/skiplist/search_path_on_skiplist.png" target="_blank" rel="external"><img src="http://zhangtielei.com/assets/photos_redis/skiplist/search_path_on_skiplist.png" alt="skiplist上的查找路径展示"></a></p><p>需要注意的是，前面演示的各个节点的插入过程，实际上在插入之前也要先经历一个类似的查找过程，在确定插入位置后，再完成插入操作。</p><p>实际应用中的skiplist每个节点应该包含key和value两部分。前面的描述中我们没有具体区分key和value，但实际上列表中是按照key(score)进行排序的，查找过程也是根据key在比较。</p><p>执行插入操作时计算随机数的过程，是一个很关键的过程，它对skiplist的统计特性有着很重要的影响。这并不是一个普通的服从均匀分布的随机数，它的计算过程如下：</p><ul><li>首先，每个节点肯定都有第1层指针（每个节点都在第1层链表里）。</li><li>如果一个节点有第i层(i&gt;=1)指针（即节点已经在第1层到第i层链表中），那么它有第(i+1)层指针的概率为p。</li><li>节点最大的层数不允许超过一个最大值，记为MaxLevel。</li></ul><p>这个计算随机层数的伪码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">randomLevel()</div><div class="line">    level := <span class="number">1</span></div><div class="line">    <span class="comment">// random()返回一个[0...1)的随机数</span></div><div class="line">    <span class="keyword">while</span> random() &lt; p and level &lt; MaxLevel <span class="keyword">do</span></div><div class="line">        level := level + <span class="number">1</span></div><div class="line">    <span class="keyword">return</span> level</div></pre></td></tr></table></figure><p>randomLevel()的伪码中包含两个参数，一个是p，一个是MaxLevel。在Redis的skiplist实现中，这两个参数的取值为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">p = <span class="number">1</span>/<span class="number">4</span></div><div class="line">MaxLevel = <span class="number">32</span></div></pre></td></tr></table></figure><h3 id="skiplist与平衡树、哈希表的比较"><a href="#skiplist与平衡树、哈希表的比较" class="headerlink" title="skiplist与平衡树、哈希表的比较"></a>skiplist与平衡树、哈希表的比较</h3><ul><li>skiplist和各种平衡树（如AVL、红黑树等）的元素是有序排列的，而哈希表不是有序的。因此，在哈希表上只能做单个key的查找，不适宜做范围查找。所谓范围查找，指的是查找那些大小在指定的两个值之间的所有节点。</li><li>在做范围查找的时候，平衡树比skiplist操作要复杂。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在skiplist上进行范围查找就非常简单，只需要在找到小值之后，对第1层链表进行若干步的遍历就可以实现。</li><li>平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而skiplist的插入和删除只需要修改相邻节点的指针，操作简单又快速。</li><li>从内存占用上来说，skiplist比平衡树更灵活一些。一般来说，平衡树每个节点包含2个指针（分别指向左右子树），而skiplist每个节点包含的指针数目平均为1/(1-p)，具体取决于参数p的大小。如果像Redis里的实现一样，取p=1/4，那么平均每个节点包含1.33个指针，比平衡树更有优势。</li><li>查找单个key，skiplist和平衡树的时间复杂度都为O(log n)，大体相当；而哈希表在保持较低的哈希值冲突概率的前提下，查找时间复杂度接近O(1)，性能更高一些。所以我们平常使用的各种Map或dictionary结构，大都是基于哈希表实现的。</li><li>从算法实现难度上来比较，skiplist比平衡树要简单得多。</li></ul><h3 id="Redis中的skiplist实现"><a href="#Redis中的skiplist实现" class="headerlink" title="Redis中的skiplist实现"></a>Redis中的skiplist实现</h3><p>skiplist的数据结构定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ZSKIPLIST_MAXLEVEL 32</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ZSKIPLIST_P 0.25</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> zskiplistNode &#123;</div><div class="line">    robj *obj;</div><div class="line">    <span class="keyword">double</span> score;</div><div class="line">    <span class="keyword">struct</span> zskiplistNode *backward;</div><div class="line">    <span class="keyword">struct</span> zskiplistLevel &#123;</div><div class="line">        <span class="keyword">struct</span> zskiplistNode *forward;</div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> span;</div><div class="line">    &#125; level[];</div><div class="line">&#125; zskiplistNode;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> zskiplist &#123;</div><div class="line">    <span class="keyword">struct</span> zskiplistNode *header, *tail;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;</div><div class="line">    <span class="keyword">int</span> level;</div><div class="line">&#125; zskiplist;</div></pre></td></tr></table></figure><p>简单分析一下几个查询命令：</p><ul><li>zrevrank由数据查询它对应的排名，这在前面介绍的skiplist中并不支持。</li><li>zscore由数据查询它对应的分数，这也不是skiplist所支持的。</li><li>zrevrange根据一个排名范围，查询排名在这个范围内的数据。这在前面介绍的skiplist中也不支持。</li><li>zrevrangebyscore根据分数区间查询数据集合，是一个skiplist所支持的典型的范围查找（score相当于key，数据相当于value）。</li></ul><p>实际上，Redis中sorted set的实现是这样的：</p><ul><li>当数据较少时，sorted set是由一个ziplist来实现的。</li><li>当数据多的时候，sorted set是由一个dict + 一个skiplist来实现的。简单来讲，dict用来查询数据到分数的对应关系，而skiplist用来根据分数查询数据（可能是范围查找）。</li></ul><p>看一下sorted set与skiplist的关系，：</p><ul><li>zscore的查询，不是由skiplist来提供的，而是由那个dict来提供的。</li><li>为了支持排名(rank)，Redis里对skiplist做了扩展，使得根据排名能够快速查到数据，或者根据分数查到数据之后，也同时很容易获得排名。而且，根据排名的查找，时间复杂度也为O(log n)。</li><li>zrevrange的查询，是根据排名查数据，由扩展后的skiplist来提供。</li><li>zrevrank是先在dict中由数据查到分数，再拿分数到skiplist中去查找，查到后也同时获得了排名。</li></ul><p>总结起来，Redis中的skiplist跟前面介绍的经典的skiplist相比，有如下不同：</p><ul><li>分数(score)允许重复，即skiplist的key允许重复。这在最开始介绍的经典skiplist中是不允许的。</li><li>在比较时，不仅比较分数（相当于skiplist的key），还比较数据本身。在Redis的skiplist实现中，数据本身的内容唯一标识这份数据，而不是由key来唯一标识。另外，当多个元素分数相同的时候，还需要根据数据内容来进字典排序。</li><li>第1层链表不是一个单向链表，而是一个双向链表。这是为了方便以倒序方式获取一个范围内的元素。</li><li>在skiplist中可以很方便地计算出每个元素的排名(rank)。</li></ul><h3 id="Redis为什么用skiplist而不用平衡树？"><a href="#Redis为什么用skiplist而不用平衡树？" class="headerlink" title="Redis为什么用skiplist而不用平衡树？"></a>Redis为什么用skiplist而不用平衡树？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">There are a few reasons:</div><div class="line"></div><div class="line">1) They are not very memory intensive. It’s up to you basically. Changing parameters about the probability of a node to have a given number of levels will make then less memory intensive than btrees.</div><div class="line"></div><div class="line">2) A sorted set is often target of many ZRANGE or ZREVRANGE operations, that is, traversing the skip list as a linked list. With this operation the cache locality of skip lists is at least as good as with other kind of balanced trees.</div><div class="line"></div><div class="line">3) They are simpler to implement, debug, and so forth. For instance thanks to the skip list simplicity I received a patch (already in Redis master) with augmented skip lists implementing ZRANK in O(log(N)). It required little changes to the code.</div></pre></td></tr></table></figure><p>这里从内存占用、对范围查找的支持和实现难易程度这三方面总结的原因。</p><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p><a href="http://zhangtielei.com/posts/blog-redis-skiplist.html" target="_blank" rel="external">Redis内部数据结构详解(6)——skiplist</a></p></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><header class="post-header"><h1 class="post-title" itemprop="name headline"> <a class="post-title-link" href="/2017/06/26/JVM运行参数/" itemprop="url">JVM运行参数</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time itemprop="dateCreated" datetime="2017-06-26T19:53:15+08:00" content="2017-06-26">2017-06-26</time></span></div></header><div class="post-body" itemprop="articleBody"><h3 id="Java-JVM内存介绍"><a href="#Java-JVM内存介绍" class="headerlink" title="Java JVM内存介绍"></a>Java JVM内存介绍</h3><p>JVM管理两种类型的内存，堆和非堆。按照官方的说法：“Java 虚拟机具有一个堆，堆是运行时数据区域，所有类实例和数组的内存均从此处分配。堆是在 Java 虚拟机启动时创建的。”“在JVM中堆之外的内存称为非堆内存(Non-heap memory)”。简单来说堆就是Java代码可及的内存，是留给开发人员使用的；非堆就是JVM留给自己用的，所以方法区、JVM内部处理或优化所需的内存(如JIT编译后的代码缓存)、每个类结构(如运行时常数池、字段和方法数据)以及方法和构造方法的代码都在非堆内存中，它和堆不同，运行期内GC不会释放其空间。</p><h4 id="堆内存分配"><a href="#堆内存分配" class="headerlink" title="堆内存分配"></a>堆内存分配</h4><p>JVM初始分配的内存由-Xms指定，默认是物理内存的1/64；JVM最大分配的内存由-Xmx指定，默认是物理内存的1/4。默认空余堆内存小于 40%时，JVM就会增大堆直到-Xmx的最大限制；空余堆内存大于70%时，JVM会减少堆直到-Xms的最小限制。因此服务器一般设置-Xms、 -Xmx相等以避免在每次GC 后调整堆的大小。可以利用JVM提供的-Xmn -Xms -Xmx等选项可进行堆内存设置，一般的要将-Xms和-Xmx选项设置为相同，而-Xmn为1/4的-Xmx值，建议堆的最大值设置为可用内存的最大值的80%。</p><p>初始化堆的大小是JVM在启动时向系统申请的内存的大小。一般而言，这个参数不重要。但是有的应用程序在大负载的情况下会急剧地占用更多的内存，此时这个参数就是显得非常重要，如果JVM启动时设置使用的内存比较小而在这种情况下有许多对象进行初始化，JVM就必须重复地增加内存来满足使用。由于这种原因，我们一般把-Xms和-Xmx设为一样大，而堆的最大值受限于系统使用的物理内存。一般使用数据量较大的应用程序会使用持久对象，内存使用有可能迅速地增长。当应用程序需要的内存超出堆的最大值时JVM就会提示内存溢出，并且导致应用服务崩溃。所以，如果Xms超过了Xmx值，或者堆最大值和非堆最大值的总和超过了物理内存或者操作系统的最大限制都会引起服务器启动不起来。</p><h4 id="非堆内存分配"><a href="#非堆内存分配" class="headerlink" title="非堆内存分配"></a>非堆内存分配</h4><p>也叫永久保存的区域，用于存放Class和Meta信息,Class在被Load的时候被放入该区域。它和存放类实例(Instance)的Heap区域不同,GC(Garbage Collection)不会在主程序运行期对PermGen space进行清理。JVM使用-XX:PermSize设置非堆内存初始值，默认是物理内存的1/64；由XX:MaxPermSize设置最大非堆内存的大小，默认是物理内存的1/4。 GC不会对PermGen space进行清理，所以如果你的APP会LOAD很多CLASS的话,就很可能出现PermGen space错误。</p><h4 id="JVM内存限制-最大值"><a href="#JVM内存限制-最大值" class="headerlink" title="JVM内存限制(最大值)"></a>JVM内存限制(最大值)</h4><p>首先JVM内存限制于实际的最大物理内存，假设物理内存无限大的话，JVM内存的最大值跟操作系统有很大的关系。简单的说就32位处理器虽然可控内存空间有4GB,但是具体的操作系统会给一个限制，这个限制一般是2GB-3GB（一般来说Windows系统下为1.5G-2G，Linux系统 下为2G-3G），而64bit以上的处理器就不会有限制了。</p><h3 id="三种内存溢出异常介绍"><a href="#三种内存溢出异常介绍" class="headerlink" title="三种内存溢出异常介绍"></a>三种内存溢出异常介绍</h3><h4 id="OutOfMemoryError：Java-heap-space-堆溢出"><a href="#OutOfMemoryError：Java-heap-space-堆溢出" class="headerlink" title="OutOfMemoryError：Java heap space 堆溢出"></a>OutOfMemoryError：Java heap space 堆溢出</h4><p>内存溢出主要存在问题就是出现在这个情况中。当在JVM中如果98％的时间是用于GC且可用的 Heap size 不足2％的时候将抛出此异常信息。</p><h4 id="OutOfMemoryError：PermGen-space-非堆溢出（永久保存区域溢出）"><a href="#OutOfMemoryError：PermGen-space-非堆溢出（永久保存区域溢出）" class="headerlink" title="OutOfMemoryError：PermGen space 非堆溢出（永久保存区域溢出）"></a>OutOfMemoryError：PermGen space 非堆溢出（永久保存区域溢出）</h4><p>这种错误常见在web服务器对JSP进行pre compile的时候。如果你的WEB APP下都用了大量的第三方jar, 其大小超过了jvm默认的大小(4M)那么就会产生此错误信息了。如果web app用了大量的第三方jar或者应用有太多的class文件而恰好MaxPermSize设置较小，超出了也会导致这块内存的占用过多造成溢出，或者tomcat热部署时侯不会清理前面加载的环境，只会将context更改为新部署的，非堆存的内容就会越来越多。</p><h4 id="OutOfMemoryError：unable-to-create-new-native-thread-无法创建新的线程"><a href="#OutOfMemoryError：unable-to-create-new-native-thread-无法创建新的线程" class="headerlink" title="OutOfMemoryError：unable to create new native thread. 无法创建新的线程"></a>OutOfMemoryError：unable to create new native thread. 无法创建新的线程</h4><p>这种现象比较少见，也比较奇怪，主要是和jvm与系统内存的比例有关。这种怪事是因为JVM已经被系统分配了大量的内存（比如1.5G），并且它至少要占用可用内存的一半。</p><h3 id="Java-JVM内存配置"><a href="#Java-JVM内存配置" class="headerlink" title="Java JVM内存配置"></a>Java JVM内存配置</h3><p>在Linux下设置Tomcat的java虚拟机内存</p><ul><li>查看<code>catalina.sh</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">121 if [ -r &quot;$CATALINA_BASE/bin/setenv.sh&quot; ]; then</div><div class="line">122   . &quot;$CATALINA_BASE/bin/setenv.sh&quot;</div><div class="line">123 elif [ -r &quot;$CATALINA_HOME/bin/setenv.sh&quot; ]; then</div><div class="line">124   . &quot;$CATALINA_HOME/bin/setenv.sh&quot;</div><div class="line">125 fi</div></pre></td></tr></table></figure><ul><li>在tomcat的bin目录下查看是否有<code>setenv.sh</code>,如果没有则创建，然后添加如下内容</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export JAVA_OPTS=&apos;-XX:PermSize=128m -XX:MaxPermSize=256m  -Xms512m -Xmx1024m -Xmn386M -Xss228k -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=8 -XX:ParallelGCThreads=4 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC -XX:+CMSParallelRemarkEnabled -XX:+CMSClassUnloadingEnabled -XX:+CMSPermGenSweepingEnabled  -XX:CMSInitiatingOccupancyFraction=70 -XX:CMSFullGCsBeforeCompaction=5 -XX:+UseCMSCompactAtFullCollection -XX:-HeapDumpOnOutOfMemoryError -Xloggc:/srv/tomcat-forum-topic/logs/gc.log -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCApplicationStoppedTime -XX:+PrintGCApplicationConcurrentTime -Xdebug -Xrunjdwp:transport=dt_socket,address=10136,server=y,suspend=n -Djava.rmi.server.hostname=192.168.3.57 -Dcom.sun.management.jmxremote.port=10009 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false&apos;</div></pre></td></tr></table></figure><h4 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h4><ul><li><code>-XX:PermSize</code>：设定内存的永久保存区域；</li><li><code>-XX:MaxPermSize</code>：设定最大内存的永久保存区域；</li><li><code>-Xms</code>： Java Heap初始值，Server端JVM最好将-Xms和-Xmx设为相同值，开发测试机JVM可以保留默认值；</li><li><code>-Xmx</code>： Java Heap最大值，默认值为物理内存的1/4；</li><li><code>-Xmn</code>： Java Heap Young区大小，不熟悉最好保留默认值，一般设置为Xmx的3、4分之一；</li><li><code>-Xss</code>： 每个线程的Stack大小，不熟悉最好保留默认值；</li><li><code>-XX:NewSize</code>：设置JVM堆的‘新生代’的默认大小；</li><li><code>-XX:MaxNewSize</code>：设置JVM堆的‘新生代’的最大大小；</li><li><code>-XX:SurvivorRatio</code>：Eden区与Survivor区的大小比值;设置为8,则两个Survivor区与一个Eden区的比值为2:8,一个Survivor区占整个年轻代的1/10</li><li><code>-XX:MaxTenuringThreshold</code>：垃圾最大年龄；如果设置为0的话,则年轻代对象不经过Survivor区,直接进入年老代. 对于年老代比较多的应用,可以提高效率.如果将此值设置为一个较大值,则年轻代对象会在Survivor区进行多次复制,这样可以增加对象再年轻代的存活时间,增加在年轻代即被回收的概率。该参数只有在串行GC时才有效.</li><li><code>-XX:ParallelGCThreads</code>：并行收集器的线程数；此值最好配置与处理器数目相等 同样适用于CMS</li><li><code>-XX:+UseConcMarkSweepGC</code>：使用CMS内存收集；</li><li><code>-XX:+UseParNewGC</code>：设置年轻代为并行收集；可与CMS收集同时使用</li><li><code>-XX:+CMSParallelRemarkEnabled</code>：降低标记停顿</li><li><code>-XX:+CMSClassUnloadingEnabled</code>：显示在使用CMS GC时，未加载类是否可用。JVM进行GC时便会清除永久代，并且删除不再使用的类，这个选项只会在<code>UseConcMarkSweepGC</code> 可用时才起作用。</li><li><code>-XX:+CMSPermGenSweepingEnabled</code>：显示清除永久代是否可用。默认情况下这个参数是不可用的，所以要协调永久代问题，就必须显示设置这个参数。这个参数在Java 6里面被删除，所以如果你在使用Java 6或以上版本，你将不得不使用 -XX:+CMSClassUnloadingEnabled 选项。</li><li><code>-XX:CMSInitiatingOccupancyFraction＝70</code>：使用cms作为垃圾回收，使用70％后开始CMS收集</li><li><code>-XX:CMSFullGCsBeforeCompaction=5</code> ：多少次后进行内存压缩；由于并发收集器不对内存空间进行压缩,整理,所以运行一段时间以后会产生”碎片”,使得运行效率降低.此值设置运行多少次GC以后对内存空间进行压缩,整理.</li><li><code>-XX:+UseCMSCompactAtFullCollection</code>：在FULL GC的时候，对年老代的压缩；CMS是不会移动内存的，因此非常容易产生碎片，导致内存不够用，因此，内存的压缩这个时候就会被启用。</li><li><code>-XX:HeapDumpOnOutOfMemoryError</code>：当发生OutOfMemoryError错误时，才能触发<code>-XX:HeapDumpOnOutOfMemoryError</code> 输出到<code>-XX:HeapDumpPath</code>指定位置。</li><li><code>-Xloggc:/gc.log</code>：指定垃圾收集日志文件</li><li><code>-XX:+PrintGCDetails</code>：每次GC时打印详细信息</li><li><code>-XX:+PrintGCTimeStamps</code>：GC发生的时间</li><li><code>XX:+PrintGCApplicationStoppedTime</code>：GC消耗了多少时间</li><li><code>XX:+PrintGCApplicationConcurrentTime</code>：GC之间运行了多少时间</li><li><code>-Xdebug -Xrunjdwp:transport=dt_socket,address=10136,server=y,suspend=n</code>：方便客户端远程调试</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">-XDebug               启用调试。</div><div class="line">-Xnoagent             禁用默认sun.tools.debug调试器。</div><div class="line">-Djava.compiler=NONE  禁止 JIT 编译器的加载。</div><div class="line">-Xrunjdwp             加载JDWP的JPDA参考执行实例。</div><div class="line">transport             用于在调试程序和 VM 使用的进程之间通讯。</div><div class="line">dt_socket             套接字传输。</div><div class="line">dt_shmem              共享内存传输，仅限于 Windows。</div><div class="line">server=y/n            VM 是否需要作为调试服务器执行。</div><div class="line">address=3999          调试服务器的端口号，客户端用来连接服务器的端口号。</div><div class="line">suspend=y/n           是否在调试客户端建立连接之后启动 VM 。</div></pre></td></tr></table></figure><ul><li><code>-Djava.rmi.server.hostname=192.168.3.57</code>：指定ip</li><li><code>-Dcom.sun.management.jmxremote.port=10009</code>：指定端口</li><li><code>-Dcom.sun.management.jmxremote.ssl=false</code>：指定是否需要密码验证</li><li><code>-Dcom.sun.management.jmxremote.authenticate=false</code>：指定是否使用 SSL 通讯</li></ul><p><code>备注：JMX(Java Management Extensions)是一个为应用程序植入管理功能的框架,通过使用JMX，我们可以实时查询应用程序中通过JMX向外公布的相应参数或者是其他应用数据;可以使用Jconsole监控</code></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://blog.csdn.net/ye1992/article/details/9344807" target="_blank" rel="external">Tomcat中JVM内存溢出及合理配置</a></p><p><a href="http://www.cnblogs.com/redcreen/archive/2011/05/04/2037057.html" target="_blank" rel="external">JVM系列三:JVM参数设置、分析</a></p></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><header class="post-header"><h1 class="post-title" itemprop="name headline"> <a class="post-title-link" href="/2017/06/20/RPC介绍/" itemprop="url">RPC介绍</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time itemprop="dateCreated" datetime="2017-06-20T18:08:55+08:00" content="2017-06-20">2017-06-20</time></span></div></header><div class="post-body" itemprop="articleBody"><p>转载:<a href="http://blog.csdn.net/mindfloating/article/details/39474123" target="_blank" rel="external">深入浅出 RPC - 深入篇</a></p><h3 id="RPC-是什么？"><a href="#RPC-是什么？" class="headerlink" title="RPC 是什么？"></a>RPC 是什么？</h3><p>RPC 的全称是 Remote Procedure Call 是一种进程间通信方式。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即程序员无论是调用本地的还是远程的，本质上编写的调用代码基本相同。</p><h2 id="RPC-起源"><a href="#RPC-起源" class="headerlink" title="RPC 起源"></a>RPC 起源</h2><p>RPC 这个概念术语在上世纪 80 年代由 <a href="https://en.wikipedia.org/wiki/Bruce_Jay_Nelson" target="_blank" rel="external">Bruce Jay Nelson</a> 提出。在 Nelson 的论文 <a href="http://birrell.org/andrew/papers/ImplementingRPC.pdf" target="_blank" rel="external">“Implementing Remote Procedure Calls”</a> 中他提到了几点：</p><ul><li>简单：RPC 概念的语义十分清晰和简单，这样建立分布式计算就更容易。</li><li>高效：过程调用看起来十分简单而且高效。</li><li>通用：在单机计算中过程往往是不同算法部分间最重要的通信机制。</li></ul><p>通俗一点说，就是一般程序员对于本地的过程调用很熟悉，那么我们把 RPC 作成和本地调用完全类似，那么就更容易被接受，使用起来毫无障碍。今天我们使用的 RPC 框架基本就是按这个目标来实现的。</p><h3 id="RPC-结构"><a href="#RPC-结构" class="headerlink" title="RPC 结构"></a>RPC 结构</h3><p>Nelson 的论文中指出实现 RPC 的程序包括 5 个部分：</p><blockquote><ol><li>User</li><li>User-stub</li><li>RPCRuntime</li><li>Server-stub</li><li>Server</li></ol></blockquote><p>这 5 个部分的关系如下图所示:</p><p><img src="http://img.blog.csdn.net/20150108170924203?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbWluZGZsb2F0aW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"><br>这里 user 就是 client 端，当 user 想发起一个远程调用时，它实际是通过本地调用 user-stub。user-stub 负责将调用的接口、方法和参数通过约定的协议规范进行编码并通过本地的 RPCRuntime 实例传输到远端的实例。远端 RPCRuntime 实例收到请求后交给 server-stub 进行解码后发起本地端调用，调用结果再返回给 user 端。</p><h3 id="RPC-功能目标"><a href="#RPC-功能目标" class="headerlink" title="RPC 功能目标"></a>RPC 功能目标</h3><p><strong>RPC 的主要功能目标是让构建分布式计算（应用）更容易，在提供强大的远程调用能力时不损失本地调用的语义简洁性。</strong>为实现该目标，RPC 框架需提供一种透明调用机制让使用者不必显式的区分本地调用和远程调用。</p><h3 id="RPC-调用分类"><a href="#RPC-调用分类" class="headerlink" title="RPC 调用分类"></a>RPC 调用分类</h3><p>RPC调用分以下两种：</p><ol><li><p>同步调用</p><p>客户方等待调用执行完成并返回结果。</p></li><li><p>异步调用</p><p>客户方调用后不用等待执行结果返回，但依然可以通过回调通知等方式获取返回结果。</p><p>若客户方不关心调用返回结果，则变成单向异步调用，单向调用不用返回结果。</p></li></ol><p>异步和同步的区分在于是否等待服务端执行完成并返回结果。</p><h3 id="RPC-结构拆解"><a href="#RPC-结构拆解" class="headerlink" title="RPC 结构拆解"></a>RPC 结构拆解</h3><p><img src="http://img.blog.csdn.net/20150108170231000?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbWluZGZsb2F0aW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p><p>RPC服务方通过 <code>RpcServer</code> 去导出（export）远程接口方法，而客户方通过 <code>RpcClient</code> 去引入（import）远程接口方法。客户方像调用本地方法一样去调用远程接口方法，RPC 框架提供接口的代理实现，实际的调用将委托给代理<code>RpcProxy</code> 。代理封装调用信息并将调用转交给<code>RpcInvoker</code> 去实际执行。在客户端的<code>RpcInvoker</code> 通过连接器<code>RpcConnector</code> 去维持与服务端的通道<code>RpcChannel</code>，并使用<code>RpcProtocol</code> 执行协议编码（encode）并将编码后的请求消息通过通道发送给服务方。</p><p>RPC 服务端接收器 <code>RpcAcceptor</code> 接收客户端的调用请求，同样使用<code>RpcProtocol</code> 执行协议解码（decode）。解码后的调用信息传递给<code>RpcProcessor</code> 去控制处理调用过程，最后再委托调用给<code>RpcInvoker</code> 去实际执行并返回调用结果。</p><h3 id="RPC-组件职责"><a href="#RPC-组件职责" class="headerlink" title="RPC 组件职责"></a>RPC 组件职责</h3><p>下面详细说明下每个组件的职责划分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">1. RpcServer  </div><div class="line">   负责导出（export）远程接口  </div><div class="line">2. RpcClient  </div><div class="line">   负责导入（import）远程接口的代理实现  </div><div class="line">3. RpcProxy  </div><div class="line">   远程接口的代理实现  </div><div class="line">4. RpcInvoker  </div><div class="line">   客户方实现：负责编码调用信息和发送调用请求到服务方并等待调用结果返回  </div><div class="line">   服务方实现：负责调用服务端接口的具体实现并返回调用结果  </div><div class="line">5. RpcProtocol  </div><div class="line">   负责协议编/解码  </div><div class="line">6. RpcConnector  </div><div class="line">   负责维持客户方和服务方的连接通道和发送数据到服务方  </div><div class="line">7. RpcAcceptor  </div><div class="line">   负责接收客户方请求并返回请求结果  </div><div class="line">8. RpcProcessor  </div><div class="line">   负责在服务方控制调用过程，包括管理调用线程池、超时时间等  </div><div class="line">9. RpcChannel  </div><div class="line">   数据传输通道</div></pre></td></tr></table></figure><h3 id="RPC-实现分析"><a href="#RPC-实现分析" class="headerlink" title="RPC 实现分析"></a>RPC 实现分析</h3><h4 id="导出远程接口"><a href="#导出远程接口" class="headerlink" title="导出远程接口"></a>导出远程接口</h4><p>导出远程接口的意思是指只有导出的接口可以供远程调用，而未导出的接口则不能。在 java 中导出接口的代码片段可能如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">DemoService demo   = <span class="keyword">new</span> DemoService();  </div><div class="line">RpcServer  server = <span class="keyword">new</span> RpcServer();  </div><div class="line">server.export(DemoService.class, demo, options);</div></pre></td></tr></table></figure><p>我们可以导出整个接口，也可以更细粒度一点只导出接口中的某些方法，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 只导出 DemoService 中签名为 hi(String s) 的方法  </span></div><div class="line">server.export(DemoService.class, demo, <span class="string">"hi"</span>, <span class="keyword">new</span> Class&lt;?&gt;[] &#123; String.class &#125;, options);</div></pre></td></tr></table></figure><p>java 中还有一种比较特殊的调用就是多态，也就是一个接口可能有多个实现，那么远程调用时到底调用哪个？这个本地调用的语义是通过 jvm 提供的引用多态性隐式实现的，那么对于 RPC 来说跨进程的调用就没法隐式实现了。如果前面<code>DemoService</code> 接口有 2 个实现，那么在导出接口时就需要特殊标记不同的实现，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">DemoService demo   = <span class="keyword">new</span> DemoService();  </div><div class="line">DemoService demo2  = <span class="keyword">new</span> DemoService();  </div><div class="line">RpcServer   server = <span class="keyword">new</span> RpcServer();  </div><div class="line">server.export(DemoService.class, demo, options);  </div><div class="line">server.export(<span class="string">"demo2"</span>, DemoService.class, demo2, options);</div></pre></td></tr></table></figure><p>上面 demo2 是另一个实现，我们标记为 “demo2” 来导出，那么远程调用时也需要传递该标记才能调用到正确的实现类，这样就解决了多态调用的语义。</p><h4 id="导入远程接口与客户端代理"><a href="#导入远程接口与客户端代理" class="headerlink" title="导入远程接口与客户端代理"></a>导入远程接口与客户端代理</h4><p>导入相对于导出远程接口，客户端代码为了能够发起调用必须要获得远程接口的方法或过程定义。目前，大部分跨语言平台 RPC 框架采用根据 IDL 定义通过 code generator 去生成 stub 代码，这种方式下实际导入的过程就是通过代码生成器在编译期完成的。</p><p>代码生成的方式对跨语言平台 RPC 框架而言是必然的选择，而对于同一语言平台的 RPC 则可以通过共享接口定义来实现。在 java 中导入接口的代码片段可能如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">RpcClient client = <span class="keyword">new</span> RpcClient();  </div><div class="line">DemoService demo = client.refer(DemoService.class);  </div><div class="line">demo.hi(<span class="string">"how are you?"</span>);</div></pre></td></tr></table></figure><p>在 java 中 ‘import’ 是关键字，所以代码片段中我们用 refer 来表达导入接口的意思。这里的导入方式本质也是一种代码生成技术，只不过是在运行时生成，比静态编译期的代码生成看起来更简洁些。</p><h4 id="协议编解码"><a href="#协议编解码" class="headerlink" title="协议编解码"></a>协议编解码</h4><p>客户端代理在发起调用前需要对调用信息进行编码，这就要考虑需要编码些什么信息并以什么格式传输到服务端才能让服务端完成调用。出于效率考虑，编码的信息越少越好（传输数据少），编码的规则越简单越好（执行效率高）。我们先看下需要编码些什么信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">-- 调用编码 --  </div><div class="line">1. 接口方法  </div><div class="line">   包括接口名、方法名  </div><div class="line">2. 方法参数  </div><div class="line">   包括参数类型、参数值  </div><div class="line">3. 调用属性  </div><div class="line">   包括调用属性信息，例如调用附件隐式参数、调用超时时间等  </div><div class="line">  </div><div class="line">-- 返回编码 --  </div><div class="line">1. 返回结果  </div><div class="line">   接口方法中定义的返回值  </div><div class="line">2. 返回码  </div><div class="line">   异常返回码  </div><div class="line">3. 返回异常信息  </div><div class="line">   调用异常信息</div></pre></td></tr></table></figure><p>除了以上这些必须的调用信息，我们可能还需要一些元信息以方便程序编解码以及未来可能的扩展。这样我们的编码消息里面就分成了两部分，一部分是元信息、另一部分是调用的必要信息。如果设计一种 RPC 协议消息的话，元信息我们把它放在协议消息头中，而必要信息放在协议消息体中。下面给出一种概念上的 RPC 协议消息设计格式：</p><p><img src="http://img.blog.csdn.net/20150108170315663?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbWluZGZsb2F0aW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">-- 消息头 --  </div><div class="line">magic      : 协议魔数，为解码设计  </div><div class="line">header size: 协议头长度，为扩展设计  </div><div class="line">version    : 协议版本，为兼容设计  </div><div class="line">st         : 消息体序列化类型  </div><div class="line">hb         : 心跳消息标记，为长连接传输层心跳设计  </div><div class="line">ow         : 单向消息标记，  </div><div class="line">rp         : 响应消息标记，不置位默认是请求消息  </div><div class="line">status code: 响应消息状态码  </div><div class="line">reserved   : 为字节对齐保留  </div><div class="line">message id : 消息 id  </div><div class="line">body size  : 消息体长度  </div><div class="line">  </div><div class="line">-- 消息体 --  </div><div class="line">采用序列化编码，常见有以下格式  </div><div class="line">xml   : 如 webservie soap  </div><div class="line">json  : 如 JSON-RPC  </div><div class="line">binary: 如 thrift; hession; kryo 等</div></pre></td></tr></table></figure><p>格式确定后编解码就简单了，由于头长度一定所以我们比较关心的就是消息体的序列化方式。序列化我们关心三个方面：</p><ol><li>序列化和反序列化的效率，越快越好。</li><li>序列化后的字节长度，越小越好。</li><li>序列化和反序列化的兼容性，接口参数对象若增加了字段，是否兼容。</li></ol><h4 id="传输服务"><a href="#传输服务" class="headerlink" title="传输服务"></a>传输服务</h4><p>协议编码之后，自然就是需要将编码后的 RPC 请求消息传输到服务方，服务方执行后返回结果消息或确认消息给客户方。RPC 的应用场景实质是一种可靠的请求应答消息流，和 HTTP 类似。因此选择长连接方式的 TCP 协议会更高效，与 HTTP 不同的是在协议层面我们定义了每个消息的唯一 id，因此可以更容易的复用连接。</p><p>既然使用长连接，那么第一个问题是到底 client 和 server 之间需要多少根连接？实际上单连接和多连接在使用上没有区别，对于数据传输量较小的应用类型，单连接基本足够。单连接和多连接最大的区别在于，每根连接都有自己私有的发送和接收缓冲区，因此大数据量传输时分散在不同的连接缓冲区会得到更好的吞吐效率。所以，如果你的数据传输量不足以让单连接的缓冲区一直处于饱和状态的话，那么使用多连接并不会产生任何明显的提升，反而会增加连接管理的开销。</p><p>连接是由 client 端发起建立并维持。如果 client 和 server 之间是直连的，那么连接一般不会中断（当然物理链路故障除外）。如果 client 和 server 连接经过一些负载中转设备，有可能连接一段时间不活跃时会被这些中间设备中断。为了保持连接有必要定时为每个连接发送心跳数据以维持连接不中断。心跳消息是 RPC 框架库使用的内部消息，在前文协议头结构中也有一个专门的心跳位，就是用来标记心跳消息的，它对业务应用透明。</p><h4 id="执行调用"><a href="#执行调用" class="headerlink" title="执行调用"></a>执行调用</h4><p>client stub 所做的事情仅仅是编码消息并传输给服务方，而真正调用过程发生在服务方。server stub 从前文的结构拆解中我们细分了 <code>RpcProcessor</code> 和 <code>RpcInvoker</code> 两个组件，一个负责控制调用过程，一个负责真正调用。这里我们还是以 java 中实现这两个组件为例来分析下它们到底需要做什么？</p><p>java 中实现代码的动态接口调用目前一般通过反射调用。除了原生的 jdk 自带的反射，一些第三方库也提供了性能更优的反射调用，因此 <code>RpcInvoker</code> 就是封装了反射调用的实现细节。</p><p>调用过程的控制需要考虑哪些因素，<code>RpcProcessor</code> 需要提供什么样地调用控制服务呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1. 效率提升  </div><div class="line">   每个请求应该尽快被执行，因此我们不能每请求来再创建线程去执行，需要提供线程池服务。  </div><div class="line">2. 资源隔离  </div><div class="line">   当我们导出多个远程接口时，如何避免单一接口调用占据所有线程资源，而引发其他接口执行阻塞。  </div><div class="line">3. 超时控制  </div><div class="line">   当某个接口执行缓慢，而 client 端已经超时放弃等待后，server 端的线程继续执行此时显得毫无意义。</div></pre></td></tr></table></figure><h4 id="RPC-异常处理"><a href="#RPC-异常处理" class="headerlink" title="RPC 异常处理"></a>RPC 异常处理</h4><p>无论 RPC 怎样努力把远程调用伪装的像本地调用，但它们依然有很大的不同点，而且有一些异常情况是在本地调用时绝对不会碰到的。在说异常处理之前，我们先比较下本地调用和 RPC 调用的一些差异：</p><ol><li>本地调用一定会执行，而远程调用则不一定，调用消息可能因为网络原因并未发送到服务方。</li><li>本地调用只会抛出接口声明的异常，而远程调用还会跑出 RPC 框架运行时的其他异常。</li><li>本地调用和远程调用的性能可能差距很大，这取决于 RPC 固有消耗所占的比重。</li></ol><p>正是这些区别决定了使用 RPC 时需要更多考量。当调用远程接口抛出异常时，异常可能是一个业务异常，也可能是 RPC 框架抛出的运行时异常（如：网络中断等）。业务异常表明服务方已经执行了调用，可能因为某些原因导致未能正常执行，而 RPC 运行时异常则有可能服务方根本没有执行，对调用方而言的异常处理策略自然需要区分。</p><p>由于 RPC 固有的消耗相对本地调用高出几个数量级，本地调用的固有消耗是纳秒级，而 RPC 的固有消耗是在毫秒级。那么对于过于轻量的计算任务就并不合适导出远程接口由独立的进程提供服务，只有花在计算任务上时间远远高于 RPC 的固有消耗才值得导出为远程接口提供服务。</p></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><header class="post-header"><h1 class="post-title" itemprop="name headline"> <a class="post-title-link" href="/2017/06/20/Thrift详解/" itemprop="url">Thrift详解</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time itemprop="dateCreated" datetime="2017-06-20T17:14:17+08:00" content="2017-06-20">2017-06-20</time></span></div></header><div class="post-body" itemprop="articleBody"><h3 id="RPC调用流程"><a href="#RPC调用流程" class="headerlink" title="RPC调用流程"></a>RPC调用流程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">1）客户端（client）调用以本地调用方式调用服务；</div><div class="line">2）client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；</div><div class="line">3）client stub找到服务地址，并将消息发送到服务端；</div><div class="line"></div><div class="line">4）server stub收到消息后进行解码；</div><div class="line">5）server stub根据解码结果调用本地的服务；</div><div class="line">6）服务端执行并将结果返回给server stub；</div><div class="line">7）server stub将返回结果打包成消息并发送至消费方；</div><div class="line"></div><div class="line">8）client stub接收到消息，并进行解码；</div><div class="line">9）客户端得到最终结果。</div></pre></td></tr></table></figure><p><img src="http://images2015.cnblogs.com/blog/522490/201510/522490-20151003120412386-363334260.png" alt="img"></p><h3 id="Thrift主要特点"><a href="#Thrift主要特点" class="headerlink" title="Thrift主要特点"></a>Thrift主要特点</h3><ol><li>基于二进制的高性能的编解码框架</li><li>基于NIO的底层通信</li><li>相对简单的服务调用模型</li><li>使用IDL支持跨平台调用</li></ol><h3 id="Thrift核心组件"><a href="#Thrift核心组件" class="headerlink" title="Thrift核心组件"></a>Thrift核心组件</h3><ol><li><code>TProtocol</code> 协议和编解码组件</li><li><code>TTransport</code> 传输组件</li><li><code>TProcessor</code> 服务调用组件</li><li><code>TServer</code>，<code>Client</code> 服务器和客户端组件</li><li>IDL 服务描述组件，负责生产跨平台客户端</li></ol><div class="post-more-link text-center"> <a class="btn" href="/2017/06/20/Thrift详解/#more" rel="contents">阅读全文 &raquo;</a></div></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article></section><nav class="pagination"><a class="extend prev" rel="prev" href="/page/9/"><i class="fa fa-angle-left"></i></a> <a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><span class="space">&hellip;</span><a class="page-number" href="/page/30/">30</a><a class="extend next" rel="next" href="/page/11/"><i class="fa fa-angle-right"></i></a></nav></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><section class="site-overview sidebar-panel sidebar-panel-active"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="David"><p class="site-author-name" itemprop="name">David</p><p class="site-description motion-element" itemprop="description">Develop Notes</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"> <a href="/archives"><span class="site-state-item-count">148</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags"><span class="site-state-item-count">37</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/zsr" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i> GitHub</a></span><span class="links-of-author-item"><a href="http://weibo.com/u/2214956781" target="_blank" title="Weibo"><i class="fa fa-fw fa-weibo"></i> Weibo</a></span></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright"> &copy; 2016 - <span itemprop="copyrightYear">2018</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">David</span></div><div class="powered-by"> 由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div><div class="theme-info"> 主题 - <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script><script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script><script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script><script type="text/javascript">function proceedsearch(){$("body").append('<div class="popoverlay">').css("overflow","hidden"),$(".popup").toggle()}var isfetched=!1,search_path="search.xml";0==search_path.length&&(search_path="search.xml");var path="/"+search_path,searchFunc=function(e,t,a){"use strict";$.ajax({url:e,dataType:"xml",async:!0,success:function(e){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var r=$("entry",e).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get(),c=document.getElementById(t),s=document.getElementById(a);c.addEventListener("input",function(){var e=0,t='<ul class="search-result-list">',a=this.value.trim().toLowerCase().split(/[\s\-]+/);s.innerHTML="",this.value.trim().length>1&&r.forEach(function(r){var c=!0,s=r.title.trim().toLowerCase(),n=r.content.trim().replace(/<[^>]+>/g,"").toLowerCase(),i=r.url,o=-1,l=-1,p=-1;if(""!=s&&""!=n&&a.forEach(function(e,t){o=s.indexOf(e),l=n.indexOf(e),o<0&&l<0?c=!1:(l<0&&(l=0),0==t&&(p=l))}),c){e+=1,t+="<li><a href='"+i+"' class='search-result-title'>"+s+"</a>";var h=r.content.trim().replace(/<[^>]+>/g,"");if(p>=0){var u=p-20,d=p+80;u<0&&(u=0),0==u&&(d=50),d>h.length&&(d=h.length);var f=h.substring(u,d);a.forEach(function(e){var t=new RegExp(e,"gi");f=f.replace(t,'<b class="search-keyword">'+e+"</b>")}),t+='<p class="search-result">'+f+"...</p>"}t+="</li>"}}),t+="</ul>",0==e&&(t='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'),""==a&&(t='<div id="no-result"><i class="fa fa-search fa-5x" /></div>'),s.innerHTML=t}),proceedsearch()}})};$(".popup-trigger").click(function(e){e.stopPropagation(),0==isfetched?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(function(e){$(".popup").hide(),$(".popoverlay").remove(),$("body").css("overflow","")}),$(".popup").click(function(e){e.stopPropagation()})</script></body></html>