<!doctype html><html class="theme-next pisces use-motion"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css"><link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css"><meta name="keywords" content="Hexo, NexT"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1"><meta name="description" content="Develop Notes"><meta property="og:type" content="website"><meta property="og:title" content="Hello Coder"><meta property="og:url" content="http://zsr.github.io/page/25/index.html"><meta property="og:site_name" content="Hello Coder"><meta property="og:description" content="Develop Notes"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Hello Coder"><meta name="twitter:description" content="Develop Notes"><script type="text/javascript" id="hexo.configuration">var NexT=window.NexT||{},CONFIG={scheme:"Pisces",sidebar:{position:"left",display:"post"},fancybox:!0,motion:!0,duoshuo:{userId:0,author:"博主"}}</script><link rel="canonical" href="http://zsr.github.io/page/25/"><title> Hello Coder</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><script>!function(e,a,t,n,c,o,s){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,o=a.createElement(t),s=a.getElementsByTagName(t)[0],o.async=1,o.src=n,s.parentNode.insertBefore(o,s)}(window,document,"script","//www.google-analytics.com/analytics.js","ga"),ga("create","UA-81477846-1","auto"),ga("send","pageview")</script><div class="container one-collumn sidebar-position-left page-home"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Hello Coder</span><span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle"></p></div><div class="site-nav-toggle"> <button><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br> 首页</a></li><li class="menu-item menu-item-archives"><a href="/archives" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br> 归档</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br> 标签</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br> 搜索</a></li></ul><div class="site-search"><div class="popup"><span class="search-icon fa fa-search"></span> <input type="text" id="local-search-input"><div id="local-search-result"></div> <span class="popup-btn-close">close</span></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><section id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><header class="post-header"><h1 class="post-title" itemprop="name headline"> <a class="post-title-link" href="/2016/08/18/B+树索引/" itemprop="url">B+树索引</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time itemprop="dateCreated" datetime="2016-08-18T18:00:25+08:00" content="2016-08-18">2016-08-18</time></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="Mysql-索引原理"><a href="#Mysql-索引原理" class="headerlink" title="Mysql 索引原理"></a>Mysql 索引原理</h2><h3 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h3><p>B-树,这里的 B 表示 balance( 平衡的意思),B-树是一种多路自平衡的搜索树<br>它类似普通的平衡二叉树，不同的一点是B-树允许每个节点有更多的子节点。下图是 B-树的简化图.</p><p><img src="/images/B-树.jpg"></p><p>B-树有如下特点:</p><ul><li>所有键值分布在整颗树中；</li><li>任何一个关键字出现且只出现在一个结点中；</li><li>搜索有可能在非叶子结点结束；</li><li>在关键字全集内做一次查找,性能逼近二分查找；</li></ul><h3 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+树"></a>B+树</h3><p>B+树是B-树的变体，也是一种多路搜索树, 它与B-树的不同之处在于:</p><p>所有关键字存储在叶子节点出现,内部节点(非叶子节点并不存储真正的data)<br>为所有叶子结点增加了一个链指针</p><p>简化 B+树 如下图</p><p><img src="/images/B+树.jpg"></p><h3 id="为什么使用B-B-Tree"><a href="#为什么使用B-B-Tree" class="headerlink" title="为什么使用B-/B+ Tree"></a>为什么使用B-/B+ Tree</h3><p>红黑树等数据结构也可以用来实现索引，但是文件系统及数据库系统普遍采用B-/+Tree作为索引结构。MySQL 是基于磁盘的数据库系统,索引往往以索引文件的形式存储的磁盘上,索引查找过程中就要产生磁盘I/O消耗,相对于内存存取，I/O存取的消耗要高几个数量级,索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。为什么使用B-/+Tree，还跟磁盘存取原理有关。</p><h4 id="局部性原理与磁盘预读"><a href="#局部性原理与磁盘预读" class="headerlink" title="局部性原理与磁盘预读"></a>局部性原理与磁盘预读</h4><p>磁盘读取数据靠的是机械运动，每次读取数据花费的时间可以分为寻道时间、旋转延迟、传输时间三个部分，寻道时间指的是磁臂移动到指定磁道所需要的时间，主流磁盘一般在5ms以下；旋转延迟就是我们经常听说的磁盘转速，比如一个磁盘7200转，表示每分钟能转7200次，也就是说1秒钟能转120次，旋转延迟就是1/120/2 = 4.17ms；传输时间指的是从磁盘读出或将数据写入磁盘的时间，一般在零点几毫秒，相对于前两个时间可以忽略不计。那么访问一次磁盘的时间，即一次磁盘IO的时间约等于5+4.17 = 9ms左右，听起来还挺不错的，但要知道一台500 -MIPS的机器每秒可以执行5亿条指令，因为指令依靠的是电的性质，换句话说执行一次IO的时间可以执行40万条指令，数据库动辄十万百万乃至千万级数据，每次9毫秒的时间，显然是个灾难。</p><p>由于磁盘的存取速度与内存之间鸿沟(访问磁盘的成本大概是访问内存的十万倍左右),为了提高效率,要尽量减少磁盘I/O.磁盘往往不是严格按需读取，而是每次都会预读,磁盘读取完需要的数据,会顺序向后读一定长度的数据放入内存。而这样做的理论依据是计算机科学中著名的局部性原理：</p><ul><li>当一个数据被用到时，其附近的数据也通常会马上被使用</li><li>程序运行期间所需要的数据通常比较集中</li></ul><p>由于磁盘顺序读取的效率很高(不需要寻道时间，只需很少的旋转时间)，因此对于具有局部性的程序来说，预读可以提高I/O效率.预读的长度一般为页(page)的整倍数。</p><p><strong>MySQL(默认使用InnoDB引擎),将记录按照页的方式进行管理,每页大小默认为16K(这个值可以修改).linux 默认页大小为4K(每一次IO读取的数据称之为一页)</strong></p><h3 id="B-Tree索引的性能分析"><a href="#B-Tree索引的性能分析" class="headerlink" title="B-/+Tree索引的性能分析"></a>B-/+Tree索引的性能分析</h3><p>实际实现B-Tree还需要使用如下技巧：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个结点只需一次I/O。</div><div class="line">假设 B-Tree 的高度为 h,B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O(h)=O(logdN)O(h)=O(logdN)。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。</div><div class="line">而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。</div></pre></td></tr></table></figure><h3 id="为什么使用-B-树"><a href="#为什么使用-B-树" class="headerlink" title="为什么使用 B+树"></a>为什么使用 B+树</h3><ul><li>B+树更适合外部存储,由于内节点无<code>data</code>域,一个结点可以存储更多的内结点,每个节点能索引的范围更大更精确,也意味着 B+树单次磁盘IO的信息量大于B-树,I/O效率更高。</li><li>Mysql是一种关系型数据库，区间访问是常见的一种情况，B+树叶节点增加的链指针,加强了区间访问性，可使用在范围区间查询等，而B-树每个节点 key 和 data 在一起，则无法区间查找。</li></ul><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p><a href="https://segmentfault.com/a/1190000004690721" target="_blank" rel="external">MySQL索引结构</a></p><p><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="external">MySQL索引背后的数据结构及算法原理</a></p></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><header class="post-header"><h1 class="post-title" itemprop="name headline"> <a class="post-title-link" href="/2016/08/18/mysql-锁/" itemprop="url">mysql 锁</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time itemprop="dateCreated" datetime="2016-08-18T17:59:17+08:00" content="2016-08-18">2016-08-18</time></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="mysql-锁机制"><a href="#mysql-锁机制" class="headerlink" title="mysql 锁机制"></a>mysql 锁机制</h2><p>数据库为了维护事务的性质，尤其是一致性和隔离性，一般使用加锁这种方式。同时数据库又是个高并发的应用，同一时间会有大量的并发访问，如果加锁过度，会极大的降低并发处理能力。所以对于加锁的处理，可以说就是数据库对于事务处理的精髓所在。</p><h3 id="悲观锁和乐观锁"><a href="#悲观锁和乐观锁" class="headerlink" title="悲观锁和乐观锁"></a>悲观锁和乐观锁</h3><ul><li><p>悲观锁</p><p>正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。</p><p>在悲观锁的情况下，为了保证事务的隔离性，就需要一致性锁定读。读取数据时给加锁，其它事务无法修改这些数据。修改删除数据时也要加锁，其它事务无法读取这些数据。</p></li><li><p>乐观锁</p><p>相对悲观锁而言，乐观锁机制采取了更加宽松的加锁机制。悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。</p></li></ul><p>乐观锁，大多是基于数据版本（ Version ）记录机制实现。数据版本:即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。</p><h3 id="多版本的并发控制协议-以乐观锁为理论基础"><a href="#多版本的并发控制协议-以乐观锁为理论基础" class="headerlink" title="多版本的并发控制协议(以乐观锁为理论基础)"></a>多版本的并发控制协议(以乐观锁为理论基础)</h3><p>MySQL InnoDB存储引擎，实现的是基于多版本的并发控制协议——MVCC (Multi-Version Concurrency Control) (注：与MVCC相对的，是基于锁的并发控制，Lock-Based Concurrency Control)。MVCC最大的好处：读不加锁，读写不冲突。在读多写少的OLTP应用中，读写不冲突是非常重要的，极大的增加了系统的并发性能，现阶段几乎所有的RDBMS，都支持了MVCC。</p><p>在MVCC并发控制中，读操作可以分成两类：快照读 (snapshot read)与当前读 (current read)。快照读，读取的是记录的可见版本 (有可能是历史版本)，不用加锁。当前读，读取的是记录的最新版本，并且，当前读返回的记录，都会加上锁，保证其他事务不会再并发修改这条记录。</p><p>以MySQL InnoDB为例：</p><ul><li>快照读：简单的select操作，属于快照读，不加锁。(当然，也有例外，下面会分析)<ul><li>select * from table where ?;</li></ul></li><li><p>当前读：特殊的读操作，插入/更新/删除操作，属于当前读，需要加锁。</p><ul><li>select * from table where ? lock in share mode;</li><li>select * from table where ? for update;</li><li>insert into table values (…);</li><li>update table set ? where ?;</li><li>delete from table where ?;</li></ul><p>所有以上的语句，都属于当前读，读取记录的最新版本。并且，读取之后，还需要保证其他并发事务不能修改当前记录，对读取记录加锁。其中，除了第一条语句，对读取记录加S锁 (共享锁)外，其他的操作，都加的是X锁 (排它锁)。</p></li></ul><p>插入/更新/删除 操作，都归为当前读.如更新 操作，在数据库中的执行流程：</p><p><img src="/images/mysql锁机制1-1.jpg"></p><p>从图中，可以看到，一个Update操作的具体流程。当Update SQL被发给MySQL后，MySQL Server会根据where条件，读取第一条满足条件的记录，然后InnoDB引擎会将第一条记录返回，并加锁 (current read)。待MySQL Server收到这条加锁的记录之后，会再发起一个Update请求，更新这条记录。一条记录操作完成，再读取下一条记录，直至没有满足条件的记录为止。因此，Update操作内部，就包含了一个当前读。同理，Delete操作也一样。Insert操作会稍微有些不同，简单来说，就是Insert操作可能会触发Unique Key的冲突检查，也会进行一个当前读。</p><p><strong>注：根据上图的交互，针对一条当前读的SQL语句，InnoDB与MySQL Server的交互，是一条一条进行的，因此，加锁也是一条一条进行的。先对一条满足条件的记录加锁，返回给MySQL Server，做一些DML操作(数据操纵语言DML:insert, update, delete)；然后在读取下一条加锁，直至读取完毕。</strong></p><div class="post-more-link text-center"> <a class="btn" href="/2016/08/18/mysql-锁/#more" rel="contents">阅读全文 &raquo;</a></div></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><header class="post-header"><h1 class="post-title" itemprop="name headline"> <a class="post-title-link" href="/2016/08/18/java调试-jstack命令/" itemprop="url">java调试-jstack命令</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time itemprop="dateCreated" datetime="2016-08-18T15:28:54+08:00" content="2016-08-18">2016-08-18</time></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="jstack命令使用"><a href="#jstack命令使用" class="headerlink" title="jstack命令使用"></a>jstack命令使用</h2><p>jstack可用于导出java运用程序的线程堆栈，其基本使用语法为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jstack [<span class="_">-l</span>] pid</div></pre></td></tr></table></figure><p>-l 打印关于锁的附加信息,例如属于java.util.concurrent的ownable synchronizers列表.</p><h3 id="常用用法"><a href="#常用用法" class="headerlink" title="常用用法"></a>常用用法</h3><p>下面这段代码运行之后会出现死锁现象(因为线程1持有lock1，在等待lock2，线程2持有lock2在等待lock1，造成了循环等待，形成死锁)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.zsr.test.lock;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * </div><div class="line"> * Created by david.zhang</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeadLock</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object lock1 = <span class="keyword">new</span> Object();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object lock2 = <span class="keyword">new</span> Object();</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">synchronized</span> (lock1) &#123;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        Thread.sleep(<span class="number">1000</span>);</div><div class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">synchronized</span> (lock2) &#123;</div><div class="line">                        System.out.println(<span class="string">"线程1执行...."</span>);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">synchronized</span> (lock2) &#123;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        Thread.sleep(<span class="number">1000</span>);</div><div class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">synchronized</span> (lock1) &#123;</div><div class="line">                        System.out.println(<span class="string">"线程2执行..."</span>);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        t1.start();</div><div class="line">        t2.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行这段代码，然后使用jstack命令导出这个程序的线程堆栈信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nalideMacBook-Pro-4:public nali$ jstack <span class="_">-l</span> 35072 &gt; /Users/nali/deadlock.txt</div></pre></td></tr></table></figure><p>打开导出的线程堆栈信息文件，文件末尾如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">Found one Java-level deadlock:</div><div class="line"></div><div class="line">=============================</div><div class="line">&quot;Thread-1&quot;:</div><div class="line">  waiting to lock monitor 0x00007fe6d48432b8 (object 0x00000007d558e9d8, a java.lang.Object),</div><div class="line">  which is held by &quot;Thread-0&quot;</div><div class="line">&quot;Thread-0&quot;:</div><div class="line">  waiting to lock monitor 0x00007fe6d4844758 (object 0x00000007d558e9e8, a java.lang.Object),</div><div class="line">  which is held by &quot;Thread-1&quot;</div><div class="line"></div><div class="line">Java stack information for the threads listed above:</div><div class="line"></div><div class="line">===================================================</div><div class="line">&quot;Thread-1&quot;:</div><div class="line">	at com.zsr.test.lock.TestDeadLock$2.run(TestDeadLock.java:39)</div><div class="line">	- waiting to lock &lt;0x00000007d558e9d8&gt; (a java.lang.Object)</div><div class="line">	- locked &lt;0x00000007d558e9e8&gt; (a java.lang.Object)</div><div class="line">	at java.lang.Thread.run(Thread.java:745)</div><div class="line">&quot;Thread-0&quot;:</div><div class="line">	at com.zsr.test.lock.TestDeadLock$1.run(TestDeadLock.java:23)</div><div class="line">	- waiting to lock &lt;0x00000007d558e9e8&gt; (a java.lang.Object)</div><div class="line">	- locked &lt;0x00000007d558e9d8&gt; (a java.lang.Object)</div><div class="line">	at java.lang.Thread.run(Thread.java:745)</div><div class="line"></div><div class="line">Found 1 deadlock.</div></pre></td></tr></table></figure><p>导出的线程堆栈文件中明确提示发现死锁，并且指明了死锁的原因。</p><p>jstack不仅能够导出线程堆栈，还能自动进行死锁检测，输出线程死锁原因。</p></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><header class="post-header"><h1 class="post-title" itemprop="name headline"> <a class="post-title-link" href="/2016/08/18/java调试-jmap命令/" itemprop="url">java调试-jmap命令</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time itemprop="dateCreated" datetime="2016-08-18T12:08:45+08:00" content="2016-08-18">2016-08-18</time></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="jmap命令使用"><a href="#jmap命令使用" class="headerlink" title="jmap命令使用"></a>jmap命令使用</h2><p>jmap是一个多功能的命令。它可以生成java程序的堆dump文件，也可以查看堆内对象实例的统计信息，查看ClassLoader的信息以及Finalizer队列。</p><h3 id="常用用法"><a href="#常用用法" class="headerlink" title="常用用法"></a>常用用法</h3><ul><li>导出对象统计信息</li></ul><p>下面的命令生成PID为24205的java成粗的对象的统计信息，并输出到out.txt文件中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nalideMacBook-Pro-4:~ nali$ jmap -histo 24205 &gt; /Users/nali/out.txt</div></pre></td></tr></table></figure><p>生成的文件如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"> num     #instances         #bytes  class name</div><div class="line">----------------------------------------------</div><div class="line">   1:        962520       23100480  java.lang.Long</div><div class="line">   2:        481260       19250400  com.ximalaya.test.Ip</div><div class="line">   3:        962779       15404464  java.lang.Integer</div><div class="line">   4:        481300       15401600  java.util.HashMap$Entry</div><div class="line">   5:          6362        9556232  [I</div><div class="line">   6:            19        7341744  [Ljava.util.HashMap$Entry;</div><div class="line">   7:           319        2174856  [Ljava.lang.Object;</div><div class="line">   8:          6060         781024  &lt;methodKlass&gt;</div><div class="line">   9:          6060         692032  &lt;constMethodKlass&gt;</div><div class="line">  10:           415         486208  &lt;constantPoolKlass&gt;</div><div class="line">  11:           378         296288  &lt;constantPoolCacheKlass&gt;</div><div class="line">  12:           415         285880  &lt;instanceKlassKlass&gt;</div><div class="line">  13:          1358         156272  [C</div><div class="line">  14:           573          94240  [B</div><div class="line">  15:           125          52928  &lt;methodDataKlass&gt;</div><div class="line">  16:           478          46680  java.lang.Class</div><div class="line">  17:           704          45152  [[I</div><div class="line">  18:           631          38168  [S</div><div class="line">  19:          1334          32016  java.lang.String</div><div class="line">  20:            46          25024  &lt;objArrayKlassKlass&gt;</div><div class="line">  21:           101           6464  java.net.URL</div><div class="line">  22:            79           5688  java.lang.reflect.Field</div><div class="line">  23:             8           4352  &lt;typeArrayKlassKlass&gt;</div><div class="line">  24:            96           3840  java.util.LinkedHashMap$Entry</div><div class="line">  25:           119           3808  java.util.Hashtable$Entry</div><div class="line">  26:            94           3760  java.lang.ref.SoftReference</div><div class="line">  27:            91           2912  java.util.concurrent.ConcurrentHashMap$HashEntry</div><div class="line">  28:            61           2432  [Ljava.lang.String;</div></pre></td></tr></table></figure><p>从文件中可以看到，统计信息显示了内存中实例的数量和合计。</p><ul><li>导出程序堆快照</li></ul><p>下面的命令导出PID为24205的java程序当前的堆快照：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">nalideMacBook-Pro-4:~ nali$ jmap -dump:format=b,file=dump.bin 24205</div><div class="line">Dumping heap to /Users/nali/dump.bin ...</div><div class="line">Heap dump file created</div></pre></td></tr></table></figure><p>该命令成功地将运用程序的当前的堆快照导出到了dump.bin文件，之后可以使用Visual VM，MAT等工具分析对快照文件。</p><ul><li>查看java 堆（heap）使用情况</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">nalideMacBook-Pro-4:~ nali$ jmap -heap 30192</div><div class="line">Attaching to process ID 30192, please wait...</div><div class="line">Debugger attached successfully.</div><div class="line">Server compiler detected.</div><div class="line">JVM version is 24.79-b02</div><div class="line"></div><div class="line">using thread-local object allocation.</div><div class="line">Parallel GC with 4 thread(s)</div><div class="line"></div><div class="line">Heap Configuration: //堆内存初始化配置</div><div class="line">   //对应jvm启动参数-XX:M<span class="keyword">in</span>HeapFreeRatio设置JVM堆最小空闲比率</div><div class="line">   M<span class="keyword">in</span>HeapFreeRatio = 0 </div><div class="line">   //对应jvm启动参数 -XX:MaxHeapFreeRatio设置JVM堆最大空闲比率</div><div class="line">   MaxHeapFreeRatio = 100 </div><div class="line">   //对应jvm启动参数-XX:MaxHeapSize=设置JVM堆的最大大小</div><div class="line">   MaxHeapSize      = 2147483648 (2048.0MB)</div><div class="line">   //对应jvm启动参数-XX:NewSize=设置JVM堆的‘新生代’的默认大小</div><div class="line">   NewSize          = 1310720 (1.25MB)</div><div class="line">   //对应jvm启动参数-XX:MaxNewSize=设置JVM堆的‘新生代’的最大大小</div><div class="line">   MaxNewSize       = 17592186044415 MB</div><div class="line">   //对应jvm启动参数-XX:OldSize=&lt;value&gt;:设置JVM堆的‘老生代’的大小</div><div class="line">   OldSize          = 5439488 (5.1875MB)</div><div class="line">   //对应jvm启动参数-XX:NewRatio=:‘新生代’和‘老生代’的大小比率</div><div class="line">   NewRatio         = 2</div><div class="line">   //对应jvm启动参数-XX:SurvivorRatio=设置年轻代中Eden区与Survivor区的大小比值 </div><div class="line">   SurvivorRatio    = 8</div><div class="line">   //对应jvm启动参数-XX:PermSize=&lt;value&gt;:设置JVM堆的‘永生代’的初始大小</div><div class="line">   PermSize         = 21757952 (20.75MB)</div><div class="line">   //对应jvm启动参数-XX:MaxPermSize=&lt;value&gt;:设置JVM堆的‘永生代’的最大大小</div><div class="line">   MaxPermSize      = 85983232 (82.0MB)</div><div class="line">   G1HeapRegionSize = 0 (0.0MB)</div><div class="line"></div><div class="line">Heap Usage:</div><div class="line">PS Young Generation</div><div class="line">Eden Space: //Eden区内存分布</div><div class="line">   //Eden区总容量</div><div class="line">   capacity = 136839168 (130.5MB)</div><div class="line">   //Eden区已使用</div><div class="line">   used     = 62349088 (59.460723876953125MB)</div><div class="line">   //Eden区剩余容量</div><div class="line">   free     = 74490080 (71.03927612304688MB)</div><div class="line">   //Eden区使用比率</div><div class="line">   45.56377308578784% used</div><div class="line">From Space: //其中一个Survivor区的内存分布</div><div class="line">   capacity = 17301504 (16.5MB)</div><div class="line">   used     = 17299704 (16.49828338623047MB)</div><div class="line">   free     = 1800 (0.00171661376953125MB)</div><div class="line">   99.98959628018466% used</div><div class="line">To Space: //另一个Survivor区的内存分布</div><div class="line">   capacity = 27262976 (26.0MB)</div><div class="line">   used     = 0 (0.0MB)</div><div class="line">   free     = 27262976 (26.0MB)</div><div class="line">   0.0% used</div><div class="line">PS Old Generation //当前的Old区内存分布</div><div class="line">   capacity = 89128960 (85.0MB)</div><div class="line">   used     = 35824408 (34.164817810058594MB)</div><div class="line">   free     = 53304552 (50.835182189941406MB)</div><div class="line">   40.19390330595129% used</div><div class="line">PS Perm Generation //当前的 “永生代” 内存分布</div><div class="line">   capacity = 22020096 (21.0MB)</div><div class="line">   used     = 2801672 (2.6718826293945312MB)</div><div class="line">   free     = 19218424 (18.32811737060547MB)</div><div class="line">   12.723250616164435% used</div><div class="line"></div><div class="line">734 interned Strings occupying 47744 bytes.</div></pre></td></tr></table></figure></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><header class="post-header"><h1 class="post-title" itemprop="name headline"> <a class="post-title-link" href="/2016/08/18/java调试-jstat命令/" itemprop="url">java调试-jstat命令</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time itemprop="dateCreated" datetime="2016-08-18T10:16:15+08:00" content="2016-08-18">2016-08-18</time></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="jstat命令使用"><a href="#jstat命令使用" class="headerlink" title="jstat命令使用"></a>jstat命令使用</h2><p>jstat是一个可以用于观察java应用程序运行时相关信息的工具，功能非常强大，可以通过它<strong>查看堆信息的详细情况。</strong></p><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>jstat命令的基本使用语法如下：</p><p><strong>jstat -option [-t] [-h] pid [interval] [count]</strong></p><ul><li>选项option可以由以下值构成。<ul><li>-class：显示ClassLoader的相关信息。</li><li>-compiler：显示JIT编译的相关信息。</li><li><strong>-gc：显示与gc相关的堆信息。</strong></li><li>-gccapacity：显示各个代的容量及使用情况。</li><li>-gccause：显示垃圾回收的相关信息（同-gcutil），同时显示最后一次或当前正在发生的垃圾回收的诱因。</li><li>-gcnew：显示新生代信息。</li><li>-gcnewcapacity：显示新生代大小与使用情况。</li><li>-gcold：显示老生代和永久代的信息。</li><li>-gcoldcapacity：显示老年代的大小。</li><li>-gcpermcapacity：显示永久代的大小。</li><li>-gcutil：显示垃圾收集信息。</li><li>-printcompilation：输出JIT编译的方法信息。</li></ul></li><li>-t参数可以在输出信息前面加上一个Timestamp列，显示程序运行的时间。</li><li>-h参数可以在周期性的数据输出时，输出多少行数据后，跟着输出一个表头信息。</li><li>interval参数用于指定输出统计数据的周期，单位为毫秒(ms)。</li><li>count参数用于指定一共输出多少次数据。</li></ul><h3 id="详细使用"><a href="#详细使用" class="headerlink" title="详细使用"></a>详细使用</h3><h5 id="class使用"><a href="#class使用" class="headerlink" title="-class使用"></a>-class使用</h5><p>下面命令输出pid为2500这个进程的ClassLoader相关信息，每秒统计一次信息，一共输出3次。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">nalideMacBook-Pro-4:~ nali$ jstat -class -t 13640 1000 3</div><div class="line">Timestamp       Loaded  Bytes  Unloaded  Bytes     Time</div><div class="line">1522.7          414     827.5      0     0.0       0.13</div><div class="line">1523.7          414     827.5      0     0.0       0.13</div><div class="line">1524.7          414     827.5      0     0.0       0.13</div></pre></td></tr></table></figure><p>Loaded表示载入的类的数量，第一个Bytes表示载入的类的合计大小，Unloaded表示卸载的类数量，第二个Bytes表示卸载的类的合计大小，Time表示加载和卸载类花的总的时间。</p><h5 id="compiler使用"><a href="#compiler使用" class="headerlink" title="-compiler使用"></a>-compiler使用</h5><p>下面的命令查看JIT编译的信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">nalideMacBook-Pro-4:~ nali$ jstat -compiler -t 13640</div><div class="line">Timestamp       Compiled Failed Invalid   Time   FailedType FailedMethod</div><div class="line">         1814.8       99      0       0     0.51          0</div></pre></td></tr></table></figure><p>Compiled表示编译任务执行的次数，Failed表示编译失败的次数，Invalid表示编译不可用的次数，Time表示编译的总耗时，FailedType表示最后一次编译的类型，FailedMethod表示最后一次编译失败的类名和方法名。</p><h5 id="gc使用"><a href="#gc使用" class="headerlink" title="-gc使用"></a>-gc使用</h5><p>下面的命令显示与gc相关的堆信息的输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">nalideMacBook-Pro-4:~ nali$ jstat -gc 16309</div><div class="line">S0C     S1C     S0U      S1U   EC       EU        OC         OU          MC     MU </div><div class="line">45056.0 55296.0 44588.0  0.0   336896.0 222238.4  171520.0   86902.0     -      - </div><div class="line">CCSC CCSU YGC YGCT   FGC     FGCT      GCT</div><div class="line">-     -    8  0.312   1      1.328    1.640</div></pre></td></tr></table></figure><ul><li>S0C：s0(from)的大小(KB)</li><li>S1C：s1(from)的大小(KB)</li><li>S0U：s0(from)已使用的空间(KB)</li><li>S1U：s1(from)已经使用的空间(KB)</li><li>EC：eden区的大小(KB)</li><li>EU：eden区已经使用的空间(KB)</li><li>OC：老年代大小(KB)</li><li>OU：老年代已经使用的空间(KB)</li><li>MC：方法区大小(KB)</li><li>MU：方法区使用大小(KB)</li><li>CCSC:压缩类空间大小(KB)</li><li>CCSU:压缩类空间使用大小(KB)</li><li>YGC：新生代gc次数</li><li>YGCT：新生代gc耗时</li><li>FGC：Full gc次数</li><li>FGCT：Full gc耗时</li><li>GCT：gc总耗时</li></ul><h5 id="gccapacity使用"><a href="#gccapacity使用" class="headerlink" title="-gccapacity使用"></a>-gccapacity使用</h5><p>下面的命令显示了各个代的信息，与-gc相比，它不仅输出了各个代的当前大小，还输出了各个代的最大值与最小值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">nalideMacBook-Pro-4:~ nali$ jstat -gccapacity 16309</div><div class="line"> NGCMN    NGCMX     NGC     S0C     S1C       EC        OGCMN      OGCMX   </div><div class="line">44032.0 699392.0 626176.0 45056.0 55296.0 336896.0    87040.0    1397760.0    </div><div class="line"> OGC       OC       MCMN    MCMX     MC       CCSMN    CCSMX     CCSC    YGC    FGC</div><div class="line">171520.0  171520.0    -       -      -        -        -        -      8        1</div><div class="line">nalideMacBook-Pro-4:~ nali$</div></pre></td></tr></table></figure><ul><li>NGCMN：新生代最小值(KB)</li><li>NGCMX：新生代最大值(KB)</li><li>NGC：当前新生代大小(KB)</li><li>OGCMN：老年大最小值(KB)</li><li>OGCMX：老年代最大值(KB)</li><li>OGC：当前老年代大小(KB)</li><li>MCMN：方法区最小值(KB)</li><li>MCMX：方法区最大值(KB)</li><li>CCSMN：压缩类空间最小值(KB)</li><li>CCSMX：压缩类空间最大值(KB)</li></ul><h5 id="gccause使用"><a href="#gccause使用" class="headerlink" title="-gccause使用"></a>-gccause使用</h5><p>下面命令显示最近一次gc的原因，以及当前gc的原因：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">nalideMacBook-Pro-4:~ nali$ jstat -gccause 16309</div><div class="line">S0     S1     E      O      M     CCS    YGC    YGCT    FGC    FGCT     GCT   </div><div class="line">98.96  0.00  65.97  50.67   -      -      8      0.312    1    1.328    1.640</div><div class="line">LGCC                  GCC        </div><div class="line">Allocation Failure   No GC</div></pre></td></tr></table></figure><ul><li>LGCC：上次gc的原因，可以看到上次gc的原因是Allocation Failure</li><li>GCC：当前gc的原因，当前没有gc</li></ul><h5 id="gcnew使用"><a href="#gcnew使用" class="headerlink" title="-gcnew使用"></a>-gcnew使用</h5><p>下面的命令显示新生代的详细信息:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">nalideMacBook-Pro-4:~ nali$ jstat -gcnew 16309</div><div class="line"> S0C    S1C     S0U        S1U  TT MTT  DSS      EC       EU        YGC   YGCT</div><div class="line">45056.0 55296.0 44588.0    0.0  5  15   55296.0  336896.0 222238.4  8     0.312</div></pre></td></tr></table></figure><ul><li>TT：新生代对象晋升到老年代对象的年龄。</li><li>MTT：新生代对象晋升到老年代对象的年龄的最大值。</li><li>DSS：所需的Survivor区的大小。</li></ul><h5 id="gcnewcapacity使用"><a href="#gcnewcapacity使用" class="headerlink" title="-gcnewcapacity使用"></a>-gcnewcapacity使用</h5><p>下面的命令详细输出了新生代各个区的大小信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">nalideMacBook-Pro-4:~ nali$ jstat -gcnewcapacity 16309</div><div class="line">NGCMN    NGCMX    NGC      S0CMX     S0C     S1CMX     S1C       ECMX        EC      </div><div class="line">44032.0  699392.0 626176.0 232960.0  45056.0 232960.0  55296.0   698368.0  336896.0     </div><div class="line">YGC   FGC</div><div class="line">8     1</div><div class="line">```   </div><div class="line"></div><div class="line">- S0CMX：s0区的最大值(KB)</div><div class="line">- S1CMX：s1区的最大值(KB)</div><div class="line">- ECMX：eden区的最大值(KB)</div><div class="line"></div><div class="line"><span class="comment">##### -gcold使用</span></div><div class="line"></div><div class="line">下面的命令显示老年代gc概况：</div><div class="line"></div><div class="line"></div><div class="line">``` bash</div><div class="line">nalideMacBook-Pro-4:~ nali$ jstat -gcold 16309</div><div class="line">MC   MU      CCSC     CCSU       OC          OU       YGC    FGC    FGCT     GCT</div><div class="line">-    -        -        -     171520.0      86902.0     8     1      1.328    1.640</div></pre></td></tr></table></figure><h5 id="gcoldcapacity使用"><a href="#gcoldcapacity使用" class="headerlink" title="-gcoldcapacity使用"></a>-gcoldcapacity使用</h5><p>下面的命令用于显示老年代的容量信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">nalideMacBook-Pro-4:~ nali$ jstat -gcoldcapacity 16309</div><div class="line">OGCMN       OGCMX        OGC         OC       YGC   FGC    FGCT     GCT</div><div class="line">87040.0   1397760.0    171520.0    171520.0     8     1    1.328    1.640</div></pre></td></tr></table></figure></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article></section><nav class="pagination"><a class="extend prev" rel="prev" href="/page/24/"><i class="fa fa-angle-left"></i></a> <a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/24/">24</a><span class="page-number current">25</span><a class="page-number" href="/page/26/">26</a><span class="space">&hellip;</span><a class="page-number" href="/page/30/">30</a><a class="extend next" rel="next" href="/page/26/"><i class="fa fa-angle-right"></i></a></nav></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><section class="site-overview sidebar-panel sidebar-panel-active"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="David"><p class="site-author-name" itemprop="name">David</p><p class="site-description motion-element" itemprop="description">Develop Notes</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"> <a href="/archives"><span class="site-state-item-count">149</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags"><span class="site-state-item-count">37</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/zsr" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i> GitHub</a></span><span class="links-of-author-item"><a href="http://weibo.com/u/2214956781" target="_blank" title="Weibo"><i class="fa fa-fw fa-weibo"></i> Weibo</a></span></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright"> &copy; 2016 - <span itemprop="copyrightYear">2018</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">David</span></div><div class="powered-by"> 由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div><div class="theme-info"> 主题 - <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script><script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script><script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script><script type="text/javascript">function proceedsearch(){$("body").append('<div class="popoverlay">').css("overflow","hidden"),$(".popup").toggle()}var isfetched=!1,search_path="search.xml";0==search_path.length&&(search_path="search.xml");var path="/"+search_path,searchFunc=function(e,t,a){"use strict";$.ajax({url:e,dataType:"xml",async:!0,success:function(e){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var r=$("entry",e).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get(),c=document.getElementById(t),s=document.getElementById(a);c.addEventListener("input",function(){var e=0,t='<ul class="search-result-list">',a=this.value.trim().toLowerCase().split(/[\s\-]+/);s.innerHTML="",this.value.trim().length>1&&r.forEach(function(r){var c=!0,s=r.title.trim().toLowerCase(),n=r.content.trim().replace(/<[^>]+>/g,"").toLowerCase(),i=r.url,o=-1,l=-1,p=-1;if(""!=s&&""!=n&&a.forEach(function(e,t){o=s.indexOf(e),l=n.indexOf(e),o<0&&l<0?c=!1:(l<0&&(l=0),0==t&&(p=l))}),c){e+=1,t+="<li><a href='"+i+"' class='search-result-title'>"+s+"</a>";var h=r.content.trim().replace(/<[^>]+>/g,"");if(p>=0){var u=p-20,d=p+80;u<0&&(u=0),0==u&&(d=50),d>h.length&&(d=h.length);var f=h.substring(u,d);a.forEach(function(e){var t=new RegExp(e,"gi");f=f.replace(t,'<b class="search-keyword">'+e+"</b>")}),t+='<p class="search-result">'+f+"...</p>"}t+="</li>"}}),t+="</ul>",0==e&&(t='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'),""==a&&(t='<div id="no-result"><i class="fa fa-search fa-5x" /></div>'),s.innerHTML=t}),proceedsearch()}})};$(".popup-trigger").click(function(e){e.stopPropagation(),0==isfetched?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(function(e){$(".popup").hide(),$(".popoverlay").remove(),$("body").css("overflow","")}),$(".popup").click(function(e){e.stopPropagation()})</script></body></html>